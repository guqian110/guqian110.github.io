var tipuesearch = {"pages":[{"url":"https://qiangu.cool/pages/about-me.html","text":"Qian Gu 一半是码农，一半是硅农。","tags":"misc","loc":"https://qiangu.cool/pages/about-me.html","title":"About Me"},{"url":"https://qiangu.cool/posts/cs/learning_peps_series_6_pep255_and_pep289.html","text":"What is Generator PEP 255 -- Simple Generators 原文链接 。 Python 中的 generator 有两类，generator function 和 generator expressions。Genrator Function 实际上是一个工厂函数（ factory ），使用 lazily 计算方式。其特点就是：遇到 yield 之后，函数后续代码就不再执行，但是也不会退出函数，在下次被调用时会从 yield 之后继续执行。 任意一个 generator 都是一个 iterator ，但是反之不一定成立。generator 本质上是一种特殊的更高级的 Iterator ，高级的地方在于，不用实现 __iter()__ 和 __next()__ 方法，只需要一个关键字 yield . Why Generator 因为 list comprehensions 语法非常简洁，所以在实际中使用非常广泛，但是 list comprehensions 存在的一个问题是，它的返回值是一个 list 对象，当数据量比较小的时候，直接用 list comprehensions 没有问题，但是当数据量比较大的时候问题就出现了， list 对象会占用大量的内存空间 。很多时候实际上我们并不需要一次性全部把 list 生成好放到内存中，因为我们每次只处理其中的一个元素，如果只是在每次需要对应的元素时才生成它，那么就能节省大量的内存空间了，这就是 generator 出现的原因。 Construct Generator 如何得到一个生成器呢？ Generator Function 使用关键字 yield 可以把一个普通函数转换成 generator。下面是一个产生 Fibonacci 数列的典型例子， 1 2 3 4 5 def fib () : prev , curr = 0 , 1 while True : yield curr prev , curr = curr , prev + curr Generator Expression 另外一种得到 generator 的方法是 generator expressions， PEP 289 -- Generator Expressions 原文链接 。 顾名思义，generator expressions 就是产生 genrator 的表达式，这个表达式的返回值是一个 generator 对象。 Generator Expression 和 List Comprehension 语法非常相似： List Comprehension: [expr for iter_var in iterable if cond_expr] Generator Expression: (expr for iter_var in iterable if cond_expr) 正是因为它们的语法非常相似，所以把代码中已有的 list comprehensions 改成 generator comprehensions 非常容易。 list comprehensions 的出现极大地降低了 filter() 和 map() 的使用，同样 generator expressions 的出现极大地降低了 itertools.ifilter() 和 itertools.imap() 的使用，而且 itertools 中的其他迭代器还能和 generator comprehensions 配合起来使用。 Reduction 函数（比如 sum() , min() , max() 等）会把一个 Iterable 对象转换成一个单独的值，这种场景非常适合配合使用 generator。 虽然经过优化之后，在中、小数据量的时候，list comprehensions 和 generator expressions 的性能是差不多的，但是对于大数据量的场景，generator expressions 仍然具有性能优势。 Using Generator 因为 generator 本身是一个可迭代对象 Iterable ，所以我们可以直接在 for 循环中使用它，就像迭代 list 对象一样。下面是《python 核心编程》中的一个例子，说明了 generator expressions 的优势和用法。 问题：如何获取一个文件中最大的行长度？ 版本一：，打开文件，用 readlines() 把所有的行都读到一个 list 中，然后迭代该 list，找到最大行长度， 1 2 3 4 5 6 7 8 9 f = open ( '/etc/motd' , 'r' ) longest = 0 allLines = f . readlines () f . close () for line in allLines : linelen = len ( line . strip ()) if linelen > longest : longest = linelen return longest 版本二：针对版本一，使用 list comprehensions 简化代码， 1 2 3 4 5 6 7 8 9 f = open ( '/etc/motd' , 'r' ) longest = 0 allLines = [ x . strip () for x in f . readlines ()] f . close () for line in allLines : linelen = len ( line . strip ()) if linelen > longest : longest = linelen return longest 版本一和版本二的问题在于， readlines 会把所有文件内容都读出来，不适用于大文件的情况。因为迭代器是支持文件类型的，所以我们可以用迭代器来替换 readlines 。而且我们已经获取到行内容了，可以直接把行长度存下来，而不是行内容。这里的优化有两个：iterator 的使用可以简化代码，直接保存行长度节省内存。版本三的代码如下， 1 2 3 4 5 f = open ( '/etc/motd' , 'r' ) longest = 0 allLines = [ len ( x . strip ()) for x in f ] f . close () return max ( allLines ) 版本三的代码的问题在于，因为 allLines 本质上还是一个 list，所以虽然使用了迭代器，仍然需要把整个文件都读到内存中。这个时候就该 generator expressions 出场了，用它来代替 list comprehensions，然后把它放到 max 函数里面，就有版本四的代码， 1 2 3 4 f = open ( '/etc/motd' , 'r' ) longest = max ( len ( x . strip ()) for x in f ) f . close () return longest 至此，已经不存在占用内存过大的问题了。不过还可以进一步将其简化为一行代码， 1 return max ( len ( x . strip ()) for x in open ( '/etc/motd' )) 最终版的代码非常简洁，用 1 行代码高性能地实现了前面 9 行低效代码的功能，同时也不晦涩。 List Comprehension & Iterator & Generator 总结这三种语法，可以深刻体会到 Python 的设计哲学： Simple is better than complex. 这三种语法让我们可以写出更加简洁优美的代码，不需要写繁琐的 for 循环，也不需要定义和维护一堆中间变量，就可以写出 streaming code，而且大数据量场景下 generator 的 memory/CPU 效率也很高。 下面有一张国外作者文章 Iterables vs. Iterators vs. Generators 中的图，帮助区分和理解这三个概念。 Ref PEP 255 -- Simple Generators 原文链接 PEP 289 -- Generator Expressions Python 核心编程 Iterables vs. Iterators vs. Generators 完全理解 Python 迭代对象、迭代器、生成器","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_peps_series_6_pep255_and_pep289.html","title":"PEP 学习系列 #6 —— PEP255 & PEP289"},{"url":"https://qiangu.cool/posts/cs/learning_peps_series_5_pep234_and_pep279.html","text":"What is Iterator PEP 234 -- Iterators 原文链接 。 Sequence 是 python 中的一种数据结构，它们的成员是有序排列的，可以通过下标来访问特定元素，比如字符串、list、tuple 等都是 sequence。很多时候我们需要对 sequence 进行顺序访问，最简单的方法是写一个 for 循环，通过计数的方式实现迭代。但是计数的方式很原始也不高效，所以 python 提供了 iterator 来迭代 sequence。 Iterator 实际上是一个实现了工厂模式的对象，它通过 next() 方法来获取元素，而不是通过 index 计数来实现。for 循环只要调用 iterator 的 next 方法，就能获得 sequence 中的下一项，当迭代完所有的 item 后，再次调用会返回一个 StopIteration 的异常，这个异常并不代表发生了错误，而是告诉调用者，迭代已经完成了。 Iterator 对 sequence 的支持是无缝的，除此之外它还能迭代那些具有 sequence 的行为但实际上并不是 sequence 的对象，比如 dict 的 keys 以及 file。 Iteratable vs Iterator 含有 __iter__() 或 __getitem__() 方法的对象称为 \" 可迭代对象 \"： Iteratable 可以用 isinstance() 判断一个对象是否为 Iteratable 对象， 1 2 3 4 5 6 7 from collections import Iterable isinstance ([], Iterable ) # True isinstance ({}, Iterable ) # True isinstance ( 'abc' , Iterable ) # True isinstance ( 100 , Iterable ) # False isinstance ( x for x in range ( 10 ), Iterable ) # True 实现了 next() 方法的对象称为迭代器： Iterator 可以用 isinstance() 判断一个对象是否为 Iterator 对象， 1 2 3 4 5 6 7 from collections import Iterator isinstance ([], Iterator ) # False isinstance ({}, Iterator ) # False isinstance ( 'abc' , Iterator ) # False isinstance ( 100 , Iterator ) # False isinstance ( x for x in range ( 10 ), Iterator ) # True lsit , dict , str 等都是 Iterable ，但不是 Iterator ，可以用 iter() 得到其对应的 Iterator 实际上，python 的 for 循环作用于 Iterable 时，会自动调用 iter() 来得到对应的 Iterator，然后不断调用 next 获取其中的元素， 1 2 for i in seq : do_something_to ( i ) Python 在底层实现时，会自动替换成下面的方式， 1 2 3 4 5 6 7 fetch = iter ( seq ) while True : try : i = fetch . next () except StopIteration : break do_something_to ( i ) 结论： 对于 Iterable 对象，我们可以直接用 for 循环来迭代。 Why Iterator 翻译自 PEP234： 提供了一种可扩展的 iterator 接口 加强了 list 的迭代性能 dict 的迭代性能巨大提升 迭代功能的底层实现是真正的迭代，而不是用随机访问来模拟 兼容目前已有的所有用户自定义的 class、模拟 sequence 和 dict 的扩展对象、甚至那些只实现了 {__getitee__, keys, valus, itmes} 的 mappings 迭代那些非 sequence 对象的代码可以更加简洁，可读性更高 Construct Iterator 如何得到一个迭代器呢？ Using iter 只需要调用内建函数 iter() 即可，有两种调用方式： 1 2 iter ( obj ) iter ( func , sentinel ) iter(obj) ，iter 会检查 obj 是否为 sequence，如果是，则返回一个迭代器 iter(func, sentinel) ，iter 会重复调用 func，直到迭代的值为 sentinel Using itertools Python 内建的工具包，可以产生一系列各种各样的 iterator，比如无穷迭代器 count() , cycle() , repeat() ，有限长度的 accumulate() , compress() , chain() 等。 1 2 3 4 5 from itertools import count counter = count ( 10 ) next ( counter ) # 10 next ( counter ) # 11 itertools 常见的 iterator 有： 生成切片： itertools.islice() 丢弃部分数据： itertools.dropwhile() 产生所有排列组合： itertools.permutations() 一次性迭代不同容器内的元素： itertools.chain() 总结：遇到看似复杂的迭代任务，不要着急自己写复杂的 for index 循环，也不要自己尝试写一个 iterator，而是应该首先看看 itertools 里面是否提供了相关功能，往往有惊喜。 User Define Class 只要一个 class 实现了下面两个方法，就可以当作迭代器来使用， 一个 __iter()__ 方法，返回值是 self 一个 next() 方法，返回一个 item 或者是 StopIteration 异常 这两个方法分别对应了前面区分过的两种协议， 任意一个实现了 __iter()__ 或 __getitme__() 的对象，都可以用 for 循环来迭代 —— Iterable 对象 任意一个实现了 next() 的对象都可以当作是 iterator —— Iterator 协议 迭代的概念本身只涉及第二种协议，容器类的对象一般都支持第一种协议。目前 iterator 要求这两种协议都支持，支持第一种协议的目的是为了让 iterator 同时也是一个 Iterable，这样它的行为和 sequence 类似，特别是在用 for 循环中使用 iterator 的场景。 example： 定义一个产生随机 sequence 的 class（存储在 randSeq.py）， 1 2 3 4 5 6 7 8 9 10 11 12 13 #! /usr/bin/env python from random import choice class RandSeq ( object ): def __init__ ( self , seq ): self . data = seq def __iter__ ( self ): return self def next ( self ): return choice ( self . data ) 使用 for 循环调用该 class 对象， 1 2 3 4 5 6 from ranSeq import RandSeq seq = RandSeq (( 'rock' , 'paper' , 'scissors' )) for item in seq : print item 也可以像前面介绍的一样，用 isinstance() 来检查，说明我们的 RandSeq 类既是一个 Iterable 也是一个 Iterator。 1 2 isinstance ( seq , Iterable ) # True isinstance ( seq , Iterator ) # True Using Iterator Sequence 1 2 3 4 5 6 7 8 9 10 11 12 >>> myTuple = ( 123 , 'xyz' , 45.67 ) >>> i = iter ( myTuple ) >>> i . next () 123 >>> i . next () 'xyz' >>> i . netx () 45.67 >>> i . next () Traceback ( most recent call last ): File \"<stdin>, line 1, in <module> StopIteration Dict dict 内部实现了一个 sq_contaisn 的函数，它实现了 has_key() 相同的功能，所以可以这么写， 1 2 3 4 if k in dict : ... # equivalent to if dict . has_key ( k ): ... dict 内部还实现了一个 tp_iter 的函数，可以产生一个针对所有 keys 的高效迭代器。所以可以这么写， 1 2 3 4 for k in dict : ... # equivalent to, but much faster than for k in dict . keys (): ... 只要不违反 \" 禁止修改 dict 内容 \" 的约束，就可以这么用。 dict 实际上有 3 种 iterator， for x in dict 实际上是 for x in dict.iterkeys() 的缩写 1 2 3 4 5 for key in dict . iterkeys (): ... for value in dict . itervalues (): ... for key , value in dict . iteritems (): ... File file 对象内部实现了 tp_iter 方法，所以访问文件内容的代码可以写得更简洁， 1 2 3 4 5 6 7 8 9 10 11 12 13 for line in myFile : print line # as a shorthand for for line in iter ( file . readline , \"\" ): print line # equivalent, but faster than while 1 : line = file . readline () if not line : break print line Restrictions 在用 iterator 时，sequence/dict 的内容是不能被修改的。 sequence 中除了 list，其它（tuple 和 string）都是不可变的，所以只需要注意 list 的情况即可。对于 dict，只允许对一个已经存在的 key 设置它的值，其他操作（增加 / 删除 / update() ）都是不允许的。原因就是 iterator 和实际对象是绑定在一起的，一旦修改了原对象，效果会马上体现出来。 1 2 3 4 5 6 7 8 # legal myDict = { 'a' : 1 , 'b' : 2 , 'c' : 3 } for key in myDict : myDict [ key ] = myDict [ key ] + 1 # illegal for key in myDict : del myDict [ key ] 实际上，在 python 的迭代器出现之前，这个限制就已经存在了，比如 C++ 也有类似的约束。 Special Iterator enumerate() 如果想在迭代对象时，同时知道对应的索引，该怎么办？ 或许你会想在 iterator 的基础上，再加一个计数器，在每次 for 循环中不断自增，类似这样， 1 2 3 4 5 6 my_list = [ 'a' , 'b' , 'c' ] idx = 1 for val in my_list : print idx , val idx = idx + 1 但是这种写法很丑陋，最优雅的答案是用内建函数 enumerate() ，它的返回值是一个 enumerate 对象，本质上就是个迭代器，返回一个由 index 和 value 组成的 tuple。 PEP 279 介绍了这个函数的实现原理，如下 1 2 3 4 5 6 7 def enumerate ( collection ): 'Generates an indexed series: (0, coll[0]), (1, coll[1]) ...' i = 0 it = iter ( collection ) while 1 : yield ( i , it . next ()) i += 1 使用方法： 1 2 for idx , val in enumerate ( my_list ): print idx , val zip() 如果想同时迭代多个对象，每次迭代分别从中取出一个元素，应该怎么办？ 最优雅的方式是用 zip() 函数，zip 函数的返回值是一个 iterator，所以可以直接在 for 循环中使用， 1 2 3 4 5 a = [ 1 , 2 , 3 ] b = [ 'a' , 'b' , 'c' ] for i in zip ( a , b ) print i Ref PEP 234 -- Iterator PEP 279 -- The enumerate() built-in function Python 核心编程 迭代器 - 廖雪峰的官方网站 Iterables vs. Iterators vs. Generators 完全理解 Python 迭代对象、迭代器、生成器","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_peps_series_5_pep234_and_pep279.html","title":"PEP 学习系列 #5 —— PEP234 & PEP 279"},{"url":"https://qiangu.cool/posts/tools/git_flow_summary.html","text":"git-flow 是 Vincent Driessen 在 2010 年写的文章 A successful Git branching model 中提出的一种管理 git branch 的模型，当时 git 才刚刚被发明出来。经过 10 来年的发展，已经有很多公司都采用这种方式作为标准流程来管理自己的软件开发了。如果像 Web App 这类的持续交付 continuous delivery 的软件，可以采用更简单的 GitHub Flow ，但是对于传统的那种版本概念非常清晰的软件，git-flow 还是非常适用的。下面的内容是原文的简单汇总和翻译，完整内容请看原文。 Note 这里还有一篇翻译： Git 分支管理策略 Git 的工作流程有很多中，git-flow 是之前最流行的做法。就像作者自己所说，git-flow 非常适合传统的软件开发，但是对于 CI/CD 的项目，则显得太繁琐，推荐使用 Github FLow 和 GitLab FLow，这里有相关的翻译和介绍： Git 工作流程 Why Git 网上有很多 Git 和 SVN 这种集中式的代码管理系统优缺点的对比。简而言之，Git 从根本上改变了程序员对 branch/merge 的思考方式， SVN 方式：merge 要非常小心 conflict，一般很久才 merge 一次 Git 方式：每天都会进行，是日常工作的一部分 Git 让码农的生活更加容易。 Decentralized & Centralized Git 实际上是一个分布式的管理系统，并不存在技术意义上真正的 central repo，但是因为需要一个大家都能访问的服务器节点（比如 GitHub）方便相互之间同步，所以在 Git 中一般把这个服务器节点叫做 origin 。项目中的所有成员都和 origin 打交道，完成 pull , push 等操作。 有时候对于某个比较大的 feature，可能需要多个同学一起完成，这个时候相关的同学可以组成一个 subteam，他们相互之间进行 pull/push，如下图所示，Alice 和 Bob，Alice 和 David，David 和 Clair 组成了 3 个 subteam。要组建 subteam 也非常简单，Alice 只需要定义一个 git remote ，指向 Bob 的 repo 地址即可。 Main Branch 主分支一共有两条，即服务器上的 central repo 应该有两条生命期无限长的 branch， master develop 每个小组成员都应该对 origin/master 分支非常熟悉，它是发布产品的主分支， HEAD 指向的永远是可以随时在产品中部署的代码。 而 origin/develop 分支是用来发布新 feature 的主分支， HEAD 指向的代码永远指向最新交付的新功能。有些人把它叫做 集成分支，顾名思义它是用来做集成的，也就是所有开发者会把开发的新 feature 代码都集成到这个分支中，为 release 做准备。所有 nightly build 都应该用这个分支的代码。 当 develop 分支上的代码保持稳定，达到可以 release 的程度了，所有的修改都要通过某种方式 merge 回 master 分支，并且用版本号打个 tag（具体方法后面 release 分支一节描述）。所以每次 merge 回 master，都是发布了一个新的产品 release，所以可以利用 Git 提供的 hook 函数实现只要 master 有新的 commit，就自动编译和推送最新代码到产品服务器上。 Supporting Branch 除了 master 和 develop 两个主分支，还有一些支持性的分支以实现小组成员之间的并行开发，比如跟踪不同的新 feature，修改 bug 等。和主分支不同都是，这些支持性的分支的生命周期是有限的。这里一共定义了 3 种分支， Feature branches Release branches Hotfix branch 这 3 个分支每个都有非常明确的目的，使用也非常严格，从哪个分支中 branch 出来，最终 merge 到哪个 branch 都有严格要求。这些 branch 从技术上来说就是普通的 branch，并无特殊之处，但是因为我们特殊的用法所以将其归为一大类。 Feature Branches 来源：可能是 develop 终点：必须是 develop 命名规则：除了 master, develop, release-*, hotfix-* 之外，其他名字都可以 顾名思义，Feature 分支的目的就是为了开发新 feature，有时候开始开发新 feature 的时候并不知道最终 merge 回哪个 release 分支，只要开始开发这个 feature，那么该 feature 分支就会一直存在，直到最后 merge 回 develop 或者是丢弃掉（中途放弃开发）。 Feature 分支一般只存在于相关开发者的本地 repo 中，并不会存在 origin 上，除非是多和协作共同完成一个大 feature 的情况。 创建 feature 分支 1 2 // creating a new feature branch git checkout -b feature-xxx develop 结束 feature 分支 1 2 3 4 5 // merge back to develop branch git checkout develop git merge --no-ff feature-xxx git branch -d feature-xxx git push origin develop Note 用 --no-ff 来保留 branch 信息。 Release Branch 来源：可能是 develop 终点：必须是 develop & master 命名规则：release-* Release 分支的作用是为最终产品发布做准备，在这个 branch 上允许做最后一刻的修改，比如微小的 bug 修改，为发布准备 meta-data（版本号，build 日期等等），在 release 分支上做这些事情的好处是可以保持 develop 分支的干净整洁。 创建 release 分支的时间点非常关键，主要有两方面的约束， 不能太早，相关功能的代码要全部 ready：当前要发布的 release 包含的新 feature 必须都已经合入 develop 之中 不能太晚，代码要防污染：不能包含下一次 release 对应的 feature 代码 约束 1 要求 develop 分支（几乎）完成了新 release 的所有功能才可以创建 release 分支。约束 2 要求未来下一次 release 的 feature 代码则一定不能合并进来，这些新 feature 必须等到创建当前 release 之后才能合进 develop 分支。 在创建了 release 分支之后，develop 分支就可以为 \" 下一次 release\" 做准备了。 创建 release 分支 1 2 3 git checkout -b release-1.2 develop ./bump-version.sh 1 .2 git commit -a -m \"Bumped version number to 1.2\" 创建好的 release 分支可能会存在一段时间，这段时间内如果有 bug 修改，应该在 release 分支上，而不是 develop 上。新 feature 禁止直接加到 release 分支上，而是应该加到 develop 上，等待下一次的 release。 结束 release 分支 1 2 3 4 5 6 git checkout master git merge --no-ff release-1.2 git tag -a 1 .2 git checkout develop git merge -no-ff release-1.2 git branch -d release-1.2 当 release 分支最终达到可以 release 状态的时候，需要做的事情有 把 release 分支 merge 回 master（前面描述过，master 的每个结点都是一个 release 版本） 给 master 分支打 tag，方便以后回溯版本 把 release 分支 merge 回 develop 分支（保存 release 分支上的 bug 修改） Hotfix Branches 来源：可能是 master 终点：必须是 develop & master 命名规则：hotfix-* hotfix 分支的作用和 release 有点类似，也是为了新产品发布，但是它是计划之外的。hoftfix 是为了应对那种意外发现的，急待解决的产品 bug，如果发现产品上有一个马上就要解决的重大 bug，那么就可以从 master 的该节点上创建一个 hotfix 分支。 典型场景： 突然发现 master 分支上正在使用的产品版本（比如说是 release-1.2）有一个致命 bug，但是 develop 分支因为合入了新 feature，还没有稳定，不能直接在 develop 分支上进行修复，此时就需要创建一个 hotfix 分支。 由上面的例子可以看出，hotfix 分支存在的意义是让团队中的一部分人来进行快速的产品 fix，另外一部分人仍然按照计划进行开发，相互不影响。 创建一个 hotfix 分支 1 2 3 git checkout -b hotfix-1.2.1 master ./bump-version.sh 1 .2.1 git commit -a -m \"Bumped version number to 1.2.1\" 在修改完 bug 之后，把修改结果 commit 1 git commit -m \"FIxed severe production problem\" 结束 hotfix 分支 最后 bugfix 的内容除了要 merge 回 master，还要 merge 回 develop，以保证下一次 release 的时候这个 bug 已经被修复了。这个过程和结束 release 分支很类似。 1 2 3 4 5 6 git checkout master git merge --no-ff hotfix-1.2.1 git tag -a 1 .2.1 git checkout -b develop git merge --no-ff hotfix-1.2.1 git branch -d hotfix-1.2.1 有个特殊情况： 如果存在一个 release 分支，那么应该将 hotfix 分支 merge 到 release 分支，而不是 develop 分支 。Merge 到 release 的 bugfix 代码最终会随着 release 代码一起合入到 develop 分支中，不需要担心丢失。（如果 develop 分支需要马上就合入这个 bugfix，等不到 release 分支结束，那么也可以将 bugfix 合入到 develop 中。） Summary 这个模型并没有提出什么惊人的新概念，但是在实际工作中非常有用，这个优雅的模型可以让整个 team 中的成员对 branch 分支有一个共同的认识。 Practice -- git-flow 上面是原文的翻译和总结，在实践中，有个 git 扩展 git-flow 工具可以帮助我们遵守这套规则。这里有一篇 git flow cheatsheet 方便查看。 Install 1 sudo apt-get install git-flow Setup 1 git flow init 回答一系列问题即可，推荐使用默认值 Features 创建一个 feature 分支： 基于 develop 创建了一个新 feature 分支，并切换过去 1 git flow feature start MYFEATURE 结束一个 feature 分支： 把 MYFEATURE 分支 merge 回 develop 分支 删除该 feature 分支 切换回 develop 分支 1 git flow feature finish MYFEATURE 发布一个 feature 1 git flow feature publish MYFEATURE 把 feature 分支发布到 remote 服务器，方便其他人使用 获取一个其他人发布的 feature 1 git flow feature pull origin MYFEATURE Release 创建一个 release 分支 1 git flow release start RELEASE [ BASE ] 通过一个可选项 [BASE] 来制定 develop 上的某个特定节点 把 release 分支的结果发布给其他开发者 1 git flow release publish RELEASE 结束一个 release 分支 把 release 分支 merge 回 master 分支 用 release 分支的名字给 master 打 tag 把 release 分支 merge 回 develop 分支 删除 release 分支 1 git flow release finish RELEASE Note 别忘了把你的 tag push 到远程 repo：git push origin --tags Hotfix 创建一个 hotfix 分支 1 git flow hotfix start VERSION [ BASENAME ] 结束一个 hotfix 分支 把 hotfix 分支 merge 回 develop 和 master 分支 用 hotfix 的 version 给 master 分支打 tag 1 git flow hotfix finish VERSION Zsh Extension zsh 里面有两个相关插件， git flow completion ，自动补全 git-flow ，提供命令的各种 alias 给 zsh 安装 git flow completion 插件的步骤， 下载插件 1 git clone https://github.com/bobthecow/git-flow-completion ~/.oh-my-zsh/custom/plugins/git-flow-completion 更新 .zshrc 文件 1 plugins =( <some-plugin> <another-plugin> git-flow-completion ) 重新 source 之后就可以看到自动补全的效果了 Ref A successful Git branching model git flow cheatsheet","tags":"Tools","loc":"https://qiangu.cool/posts/tools/git_flow_summary.html","title":"Git Flow 小结"},{"url":"https://qiangu.cool/posts/cs/learning_peps_series_4_pep202_and_pep274.html","text":"What is List Comprehensions PEP 202 -- List Comprehensions 原文链接 。 List Comprehensions 是一种 python 语法扩展，它可以实现用 for 和 if 语句直接构建 list。 Examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 >>> print [ i for i in range ( 10 )] [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> print [ i for i in range ( 20 ) if i%2 == 0 ] [ 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 ] >>> nums = [ 1 , 2 , 3 , 4 ] >>> fruit = [ \"Apples\" , \"Peaches\" , \"Pears\" , \"Bananas\" ] >>> print [( i, f ) for i in nums for f in fruit ] [( 1 , 'Apples' ) , ( 1 , 'Peaches' ) , ( 1 , 'Pears' ) , ( 1 , 'Bananas' ) , ( 2 , 'Apples' ) , ( 2 , 'Peaches' ) , ( 2 , 'Pears' ) , ( 2 , 'Bananas' ) , ( 3 , 'Apples' ) , ( 3 , 'Peaches' ) , ( 3 , 'Pears' ) , ( 3 , 'Bananas' ) , ( 4 , 'Apples' ) , ( 4 , 'Peaches' ) , ( 4 , 'Pears' ) , ( 4 , 'Bananas' )] >>>> print [( i, f ) for i in nums for f in fruit if f [ 0 ] == \"P\" ] [( 1 , 'Peaches' ) , ( 1 , 'Pears' ) , ( 2 , 'Peaches' ) , ( 2 , 'Pears' ) , ( 3 , 'Peaches' ) , ( 3 , 'Pears' ) , ( 4 , 'Peaches' ) , ( 4 , 'Pears' )] >>> print [( i, f ) for i in nums for f in fruit if f [ 0 ] == \"P\" if i%2 == 1 ] [( 1 , 'Peaches' ) , ( 1 , 'Pears' ) , ( 3 , 'Peaches' ) , ( 3 , 'Pears' )] >>> print [ i for i in zip ( nums, fruit ) if i [ 0 ] %2 == 0 ] [( 2 , 'Peaches' ) , ( 4 , 'Bananas' )] Why Comprehensions 如果想用从一个 list 中挑选出一部分满足条件的元素组成一个新的 list，该怎么做？ 方法一：最直观简单的方法，写一个 for 循环，然后从中挨个挑选出符合条件的元素 方法二：使用函数式编程中的 map() / filter() 既然方法一和方法二都能实现相同的功能，为什么还需要再提出 list comprehensions 呢？ 答案是：为了更加优雅的构建 list。 方法一虽然简单但是很臃肿，方法二要调用两个函数（ map / filter , lambda ）仍然不够简化，所以出现了 list comprehensions ， 它实际上来自于函数式编程语言 Haskell， 提供了另外一种更加简洁的实现方法（Simple is better than complex.） 。 Understanding and Using List Comprehensions 以数学的角度理解 list comprehensions 下面这个集合表示从自然数中挑选出符合条件 x > 5 且 x < 10 的所有元素， $$new\\_list = \\{x | x \\in N, x > 0, x < 10\\}$$ 下面是 Python 的实现版本， 1 new_list = [ x for x in N if x > 0 and x < 10 ] 对比一下 python 版本的代码就可以知道两者非常相似，只不过 python 用 for 和 if 语句来描述数学中的条件表达式。尤其是 python 中有集合 set 的概念，set 也是可以写成 comprehensions 形式的，这个时候就和数学就完全等价了。 如何写 list comprehensions 因为 list comprehensions 本质是 for 和 if 的简洁写法，所以我们可以总结出一个模板，只要满足这个模板的 for 循环就可以改成写 list comprehensions. 1 2 3 for item in old_list : if condition ( item ) : new_list . append ( func ( item )) 可以改写成下面的形式 1 new_list = [ func ( item ) for item in old_list if condition ( item )] 循环嵌套的 list comprehensions 循环嵌套的 list comprehensions 例子：将矩阵展平， 1 2 3 for row in matrix : for n in row : flattened . append ( n ) 可以写成 1 flattend = [ n for row in matrix for n in row ] 提高 list comprehensions 的可读性 因为 python 支持在括号之间断行，所以前面的例子，可以该写成下面的形式以提高可读性： 1 2 3 4 5 new_list = [ func ( itme ) for item in old_list if condition ( itme ) ] 1 2 3 4 5 flattend = [ n for row in matrix for n in row ] 小结 无论是单层还是嵌套的 for 循环，改成 list comprehensions 的方法其实方法非常简单，就是把普通的 for 循环调整了顺序，将循环内的语句写在了最前面，剩余部分按原顺序写就可以了。 上面的语法只适用于一个元素（the Right One） 不允许写成 [x, y for ...] 形式，但是可以写成一个 tuple 元素的形式 [(x, y) for ...] 允许嵌套形式 [... for x... for y...] ，就像嵌套循环一样，最后一个 index 是变化最快的 GvR 也说 map() / filter() 函数用起来实在太繁琐了，我们应该多使用 comprehensions。但是我们应该记住，谨防滥用。 filter and map should die and be subsumed into list comprehensions, not grow more variants. I'd rather introduce built-ins that do iterator algebra (e.g. the iterzip that I've often used as an example). （关于 iterator ，后面的学习笔记中会有介绍。） Dict Comprehensions PEP 274 -- Dict Comprehensions 原文链接 。 dict comprehensions 和 list comprehensions 非常相似，不同之处是用 {} 而不是 [] 。同时，关键字 for 前面的部分表达式改成了用冒号隔开的 key-value 对。 Examples 1 2 >>> print { i : chr ( 65 + i ) for i in range ( 4 )} { 0 : 'A' , 1 : 'B' , 2 : 'C' , 3 : 'D' } 1 2 >>> print { k : v for k , v in someDict . iteritems ()} == someDict . copy () 1 1 2 >>> print { x . lower () : 1 for x in list_of_email_addrs } { 'barry@zope.com' : 1 , 'barry@python.org' : 1 , 'guido@python.org' : 1 } 1 2 3 4 5 6 >>> def invert ( d ): ... return { v : k for k , v in d . iteritems ()} ... >>> d = { 0 : 'A' , 1 : 'B' , 2 : 'C' , 3 : 'D' } >>> print invert ( d ) { 'A' : 0 , 'B' : 1 , 'C' : 2 , 'D' : 3 } 1 2 3 4 5 >>> {( k , v ): k + v for k in range ( 4 ) for v in range ( 4 )} ... {( 3 , 3 ): 6 , ( 3 , 2 ): 5 , ( 3 , 1 ): 4 , ( 0 , 1 ): 1 , ( 2 , 1 ): 3 , ( 0 , 2 ): 2 , ( 3 , 0 ): 3 , ( 0 , 3 ): 3 , ( 1 , 1 ): 2 , ( 1 , 0 ): 1 , ( 0 , 0 ): 0 , ( 1 , 2 ): 3 , ( 2 , 0 ): 2 , ( 1 , 3 ): 4 , ( 2 , 2 ): 4 , ( 2 , 3 ): 5 } Ref Python List Comprehensions: Explained Visually 用数学思维理解 Comprehension if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; var configscript = document.createElement('script'); configscript.type = 'text/x-mathjax-config'; configscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" availableFonts: ['STIX', 'TeX'],\" + \" preferredFont: 'STIX',\" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript); (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_peps_series_4_pep202_and_pep274.html","title":"PEP 学习系列 #4 —— PEP202 & PEP274"},{"url":"https://qiangu.cool/posts/cs/learning_peps_series_3_pep20.html","text":"著名的 python 之禅， PEP 20 -- The Zen of Python 原文链接 。 item detail PEP 20 Title The Zen of Python Author tim.peters at gmail.com (Tim Peters) Status Active Type Informational Created 19-Aug-2004 Post-History 22-Aug-2004 Abstract 很久之前，Python 先驱 Tim Peters 将 BDFL（Benevolent director for life，仁慈的终身独裁者，特指 Python 之父 Guido van Rossum）的 Python 设计指导原则总结成 20 条格言，只记录下了其中的 19 条。 The Zen of Python 网上有很多不同版本的翻译，有些语言风趣幽默，有些正经严肃。我个人更喜欢严肃的翻译，因为幽默的翻译有时候需要特定的语境和背景只是才能理解，反而增加了理解难度。下面的翻译一些是我按照自己的理解写的，有些是网上别人的翻译（因为出处已经无法找到了，所以只能感谢原作者的分享了）。文学水平太低做不到 达雅 ，只能争取做到 信 ，尽量不要误导大家。 Beautiful is better than ugly. 优美胜于丑陋 PEP8 中提到，Python 的理念是代码更多时候是用来读的，所以以编写 优美 的代码为目标， if a == 0 and b == 1 or c == True: 要比 if a == 0 && b == 1 || c == True: 更加优美。优美的代码包含的内容非常广泛，PEP8 提供了一些如何写出优美代码的建议。 Explicit is better than implicit. 显式胜于隐式 代码应该清晰易懂，比如良好的命名可以提高代码的可读性。几个不好的例子， 太宽泛： my_list 太冗长： list_of_machine_learning_data_set 太模糊： I , o , O , a , b , c 关于命名可以参考 PEP8. Simple is better than complex. 简单胜于复杂 选择最简单实现方案，python 有很多功能强大的内置 method，合理利用它们可以减少你的代码量，删繁就简只保留核心代码。一个直观例子是用 enumerate() 来迭代容器，另外一个例子是用 zip() 快速创建字典。减少代码量不仅仅可以提高可读性，还意味着出错的概率更低，而且代码的性能更好（因为通常库实现更加高效）。 Complex is better than complicated. 复杂胜于凌乱 如果复杂不可避免，也要避免晦涩的实现。复杂和晦涩的区别，我理解就是复杂是可以通过分解来理解，但是晦涩特指那种非常难理解的语法、不符合常规思维的实现方式。 Flat is better than nested. 扁平胜于嵌套 代码尽量少嵌套，降低理解难度。 Sparse is better than dense. 间隔胜于紧凑 适当的间隔和空行能提高可读性，同参考 PEP8. Readability counts. 可读性很重要 同参考 PEP8，两个例子： 使用下划线对很长的数字分组， money = 1_000_000 f-string 可以大幅提高代码的可读性， print(f\"I have {money} dollars.\") Special cases aren't special enough to break the rules. 规则至高无上，没有什么特例可以打破规则 Although practicality beats purity. 但是实用性胜过代码的纯粹性 与前一句相矛盾，提醒我们掌握它们之间的平衡。 Errors should never pass silently. 不要默许任何错误 默许的错误会导致隐患，使用异常处理以尽量写出健壮的代码。 Unless explicitly silenced. 除非你确定要这么做 在某些情况下，小错误是可以容忍的，和前一条组合在一起，避免走极端。 In the face of ambiguity, refuse the temptation to guess. 面对歧义，拒绝猜测的诱惑 避免写含糊不清的代码。 There should be one-- and preferably only one --obvious way to do it. 应该有且只有一个最优解决方案 —— 最显而易见的实现方案 python 的语法非常灵活，库也非常强大，所以同一个问题可以有非常多种不同实现方式，那么最优方案应该是那个最直观的解决方案。不要走标新立异的路线，用最显而易见的方法，花费最少的时间解决问题，珍惜自己的生命，也珍惜读者（代码维护者）的生命。 life is short, you need pyhton. Although that way may not be obvious at first unless you're Dutch. 虽然一开始并不容易，除非你是 Pyhton 之父 Now is better than never. 现在开始做胜过永远拖延 拒绝拖延症！ Although never is often better than right now. 但是不假思索地的行动还不如拖延 行动前要仔细思考，制定计划。 If the implementation is hard to explain, it's a bad idea. 如果实现方案很难向别人解释，那么它就是个坏方案 小黄鸭调试法。 If the implementation is easy to explain, it may be a good idea. 反之亦然，良好的实现方案应该清晰容易理解 好方案的一个共同特点就是清晰易懂，因为它们抓住了问题的关键点，从而可以用简单的方法高效地解决问题 —— 奥卡姆剃刀 。 Namespaces are one honking great idea -- let's do more of those! 命名空间是一个绝妙的理念，我们要多加利用 给变量起名字是一门艺术，尤其是大工程多人协同工作时，难免会有命名冲突，因为好名字是大家有共识的，使用命名空间可以让你不再有命名冲突的烦恼。 Easter Egg 在解释器中用下面的命令就可以看到原文。 1 import this Ref Python 之禅 《Python 之禅》的翻译和解释 怎样让你写的 Python 代码更优雅？","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_peps_series_3_pep20.html","title":"PEP 学习系列 #3 —— PEP20"},{"url":"https://qiangu.cool/posts/cs/learning_peps_series_2_pep257.html","text":"PEP 257 -- Docstring Conventions 原文链接 item detail PEP 257 Title Docstring Conventions Author David Goodger , Guido van Rossum Status Active Type Informational Created 29-May-2001 Post-History 13-Jun-2001 摘要 本文描述了 Python docstrings 的语法和惯例。 基本原理 本文的目的是在 high-level 的层次对 docstrings 结构进行标准化：应该包含哪些内容，以及如何表述（docstrings 内部不需要任何的标记性语法）。本文的内容是惯例，而不是严格的语法或法律。 \"A universal convention supplies all of maintainability, clarity, consistency, and a foundation for good programming habits too. What it doesn't do is insist that you follow it against your will. That's Python!\" —Tim Peters on comp.lang.python, 2001-06-16 如果你违法了这些惯例，最差的结果也只不过是你的作品看起来比较丑陋。但是一些软件（比如 Docutils 系统）会感知到 docstrings，所以遵守这些惯例可以让你获得最好的结果。 标准 Docstrings 是什么 docstrings 是一个字符串，是 module , function , class , method 中的第一个语句，这些字符会变成该 object 的特殊属性 __doc__ 。 所有的 module 都应该有 docstrings，module 中所有可以导出的 function 和 class 也都应该有 docstrings。class 的 public method（包括 __init__ 构造器）也应该有 docstrings。一个 package 可以在自己目录下面 __init__.py 文件的 docstrings 中进行描述。 Python 文件中其他位置的字符串也可以成为文档的一部分，它们无法被 Python 的字节码编译器识别，runtime 的时候也无法访问（也就是说，没有赋值给 __doc__ 属性），但是有两种类型的 docstrings 可以被软件工具识别出来： 在 module, class, __init__ 方法的顶层，简单赋值语句后面的字符串，叫做 \"attribute docstrings\" 在 docstrings 之后紧跟着出现的字符串，叫做 \"additional docstrings\" 关于这两种 docstrings 的详细描述请参考 PEP258 \"Docutils Design Specification\" 。 为了保持一致性，永远使用三个双引号 \"\"\"triple double quotes\"\"\" 包围 docstrings。如果在 docstrings 中使用到了反斜线，请使用 r\"\"\"raw triple double quotes\"\"\" ，对于使用 Unicode 字符的情况，请使用 u\"\"\"Unicode triple quoted string\"\"\" 。 docstrings 有两种形式：单行、多行。 单行 Docstrings 单行 docstrings 显而易见，就是只有一行。举例， 1 2 3 4 5 def kos_root (): \"\"\"Return the pathname of the KOS root directory.\"\"\" global _kos_root if _kos_root : return _kos_root ... 注意： 即使是单行的情况，仍然使用三双引号，方便以后扩展成多行的情况 开头和结尾的引号在同一行，这样看起来要美观一些 docstrings 前后没有空行 docstrings 用一个以句号结尾的短语，它用命令性的方式规定了 function/method 的效果（比如 \"Do this\"，\"Return that\"），而不是描述性的方式（比如，不要写成这样 \"Returns the pathname...\"） 单行的 docstrings 不应该是 function/method 的参数的重新声明（可以通过内省实现），不要写成这样 1 2 def function ( a , b ): \"\"\"function(a, b) -> list\"\"\" 这种类型的 docstrings 只适合于 C 函数（比如内建函数），因为 C 没有内省机制。然而内省无法决定返回值的类型，所以要在 docstrings 中进行说明。所以 docstrings 应该优先选择下面的方式， 1 2 def function ( a , b ): \"\"\"Do X and return a list.\"\"\" 多行 Docstrings 多行 docstrings 的结构分为 2 段，第一段是一个类似于单行 docstrings 的总结行，第二段是更详细的描述，两段之间用一个空行隔开。总结行可能会被自动化索引工具使用到，所以让它的长度保持在一行内，并且用空行和其他部分隔开非常重要。总结行可以放在开头引号的同一行，也可以放到下一行。整个 docstrings 和引号的缩进保持一致（见下面的例子）。 class 的 docstrings 的后面要插入一（多）个空行。一般来说 class 的 methods 之间会通过一个空行进行隔离，docstrings 也需要一个空行来和第一个 method 进行隔离。 一个脚本（作为一个单独的程序）的 docstrings 应该可以当作 Usage message 来使用，当使用不正确的参数（或者是表示 help 的 -h 参数）调用脚本时打印出这些内容。这种 docstrings 应该包含脚本的功能、命令行语法、环境变量、文件等信息。Usage message 可以非常详细（内容长达几个全屏），达到可以指导一个新用户正确使用本脚本命令，这个信息也可以作为高级用户查询所有选项和参数的快速参考。 一个 module 的 docstrings 应该列出所有可以被导出的 class，exception 和 function 以及其他 objects，每个对象都有一个单行的总结性描述（这些总结比 docstrings 的总结行更简洁）。 一个 package 的 docstrings（比如， __init__.py 的 docstrings）也应该列出可以导出的 module 和 subpackage。 一个 function/method 的 docstrings 应该总结它的行为，描述它的参数，返回值，副作用，抛出的 exception，调用时的约束。同时应该指出可选参数，无论 keyword 参数是不是接口的一部分，都应该进行描述。 一个 class 的 docstrings 应该总结它的行为，列出 public method 和 instance varibale。如果它本身的设计目的是子类化，并且针对 subclass 留有额外的接口，那么这个额外接口应该在 docstrings 中单独列出来。构造器应该在 __init__ 方法的 docstrings 中描述，其他的 method 都在自己的 docstrings 中进行描述。 如果一个 subclass 的大部分行为都继承自另外一个 class，那么它的 docstrings 应该提到这一点并且总结两者的不同之处。用动词 override 来说明 subclass 的方法重写了 superclass 的同名方法；用动词 extend 来表示 subclass 的方法调用了 superclass 的同名方法，并且添加了自己额外的功能。 在 docstrings 中涉及到 function/method 的参数时不要用 Emacs 的大写惯例。Python 对大小写敏感而且参数的名字可以用作是 keyword 参数，所以 docstrings 应该使用正确的参数名字。最好按照每行一个参数的形式列出来。举例， 1 2 3 4 5 6 7 8 9 10 def complex ( real = 0.0 , imag = 0.0 ): \"\"\"Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) \"\"\" if imag == 0.0 and real == 0.0 : return complex_zero ... 除非是所有内容都可以在一行内完全放下，否则把结尾的引号单独放在一行，这样 Emacs 的 fill-paragraph 命令就可以使用了。 处理 Docstrings 的缩进 docstrings 工具可以对 docstrings 的第二行及以后的行进行整体的缩进删除，删除的长度是后面这些行中的最小缩进，也就是说后面这些行的缩进最小化。第一行 docstrings 的任何缩进都是没有用的，会被删除。后续行的缩进也会被保留下来。应该删掉 docstrings 开头和结尾的空行。 因为代码比描述更准确，这里贴出来这个规则（算法）的实现， 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def trim ( docstring ): if not docstring : return '' # Convert tabs to spaces (following the normal Python rules) # and split into a list of lines: lines = docstring . expandtabs () . splitlines () # Determine minimum indentation (first line doesn't count): indent = sys . maxint for line in lines [ 1 :]: stripped = line . lstrip () if stripped : indent = min ( indent , len ( line ) - len ( stripped )) # Remove indentation (first line is special): trimmed = [ lines [ 0 ] . strip ()] if indent < sys . maxint : for line in lines [ 1 :]: trimmed . append ( line [ indent :] . rstrip ()) # Strip off trailing and leading blank lines: while trimmed and not trimmed [ - 1 ]: trimmed . pop () while trimmed and not trimmed [ 0 ]: trimmed . pop ( 0 ) # Return a single string: return ' \\n ' . join ( trimmed ) 下面这个例子中的 docstrings 包含两个换行符号，所以一共有 3 行，第一行和最后一行是空行， 1 2 3 4 def foo (): \"\"\" This is the second line of the docstring. \"\"\" 在命令行中运行一下看看， 1 2 3 4 5 6 >>> print repr(foo.__doc__) '\\n This is the second line of the docstring.\\n ' >>> foo.__doc__.splitlines() ['', ' This is the second line of the docstring.', ' '] >>> trim(foo.__doc__) 'This is the second line of the docstring.' 一旦经过 trim 处理， 下面这两种 docstring 是等效的， 1 2 3 4 5 6 7 8 9 10 def foo (): \"\"\"A multi-line docstring. \"\"\" def bar (): \"\"\" A multi-line docstring. \"\"\" 参考 参考阅读 PEP 256 -- Docstring Processing System Framework PEP 258 -- Docutils Design Specification 附：实践 使用 flake8-docstrings 工具来帮助自己检查 docstrings 是否符合规范。","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_peps_series_2_pep257.html","title":"PEP 学习系列 #2 —— PEP257"},{"url":"https://qiangu.cool/posts/cs/pep8_in_practice.html","text":"PEP8 & PCQA PEP8 之前已经介绍过了，这里有 中文翻译（前一篇博客） 。 PCQA 是 Python Code Quality Authority 的缩写，它是一个松散的组织，聚集了各地的开发者，大家以在线协作的方式，为广大 python 码农提供各种 automatic style and quality reporting 工具，方便大家做项目时可以在不同项目都能保持代码风格一致。 PCQA 源自于 Ian Cordasco 在把 Flake8 迁移到 Git 时发出的一封邮件，大家积极提议把项目迁移到 GitLab 上，所以他在 GitLab 和 GitHub 上都建了一个 group 来专门维护 Flake8 和 flake8-docstrings 。后来其他人开发维护的各种 lint 工具也源源不断地加入，PCQA 逐渐壮大。 在 PCQA 的 GitHub 主页 上可以看到很多工具，很多常见的 linter 和 formatter 工具大部分来自于 PCQA，下文会经常看到 PCQA 的身影。 Linter pycodestyle PCQA 荣誉出品， pycodestyle 原名叫 pep8 ，后应 python 之父的 要求 ，后来改名为 pycodestyle 。 This package used to be called pep8 but was renamed to pycodestyle to reduce confusion. Further discussion can be found in the issue where Guido requested this change, or in the lightning talk at PyCon 2016 by @IanLee1521: slides video. 安装和使用方法直接看 pycodestyle Github 主页 ，或者在命令行中查询。 1 pycodestyle -h 关于配置，pycodestyle 的 文档 里面有详细介绍，如果想自定义忽略某些检查项，则根据文档查阅这些检查项对应错误代码，在配置文件中添加忽略选项即可。 pycodestyle 是一个非常基础、应用非常广泛的工具，很多 lint 工具底层都依赖于它！ pyflakes PCQA 荣誉出品， pyflakes Github 主页 介绍到 pyflakes 的设计原则非常简单： it will never complain about style, and it will try very, very hard to never emit false positives. 它通过解析每个源文件的 syntax tree，而不是通过 import 的方式来检查代码，所以很安全没有副作用，速度也会比 pylint 和 Pychecker 快很多。但是付出的代价就是它能检查的类型有限。 pyflakes 的使用方法也非常简单，没有命令行参数，像下面这样直接调用即可， 1 pyflakes my_file.py 所以 pyflakes 只是检查语法错误，而不检查 code style，如果想要语法检查 + style 检查，那么可以使用下面介绍的 flake8 。 flake8 PCQA 荣誉出品， flake8 实际上是一个集成工具，它集成了 PyFlakes pycodestyle Ned Batchelder's McCabe script 通过一个单条的 flake8 命令可以启动这三个命令进行检查。 1 flake8 my_file.py 详细用法可以通过 help 选项查看或者阅读 flake8 的文档 。 flake8 流行的一个重要原因是它提供扩展功能，官方已经为 flake8 开发了很多插件。比如 flake8-docstirngs 基于 PEP257 检查文档的 docstrings。 每个插件的安装方法直接参考该插件的文档即可，安装完之后就可以像前面一样直接使用了。下面几个是常用插件： pep8-naming flake8-bugbear flake8-import-order flake8-commas flake8-docstrings pylint PCQA 荣誉出品，提到 pylint ，必须先引用官网的一句话， It's not just a linter that annoys you! pylint 会检查代码语法错误，coding style（默认的检查标准和 PEP8 非常相似），它还能建议代码应该如何重构，它还会根据检查结果对你的代码打分 XD。 不过 pylint 的检查非常严格，而且运行速度也要慢一些，所以很多人更喜欢用 flake8 等其他工具。 上面的工具的使用流程都是一样的： 写代码 命令行调用工具检查 根据检查结果逐个修改代码 迭代 1~3 直到没有 error 和 warning 如果经常改动代码，这个过程会重复很多次，依然会很繁琐，所以下面介绍的几个工具可以提供自动化处理，减轻工作量。 Formatter autopep8 来自于一个日本程序猿之手， autopep8 依赖于 pycodestyle，安装和使用说明直接看 Github 主页即可。通过命令行使用起来稍微有点繁琐，后面小节中有介绍使用 sublime 插件实现一键调用。 yapf 首先必须说明 yapf 并不是 Google 的官方产品，仅仅是恰好代码所属权是 Google。 下面内容是一段官方文档的翻译： 目前大部分的 python formatter 工具的机制是根据 lint 结果把 error 信息逐个修掉。这么做有很明显的局限性，比如某些代码虽然遵循了 PEP8，但是并不代表它的 coding style 是良好的。 yapf 才用了另外一种思路，它基于 clang-format 工具，使用算法提取代码，尽最大努力将其 format 成最佳 style，即使有时候代码并没有违背规范。它终结了 formatting 的圣战：如果项目中有代码改动，将整个 codebase 用 yapf 过一遍，那么所有代码的风格就会保持一致，在 code review 的时候就不再有无意义的争吵。 yapf 的终极目标是产生的代码和（遵循规范的）程序猿写出的代码一样，它可以替你完成维护代码中的一些繁琐的事情。 安装和使用方法见官方主页。 black 查看资料说 black 和 yapf 类似，但是限制条件比较多，没有太多的自定义选项，所以优点是省心。因为基于 python3，目前我还在使用 python 2.7，所以暂时记录一下，以后切换成 python 3 了再补坑。 Practice in Sublime sublime 有很多 linter 和 formater 插件，下面总结一下。 SublimeLinter SublimeLinter 是一个 sublime 的插件，可以提供一个框架，配合扩展插件完成各种语法和规则的 lint 检查。 SublimeLinter 官方出品的扩展插件命名为 SublimeLinter-xxx 的格式，第三方的插件则命名为 SublimeLinter-contrib-xxx 的格式，比如 集成 iverilog 的插件 Sublime​Linter-contrib-iverilog 集成 verilator 的插件 Sublime​Linter-contrib-verilator 集成 modelsim 的插件 Sublime​Linter-contrib-modelsim 下面介绍的插件都是官方出品的插件。 Sublime​Linter-pep​8 / Sublime​Linter-pycodestyle 如前文所述，因为 pep8 已经改名叫 pycodestyle ，所以 sublimlinter 也弃用了 Sublime​Linter-pep​8 ，而是使用 Sublime​Linter-pycodestyle 为 sublimelinter 提供与 pycodestyle 的集成接口。 安装完之后就可以看到效果了，根据提示修改代码即可。 Sublime​Linter-pyflakes Sublime​Linter-pyflakes 为 sublimelinter 提供与 pyflakes 的集成接口，安装完之后也可以看到效果。 SublimeLinter-flake8 Sublime​Linter-flake8 为 sublimelinter 提供与 flake8 的集成接口，安装完之后也可以看到效果。 因为 flake8 已经在底层集成了 pycodestyle 和 pyflake，所以只安装 SublimeLinter-flake8 即可，没有必要安装把这三个插件都安装了，这样会有很多重复提示。 AutoPEP8 AutoPEP8 为 sublime 提供与 autopep8 的集成接口，可以一键调用 autopep8 检查代码是否符合 PEP8 规范，使用起来特别方便，目前安装量有 117K。 注意：AutoPEP8 不是完整的 linter，严格说应该属于 formatter，只能实现 PEP8 规范中的部分功能。 安装完成后可以通过快捷键 ctrl + 8 或者是 shift + ctrl + 8 直接使用。 ctrl + 8 ：会生成一个 patch 文件，可以预览改动 shift + ctrl + 8 ：直接修改目标文件 Py​Yapf Python Formatter PyYapf 为 sublime 提供与 yapf 集成的接口，安装之后可以通过快捷键或者是 ctrl + shift + p 在 sublime 内调用 yapf。 Summary 综上，python 有众多 linter 和 formatter 工具，很多工具之间的功能大部分都是重复的，选择一个用着顺手的即可。因为我使用 sublime text 作为主力编辑器，所以 PEP8 实践的最佳方案是： item solution editor sublime linter sublimelinter-flake8 formatter PyYapf","tags":"CS","loc":"https://qiangu.cool/posts/cs/pep8_in_practice.html","title":"PEP8 实践"},{"url":"https://qiangu.cool/posts/cs/learning_peps_series_1_pep8.html","text":"PEP 8 -- Style Guide for Python Code 原文链接 item detail PEP 8 Title Style Guide for Python Code Author Guido van Rossum , Barry Warsaw , Nick Coghlan Status Active Type Process Created 05-Jul-2001 Post-History 05-Jul-2001, 01-Aug-2013 介绍 本文介绍 Python 主要发布版本中标准库的 code style，对于 CPython 中的 C 代码的 style guide 请查看相关文档 PEP7 。 本文和 PEP257(docstring 规范 ) 来源于 Guido 写的原始文章：《python code style》，部分来自于 Barry 的 GNU Mailman style guide 。 本文随着语言本身的变化不断进化，舍弃了部分规则的同时新加了一些规则。 许多项目都有自己的 coding style guide，如果和本文有任何冲突，应该以该项目自己的 guide 为准。 尽信书，不如无书 Guido 的一个重要见解是：代码更多是用来读而不是写。本文提供的 guideline 的目的是提高代码的可读性，使得广泛的 python 代码保持一致性。正如 PEP20 所述，\" 可读性非常重要 \"。 一篇 style guide 主要内容是一致性。虽然本文的一致性很重要，但是一个项目内的一致性更重要，最重要的是一个 module 或者 function 内部的一致性。 但最重要的是，要知道什么时候不保持一致性，在实际应用时候有些 guide 并不适用，如果有疑问，根据自己的最佳判断，看看其他代码例子然后决定怎么写代码看起来最好。不要羞于发问。 特别注意：不要为了遵守本文而破坏向后的兼容性！ 一些可以忽略本 guideline 的情况： 遵守本 guideline 会导致代码的可读性下降，即使对于那些习惯于遵守本文来阅读代码的人来说 （可能出于历史原因）为了保持和周边代码的一致性可以忽略本 guideline，虽然这是个清理其他人垃圾的好机会（实现真正的极限编程 Extreme Programming） 代码出现在本规范之前，并且没有其他理由去修改它 代码需要和不支持本规范的旧版本 Python 代码保持一致 代码布局 缩进 每级缩进为 4 个空格。 连续行应该按照包围的元素对齐，要么使用 python 圆括号、方括号、花括号的隐式行连接在垂直方向对齐，要么使用 hanging indent 。使用 hanging indent 的时候应该注意，第一行不应该有任何参数，后续行多一级缩进以便和其他行能清晰地区分开。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Correct: # Aligned with opening delimiter. foo = long_function_name ( var_one , var_two , var_three , var_four ) # Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest. def long_function_name ( var_one , var_two , var_three , var_four ): print ( var_one ) # Hanging indents should add a level. foo = long_function_name ( var_one , var_two , var_three , var_four ) 1 2 3 4 5 6 7 8 9 10 11 # Wrong: # Arguments on first line forbidden when not using vertical alignment. foo = long_function_name ( var_one , var_two , var_three , var_four ) # Further indentation required as indentation is not distinguishable. def long_function_name ( var_one , var_two , var_three , var_four ): print ( var_one ) 对于后续的行，4 个 space 的规则是可选的， 1 2 3 4 # Hanging indents *may* be indented to other than 4 spaces. foo = long_function_name ( var_one , var_two , var_three , var_four ) 如果 if 语句的条件部分太长以至于要写成多行的形式，要注意，一个双字符的关键字（比如 if）加上一个空格，再加上右括号，会天然形成一个 4 space 的缩进。这会导致条件语句和 if 内部的嵌套语句（本身也是 4 space 缩进）产生视觉冲突。本文没有明确规定如何（是否需要）进一步在视觉上区分条件语句和内嵌语句，可选但是不限于下面几种方式： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # No extra indentation. if ( this_is_one_thing and that_is_another_thing ): do_something () # Add a comment, which will provide some distinction in editors # supporting syntax highlighting. if ( this_is_one_thing and that_is_another_thing ): # Since both conditions are true, we can frobnicate. do_something () # Add some extra indentation on the conditional continuation line. if ( this_is_one_thing and that_is_another_thing ): do_something () （也可参考下面关于二元操作符前后断行的讨论） 右括号可以和最后一行第一个非空格字符对齐， 1 2 3 4 5 6 7 8 my_list = [ 1 , 2 , 3 , 4 , 5 , 6 , ] result = some_function_that_takes_arguments ( 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , ) 也可以和第一行的第一个字符对齐， 1 2 3 4 5 6 7 8 my_list = [ 1 , 2 , 3 , 4 , 5 , 6 , ] result = some_function_that_takes_arguments ( 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , ) 注： hanging indentation 是指除了首行之外，其他行都缩进的打印风格。在 python 中，这个术语指的是一个带括号的语句，左括号是该行的最后一个字符，除了右括号，剩余行都会加上缩进 Tabs 还是 Spaces？ 首选空格 space 作为缩进方式。 只有为了和已有代码中的 tab 保持一致才能继续使用 tab。 python 3 不允许 tab 和 space 混合使用，python 2 中的 tab 和 space 混合使用时，应该先统一转换成 space。 如果 python 2 的命令行解释器带了 -t 选项，如果有 tab 和 space 混合使用的情况，它会报告 warning，如果带了 -tt 选项，则会报告 error。强烈推荐使用这些选项。 最大行长度 所有行的最大行长是 79 个字符。 对于基本没有结构化约束的长的文本（docstring 和注释），其长度不能超过 72 个字符。 限制编辑器的宽度的好处是可以并列打开多个文件，在 code review 的时候比较两个版本的代码时很方便。 许多工具的默认 warp 功能会破坏代码的视觉结构，使得代码难以理解。选择这些限制的目的就是为了防止 warp 功能设置为 80 个字符的编辑器自动 warp，即使有些编辑器在最后一列放了一个标记来提醒。一些基于 web 的工具甚至都不提供 warp 功能。 一些团队强烈希望更长的行长，如果代码由一个可以达成一致的团队维护，那么可以把限制放宽到 99 个字符，但是注释和 docstring 仍然不超过 72 个字符。 Python 标准库是保守主义，所以要求行长不超过 79（docstring 和注释不超过 72）。 对于很长的行，优先选择的方式应该是使用括号隐式的断行，而不是使用 \\ 来断行。 反斜线 \\ 有时候还是有用的，比如较长的 with 语句不能使用括号的方式，所以只能选择反斜线。 1 2 3 with open ( '/path/to/some/file/you/want/to/read' ) as file_1 , \\ open ( '/path/to/some/file/being/written' , 'w' ) as file_2 : file_2 . write ( file_1 . read ()) （对于这种 with 语句，可以参考前面讨论 if 语句的处理方式） 这种情况的另外一个例子是 assert 语句。 确保在后续的行中适当地缩进。 应该在二元操作符的前还是后断行？ 几十年以来，我们一直推荐的是在二元操作符之后断行，但是这样可能会伤害到代码的可读性，原因有两个：运算符一般分布在不同列，并且每个运算符和它的操作数被分开了，放到了操作数的前一行。下面的例子说明了需要读者的眼睛额外做一些工作来分辨那些变量是相加，哪些变量是相减， 1 2 3 4 5 6 7 # Wrong: # operators sit far away from their operands income = ( gross_wages + taxable_interest + ( dividends - qualified_dividends ) - ira_deduction - student_loan_interest ) 为了解决这个可读性的问题，数学家和出版商遵循了相反的约定。Donald Knuth 在他的 Computer and Typesetting 系列中解释了传统的规则：\" 虽然段落中的公式总是在二元操作符、关系操作符的后面断开，但是单独显示出来的公式却总是在二元操作符的前面断开。\" 遵循数学家的传统通常可以得到可读性更好的代码： 1 2 3 4 5 6 7 # Correct: # easy to match operators with operands income = ( gross_wages + taxable_interest + ( dividends - qualified_dividends ) - ira_deduction - student_loan_interest ) 在 python 代码中，在二元符号之前或之后都可以断行，只要在本地保持一致即可。对于新写的代码，推荐使用 Knuth 的风格。 空行 顶层的 function 和 class 定义前后需要两个空行。 class 内部的 method 定义前后需要一个空行。 一组功能相关的 function 可以通过额外的一个空行来区分（谨慎使用）。一组相关的单行代码之间的空行可以省掉（比如一组 dummy implementation）。 在 function 内部（谨慎）使用空行区分逻辑段。 python 接受 control-L 作为空格，许多工具把这些字符当作页面分割符，所以你可以用它们来区分文件中的相关段落。注意，一些编辑器和基于 web 的阅读器可能无法识别 control-L，会在其位置显示一个其他符号。 源文件的编码格式 python 核心发布版本中的代码总是使用 UTF-8 来编码（python 2 中用 ASCII）。 python 2 中使用 ASCII 的文件和 python 3 中使用 UTF-8 的代码不应该有编码申明。 在标准库中，只有以测试目的或者注释、docstring 中需要提及包含非 ASCII 字符的作者名时，才能使用非默认编码方式；其他情况下，在字符串中优先使用 \\x ， \\u ， \\U ， \\N 来转义非 ASCII 字符。 对于 python 3.0 和更高版本来说，标准库使用了下面的政策（见 PEP3131 ）：标准库中所有标识符 必须 使用 ASCII 标识符，并在尽可能使用英语单词（在很多情况下，缩写和术语是非英语）。除此之外，string literals 和注释必须也使用 ASCII。只有两个例外， 测试非 ASCII 的测试用例 作者的名字 如果作者的名字不是基于拉丁字符， 必须 提供一个拉丁字母音译。 鼓励具有全球受众的开源项目采取类似的策略。 Imports import 通常应该分开每行一个， 1 2 3 4 5 6 # Correct: import os import sys # Wrong: import sys , os 但是这么写也是 ok 的， 1 2 # Correct: from subprocess import Popen , PIPE import 必须放在文件的顶部，位于 module 注释和 docstring 的后面，在模块的全局变量 / 常量的前面。 import 应该按照下面的顺序分组： 标准库 import 相关的第三方库 import 本地应用 / 库的特定 import 在每组之间插入一个空行。 推荐使用绝对路径导入，因为当 import 系统配置不正确时（比如 package 内的一个目录以 sys.path 结尾），这么做的可读性更好，性能也更好（至少 error 信息更加清晰）。 1 2 3 import mypkg.sibling from mypkg import sibling from mypkg.sibling import example 然而，显式的相对路径也是一种可接受的方案，特别是使用绝对路径会导致不必要的复杂 package 布局的情况。 1 2 from . import sibling from .sibling import example 标准库中的代码应该避免复杂的 package 布局，并且永远使用绝对路径 import。 隐式的相对路径 import 永远都不应该使用，在 python 3 中已经删除了它。 当从一个包含 class 的 module 中 import 一个 class 时，一般可以这么写， 1 2 from myclass import MyClass from foo.bar.yourclass import YourClass 如果这种拼写方式导致名字冲突，那么可以这么写， 1 2 import myclass import foo.bar.yourclass 然后在代码中使用 myclass.Myclass 和 foo.bar.yourcalss.YourClass 。 应该避免使用通配符 * （ from <module> import * ），因为这样会使得命名空间中的名字变得不清晰，使很多读者和许多自动化工具产生混淆。有一种情况下可以使用 * ，即将内部的接口作为 public API 的一部分重新发布出来。（比如，有一个可选的加速模块，它有某个提前无法知道是否会被重写的端口，使用纯 Python 将其实现的情况） 当使用这种重新发布名称时，以下关于 public 和 内部接口的规则仍然适用。 模块级别的 dunber name 模块级别的 dunber （即使那些使用双下划线 __ 包围的名字），比如 __all__ ， __author__ ， __version__ 等等，应该放在 module 的 docstring 的后面，任何 import 语句之前（ form __future__ 除外）。python 要求 future-import 必须位于除过 docstring 之外的任何代码之前。 1 2 3 4 5 6 7 8 9 10 11 12 13 \"\"\"This is the example module. This module does stuff. \"\"\" from __future__ import barry_as_FLUFL __all__ = [ 'a' , 'b' , 'c' ] __version__ = '0.1' __author__ = 'Cardinal Biggles' import os import sys 注： dunber 指的是 Double + Underscore 的合体，指那些带双下划线的 method 或 attribute，如 __init__ 、 __main__ 、 __verison__ 等。 https://wiki.python.org/moin/DunderAlias An awkward thing about programming in Python: there are lots of double underscores. [snip] My problem with the double underscore is that it's hard to say. How do you pronounce init ? \"underscore underscore init underscore underscore\"? \"under under init under under\"? Just plain \"init\" seems to leave out something important. I have a solution: double underscore should be pronounced \"dunder\". So init is \"dunder init dunder\", or just \"dunder init\". string 引用 在 python 中，单引号和双引号字符串是一样的，本文关于这个不会给出建议。选择一个规则并且坚持下去即可。当一个 string 包含单引号或者是双引号时，在内部使用另外一种引号，这样可以避免在代码内部使用反斜线 \\ ，提高代码的可读性。 根据 PEP257 ，对于三引号 string，永远使用双引号。 表达式和语句中的空格 一些小问题 避免下面情况中出现的无关空格， 紧跟在括号之后 1 2 3 4 5 # Correct: spam ( ham [ 1 ], { eggs : 2 }) # Wrong: spam ( ham [ 1 ], { eggs : 2 } ) 在 trailing 逗号和右括号之间 1 2 3 4 5 # Correct: foo = ( 0 ,) # Wrong: bar = ( 0 , ) 紧贴在逗号，分号，冒号之前 1 2 3 4 5 # Correct: if x == 4 : print x , y ; x , y = y , x # Wrong: if x == 4 : print x , y ; x , y = y , x 然而， slice 内部的冒号就像是个二元操作符（把它当作是优先级最低的操作符），所以两边应该有相同数量的空格。在一个扩展 slice 中，所有的冒号必须有相同的间距。例外情况：slice 的一个参数被忽略了，它附带的空格也就被忽略了 1 2 3 4 5 6 7 8 9 10 11 12 # Correct: ham [ 1 : 9 ], ham [ 1 : 9 : 3 ], ham [: 9 : 3 ], ham [ 1 :: 3 ], ham [ 1 : 9 :] ham [ lower : upper ], ham [ lower : upper :], ham [ lower :: step ] ham [ lower + offset : upper + offset ] ham [: upper_fn ( x ) : step_fn ( x )], ham [:: step_fn ( x )] ham [ lower + offset : upper + offset ] # Wrong: ham [ lower + offset : upper + offset ] ham [ 1 : 9 ], ham [ 1 : 9 ], ham [ 1 : 9 : 3 ] ham [ lower : : upper ] ham [ : upper ] 紧跟在（函数调用参数列表）的左括号之后 1 2 3 4 5 # Correct: spam ( 1 ) # Wrong: spam ( 1 ) 紧跟在 index 或者是 slice 的左括号之前 1 2 3 4 5 # Correct: dct [ 'key' ] = lst [ index ] # Wrong: dct [ 'key' ] = lst [ index ] 为了和其他赋值语句对齐，在赋值语句周围使用多于 1 个空格 1 2 3 4 5 6 7 8 9 # Correct: x = 1 y = 2 long_variable = 3 # Wrong: x = 1 y = 2 long_variable = 3 别的建议 避免尾部空格。因为一般它都是不可见的，这可能会导致困惑：比如，反斜线后面跟着一个空格和一个换行符时，并不算做是一个有效的续行标记。一些编辑器不会保留尾部空格，并且很多项目（比如 CPython 自身）在 commit 之前会有相关检查来滤掉它。 永远在二元操作符两边加上单个空格，比如赋值 = ，增量赋值 += ， -= ，比较 == ， < ， > ， ！= ， <> ， <= ， >= ， in ， not ， is ， not ，布尔运算符 and ， or ， not 。 如果使用了具有不同优先级的运算符，考虑在低优先级的运算符周围加上额外的空格。使用自己的判断，但是空格数量不要超过 1 个，并且在二元运算符周围使用相同数量的空格。 1 2 3 4 5 6 7 8 9 10 11 12 13 # Correct: i = i + 1 submitted += 1 x = x * 2 - 1 hypot2 = x * x + y * y c = ( a + b ) * ( a - b ) # Wrong: i = i + 1 submitted += 1 x = x * 2 - 1 hypot2 = x * x + y * y c = ( a + b ) * ( a - b ) 函数注解应该使用正常的冒号规则，如果有 -> ，要在其周围加上空格（参考下文函数注解部分的更多信息） 1 2 3 4 5 6 7 # Correct: def munge ( input : AnyStr ): ... def munge () -> PosInt : ... # Wrong: def munge ( input : AnyStr ): ... def munge () -> PosInt : ... = 用来标记关键字参数或者是参数默认值时，不要使用空格 1 2 3 4 5 6 7 # Correct: def complex ( real , imag = 0.0 ): return magic ( r = real , i = imag ) # Wrong: def complex ( real , imag = 0.0 ): return magic ( r = real , i = imag ) 当参数有类型注释且有默认值时，要在 = 周围加上空格 1 2 3 4 5 6 7 # Correct: def munge ( sep : AnyStr = None ): ... def munge ( input : AnyStr , sep : AnyStr = None , limit = 1000 ): ... # Wrong: def munge ( input : AnyStr = None ): ... def munge ( input : AnyStr , limit = 1000 ): ... 复合语句（单行有多个语句）一般是不允许的 1 2 3 4 5 6 # Correct: if foo == 'blah' : do_blah_thing () do_one () do_two () do_three () 最好不要这样， 1 2 3 # Wrong: if foo == 'blah' : do_blah_thing () do_one (); do_two (); do_three () 有时候 if / for / while 可以和一小块代码放在同一行，但是多行语句时不要这样做，同时避免行长太长导致折叠！ 最好不要这样， 1 2 3 4 # Wrong: if foo == 'blah' : do_blah_thing () for x in lst : total += x while t < 10 : t = delay () 绝对不要这样， 1 2 3 4 5 6 7 8 9 10 11 # Wrong: if foo == 'blah' : do_blah_thing () else : do_non_blah_thing () try : something () finally : cleanup () do_one (); do_two (); do_three ( long , argument , list , like , this ) if foo == 'blah' : one (); two (); three () 什么时候使用尾部逗号 尾部逗号一般是可选的，除非是在构造单元素的 tuple 时它是强制性必须存在的，在 python2 的 print 中逗号是语法的一部分。为了清晰起见，推荐用（冗余的）圆括号包围起来： 1 2 # Correct: FILES = ( 'setup.cfg' ,) 1 2 # Wrong: FILES = 'setup.cfg' , 使用版本控制系统时冗余的尾部逗号通常非常有用，比如随着时间发展，由值或者是参数组成的 list ， import 的内容不断增多的时候，在最后加上尾部逗号非常有用。一般的写法是每个值一行，然后在最后添加一个元素后面加上尾部逗号，最后在下面的另外一行加上右括号。但是如果元素都在同一行，那么就没有理由加尾部逗号（除非是上面提到的单元素 tuple）： 1 2 3 4 5 6 7 8 # Correct: FILES = [ 'setup.cfg' , 'tox.ini' , ] initialize ( FILES , error = True , ) 1 2 3 # Wrong: FILES = [ 'setup.cfg' , 'tox.ini' ,] initialize ( FILES , error = True ,) 注释 和代码相冲突的注释比没有注释更糟糕，在代码改变之后永远第一时间更新相关注释。 注释应该是完整的句子，除非是用标识符开头的语句（永远不要改变标识符的大小写！），其他情况下第一个单词的首字母应该大写。 块注释一般由一段或者是多段的完整句子组成，并且每句都带一个句号。 在多语句的注释中，每句结束后面应该有两个空格，除非是最后一句。 用英语写注释时，遵循 Strunk and White 风格 如果你是非英语 python 码农，请使用英语写注释，除非你 120% 确保代码永远不会被不说你母语的人读到。 块注释 块注释一般放在代码前面，和代码的缩进同级，块注释中的每一行都以 # + 一个空格开头（除非是注释内部的缩进）。 块注释内部的段落用一个以 # 开头的空行隔开。 行内注释 谨慎地使用行内注释。 行内注释指的是和代码在同一行的注释，行内注释和代码应该用至少 2 个空格隔开，且以一个 # + 一个空格开始。 行内注释一般没有必要，事实上还会分散注意力。不要写类似下面的注释， 1 x = x + 1 # Increment x 但是有时候，这样写是很有用的， 1 x = x + 1 # Compensate for border docstring docstirng 的规则总结在 PEP257 内，其内容永远都不会改变。 为所有的 public module , function , class , method 写 docstirng。对非 public method 没有必要写 docstirng，但是你应该写个注释描述该 method 的作用。这个注释应该出现在 def 行的下面。 PEP257 描述了良好的 docstirng 惯例，要特别注意的是，多行的 docstirng 的结尾 \"\"\" 应该单独放一行。 1 2 3 4 \"\"\"Return a foobang Optional plotz says to frobnicate the bizbaz first. \"\"\" 对于单行的 docstring，把结尾的 \"\"\" 放在该行内 命名规范 python 库的命名规则有点混乱，我们一直没有完全统一，然而，这里列了一些当前推荐的命名标准。新写的 module 和 package （包括第三方的 framework）应该遵守下面的标注，但是如果一个已经存在的库有其他的 style，只要内部保持一致性即可。 最重要的规则 API 中那些对用户可见的公共接口的名字，应该遵循反映用法而不是内部实现的原则。 描述性的：命名风格 有许多不同的命名 style，下面这些可以帮助我们识别出正在使用什么样的 style，而和他们用来做什么没有关系。 下面是一些常见的方式： b （单个小写字母） B （单个大写字母） lowercase 小写 lower_case_with_underscores 小写带下划线 UPPERCASE 大写 UPPER_CASE_WITH_UNDERSCORES 大写带下划线 CapitalizedWords （或者叫 CapWords，CamelCase —— 驼峰命名法），有时也叫做 StudlyCaps 注意：在驼峰中使用首字母缩写时，所有字母都要大写，所以 HTTPServerError 比 HttpServerError 要好 mixedCase （和驼峰不同之处在于第一个字母小写） capitalized_Words_With_Underscores （丑陋！） 还有一种使用短缩写前缀来使一组相关的名字形成一个 group，Pyhton 中这种场景并不多见，这里只是为了全面而提一下。比如， os.stat() 函数返回了一个 tuple ，内部的变量是 st_mode , st_size , st_mtime 之类的名字。（这么做的目的是为了强调和 POSIX 系统调用的相关性，以帮助程序员熟悉它） X11 库里面所有的 public 函数都加了 X 前缀，在 python 里，这种风格通常是没有必要的，因为 attribute 和 method 调用的时候前面一般都会带上 object 前缀，而函数名前面会带上 module 的名字。 除此之外，下面的这种带前缀或后缀下划线 _ 的格式是可以的（通常和一些惯例结合在一起使用）： _single_leading_underscore_ ，弱 \" 内部使用 \" 标志。比如， from M import * 不会导入类似以 _ 开头的对象 single_trailing_underscore_ ，用来避免和 python 内部的关键字相冲突 1 Tkinter . Toplevel ( master , class_ = 'ClassName' ) __double_leading_underscore ，用来给 class 的 attribute 命名，调用它时会被矫正（在 class FooBar 中， __boo 会变成 _FooBar_boo ） __double_leading_and_trailing_underscore__ ，\"magic\" 对象 /attribute，存在于用户控制的 namespcae ，比如， __init__ ， __import__ ，或者 __file__ 。仅仅像文档说明的这样用，永远不要自己发明这种名字。 规范性的：命名惯例 避免使用的名字 永远都不要使用小写字母 l ，大写字母 O ，大写字母 I 作为单字母变量名。 在某些字体中，这些字符会和数字 0/1 混淆不清，如果要使用小写字母 l ，使用 L 代替。 兼容 ASCII 如 PEP3131 中所述，标准库中的标识符必须是 ASCII 兼容的。 package 和 module 的名字 module 必须使用简短，全小写的名字。如果使用下划线能提高代码的可读性，那么就可以使用。 虽然不鼓励使用下划线，但是 package 也必须也用简短、全小写的名字。 如果一个模块的底层实现使用的是 C/C++，并且有个用 python 模块来提供更高层次接口（比如，面向对象），那么这个 C/C++ module 名字必须要有下划线前缀（比如， _socket ）。 class 的名字 class 的名字一般应该使用 CapWords 的惯例。 如果 interface 被文档化了并且主要作为被调用的场景，那么可以换成 function 的命名惯例。 注意，对于内置的名字有个单独的惯例：大部分内置名字一般是单个单词（或者是两个单词连在一起）， CapWords 之用于 exception 和内置常量。 类型变量的名字 在 PEP484 中的类型变量名字，相比于短名字，如 T , AnyStr ， Num ，一般优先使用 CapWords 。推荐给变量加上后缀 _co 或者是 _contra 来声明相关的协变量或者是逆变量。 1 2 3 4 from typing import TypeVar VT_co = TypeVar ( 'VT_co' , covariant = True ) KT_contra = TypeVar ( 'KT_contra' , contravariant = True ) Exception 的名字 因为 exception 应该是个 class，所以使用 class 的规则即可。但是，如果某个 exception 确实是个 error，则应该给它加上 Error 后缀。 全局变量名 希望这些变量只会在单个 module 内使用。它的命名规则和 function 一样。 通过 from M import * 来使用的 module，应该使用 __all__ 机制来防止暴露 global 变量，或者使用以前加前缀的规则，比如给这些 global 变量加上单个下划线（表明你想暗示这些变量是 module 内，非 publicc 的）。 Function 和 变量 名 function 名应该小写，如果有必要，使用下划线将单词分隔开以提高可读性。 变量名和函数的规则一样。 只有在为了和旧代码（比如 threading.py ）保持兼容性时，才允许使用 mixedCase 风格的名字。 Function 和 Method 的参数 永远要把 self 作为例化 mehod 的第一个参数。 永远使用 cls 作为例化 class 的第一个参数。 如果一个 function 的参数名和关键字相冲突，一般最好在尾部加一个后缀的单下划线，而不是使用缩写或是故意拼写错误。所以 class_ 比 clss 要更好（也许最好的方式是使用一个同义词来避免这种情况）。 Mehtod 和 Instance 的名字 使用和 function 一样的命名规则：用下划线把小写单词分隔开以提高可读性。 只有非 public 的 method 和 instance variables 才可以加上前缀下划线。 为了避免和类名相冲突，使用两个前缀下划线来触发 python 的命名矫正规则。 python 会使用 class 的名字来矫正这些名字：如果 class Foo 有一个名字为 __a 的 attribute，则无法通过 Foo.__a 来访问它（用户可以通过 Foo._Foo__a 的方式来访问）。一般来说，双下划线前缀只应该用来避免和子类中的名字相冲突的情况。 常量 常量定义一般和 module 同级别，并且全部大写，用下划线隔开单词。比如 MAX_OVERFLOW 和 TOTAL 。 继承的设计 始终要考虑一个 class 的 method 和 instance variables（统称为： attribute ）应该是 public 还是 non-public。如果有疑问，那么就选择做成 non-public；因为之后将其再改为 public 要比反过来做更容易。 public attribute 是那些你希望和你的 class 不相关的用户可以使用的 attribute，并且你应该保证以后修改时不会发生向后不兼容的情况。non-public attribute 是那些不打算给第三方使用的 attribute，你没必要保证 non-public attribute 以后不会改变或甚至是被删除。 我们不使用术语 private ，是因为 python 里面的 attribute 并不是真正的 private（为了避免大量不必要的工作）。 基类中还有另外一类 attribute，它们会作为 subclass API 中一部分（通常在别的语言里面叫作 protected ）。有些 class 被特意设计成被继承形式，一般是为了扩展或者修改原来 class 的行为。当设计这种 class 时，要小心决定哪些 attribute 是 public 的，哪些 attribute 是 subclass 的 API，哪些是真正只有 base class 才会使用的。 遵守以上的思想，这里有一些 pythonic guideline： public attrbute 不应该有前缀下划线 如果你的 public attribute 的名字和保留的关键字冲突了，在属性的最后缀上一个下划线。优先选择这种方法而不是采用缩写或者是错误拼写（但是尽管有这样的规则，对于 class method 作为第一个参数的情况，优先选择用 'cls' 表示 class 类型的变量 / 参数） 注意 1：对于 class 的 method 的参数命令参考前面的讨论。 对于简单的 public data attribute，最好直接暴露它的名字，而不是再写一个复杂的 accessor/mutator method。如果一个 data attribute 需要增加功能，python 提供了一个方便的途径。这种情况下，使用 property 来隐藏简单的数据访问背后的 功能实现。 注意 1：property 应该只在 new-style 的 class 中实现。 注意 2：虽然有些副作用（比如 caching）是可以接受的，但是要尽量尝试让 function 的行为没有副作用 注意 3：property 会让调用者认为访问开销相对较小，所以尽量避免使用 property 来做大开销的计算 如果你的 class 可能会被扩展出 subclass，并且你不希望 subclass 使用一些 attribute，那么考虑用两个下划线前缀、没有下划线后缀的方式给这些 property 命名。这样会触发 python 的命名矫正算法，这个 attribute 的名字前会加上 class 的名字。这样可以避免 subclass 意外使用相同名字时的冲突。 注意 1：只有 class 的名字才会合入到 attribute 名字中，所以如果 subclass 的名字和其 attribute 的名字和父类名字相同，那么还是会有冲突 注意 2：命名矫正在某些情况下很不方便，比如 debug 或者是 __getattr__() 。但是命名矫正算法的文档很完善，使用起来也很方便。 注意 3：并不是每个人都喜欢命名矫正，尽量避免和潜在的高级调用者产生命名冲突。 public 和 internal 接口 任何的向后兼容只适用于 public 接口，因此，让用户能清晰地区分出 public 和 内部接口非常重要。 文档化的接口可以认为是 public 接口，除非文档中明确说明该接口是拥有向后兼容豁免权的临时 / 内部接口。所有没有文档化的接口都应该视为内部接口。 为了更好地支持 introspection，module 应该用 __all__ 明确声明 public API 的名字。如果没有 public API，那么就把 __all__ 设置为空 list。 即使合理地设置了 __all__ ，内部接口（package、module、class、function、attribute 或其他名字）还是应该加上单下划线前缀。 如果 namespace（package、module、class）被认为是内部的，那么包含在内的接口也会被认为是内部的。 import 的名字应该永远被认为是实现细节。除非是 module API 的一部分，否则别的 module 不能间接访问这些名字。比如， os.path 或者是一个 package 的 __init__ module。 编程建议 代码不能伤害其他 python 的实现（比如 PyPy、Jython、IronPython、Cython、Psyco 等等） 比如，字符串连接时不要依赖于 CPython 中的高效实现形式 a += b 或者是 a = a + b 。即使在 Cpython 中这种优化也是很脆弱的（只适用于部分类型），而且如果不使用 refcouting 那么就完全不会产生这种优化。库中对性能敏感的部分，应该使用 ''.join() 的方式。这样可以保证在各种实现中，字符串连接的时间开销是线性的。 和类似 None 这样的单例对象的比较，应该永远使用 is 或者是 is not ，永远不要使用等号操作符。 此外，如果你的目的是 if x is not None 那么要小心别写成 if x 。举例：判断一个默认值是 None 的变量 / 参数是否被设置成其他值，这个值（比如容器）的类型在 boolean 表达式中可能会是 false！ 使用 is not 而不是 not ... is 。虽然两个表达式的功能相同，但是前一种写法的可读性更强： 1 2 3 4 5 # Correct: if foo is not None : # Wrong: if not foo is None : 当使用丰富的比较实现排序时，最好实现所有的比较符（六个： __eq__ , __ne__ , __lt__ , __le__ , __gt__ , __ge__ ），而不是依赖于其他（只在特定比较上验证过的）代码 为了最小化开销，装饰器 functools.total_ordering() 可以提供一个工具来生成缺少的比较操作。 PEP207 指出 python 实现了反射机制，所以，解析器可能会把 y > x 转换成 x < y ，把 y >= x 转换成 x <= y ，把 x == y 转换成 x != y 。 sort() 和 min() 可以确保使用 < 操作符， max() 使用 > 操作符。但是，最好实现这六个操作符，这样在其他地方就不会有困惑。 始终使用 def 而不是赋值语句来把一个 lambda 表达式绑定到一个标识符上 1 2 3 4 5 # Correct: def f ( x ): return 2 * x # Wrong: f = lambda x : 2 * x 前一种形式意味着生成的 function 对象是 f 而不是通用的 <lambda> 。这在回溯和 stirng 显示的时候更加有用。赋值语句会消除 lambda 表达式优于显式使用 def 语句的唯一优势。（即 lambda 表达式可以内嵌在一个更大的表达式中） 从 Exception 而不是 BaseException 中继承 exception，直接从 BaseException 中继承得到的 exception 是保留的，捕捉这些异常是大部分情况下一件错误的事情。 基于需要捕捉 exception 的代码，而不是抛出 exception 的位置代码来设计 exception hierarchies。以编程的角度回答 \" 发生了什么错误 ?\" 这个问题，而不是只是说 \" 发生了错误 \"（内置 exception hierarchies 的例子见 PEP3151 ） 应该遵守 class 的命名规则，除非你的 exception 本身就是一个 error，那么就给这个 exception class 名字加上 Error 后缀。用于非本地控制或其他形式的非 error exception 不需要特殊的后缀。 适当地使用 exception 链，在 python 3 中，为了不丢失原始的回溯信息，应该使用 raise X from Y 来表示明确的替换。 当故意替换内部 exception 时（在 python 2 中用 raise X ，在 python 3 中用 raise X from None ），确保相关的细节被转移到了新的 exception 中（比如把 KeyError 转换成 AttributeError 时保留属性名，或在新的 exception 中嵌入原始 exception 的文本内容） 在 python 2 中抛出一个 exception 时，使用 raise ValueError('message') 而不是以前的形式 raise ValueError, message 。 后面这种格式在 python 3 中是非法的。 使用括号的格式意味着如果 exception 的参数特别长或者包含格式化字符串时不必使用换行符号。 当捕获 exception 时，如果可以尽量加上明确的 exception 名字，而不是写一个光秃秃的 except: 块： 1 2 3 4 5 # Yes try : import platform_specific_module except ImportError : platform_specific_module = None 一个光秃秃的 except: 块会捕捉到 SystemExit 和 KeyboardInterrupt ，导致很难通过 Control-C 的方式中断一个程序，而且会掩盖其他问题。如果你想捕获程序的所有异常，使用 except Exception: （光秃秃的 except 相当于 except BaseException: ）。 允许使用使用光秃秃的 except 的两种情况： exception 处理代码会打印或者记录 log，这样用户至少知道发生了错误 代码需要做一些清理工作，这种情况下最好使用 raise.try...finally 使 exception 可以继续向上传递 当把一个 exception 绑定到一个名字时，优先使用 python2.6 中新加的显式名字绑定： 1 2 3 4 try : process_data () except Exception as exc : raise DataProcessingFailedError ( str ( exc )) 这个语法只有 python3 才支持，它可以避免和原来基于逗号的语法之间的歧义。 当捕捉到操作系统的错误时，优先使用 python3.3 中的 explicit exception hierarchy 而不是 errno 值。 此外，对于所有的 try / except 块， try 语句中只使用必要的最小化代码，这样可以避免 bug 被掩盖掉： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Correct: try : value = collection [ key ] except KeyError : return key_not_found ( key ) else : return handle_value ( value ) # Wrong: try : # Too broad! return handle_value ( collection [ key ]) except KeyError : # Will also catch KeyError raised by handle_value() return key_not_found ( key ) 特定代码的局部资源，使用 with 语句来确保这个资源使用完成后被清理干净，下次还能继续使用。也可以用 try / finally 语句。 除了获取 / 释放资源，其他时候都应该通过独立的 function 或 method 来调用上下文管理器 1 2 3 4 5 6 7 # Correct: with conn . begin_transaction (): do_stuff_in_transaction ( conn ) # Wrong: with conn : do_stuff_in_transaction ( conn ) 后面这个例子没有提供任何信息来指示 __enter__ 和 __exit__ 两个 method 除了在 tansaction 之后关闭连接之外做的其他事情，。在这种情况下，明确指明很重要。 返回语句要保持一致性。要么所有 function 的返回语句都返回一个表达式，要么都不返回。如果有返回语句返回的是表达式，那么不返回值的返回语句应该明确声明 return None ，并且位于 function 的最后一句 （如果能跑到这一句的话）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Correct: def foo ( x ): if x >= 0 : return math . sqrt ( x ) else : return None def bar ( x ): if x < 0 : return None return math . sqrt ( x ) # Wrong: def foo ( x ): if x >= 0 : return math . sqrt ( x ) def bar ( x ): if x < 0 : return return math . sqrt ( x ) 使用 string method 而不是 stirng module。 string mothod 总是速度更快，而且和 unicode string 共享相同的 API，如果要求兼容 python2.0 以前的版本则可以忽略这条规则。 使用 ''.startswith() 和 ''.endswith() 而不是 string 切片来检查前缀 / 后缀。 startwith() 和 endswith() 更加清晰，而且不易出错： 1 2 3 4 5 # Correct: if foo . startswith ( 'bar' ): # Wrong: if foo [: 3 ] == 'bar' : 对象类型的比较应该使用 isinstance() 而不是直接比较类型： 1 2 3 4 5 # Correct: if isinstance ( obj , int ): # Wrong: if type ( obj ) is type ( 1 ): 如果检查一个对象是否为 string，记得它有可能是个 unicode string！在 python 2 中， str 和 unicode 有相同的基类 basestring ，所以你可以这么做： 1 if isinstance ( obj , basestring ): 注意在 python 3 里面， unicode 和 basestring 都不再存在了（只有 str ），并且 bytes 对象不再是 string 的一种，它是整数序列。 对于序列（stirngs，list，tupels）来说，空序列的值是 false： 1 2 3 4 5 6 7 # Correct: if not seq : if seq : # Wrong: if len ( seq ): if not len ( seq ): 写 string 时不要依赖结尾的空格，这种空格在视觉上难以区分，而且一些编辑器（比如 reindent.py）会删掉他们。 不要使用 == 来比较 boolean 值和 True / False ： 1 2 3 4 5 # Correct: if greeting : # Wrong: if greeting == True : 更糟糕的情况： 1 2 # Wrong: if greeting is True : 在 try...finally 的最后一个分支中使用流程控制语句 return / break / continue ，而且这个语句会跳转到外面，不鼓励这种方式。因为这种语句会隐式地取消所有的正在通过最后一个分支传播的 exception： 1 2 3 4 5 6 # Wrong: def foo (): try : 1 / 0 finally : return 42 函数注解 随着 PEP484 的引入，下面的函数注解规则有些变化： 为了前向兼容，python 3 中的函数注解应该优先使用 PEP484 的语法（在之前的章节中有一些注解的推荐规则） 不再鼓励使用本文以前推荐的实验性注释风格 但是，除了标准库，鼓励使用 PEP484 中的实验性规则。比如，使用 PEP484 中的 style 为一个大型第三方库 / 应用添加注解，检查添加这些注解的容易程度，观察这些注解的出现是否提高了可读性。 python 的标准库应该保守地使用这些注解，但是新代码和大型的重构可以使用这种注解。 如果代码想用另外一种方式使用函数注解，推荐在文件顶部添加这样一条注释： 1 # type : ignore 这会告诉 type checker 忽略所有的注解（在 PEP484 中可以找到更加详细的关于细颗粒度的关闭 type checker 的报错） 和 linter 类似，type checker 是独立可选的工具，python 解释器默认不会报出任何 type checker 的内容，而且不会基于注释改变它们的行为。 用户不想使用 type checker 时可以忽略它们。但是，第三方库的用户可能希望在这些库上运行 type checker，为此， PEP484 推荐使用 stub 文件：相比于 .py 文件，type checker 优先读取 .pyi 文件。stub 文件可以和库一起发布，也可以通过单独的 typeshed repo 发布（通过库的作者许可） 对于需要向后兼容的代码，可以以注释的方式添加类型注解，相关内容见 PEP484 。 变量注解 PEP526 介绍了变量注解，对于变量的注解风格和前面描述的函数注解类似： 对于 module 级别的变量，class 和 instance variables，局部变量，应该在冒号后面加个空格 冒号前面不应该有空格 如果赋值语句有右侧内容，那么等号两边的空格数应该相等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Correct: code : int class Point : coords : Tuple [ int , int ] label : str = '<unknown>' # Wrong: code : int # No space after colon code : int # Space before colon class Test : result : int = 0 # No spaces around equality sign 虽然 python 3 可以使用 PEP526 ，但是对于所有版本的 python，首先以 stub 文件的语法优先选择变量注解。（细节见 PEP484 ） 翻译参考 PEP8 Python PEP8 编码规范中文版 附 Google 推出过开源项目的 coding style 规范，包含了常见编程语言，如 C++ , java , Python , Shell 等。因为已经有国内程序员凭热情创建和维护的中文版本，所以就不再翻译了。 Google Style Guide Google 开源项目风格指南 ( 中文版 )","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_peps_series_1_pep8.html","title":"PEP 学习系列 #1 —— PEP8"},{"url":"https://qiangu.cool/posts/cs/learning_peps_series_0_pep0.html","text":"PEP 简介 PEPs 是 Python Enhancement Proposals 的缩写，它源自于 Python 核心开发者的邮件列表所讨论的问题、提议，最终汇总成了正式文档，为众多 Python 用户提供指导。 PEP0 是所有 PEP 的目录， PEP1 说明了 PEP 的目的以及 Guidelines，这里不再赘述。 从 PEP0 中可以知道，PEP 一共分为 3 类： I - Informational PEP P - Process PEP S - Standards Track PEP PEP 根据状态可以分为下面几种： A - Accepted(Standards Track only) or Active proposal D - Deferred proposal F - Final proposal P - Provisional proposal R - Rejected proposal S - Superseded proposal W - Withdrawn proposal 翻译计划 为了督促自己有计划地完成 PEP 的学习，也是为了以后可以温故而知新，在这里记录一下自己的学习笔记。从 PEP0 中可以知道，各种各类的 PEP 加起来目前一共有几百篇，参考网上其他介绍，学习计划中暂时选择了下面几篇，以后再持续更新。 PEP 0 -- Index of Python Enhancement Proposals PEP 8 -- Style Guide for Python Code PEP 257 -- Docstring Conventions PEP 20 -- The Zen of Python PEP 202 -- List Comprehensions PEP 274 -- Dict Comprehensions PEP 234 -- Iterators PEP 255 -- Simple Generators PEP 289 -- Generator Expressions PEP 279 -- The enumerate() built-in function PEP 380 -- Syntax for Delegating to a Subgenerator PEP 282 -- A Logging System PEP 285 -- Adding a bool type PEP 318 -- Decorators for Functions and Methods PEP 484 -- Type Hints PEP 3115 -- Metaclasses in Python 3000 参考 PEP0 PEP1 python 中的 PEP 是什么？怎么理解？（转）","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_peps_series_0_pep0.html","title":"PEP 学习系列 #0 —— PEP0"},{"url":"https://qiangu.cool/posts/ic/fifo_design_notes.html","text":"FIFO 的重要性就不用再重复了，在笔试面试的时候也常常被问到，总结一下设计 FIFO 需要注意的问题。 FIFO 可以分为两类： Sync FIFO: write 和 read 使用同一个时钟 Async FIFO: write 和 read 分别使用两个时钟 设计 FIFO 的时候，通常需要考虑的问题有： FIFO 的大小 FIFO 空满的判断 Sync FIFO Sync FIFO 的框图如下所示： 因为同步 FIFO 的读写速率是相同的，所以 FIFO 的大小设置不必考虑读写速率差这个因素，要简单很多。 在 FIFO 内部，一般使用 dual port RAM 存储数据。双端口 RAM 有两套独立的读写地址，读地址和写地址分别由读指针和写指针来产生：写指针指向下一个数据被写入的地址，读指针指向下一个被读出的数据的地址，通过判断读写指针的相对大小，就可以得到 FIFO 的状态（full / empty）。 还有另外一种方法来产生 full / empty 信号：FIFO 内部维护一个计数器，每次写入一个数据 cnt++，每次读出一个数据 cnt--。这种方法产生 full / empty 很简单：当 cnt == 0，表示 FIFO empty；当 cnt == max，表示 FIFO full。虽然这种方法产生 full / empty 很简单，但是需要额外的计数器，而且计数器的位宽随着 FIFO 的深度增加，不仅占用的资源更多，而且会降低 FIFO 最终可以达到的速度。 Async FIFO 一般异步 FIFO 的读写速率不同，如果写速度 > 读速度，则当数据量超过一定长度时，会出现溢出的情况，为了防止这种情况，可以采用两种措施： 预先知道写速率和模式（burst / nonburst），最小的读速率，根据这些条件设置 FIFO 的深度 通常发送端的数据都是突发的形式，FIFO 的深度至少要大于等于突发数据的最大长度。 握手机制（full / empty） 很多情况下，突发数据的长度和分布是预先不知道的，此时则无法确保 FIFO 的深度足够大，因此需要握手机制来告诉发送端已经没有多余的空地址保存数据 or 告诉接收端已经内部已经没有剩余的可以读取的数据。通常使用如下的 FSM 来实现： 发送端，写数据： 接收端，读数据： Gray Code 在异步 FIFO 中，因为一些内部的信号要从写 / 读时钟域传递到读 / 写时钟域，所以必须要解决异步信号同步的问题，而且有的信号不止 1 bit，如果使用 \" 同步桥 \"，则因为各个 bit 的同步时延不一定（1~2T），所以不能用同步桥。 这个问题可以使用 gray code 解决：gray code 是循环码，每次只有 1 bit 变化，这样就避免了多 bits 变化的数据同步问题。如下图： gray code 与 binary code 的相互想换见另 外一篇 blog 。 wr_ptr / rd_ptr Sync Lag 异步 FIFO 还有个问题是：地址信号跨时钟域时，可能会有 1T 的时延，这个多余的时延并不会导致 full /empty 错误置位，引起错误的 overf： 如果地址信号传递到读时钟域时延时了 1T，此时接收端并不知道数据已经写入了 FIFO，仍然认为 FIFO 是空的，这种情况只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 underflow； 如下图，先写满 FIFO，然后开始读：在 t6 时 FIFO 读空，empty = 1，在 t7 时，写入了一个新数据，此时 FIFO 内已经有有效数据了，但是 wr_ptr 同步到读时钟域要花费 2T，所以在 t9 时 empty = 0。有两个时钟周期（t7, t8） rd 被阻塞了，但是并不影响 FIFO 正常工作。 时序图： 如果地址信号传递到写时钟域时延是了 1T，此时发送端并不知道 FIFO 已经有空余地址了，仍然认为 FIFO 是满的，这种情况也是只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 overfl； 如下图，先写满 FIFO，然后开始读：在 t5 时，full = 1，在 t6 时，读出了一个数据，此时 FIFO 已经有空余地址了，但是 rd_ptr 同步到写时钟域要花费 2T，所以在 t8 时 full = 0。有两个时钟周期（t6, t7） wr 被阻塞了，但是并不影响 FIFO 正常工作。 时序图： Full / Empty Generation 因为 wr_ptr 和 rd_ptr 相同时，FIFO 既可能是 full，也有可能是 empt，所以需要额外的 1 bit 来区别这两种情况： 假设 FIFO 的深度是 8，则地址为 3 bits，初始时 wr_ptr 和 rd_ptr 都是 0000 ，FIFO 此时是 empty： 当连续 8 个数据写入到 FIFO full，wr_ptr = 1000 ，而 rd_ptr = 0000 ， MSB 不同，剩余位相同 当连续 8 次读取数据 FIFO empty，rd_ptr = wr_ptr = 1000 ， 所有 bits 都相等 借助这多余的 1 bit，可以区分出是 wr_ptr 太快，将 rd_ptr 套圈了（wr_ptr = 1000 ，rd_ptr = 0000 ， 即 full），还是 rd_ptr 更快，追上了 wr_ptr（rd_ptr = wr_ptr = 1000 ）。 框图如下： 这种 wr_ptr / rd_ptr 用 gray code 保存，比较 /+1 用 binary 保存的方式，使得 design / debug 变得很简单，但是需要的资源比较多。如果全部使用 gray code，虽然可以降低资源占用，但是需要其他逻辑。 Dual Clock FIFO Design 下图是使用 Dual port RAM 的异步 FIFO 框图，其中 wr_ptr 和 rd_ptr 直接使用 gray code，节省了 gray code 和 binary code 之间的转换逻辑。 和前面的逻辑类似，使用多 1 bit 来辅助区分 full / empt，不过因为改成用 gray code 来比较，所以稍有不同，下图显示了 FIFO 从 empty 到 full 再到 empty 的过程： FIFO empty 当 wr_ptr = rd_ptr 时 FIFO empty FIFO full 如上图，FIFO 初始状态为 empty，然后连续写入 8 个数据，再读出 8 个数据，此时 wr_ptr = rd_ptr = 7，FIFO 又变为 empty。此时如果再写入一个数据，wr_ptr = 8，rd_ptr = 7，如果仍然使用前面介绍的方法（MSB 不同，剩余位相同 )，则会得出 FIFO full 的错误结论，实际上 FIFO 并没有满。 仔细观察 gray code 的对称性，就可以知道，当 full 时（wr_ptr 将 rd_ptr 套圈时），MSB 不同，wr_ptr 的 2nd MSB 要先翻转，才和 rd_ptr 相同。所以，当下面 3 个条件都满足时，FIFO full： wr_ptr 和 rd_ptr 的 MSB 不相等 wr_ptr 的 2nd MSB 翻转后和 rd_ptr 的 2nd MSB 相等 剩余 bits 全部相等 Summary 总结 FIFO 的设计，只要注意 FIFO 通过 wr_ptr 和 rd_ptr 得到 full / empty，而且使用 gray code 来跨时钟域，基本上就没问题了 :-D Ref The Art of Hardware Architecture: Design Methods and Techniques for Digital Circuits Advanced FPGA Design: Architecture, Implementation, and Optimization","tags":"IC","loc":"https://qiangu.cool/posts/ic/fifo_design_notes.html","title":"FIFO 设计笔记"},{"url":"https://qiangu.cool/posts/telecom/summary_of_frequency_in_digital_signal_processing.html","text":"最近实习的时候，发现自己的 DSP 基本功还是不够扎实，关于模拟 / 数字角频率，频率，采样速率等一些概念理解的都不太深刻，愧对老师和这么多年的学习，Google 到一些讲解的比较清楚的 blog，备忘（抄袭）过来，温故而知新。 unit circle & sin(cos) 首先从最基本的三角函数的定义开始： 三角函数的定义方式有很多种，我觉得基于单位圆的定义是最形象，对之后理解各种角频率的物理 / 数学含义最有帮助。 我们应该是在初中的时候第一次接触到三角函数，那时候三角函数的定义是直接给个三角形，然后直接定义 sin(cos) 为哪条边比哪条边的值，然后给出 sin(cos) 的波形如下图所示： \"Sine cosine one period\" by Geek3 - Own work. Licensed under CC BY 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Sine_cosine_one_period.svg#/media/File:Sine_cosine_one_period.svg 当我们将这个三角形和单位圆联系在一起的时候，sin(cos) 的几何意义就很明显了： \"Circle-trig6\" by This is a vector graphic version of Image:Circle-trig6.png by user:Tttrung which was licensed under the GFDL. Based on en:Image:Circle-trig6.png, which was donated to Wikipedia under GFDL by Steven G. Johnson. - This is a vector graphic version of Image:Circle-trig6.png by user:Tttrung which was licensed under the GFDL. ; Based on en:Image:Circle-trig6.png, which was donated to Wikipedia under GFDL by Steven G. Johnson.. Licensed under CC BY-SA 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Circle-trig6.svg#/media/File:Circle-trig6.svg 图中红色的线段长度就是 sin 的值，蓝色的线段长度就是 cos 的值，如果我们假设坐标系的原点和单位圆重合，脑补一下下面的场景：有个小球（只能）沿着单位圆的圆周做运动。这时候，我们就会发现一个事实： sin(t) 是小球 t 时刻在 y 轴上的投影，cos(t) 是小球 t 时刻在 x 轴上的投影。 进一步，当小球的运动速率是匀速率的时候，就有了上面提到的波形，更加形象的图如下： \"Circle cos sin\" by LucasVB - Own work. Licensed under Public Domain via Commons - https://commons.wikimedia.org/wiki/File:Circle_cos_sin.gif#/media/File:Circle_cos_sin.gif P.S. 关于投影，wiki 上有个解释欧拉公式的图特别好： \"Sine and Cosine fundamental relationship to Circle (and Helix)\" by Tdadamemd - Own work by uploader (.gif frames created in Powerpoint). Licensed under CC BY-SA 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Sine_and_Cosine_fundamental_relationship_to_Circle_(and_Helix).gif#/media/File:Sine_and_Cosine_fundamental_relationship_to_Circle_(and_Helix).gif 有了上面简单的背景，就可以开始逐个讨论信号处理中的概念了。 Ω 我们已经知道小球在圆周上做匀速率的圆周运动时，它在两个坐标轴上的投影就分别是 sin(cos)，如果我们想进一步描述小球的运动速率的快慢呢？ 假设小球完整转一圈所花费的时间为 T，转动的角度为 2π，则我们可以定义 模拟角频率 Ω = 2π/T ，单位是 rad / s 来描述小球的转动速率的快慢。 当 t = 2π 时，y = sin(Ω*2π)，这时候可以看出 Ω 的物理含义： 在 2π 的时间内，小球所完成的圈数。 下面的 Matlab 小程序演示了 2π 时间内 Ω 和周期的对应关系： 1 2 3 4 5 6 7 8 t = 0 : pi / 50 : 2 * pi ; for OMEGA = 1 : 4 y (:, OMEGA ) = sin ( OMEGA * t ); str { OMEGA } = [ 'OMEGA=' , num2str ( OMEGA )]; end h = plot ( t , y ); grid on ; xlabel ( 't / s' ); ylabel ( 'amp' ); title ( 'y = sin(OMEGA*t)' ); legend ( h , str ); 结果如下图： f 小球在二维平面上的圆周运动投影到一维的坐标轴 x(y) 轴上看，则是左右（上下）振动。和 Ω 类似，我们也可以定义一个物理量来描述这种振动的快慢： 小球完成一次完整的圆周运动所花费的时间为 T，也就是完成一次振动花费了 T 时间，我们定义 频率 f = 1 / T ，单位是 Hz 来描述振动的快慢。由前面 Ω 的定义式可知， Ω = 2π * f ，有 y = sin(2π * f * t)。 当 t = 1s 时，y = sin(2π * f)，这时候可以看出 f 的物理意义： 在 1s 的时间内，小球所完成的振动次数。 下面的 Matlab 小程序演示了 1s 时间内 f 和振动周期的对应关系： 1 2 3 4 5 6 7 8 t = 0 : 1 / 100 : 1 ; for f = 1 : 4 y (:, f ) = sin ( 2 * pi * f * t ); str { f } = [ 'f=' , num2str ( f )]; end h = plot ( t , y ); grid on ; xlabel ( 't / s' ); ylabel ( 'amp' ); title ( 'y = sin(2*pi*f*t)' ); legend ( h , str ); 结果如下图： w 计算机的世界是离散的，所以当连续信号经过采样、量化得到离散信号后： y = sin(Ω t) = sin(Ω n Ts) = sin(Ω Ts n) = sin(w n) 从数学上我们就可以得到： 数字角频率 w = Ω*Ts = Ω / Fs ，单位是 rad 可以看到，w 是用采样频率 Fs 对 Ω 进行归一化得到的，所以 w 准确地应该叫做归一化数字角频率。 连接模拟和数字的桥梁就是采样频率 Fs，由计算过程可以知道，w 相同的两个信号，它们的 Ω 不一定相同。因为丢失了 Fs 信息，所以单独讨论 w 是没有意义的。 虽然单独讨论 w 是没有意义的，但是这不代表 w 没有物理意义，当小球的振动频率为 f 时，每秒在圆周上转过的角度为 Ω = 2π * f，而采样频率为 Fs 就是说每秒钟对小球进行 Fs 次采样（拍照），显然有 Fs 个样值（照片）。这些样值（照片）是均匀分布的，所以每两个样值点之间的弧度为 2π * f / Fs = w，这也就是 w 的物理含义： 相邻两个样值点之间的弧度数。 ================================== summary ==================================== 这几个频率之间是线性关系，可以得到下面的对应关系： Item Min Mid Max n 0 (N-1)/2 N Ω 0 Ωs/2 Ωs f 0 Fs/2 Fs w 0 π 2*π 由频谱的搬移过程可以知道，w 从 π 到 2π 是负频率搬移的结果，所以通常分析的时候 w 的范围为 [-π, π)，如下 Item Min Mid Max Ω -Ωs/2 0 Ωs/2 f -Fs/2 0 Fs/2 w -π 0 π Ref Trigonometric functions 阿英讲频率 f，角频率 Ω 和数字频率 w 的物理含义 -- 附 MATLAB 仿真 傅里叶分析之掐死教程（完整版）更新于 2014.06.06","tags":"Telecom","loc":"https://qiangu.cool/posts/telecom/summary_of_frequency_in_digital_signal_processing.html","title":"数字信号处理中的各种频率"},{"url":"https://qiangu.cool/posts/ic/low_power_design.html","text":"在一些情况下，是不需要考虑低功耗设计的，但是更多的情况下，低功耗是必须考虑的，总结一下 THE ART OF HARDWARE ARCHITECTURE 中介绍的低功耗设计的方法。 Sources of Power Consumption 首先，分析功耗的来源。 功耗可以分为 3 类： Inrush 浪涌电流（Inrush current）也叫做启动电流（start-up current）。它指的是设备上电时产生的瞬间最大电流，这个值和设备有关。基于 SRAM 的 FPGA 有很大的浪涌电流，因为它需要从外部 ROM 中下载数据来配置内部逻辑资源，反之，基于 anti-fuse 的 FPGA 因为不需要上电配置，所以也就不存在浪涌电流。 Static 待机电流（Standby current）是指待机状态下的电流，由待机电流产生的功耗称为待机功耗（standby power），也就是静态功耗（static power）。静态功耗和浪涌功耗类似，也和器件的电气特性密切相关。（静态功耗包含了晶体管的漏电流导致的功耗） Dynamic 动态功耗（Dynamic power）是门电路的逻辑值切换时产生的功耗。动态功耗可以从一个定义式中计算出来。 综上，ASIC 的总功耗定义为： Ptotal = Pdynamic + Pstatic 其中，动态功耗占了主要部分，典型应用中，动态功耗占到总功耗的 80% 。 Power Reduction Power Reduction 可以从系统的不同层次来降低功耗，下图展示了不同级别的不同技术，虽然可以在各个级别进行，但是在抽象层次越高的级别，得到的效果越有效，即在系统层（system level）和体系结构层（architecture level）进行。 下面一张表展示了各个级别对功耗降低程度的影响： 下面分别从不同层次总结。 System Level SoC Approach 对于纳米级高端芯片，I/O 使用比芯片内核更高的电压，占到了总功耗的 50% 以上。如果有很多芯片的话，芯片之间的连线会消耗大量的功耗，所以就提出了 SoC，以缩减面积，降低成本。 HW/SW Partitioning 相比于硬件，使用软件高级语言编程可以很方便的实现功能。但是，一些功能可以使用硬件来实现，来降低功耗。 比如通信算法中有很多递归运算，实现递归的软件代码可能很少，但是这段只占代码量的 10% 的代码却花费了 90% 的执行时间，如果将这段代码使用硬件实现，就能够节约大量能源，显著降低功耗。 常规的软硬件划分方法如下图所示： 典型的设计流程如下： Specifications Partitioning Synthesis Integration Co-Simulation Verification 首先，设计者根据规范和自身经验对系统性能做出推测，根据推测来决定系统哪部分用硬件实现，哪部分用软件实现。 然后，对软硬件进行描述，硬件用 Verilog/VHDL，软件使用 C 。 下一步对软硬件进行协同仿真，验证设计功能。如果不满足要求，则从系统划分开始重新再来。 Low Power Software 软件设计部分也可以像硬件设计一样，在设计时就进行一些优化，得到更加绿色、高效的系统。 比如，将下面的两个循环合并为一个： // code1 for i = 1 to n do a ; end for i = 1 to n do b ; end // code2 for i = 1 to n do a ; do b ; end 因为减少了循环计数器（初始化、递增、比较），所以循环指令数目就减少了。 Choice of Processor 选择处理器会对整体功耗产生明显影响。（高级话题，以后再补） Architecture Level Power Reduction Advanced Clock Gating 同步设计中，时钟占据了整个动态功耗的绝大部分，在许多情况下都可以通过门控时钟将绝大多数不使用的电路关闭掉。 门控时钟有如下的两种： 组合门控时钟 时序门控时钟 Dynamic Voltage and Frequency Scaling (DVFS) ... Cache Based Architecture 缓存一方面可以缓解内存和 CPU 之间速度的差异，还可以用来减少访问内存的次数，把需要频繁访问的数据保存在缓存中，可以使得计算能耗大量下降。 Log FFT Architecture 对于大规模运算的应用，使用对数系统（ logarithmic number system，LNS）比线性系统更好。LNS 在降低平均位元活跃度的同时用加法和奖罚实现乘除运算，使其效率比线性系统更高。 Asynchronous (Clockless) Design 同步设计的时钟信号带来的问题很多，同时产生的功耗也很大，所以移除时钟是一个很有诱惑力的想法，这就是异步设计的基本意图，不过异步设计不是简单的移除时钟，仍然需要对电路进行某种控制。异步电路本质上进行自我控制，因此也成为自定时电路。 Power Gating ... Multi-threshold Voltage ... Multi-supply Voltage ... Gate Memory Power ... Register Transfer Level (RTL) Power Reduction 在大规模 ASIC 中，在 RTL 级完成时，至少 80% 的功耗已经确定了，后端流程无法解决所有的功耗问题，后端无法解决微架构、RTL 代码风格对动态和静态功耗的影响，所以在 RTL 阶段就要将功耗相关的问题一起解决。 State Machine Encoding and Decomposition 在各种状态机编码类型中，格雷码是最符合低功耗设计的。因为格雷码相邻码之间只有一位翻转，所以消耗的能量最少。（格雷码是最优的，有个 条件就是状态机是按顺序跳转的，如果状态跳转的次序是不定的，那么格雷码的优势就不存在了） 即使因为一些原因，没有使用格雷码，仍然可以通过降低翻转较多的状态的切换频率，来降低功耗。 还有一种方法是将 FSM 进行分解为两个，两个小的 FSM 组合起来等效于原始的 FSM。当一个的 FSM 激活时，可以关闭另外一个 FSM，这样绝大多数时间内只需要给较小且更有效率的子 FSM 提供时钟，从而降低了功耗。 Binary Number Representation 虽然在大多数应用中，补码比原码更方便，但是有些特殊应用中，在切换过程中原码更有优势。比如 0 和 -1 分别用原码和补码表示： // Signed Magnitude 0 -> 00000000 - 1 -> 10000001 // 2 ' s compliment 0 -> 00000000 - 1 -> 11111111 当从 0 变为 1 时，原码只需要变化两位，而补码所有位都会变化。 Basic Gated Clock 门控时钟在 Architecture 部分已经说过了，这里从 RTL 的角度再重复一下。RTL 的代码风格会影响到最终的实现结果，所以应该在编写 RTL 的时候需要特别注意。 // bad example always @ ( posedge clk or negedge rst_n ) begin if ( ! rst_n ) test_ff <= 32 ' b0; else test_ff <= test_next ; end assign test_next = load_cond ? test_data : test_ff ; // good example always @ ( posedge clk or negedge rst_n ) begin if ( ! rst_n ) test_ff <= 32 ' b0; else if ( load_cond ) test_ff <= test_data ; end One Hot Encoded Multiplexer Mux 的编码方案也可以采用独热码的方式，从而减少开关切换的数目，降低功耗。 Removing Redundant Transactions 有时候，一些没有意义的数据切换去掉，从而降低功耗。比如前级的逻辑产生一些数据，但是在后级逻辑中没有使用，这时候就可以修改设计，在前面一级就关闭，在需要数据的时候，让真正生成数据的电路工作。 Resource Sharing 如果有一些相同的操作，那么可以使用资源共享的方法，避免运算逻辑重复出现。 // bad example always @ * begin case ( SEL ) 3 ' b000: OUT = 1 ' b0 ; 3 ' b001: OUT = 1 ' b1 ; 3 ' b010: OUT = (value1 == value2); 3 ' b011: OUT = (value1 != value2); 3 ' b100: OUT = (value1 >= value2); 3 ' b101: OUT = (value1 <= value2); 3 ' b110: OUT = (value1 < value2); 3 ' b111: OUT = (value1 > value2); endcase end // good example assign cmp_equal = ( value1 == value2 ) ; assign cmp_greater = ( value1 > value2 ) ; always @ * begin case ( SEL ) 3 ' b000: OUT = 1 ' b0 ; 3 ' b001: OUT = 1 ' b1 ; 3 ' b010: OUT = cmp_equal; 3 ' b011: OUT = !cmp_equal; 3 ' b100: OUT = (cmp_equal || cmp_greater); 3 ' b101: OUT = !cmp_greater; 3 ' b110: OUT = !cmp_equal && !cmp_greater; 3 ' b111: OUT = cmp_greater; endcase end Using Ripple Counters for Low Power 行波计数器属于异步设计，会给时序分析，电路的可靠性带来很多问题。所以一般要避免使用的。不过在一些低速的应用中（比如数码管显示），仍然可以使用行波计数器来降低功耗。 Bus Inversion 当总线上的当前数据和下一个数据之间的汉明距离大于 N/2 时（N 是总线宽度），就将下一个数据反向再传输。这样做可以降低总线上出现的转换次数，从而降低功耗。 如下图所示： Transistor Level Power Reduction 寄存器级别的技术基本属于后端 & 微电子科学了，就不再总结了。 Ref THE ART OF HARDWARE ARCHITECTURE","tags":"IC","loc":"https://qiangu.cool/posts/ic/low_power_design.html","title":"低功耗设计"},{"url":"https://qiangu.cool/posts/ic/the_art_of_pipelining.html","text":"PC 世界永恒不变的信条就是提高性能，其中一个方法就是提高系统的时钟频率。 在另外一篇 blog 静态时序分析 STA 中已经总结过了，限制系统最大工作频率的因素有很多，设计者能够控制的是 DFF 之间的组合逻辑的时延 Tcomb，降低最大时延路径（关键路径，critical path）的时延 Tcomb，就可以提高系统的工作频率。 如何降低呢？方法就是流水线（pipeline）。 Pipeline Intro 所谓流水线（pipeline）设计，应该是从汽车工业中的 流水生产线 借鉴过来的说法吧。 在汽车生产的时候，假设分为 5 个阶段，每个阶段都需要 1 个工人花费 1 小时完成，因为后续的阶段必须等前面阶段完成后才能进行，所以总共需要 5 个小时才能完成一辆汽车。但是采用流水线方式，在进行后续阶段时，前面的阶段可以进行新的工作，那么每个小时都可以生产出一辆汽车了，生产效率提高了 5 倍。 可以看到，流水线之所以可以大大提高效率的原因在于：传统的方式，某个阶段进行时，其他阶段是空闲等待的，浪费时间；而流水方式中，在处理后续阶段时，前面的阶段可以进行新的加工，每时每刻，每个工人都是在工作的，这就是流水线能提高生产效率的原因。 和汽车生产类似，组合逻辑路径可以看作是一条生产线，路径上的每个逻辑单元都可以看作是一个阶段，都会产生时延。 如果不采用流水设计，前后级组合逻辑依次工作，那么这条路径的模型就是原始的生产线 如果采用流水设计，那么前后级组合逻辑可以同时工作，就像新的生产线一样 A Simple Example 采用流水设计的方法就是： 在较长的组合逻辑路径中插入 DFF，将其分割为几个小的组合逻辑，新的 Tcomb 显然小于原来的 Tcomb，所以系统的时钟频率就可以提高了。 举例来说明：设计一个电路完成 i = (a + b + c + d) + (e + f + g + h) 运算。 下面是没有流水的设计： 可以计算出第一级 DFF 到第二级 DFF 之间数据路径的时延为 Tff = Tco + Tcomb = Tco + 3 * Tadder 下面是插入两级流水的设计： 现在相邻的两级 DFF 之间的组合逻辑只有 1 级加法器，而不是原来的 3 级，这时数据路径的时延为 Tff = Tco + Tcomb = Tco + Tadder 显然，采用流水后 Tff 更小，系统能够达到的工作时钟频率也就更高。 Performance Increase from Pipelining 下面更加详细地分析一下流水带来的速度性能的提升。 首先说明，可以使用系统的流量 throughout 和系统的时滞 latency 来衡量速度性能。 throughout : 每个时钟周期处理的数据量，单位一般是 bps latency : 数据输入到数据输出之间的时间，一般用 时钟周期的个数 来表示 如下图所示，两个 DFF 之间存在着大规模的组合逻辑： 组合逻辑的时延决定了系统的最大工作频率（也即时钟周期 T 的最小值），此时 latency = Tcomb + Treg + Tclk -- Eq1 Tbefore = latency = Tcomb + Treg + Tclk -- Eq2 其中 Treg 表示 DFF 带来的时延，Tclk 表示时钟的 skew 和 jitter 带来的时延。 在使用流水之后，如下图所示： 此时，每个 stage 的周期为 Tstage = ( Tcomb ) stage + Treg + Tclk 而时延最大的那个 stage 决定了系统的最大工作频率（也即时钟周期 Tclk 的最小值），此时 Tpipe = max { ( Tcomb ) stage } + Treg + Tclk latency = n * Tpipe 在理想状况下，各 stage 的时延应该相等，从而达到最小的 latency。即 Tcombi = Tcomb / n 所以，最小的流水周期 Tpipe 为 ( Tpipe ) min = Tcomb / n + Treg + Tclk 代入 latency 的表达式，有 latency = n * ( Tpipe ) min = Tcomb + n ( Treg + Tclk ) -- Eq3 Tafter = Tpipe = Tcomb / n + Treg + Tclk -- Eq4 首先比较系统的工作频率，或者 throughout（Eq2 和 Eq4）： Fafter / Fbefore = Tbefore / Tafter = ( Tcomb + Treg + Tclk ) / ( Tcomb / n + Treg + Tclk ) 显然这个数 > 1，即 conclusion : 系统的工作频率和 throughout 得到了提升。 如果定义 k = (Treg + Tclk) / (Tcomb + Treg + Tclk)，为 reg 和 clk 占的总周期的比例，则 Fafter / Fbefore = 1 / [( 1 - k / n ) + k ] 其次，比较 latency（Eq1 和 Eq3）： Lafter / Lbefore = [ Tcomb + n ( Treg + Tclk )] / ( Tcomb + Treg + Tclk ) 显然这个数 > 1，即 conclusion : 系统的 latency 增加了（增加的很小，近似可以忽略）。 最后比较面积： conclusion : 使用流水比不使用流水多使用了 n * m 个 DFF，还使用了更多的连线资源。 综上，可以看到，虽然流水可以提高系统的工作频率和吞吐率，但是它付出的代价是面积和功耗的增加，这也是 速度和面积之间相互转化 的体现。 DXL Instruction THE ART OF HARDWARE ARCHITECTURE 中还介绍了 DXL 指令集的实现，简单记录一下笔记，详细过程还是看书吧。 DXL 指令是 32 位的 RISC 微处理器，每条指令最多由 5 个部分组成： Instruction Fetch (IF) Instruction Decode/Register Fetch (ID) Execution/Effective address cycle (EX) Memory access/branch completion cycle (MEM) Write Back Cycle (WB) 非流水的方式实现如下图： 因为是非流水的方式，所以指令不能并行执行，必须等到前一条指令执行完之后才能开始执行下一条指令，如下图所示，假设每条指令需要 8 ns，那么执行 4 条指令总共需要 8 * 4 = 32 ns。 采用流水的方式，在 5 级操作中都加上一个流水阶段（即每个阶段加入一组 DFF），实现如下图： 因为是流水的方式，所以指令可以并行执行，如下图所示： 假设执行每条指令花费 10 ns，那么执行 5 条指令： 非流水的方式总共花费 10 * 5 = 50 ns；流水的方式每条指令花费 5 个时钟周期，每个周期只有 2 ns，完成 5 条指令只需要 5 个时钟周期，总共花费 9 * 2 = 18 ns；性能是原来的 50/18 = 2.8 倍。 Pipelining Principles THE ART OF HARDWARE ARCHITECTURE 还总结了流水需要注意的问题： 所有的中间值必须在各周期锁存 不能复用任何模块 一个阶段的所有操作必须在一个周期内完成 冒险会给流水带来问题，冒险分为 结构冒险，由于资源不够，无法同时支持所有指令同时执行 数据冒险，执行需要的中间数据还没有计算出来 控制冒险，分支点流水线和其他指令改变程序的计数器的值 解决以上问题的方法就是停止流水线直至风险解除，在流水线中插入多个 \" 气泡 \"（缺口）。 Another Example 将前面总结的 \" 在组合逻辑路径中插入 DFF，形成流水 \" 的思路进一步扩展，可以得到更加上层的流水思想。 Advanced FPGA Design: Architecture, Implementation, and Optimization 中介绍了一个算法中使用流水的例子，其关键在于 \" 拆开环路 \"： 假设要计算 x&#94;3 这个值，下面这段软件的代码 Xpower = 1 ; for ( i = 0 ; i < 3; i++) Xpower = X * Xpower ; 将这段软件代码翻译成 Verilog 代码，重复使用相同的寄存器和计算资源，得到的结果如下： 这种迭代的方法无法实现并行计算，其性能： Throughput = 8 / 1 , or 8 bits / clock Latency = 3 clocks Timing = One multiplier delay in the critical path 而使用 pipeline 的方法 1 2 3 4 5 6 7 8 9 10 // stage 1 X1 <= X ; Xpower1 <= X ; // stage 2 X2 <= X1 ; Xpower2 <= Xpower1 * X1 ; // stage 3 Xpower <= Xpower2 * X2 ; 得到的结果如下图： 可以并行计算，其性能： Throughput = 8 bits / clock ( assuming one new input per clock ) Latency = Betw een one and two multiplier delays , 0 clocks Timing = Two multiplier delays in the critical path 可以看到，throughout 的提升是以面积为代价的。 Ref THE ART OF HARDWARE ARCHITECTURE Advanced FPGA Design: Architecture, Implementation, and Optimization","tags":"IC","loc":"https://qiangu.cool/posts/ic/the_art_of_pipelining.html","title":"流水线 pipeline 的艺术"},{"url":"https://qiangu.cool/posts/tools/learning_vim_signature_plugin.html","text":"在追踪代码时，经常跳转到很多新文件中，想回到原点时就比较麻烦了，这时候就需要 \" 书签 \" 了。 Bookmarks 用 :help marks 来查看关于书签的说明： 书签可以分为 3 类： lowercase marks 书签名只能为 'a - 'z，只在所在文件内有效，不能在文件之间跳转，不同书签名不能包含有相同字符 uppercase marks 书签名只能为 'A - 'Z，也叫文件书签，可以在文件之间跳转，不同书签名不能包含有相同字符 numbered marks 书签名只能为 '0 - '9，用 .viminfor 文件来设置 使用字母 a-zA-Z 建立的书签能被保存下来，再次打开时仍然存在，而用数字 0-9 建立的书签在关闭文件后就被删除了，不能恢复，所以 一般使用 a-zA-Z 更多一点吧。 知道这些最基本的东西就可以顺利使用书签了。 P.S. help 文档中说 numbered marks 不能手动设置，实际上是可以的，不知道是不是我理解错了，不过这个应该不影响平常的使用。 Usage 常用的几个 Vim 内置的书签命令如下： 设置书签 m{a-zA-Z} ，如 ma 删除书签 delm {marks} ，如 delm a 跳转书签 跳转有两种方式： 使用 backtick 键（数字 1 键左边），跳转到设置书签时光标所在的行和列，如 `a 使用单引号 ' ，跳转到书签所在行的第一个非空字符处（不包含列信息），如 'a `` 回到到上次修改的位置 列出所有书签 :marks Vim-signature 使用 Vim 书签时，最大的不方便之处是：书签是不可见的，也就是说我们输入命令之后，是无法看到书签是否建立成功了，外观上是看不出书签行和普通行的区别的。还好有个很不错的插件 vim-signature 可以帮助我们实现可视化的书签。 在 github 项目上有这个插件的简单介绍，另外在 Vim 中也可以看 help 文档查阅详细帮助，这里只记录我用到简单配置。 Install 使用这个插件需要 vim 支持 sign 特性，使用命令 :echo has('signs') 来查看 vim 是否支持这个特性，如果结果是 1，则支持，如果结果是 0，需要重新编译 vim。 使用 Vundle 安装： Bundle 'vim-signature' Usage 使用 :help signature 可以查看帮助文档。 mx Toggle mark ' x ' and display it in the leftmost column dmx Remove mark ' x ' where x is a - zA - Z m , Place the next available mark m . If no mark on line , place the next available mark . Otherwise , remove ( first ) existing mark . m - Delete all marks from the current line m < Space > Delete all marks from the current buffer ]` Jump to next mark [` Jump to prev mark ] ' Jump to start of next line containing a mark [ ' Jump to start of prev line containing a mark `] Jump by alphabetical order to next mark `[ Jump by alphabetical order to prev mark ' ] Jump by alphabetical order to start of next line having a mark ' [ Jump by alphabetical order to start of prev line having a mark m / Open location list and display marks from current buffer m [ 0 - 9 ] Toggle the corresponding marker ! @#$ %&#94;&* () m < S - [ 0 - 9 ] > Remove all markers of the same type ] - Jump to next line having a marker of the same type [ - Jump to prev line having a marker of the same type ] = Jump to next line having a marker of any type [ = Jump to prev line having a marker of any type m ? Open location list and display markers from current buffer m < BS > Remove all markers 而且 help 中列出了具体配置，我们可以对其修改，自定义快捷键。总结一下我常用的操作： 设置书签 mx ，比如 ma 删除书签 直接在目标行重新输入 mx ，旧书签就会被删除，并且设定到光标所在行 将光标移动到旧书签行，重新输入 mx 删除所有 lowercase + uppercase marks， m<Space> 删除所有 numbered marks， m<BS> 跳转书签 ]`，跳转到前一个书签 [`，跳转到后一个书签 ]-，跳转到之前同一类型的 numbered marks 书签行 [-，跳转到之后同一类型的 numbered marks 书签行 Ref vim-signature 像 IDE 一样使用 Vim","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_signature_plugin.html","title":"学习 Vim 之 vim_signature 插件"},{"url":"https://qiangu.cool/posts/tools/learning_vim_lookupfile_plugin.html","text":"系统内置的 :find 命令不够好： 项目比较大，文件比较多时，查找速度慢 必须输入文件全名，而且不能使用正则表达式查找 而使用 NERDTree 的话，在一个小窗口内，按照目录浏览查找的效率也很低。 lookupfile 这个插件可以实现类似 Sublime Text 中 Ctrl + P 的效果，只需要输入文件的部分名字即可匹配查找到文件。 Install lookupfile 需要 genutils 插件的支持，使用 Vundle 安装两个插件： Bundle 'genutils' Bundle 'lookupfile' Config 关于 lookupfile 的详细配置，查看 help 文档，下面是几个常用的配置选项： let g : LookupFile_MinPatLength = 2 let g : LookupFile_PreserveLastPattern = 0 let g : LookupFile_PreservePatternHistory = 1 let g : LookupFile_AlwaysAcceptFirst = 1 let g : LookupFile_AllowNewFiles = 0 tags vi/vim 使用进阶 : lookupfile 插件 中介绍到 lookupfile 可以使用 ctags 生成的 tags 文件来查找，不过其查找效率比较低，所以作者写了一个 shell 脚本来生成专用的 tags 文件： 1 2 3 4 5 #!/bin/sh # generate tag file for lookupfile plugin echo -e \"!_TAG_FILE_SORTED\\t2\\t/2=foldcase/\" > filenametags find . -not -regex '.*\\.\\(png\\|gif\\)' -type f -printf \"%f\\t%p\\t1\\n\" | \\ sort -f >> filenametags 为了方便起见，把这个脚本保存为 genfiletags 文件，然后将其移动到专门存放常用 shell 脚本的目录下，将这个目录添加到系统变量 $PATH 中，这样在 vim 中直接运行 :!genfiletags 就可以生成 tags 文件了。 生成好 tags 文件后，还要配置 vim，告诉它使用这个文件来查找： if filereadable ( \" ./filenametags \" ) let g : LookupFile_TagExpr = ' \"./filenametags\" ' endif case sensitive lookupfile 插件是大小写敏感的，可以在查找到时候加上 \\c 就能忽略大小写，不过这样很麻烦，下面是更加简单的方法，在 .vimrc 中添加下面这段代码即可： function ! LookupFile_IgnoreCaseFunc ( pattern ) let _tags = & tags try let & tags = eval ( g : LookupFile_TagExpr ) let newpattern = ' \\c ' . a : pattern let tags = taglist ( newpattern ) catch echohl ErrorMsg | echo \" Exception: \" . v : exception | echohl NONE return \"\" finally let & tags = _tags endtry \" Show the matches for what is typed so far. let files = map ( tags , ' v:val[\"filename\"] ' ) return files endfunction let g : LookupFile_LookupFunc = ' LookupFile_IgnoreCaseFunc ' Summary 综上，.vimrc 中的配置内容如下： \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Config lookupfile \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" let g : LookupFile_MinPatLength = 2 let g : LookupFile_PreserveLastPattern = 0 let g : LookupFile_PreservePatternHistory = 1 let g : LookupFile_AlwaysAcceptFirst = 1 let g : LookupFile_AllowNewFiles = 0 if filereadable ( \" ./filenametags \" ) let g : LookupFile_TagExpr = ' \"./filenametags\" ' endif nmap < silent >< leader > lk : LUTags < cr > nmap < silent >< leader > ll : LUBufs < cr > nmap < silent >< leader > lw : LUWalk < cr > \" lookup file with ignore case function ! LookupFile_IgnoreCaseFunc ( pattern ) let _tags = & tags try let & tags = eval ( g : LookupFile_TagExpr ) let newpattern = ' \\c ' . a : pattern let tags = taglist ( newpattern ) catch echohl ErrorMsg | echo \" Exception: \" . v : exception | echohl NONE return \"\" finally let & tags = _tags endtry \" Show the matches for what is typed so far. let files = map ( tags , ' v:val[\"filename\"] ' ) return files endfunction let g : LookupFile_LookupFunc = ' LookupFile_IgnoreCaseFunc ' Usage lookupfile 可以查找文件夹、缓冲区、按照目录查找三种方法： :LookupFile 按 F5 或者输入命令 :LookupFile 来打开上部的 lookupfile 小窗口，输入文件名即可查找，可以使用 vim 的正则表达式查找，使用 Ctrl-N 和 Ctrl-P 来上下选择查找结果。 :LUBufs 虽然有 BufExplorer 可以查看 buffers，但是当 buffer 很多时，使用 lookupfile 更加方便一点。 输入命令 :LUBufs 查找缓冲区的文件。 :LUWalk 使用 :LUWalk 来浏览目录。这个功能和 NERDTree 重复了，个人感觉 NERDTree 浏览目录更加方便一点，毕竟不用输入文件目录名，可以少翘几个字符 ... Ref vi/vim 使用进阶 : lookupfile 插件 lookupfile.vim 插件详解【OK】","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_lookupfile_plugin.html","title":"学习 Vim 之 lookupfile 插件"},{"url":"https://qiangu.cool/posts/cs/summary_of_regular_expression.html","text":"看完了 Introducing Regular Expressions ，记录一下学习笔记。这本书是非常简单的入门书，一天时间就能看完。作者还推荐了基本进阶书： Mastering Regular Expressions Regular Expressions Cookbook Regular Expression Pocket Reference 看完这本书，基本上已经满足项目中简单的 RE 需求，以后需要深入的话，再补这几本书。 What Is a RE? 引用 Ken Thompson 的话： A regular expression is a pattern which specifies a set of strings of characters; it is said to match certain strings. Basic metacharacters 元字符，在表达式中有特殊的含义，也是保留字。一共有 14 个： . // 匹配任意字符 \\ // 对字符转义 | // 选择操作（或） &#94; // 行起始 $ // 行结束 ? // 匹配 0 或 1 次 * // 匹配 0 或 多次 + // 匹配 1 或 多次 [] // 字符组符号 {} // 量词或代码块符号 () // 分组符号 character shorthand 也叫做 character escape，中文翻译成：\" 字符组简写 \" / \" 转义字符 \"，常用简写： \\ d // 数字字符， = [ 0 - 9 ] \\ D // 非数字字符， = [ &#94; 0 - 9 ] \\ w // 单词字符 \\ W // 非单词字符 \\ s // 空格 \\ n // 换行 \\ r // 回车 \\ b // 单词边界 \\ a // 报警符 \\ cx // 控制字符 Simple Match Patterns 几个常见的模式匹配： string literals 使用普通字符。 digits \\ d // 简写形式 [ 0 - 9 ] // 0 ~ 9 任意一个数字 [ 1278 ] // 限定备选集合为 1 ， 2 ， 7 ， 8 non-digits 大写的简写形式 或者 取反 即可： \\ D [ &#94; 0 - 9 ] [ &#94; \\ d ] word characters \\ w // 简写形式 [ a - zA - Z0 - 9 ] // a ~ z 、 A ~ Z 、 0 ~ 9 任意一个字符 non-word characters 大写的简写形式 或者 取反 即可： \\ W [ &#94; a - zA - Z0 - 9 ] [ &#94; \\ w ] whitespace \\ s [ \\ t \\ r \\ n ] any characters . Boundaries 行首、行尾 &#94; // 行首 $ // 行尾 单词边界 \\ b // 单词边界 \\ < // 单词开头 \\ > // 单词结尾 非单词边界 \\ B Alternation, Groups, and Backreferences Alternation 比如要匹配 THE 或者 The 或者 the，使用如下的语法 ( THE | The | the ) Subpatterns THE、The、the 是 3 个子模式： ( THE | The | the ) 括号对于子模式不是必须的： \\ b [ tT ] h [ ceinry ]* \\ b 可以匹配 the、The、their 等单词，严格意义上中括号内的叫做 字符组 character classes ，不过因为两者有近似的功能，所以也可以将其做一类。 Capturing Groups and Backreferences 对于括号 () 内的模式进行捕获，将其存储在临时内存中，然后可以通过后向引用重用已捕获的内容。 重引用时 \\1 、 $1 表示对第一个分组的引用； \\2 、 $2 表示对第二个分组的引用；依次类推。 Non-Capturing Groups 对于之后不会进行引用的分组，可以使用非捕获分组，因为不会对其分配内存所以可以提高性能。 ( ? : THE | The | the ) Character Classes Character Classes 也叫做 方括号表达式，字符组可以帮助我们匹配特定字符或者特定的字符序列： 匹配特定字符 [ aeiou ] // 匹配元音字符 匹配特定字符序列： \\ b [ 1 ][ 24680 ] \\ b // 匹配 10 ～ 19 之间的偶数 Negated Character Classes 匹配与字符组不匹配的字符，方法就是在开头加上 脱字符 &#94; ： [ &#94; aeiou ] // 不想匹配元音字符 Union and Difference 字符组可以像集合一样操作（如求并集、求差集），实际上字符组还有一个名字就叫做 字符集 character set 。 并集： [ 0 - 3 ][ 6 - 9 ] // 匹配 0 ~ 3 或者 6 ~ 9 之间的数字 差集： [ a - z && [ &#94; m - r ]] // 匹配 a ~ z 之间，但是排除 m ~ r 之间的字符 POSIX Character Classes POSIX (Portable Operating System Interface ) 是 IEEE 维护的一系列标准，格式如下： [[: xxxx:]] [[:&#94; xxxx:]] // 取反匹配 其中 xxxx 取值为 digit、word 等，举例： [[: alnum :]] // 匹配字母和数字 [[: alpha :]] // 匹配大写或小写字母 [[: ascii :]] // 匹配 ASCII 范围内的字符 一般不常用 POSIX 格式。 Matching Unicode and Other Characters Matching a Unicode Character / uxxxx // syntax / u00e9 // = character é / u6c60 // = character 池 Matching Characters with Octal Numbers ` \\ xxx ` // xxx 是 3 位 8 进制数字 比如 é 也可以用 \\351 来匹配。 Matching Control Characters \\ cx // x 是想匹配的控制字符 \\ c @ // 空字符 0 . NUll \\ cG // 报警字符 BEL \\ cH // 退格符 Backspcace Quantifiers Greedy, Lazy, and Possessive 量词的属性有 贪婪，懒惰，占有。 Greedy 所谓 \" 贪婪 \" 就是说 在匹配前会选定尽可能多的内容，也就是整个输入。然后开始匹配时，会首先匹配整个字符串，如果失败，则回退一个字符，重新匹配（这个过程叫做回溯 backtracking），直到找到匹配的内容或者没有字符可以尝试为止。 量词的默认属性是贪婪的。 形象的描述是：它先 \" 吃 \" 进所有的字符，然后每次 \" 吐 \" 出一点，慢慢咀嚼消化 ... It takes a mouthful, then spits back a little at a time, chewing on what it just ate. Lazy 量词的另外一种策略。从待匹配的内容起始位置开始尝试匹配，每次检查字符串的一个字符，寻找匹配内容，最后会尝试匹配整个字符串。 形象的描述是：它每次只吃一点。 It chews one nibble at a time Possessive 占有量词会抓取整个目标，然后尝试寻找匹配。不过它只尝试一次，不会回溯。 形象的描述是：它不 \" 咀嚼 \" 而是直接 \" 吞咽 \"，然后才想知道 \" 吃 \" 的是什么。 It doesn't chew; it just swallows, then wonders what it just ate. Basic Quantifiers ? 匹配 0 或 1 次 + 匹配 1 或 多次 * 匹配 0 或 多次 这些量词默认是贪心的，也就是说第一次尝试时会尽可能多地匹配字符。 .* 叫做 Kleene star ，以纪念 RE 的发明人 Stephen Kleene。 Range Syntax {n} 精确匹配 n 次 {n,} 匹配 n 次 或 多次 {m,n} 匹配 m 至 n 次 {0,1} 与 ? 相同（0 或 1 次） {1,0} 与 + 相同（1 或 多次） {0,} 与 * 相同（0 或 多次） Lazy Quantifiers 懒惰的意思就是匹配尽可能少的字符，它就是个懒虫！它总会找到匹配下限。比如 5*?，它不会匹配任何内容，因为 * 的下限是 0 次；再比如 5+?，它只会匹配 1 个 5，因为 + 的下限是 1 次；再比如 5{2,5}?，它只会匹配 2 个 5，因为下限是 2。 ?? +? *? {n}? {n,}? {m,n}? 上面这些加了 ? 的 RE 表示懒惰匹配，也就是 找下限 。 Possessive Quantifiers 占有式量词就是贪婪式量词的弱化版，只在第一次进行匹配，如果失败就停止，而不是继续回溯下去。它会将自己的输入 ?+ ++ *+ {n}+ {n,}+ {m,n}+ 这些量词后面加了 + 的 RE 表示占有匹配，也就是只检查第一次尝试。 Lookarounds 环视 是一种非捕获分组，它的作用是检查模式的前 / 后的内容来匹配，也成为 零宽度断言 zero-width assertions 。 Positive Lookaheads 正前瞻。 pattern 之后必须紧随着 lookaround 的才会被匹配。 比如想找到所有之后紧随着一个 marinere 的 ancyent ： ancyent ( ?= marinere ) Negative Lookaheads 反前瞻。对正前瞻的取反，也就是 pattern 之后必须没有 lookarounds 的才会被匹配。 比如想找到所有后面没有 marinere 的 ancyent： ancyent ( ?! marinere ) Positive Lookbehinds 正后顾。后顾和前瞻的方向相反，检查 pattern 之前的内容，之前有 lookarounds 的 pattern 才会被匹配到。 比如想找到所有之前有 ancyent 的 marinere： ( ?<= ancyent ) marinere Negative Lookbehinds 反后顾。对正后顾的取反，也就是 pattern 之前必须没有 lookarounds，才会被匹配。 比如想找到所有之前不存在 ancyent 的 marinere： ( ?<! ancyent ) marinere 关于正、反；前瞻、后顾可以用下面的规律记： 前瞻 / 后顾： 以 lookarounds 为原点， pattern 在 lookarounds 之前就是 前瞻 pattern 在 lookarounds 之后就是 后顾 正 / 反： 如果条件是 lookarounds 存在，就是 正 如果条件是 lookarounds 不存在，就是 负 了解了这些基础知识，基本上就可以读懂、书写 RE 了，还需要的就是平时多加思考练习，然后看更加高阶的书了。 Ref Introducing Regular Expressions","tags":"CS","loc":"https://qiangu.cool/posts/cs/summary_of_regular_expression.html","title":"Regular Expression 小结"},{"url":"https://qiangu.cool/posts/ic/verilog_hdl_coding_style_guide.html","text":"Update (2015/04/21): 参考了网上流传的 华为 coding style guide 和 其他的一些资料，还有 Verilog 编程艺术 的内容，重新整理一下自己的 Coding Style Guide，以便做项目的时候参考对比。 Version : 2.0 Date : 2015-04-21 Author : Qian Gu (guqian110@gmail.com) Summary : This is a personal Verilog HDL coding style guide for designs on FPGA. Goal 干干净净的代码： 代码整洁、结构合理、层次清晰、注释明了、没有烂代码、没有冗余代码，合理地建立目录，合理地分配到不同文件中。 下面分几个方面来总结，如何达到这样的目的。 Module Partition 把代码划分为 模块、函数、任务，形成合理的层次结构。 划分的原则：高内聚、低耦合 一般来说，每个模块、函数、任务完成一个功能，隐藏内部实现细节，提供一个干净的接口 灵活掌握，不要划分出太多的模块，不必拘泥于 \" 模块最好在 500 行左右 \"（太多的实例和连线反而容易出错） 低耦合的原则就是模块之间尽量用少的连线 提取公共代码、常用代码形成模块、函数、任务，便于使用和以后移植，有可能的话，参数化、通用化、IP 化（比如 CRC 计算、时钟分频、同步电路、通用 GPIO 控制等） 划分模块时，将相关组合逻辑划分到同一模块，以便综合时进行优化（一般工具不会越过模块边界来优化） 在模块内部，合理切分逻辑，让相关代码组合在一起形成逻辑块，合理安排逻辑块的顺序，并且用固定长度的横线分割这些逻辑块，加以注释 模块内部不要存在重复的代码（子模块、函数、任务、循环语句、寄存器组、for/generate） 为了减少修改内容、避免出错、移植方便、创建可重用模块，在编写代码的时候使用 define、parameter、localparam 定义可重定义的参数（如 SIZE、WIDTH、DEPTH 等）。如果可能，把所有 define 放在一个 definition.vh 中，编译时首先读取这个文件 Coding Style 灵活合理地运用，才能设计出强壮的、简洁的代码，目标是可以清晰地表达出设计意图。 Part A 设计时把应用文档和设计文档写好，在设计文档中要把设计思路、数据通路、实现细节等描述清楚，在经过评审之后才能开始编写代码（磨刀不误砍柴工，节约时间，而且项目可控、可实现） 尽量使用可靠的 IP 每个模块放到一个单独的文件中，< 文件名 >=< 模块名 >.< 扩展名 >（很多小模块则可以放到一个文件中，便于管理，如 cell 库） Top 模块只包含子模块的例化（即使有逻辑，也是简单的 glue 逻辑） 按照合理的层次结构组织各个模块，存放在合理的目录结构中 Part B 避免书写可能导致竞争冲突（race condition）的语句（给仿真调试带来很大的麻烦） 避免实例化具体的门级电路（可读性差、难于理解维护、不可移植） 避免使用内部三态电路，使用 MUX 代替 避免任何器件的输入悬空（会导致很大的电流消耗） 避免使用嵌入式的综合指令（synthesis directive）（仿真工具忽略这些指令，仿真和综合结果不一致） 避免 Latch，避免无意中形成的 Latch（常规设计中，只有顶层模块的 clock_gate 会使用 latch，以节省功耗） Part C 保证时钟和复位信号没有 glitch 尽量保持时候总和复位信号的简单，不要使用复杂的组合逻辑（便于测试、后端生成时钟树和复位树） 尽量做到所有寄存器同时复位 小心使用门控时钟（Gated clock） 避免在模块内部产生时钟，最好使用同步设计，用 clock enable 来实现低频时钟操作 避免在模块内部产生复位 如果确实要使用门控时钟、内部时钟、内部复位，把这些信号的代码放到一个独立的模块里，并在顶层模块例化这个独立模块 一个模块内尽量只使用一个时钟。多时钟设计中，时钟域隔离带逻辑（同步电路）放到一个独立的模块中 只使用时钟的一个沿（上升 or 下降） 对跨时钟域的信号要进行同步处理 避免多周期路径（multicycle_path）和假路径（false_path），一旦有这种路径，在代码和设计文档中标注写明 写可测性的设计（DFT, Design for Test） Part D 对于组合逻辑，使用 always @* 注意 \"=\" 和 \"<=\" 不要在一个 always 块中混杂使用两者 组合逻辑，使用 \"=\" 时序逻辑，使用 \"<=\" 编写合理的 FSM 无优先级的多路复用器使用 case，有优先级的多路复用器使用 if-else 或者是 ? : 通常，case 的时序比 if-else 的时序好，优先级编码器只有在信号先后到来的时候才使用。 Part E 模块的输入信号尽量用 DFF 先锁存再使用（若输入是其他的寄存器输出则不必） 模块的输出信号尽量用 DFF 先锁存再输出（便于综合和 STA，处理起来简单，Timing 更好） 使用端口名映射法进行模块实例化 声明每一个用到的信号（若无声明，默认是 1 bit 的 wire） 设计代码中，reg 只能在一个 always 中复制；验证代码无此要求 设计代码中，函数、任务不要使用全局变量；验证代码无此要求 Part F `include 的文件名不要包含路径名（后期编译、综合、移植困难） 常用 define 做常数声明，把 define 定义的参数放在一个独立的文件中，然后在模块头部 `include 这个文件。 头文件保护 只有全局的，不会被修改的常量采用 define 定义 作用域只在一个模块内，使用 localparam 代替 `define 为了模块可配置、可移植，使用 parameter Part G 使用简洁的写法（可省略的 begin-end 省略不写） 我看到有一些 coding style 中要求即使只有一条语句，if-else、case 等语句的 begin-end 也要写上，这样是为了方便以后添加代码，而且减少出错的机会。 不过我更认同 Cummings 的观点： The Sunburst Design - \"Where's Waldo\" Principle of Verilog Coding I am a big fan of very concise coding. In general (but not always), the shorter the code, the better. The more code I can see, nicely spaced and formatted on one page, the easier it is to understand the intent of the design or verification code. I call this the \"Where's Waldo\" Principle based on the child puzzle-books of the same name. Even though Waldo is dressed in a bright red and white stripped shirt, when he is surrounded by enough additional clutter, he is hard to find. Just as Waldo is hard to find when surrounded by clutter, simple RTL coding bugs can be obscured when surrounded by poorly spaced and formatted RTL code and silly comments that state the obvious. 比如下面这段 11 行、129 个字符的代码可以使用 3 行、57 个字符的代码代替： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // code1 always @( posedge clk or negedge rst_n ) begin if ( ! rst_n ) begin q <= 0 ; end // end-if-begin else begin q <= d ; end // end-else-begin end // end-always-begin // code2 always @( posedge clk or negedge rst_n ) if ( ! rst_n ) q <= 0 ; else q <= d ; Naming 建立一套命名约定和缩略语清单，以文档的形式记录下来，严格遵守 使用有意义而且有效的名字，含义清楚、名副其实，避免含糊误导 模块名大写，所在文件名小写 函数、任务、信号、变量、端口名字用小写字母 `define、parameter、localparam、const、enum 用大写字母 子模块的名字应该使用调用模块的名字作为前缀，如 emi、emi_ahb、emi_reg、emi_sram 使用协议定义的标准名字，根据需要在这些名字前附加前缀（模块名） 同一信号的名字在各个子模块中保持一致 进入到同一个模块的连线用模块的名字作前缀（前缀比后缀更清晰） 每行定义一个信号，上面一行 / 同一行的尾部加上简短注释 信号名的定义顺序：控制信号、相应信号、数据信号 模块名 单词首字母缩写，大写。举例 1 2 DMI // Data Memory Interface DEC // Decoder 模块间信号名 分为两部分，第一部分表示信号方向，大写，第二部分表示信号意义，小写，下划线连接。举例 1 wire CPUMMU_wr_req ; // write request form CPU to MMU 模块内命名 单词缩写，下划线连接，小写。举例 1 wire sdram_wr_en ; // SDRAM write enable 系统级命名 时钟信号、置位信号、复位信号等需要输送到各个模块的全局信号，以 SYS_ 前缀开头。举例 1 2 3 wire SYS_clk_100MHz ; // system clock wire SYS_set_cnt ; // system counter set wire SYS_rst_cnt ; // system counter reset 低电平有效信号命名 低电平有效信号加后缀 _n ，举例 1 wire rst_n ; // low valid reset 经过锁存器的信号 经过锁存器的信号加后缀 _r ，以和锁存前区别。举例 1 reg din_r ; // latch input data 参数名 parameter 全部大写，用 parameter 定义有实际意义的常数，比如 LED 亮灯状态、状态机状态等，避免 \"magic number\"。举例： 1 2 parameter IDLE = 10 'd0 , WAIT = 10 'd1 ; 常用信号名缩写： name short name short name short acknowledge ack error err ready rdy adress addr enable en receive rx arbiter arb frame frm request req check chk generate gen resest rst clock clk grant gnt segment seg config cfg increase inc source src control ctrl input in statistic stat counter cnt length len switcher sf data in din output out timer tmr data out dout packet pkt tmporary tmp decode de priority pri transmit tx decrease dec pointer ptr valid vld delay dly read rd write enable wr_en disable dis read enbale rd_en write wr Format Poart Declaration 尽量使用 Verilog-2001 标准，减少代码行，便于修改和删除 每行只声明一个端口，这样可以在上面 / 后面添加简短注释 声明顺序：按照功能分组，分组前添加注释，分组之间空行分割，便于阅读 在功能分组内，哪个信号最主控，哪个就最靠前。（控制信号、数据信号），顺序如下： test_mode 信号，工作模式（=0）或 测试模式（=1） 异步复位 时钟信号 使能信号 控制信号 地址信号 响应信号 数据信号 Module Instantiate 例化名和模块名保持一致，加统一的前缀，如 u1_ 、u2_ 端口名映射法，not 位置映射法 例化端口顺序 = 模块端口声明顺序，不用的端口也列出来 例化 大模块 时，每个端口占用一行， .port_name 对齐， .(signal_name) 也对齐 例化 大量小模块 时，可以多个端口放在同一行的紧凑形式（如大量 PAD 实例化） Task & Function 使用 C 语言的习惯，在合适的位置添加空格 Statement 每个语句单独成行 对于 always、for、while 语句，begin 最好在它们的下一行 对于 initial、if、elseif、else 语句，begin 最好与它们同行 end 占用单独一行 一个逻辑块内不加空行，表明它们之间的紧密关系 不同逻辑块之间添加空行，表明每个逻辑块实现不同的功能 7。 每行不多于 80 个字符，以提高可读性 采用缩进，不要嵌套太深 合理使用 tab （1 tab = 4 space） Expression 使用括号表示优先级（括号有可能影响综合结果的情况不在此列） 双目、三目操作符左右空格，如 =、+、-、×、/、%、<<、>>、&、&&、|| 等 逗号 (,) 只在逗号后加空格 分号 (;) 只在分号后加空格 行尾不加空格 上下行有关时，使用空格对齐 表达式很长时，适当位置断行，使用空格对齐某些变量 Comments 文件头，使用 doxverilog 注释 在逻辑块、重要代码行的上方添加注释 注释简明扼要，足够说明设计意图 保证注释和代码一致 有效实用的注释格式，Doxygen 英文注释，标点后空一格，英文习惯 解释复杂过程，列出要点和步骤 模块开始要有模块级的注释 模块端口，简要注释，描述功能和有效电平 特殊注释：note、warning、todo Lint 编译时，打开 vcs 或 ncveriog 的 lint 检查 检查编译的输出结果，Warning 可能导致仿真失败、综合失败，尽量修正 检查是否生成 latch 检测 always 敏感列表是否完全 Appdidx FSM 的模板 另外一篇博客 中已经总结过了。下面是一个简单的模块模板格式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /////////////////////////////////////////////////////////////////////////////////// // Module Declaration // /////////////////////////////////////////////////////////////////////////////////// module MODULE_NAME #( parameter PARAM1 = xxx , PARAM2 = xxx ) ( //---------------------------------- // Interface1 port_1 , // comments port_2 , ... //---------------------------------- // Interface2 port_n ); /////////////////////////////////////////////////////////////////////////////////// // Parameter Declarations // /////////////////////////////////////////////////////////////////////////////////// localparam DIN = 16 , DOUTA = 16 , DOUTE = 16 , DOUTCTR = 16 ; /////////////////////////////////////////////////////////////////////////////////// // Main Body of Code // /////////////////////////////////////////////////////////////////////////////////// /////////////////////////////////////////////////////////// // Instantiate sub module // /////////////////////////////////////////////////////////// MODULE_NAMW_A U_MODULE_NAMW_A ( . A ( A ) . B ( B ) ... ); /////////////////////////////////////////////////////////// // Some Logic // /////////////////////////////////////////////////////////// //---------------------------------------- // sequential logic always @( posdge clk ) begin if ( rst ) begin // reset ... end else begin // do something ... end end //--------------------------------------- // combinational logic assign wire_1 = wire_2 ; ... endmodule","tags":"IC","loc":"https://qiangu.cool/posts/ic/verilog_hdl_coding_style_guide.html","title":"Verilog HDL coding style"},{"url":"https://qiangu.cool/posts/ic/verilog_project_setting.html","text":"参考书和网上的资料，自己总结的一个简单的项目设置，虽然实验室的项目和公司比起来很不规范，都是学生自己做的玩具类型的项目，但是聊胜于无，给自己一个参考。 Directory 分类存放文件，项目的目录结构如下： project | ___ src // 设计代码 | | ___ header // header file | | ___ module1 // module1 . v | | ___ module2 // module2 . v | | ___ ... | ___ sim // 验证代码 | | ___ module1 // tb_module1 . v | | ___ module2 // tb_module2 . v | | ___ ... | ___ vrf // 编译、运行脚本 | ___ doc // 文档 | ___ html // doxverilog 文档 | ___ ref // 设计参考文档 Document 省略应用文档（Datasheet、SPEC） 实验室的小项目，设计很简单，而且是自己用，就不需要应用文档了。 设计文档 —— doxverilog 生成 最重要的文档，可以使用 doxverilog 生成。但是貌似 doxverilog 对 verilog 的支持实际上并不是非常好。结果勉强可以接受。 除了常规的信息注释外，在源文件的注释中主要包含以下内容： 模块需要的文件列表（子模块文件） 模块的功能描述 模块的端口描述（直接在 ASNI-C 风格的端口声明处注释） 模块的参数配置 注意事项（ //% @note ） 参考文档列表 Ref","tags":"IC","loc":"https://qiangu.cool/posts/ic/verilog_project_setting.html","title":"Verilog 项目配置"},{"url":"https://qiangu.cool/posts/ic/clock_generate_unit.html","text":"Verilog 编程艺术 时钟生成 笔记，内容基本上都是书上的内容，还有我自己的总结，混合在一起，就不加引用符号了。 如果说总线互连（Bus Matrix）是系统各骨架，CPU 是系统的大脑，那么时钟生成模块（CGM）就是系统的心脏，整个系统就是在时钟的脉搏下有序协调地工作。 我们在设计时钟生成模块时，我们需要考虑下面这些问题。 芯片需要多少时钟？它们之间的关系是同步到还是异步的？ 芯片需要几个时钟源？时钟源是在芯片内还是芯片外？ 需要使用 PLL 吗？需要几个 PLL？PLL 最高工作频率是多少？ 如何分频生成各个模块所需要的时钟频率？ 为了节省功耗需要几种工作模式？它们之间如何切换？ 测试模式下如何处理时钟信号？综合时如何插入扫描链？ 代码如何编写才能方便后端做时钟树综合？后端如何做时钟树综合？ Clock 我们都知道，电路设计可以分为 同步设计 和 异步设计 两种，两者的优缺点就不再赘述。由于同步设计的一些优点，一般推荐使用同步设计，即使有异步信号，也将其转化为同步信号，来避免异步信号导致的问题。 虽然同步电路有很多优点，但是它也有一些缺点： 首要问题是 时序收敛问题 也就是要保证所有的 flip-flop 的输入端和时钟端之间满足 setup/hold time 的要求，否则就会出现亚稳态，导致电路无法正常工作。 不满足 setup time 的要求，可以通过降低工作频率的方法解决，但是不满足 hold time 时，芯片根本就无法工作。 时序收敛点工作都是由 EDA 工具自动完成的，我们只要设置合理的时间约束，综合及布局布线工具就可以实现时钟平衡，时序分析工具就可以检查电路是否满足时序收敛。 其次，对时钟信号要求高 同步设计的基础是时钟信号。关于时钟信号，另外一篇博客 静态时序分析 STA 1 —— 基础知识 有一些总结，比如时钟偏斜 skew、时钟抖动 jitter、占空比失真 Duty Cycle Distortion。 时钟偏斜 skew 的解决方法是采用 EDA 工具进行时钟树综合，它的原理就是按照时钟树的最大长度去平衡其他的时钟路径。但是这种方法会引入大量延迟单元的插入，使得电路的面积和功耗大大增加。 Design Principle 下面是设计时钟生成模块（CGM）时要遵守的一些原则： CGM 要独立于系统的其他模块，其他模块所使用的时钟都要从 CGM 中引出 CGM 要有很好的层次结构，既便于前端定义时钟和分析时序，又便于后端做时钟树综合 为了调整性能和功耗，CGM 应该支持分频器和停时钟，而且软件能灵活控制 在时钟切换和启停时钟时，一定不能出现毛刺，否则电路不能正常工作 Clock Divider 在一个系统中，各个模块可能需要不同的工作频率，这就需要通过 PLL 把时钟源的频率提高到高频，然后通过不同的分频器为每个模块分出不同的工作频率。 以前总结一篇关于 时钟分频器 的博客。 Clock Switch 有时候，我们需要在模块运行的过程中切换时钟，切换时钟最简单的方法就是使用 MUX。但是这种方法会造成毛刺（glitch）。如下： 1 2 3 always @( clk_a or clk_b or sel ) begin if ( sel ) out_clk <= clk_a ; else out_clk <= clk_b ; 书上提供了一个通用的没有 glitch 的时钟切换模块，支持多个时钟的切换，其中 select 信号必须使用 one-hot 编码。（代码略 ...） Clock Generation 有了上面的基础，就可以设计时钟生成模块了。书里面以一个 时钟切换 + 时钟分频 的组合来说明如何设计。 书后面一章还提供了一个实际项目中的 CGM 的设计文档，以供参考。 Ref Verilog 编程艺术","tags":"IC","loc":"https://qiangu.cool/posts/ic/clock_generate_unit.html","title":"时钟生成"},{"url":"https://qiangu.cool/posts/ic/configurable_design.html","text":"Verilog 编程艺术 的可配置设计一章 学习笔记。 Configurable design 我们做设计的时候，就要考虑做成可以灵活配置的设计，不管是小模块，还是大模块，这样便于以后维护和移植。可配置模块的设计方法如下： 使用 parameter 和 `define 使用 for 语句生成多条语句 使用 generate、for、if 等语句生成多条语句和多个实例化 通过工具或脚本生成配置参数 通过工具或脚本直接生成 Verilog 代码 书里面总结了上面的这些方法，以前总结过另外一篇博客： Verilog 中的参数化建模 ，里面总结了 条件编译、`define、parameter、localparam 的用法和区别。 Reuse Methodology Manual for System-on-a-Chip Designs 是一本很经典的书，里面有全面详细的可重用设计的方法，有时间了看了再补上。 下面是一些实际例子，展示如何设计可配置模块。 Gray-2-Binary Binary 编码是最自然的、最符合平常的思维的，但是这种编码方式有时候存在一些问题：比如在 DAC 中，数字 3(011) 变为 数字 4(100) 时，每 1 bit 都发生了变化，电路中会产生很大的尖峰电流脉冲。 而 Gray 编码就没有这样的问题，Gray 码有很多优点，应用很广泛，就不再重复了。（比如在 FIFO 设计中，内部就有 Gray 和 Binary 的相互转换） 下面的例子，通过 将端口位宽参数化 ，实现了可配置的转换模块： example1: # verilog module gray2bin # ( parameter SIZE = 8 ) ( input [ SIZE - 1 : 0 ] gray , output [ SIZE - 1 : 0 ] bin ) ; generate genvar i ; for ( i = 0 ; i < SIZE; i = i + 1) begin : bit assign bin [ i ] = &#94; gray [ SIZE - 1 : i ] ; end endgenerate endmodule # verilog module bin2gray # ( parameter SIZE = 8 ) ( input [ SIZE - 1 : 0 ] bin , output [ SIZE - 1 : 0 ] gray ) ; assign gray = bin &#94; { 1 ' b0, bin[SIZE-1 : 1] }; endmodule CRC Cyclic Redundancy Check，循环冗余检测。不同的协议使用的 CRC 多项式不相同，在硬件上体现在 LSR 的宽度和抽头位置不同，我们可以写一个通用的 CRC 模块。 下面的例子，通过 将端口位宽参数化 ，实现了可配置的 CRC 模块。 example2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module general_crc #( parameter WIDTH = 16 , [ WIDTH - 1 : 0 ] INIT_VALUE = 0 , [ WIDTH - 1 : 0 ] CRC_EQUATION = 0 ) ( input clk , input rst , input init , // if init = 1, initialize crc_value // with INIT_VALUE input enable , // if enbale = 1, calculate crc_value // from din input drain , // if drain = 1, crc_value is shifted // out from dout input din , output dout , output reg [ WIDTH - 1 : 0 ] crc_value // parallel out crc_value ); // implementation code endmodule 在调用时，通过传递合适的参数即可实现不同的 CRC 模块。 FIFO controller 略 ... RAM wrapper problem FPGA 中的 RAM/ROM 是用厂家的工具生成的，而 ASIC 中的 RAM/ROM 是用 ARM 公司的 Memory Compiler 生成的，两者的端口名不一样，有些控制信号的极性也不相同。 通常的做法是 使用条件编译 ，写如下的代码 1 2 3 4 5 `ifdef FPGA // instantiate module for FPGA `else // instantiate module for ASIC `endif 这种方法的缺点主要有： 但内部有几十个到上百个 RAM/ROM 时，手动连接的工作量很大 做 ATPG 时，手工写代码很容易出错 做 BIST 测试时，需要添加额外的逻辑 另外一种更好的方法是 写 wrapper wrapper name 命名规范：按照 ARM 公司的规范， RAM/ROM type: Type little/large Ports Comments RF1 little single RA1 large single RF2 little dual one read port & one write port RA2 large dual two read port & two write port ROM single RAM/ROM write enable (WEN) type: Type Description IW bit-write-enable BW byte-write-enable WW word-write-enable 命名时按照 <ram_type>_<wen_type>_<depth>x<width> 的规则，在 FPGA 上则加上前缀 F_ ，即： F_<ram_type>_<wen_type>_<depth>x<width> 举例： F_RA1_BW_2kx32：RA1 类型，支持 byte 写，4 个 WEN，深度为 2k，宽度为 32-bit F_RF1_IW_128x8：RF1 类型，支持 bit 写，8 个 WEN，深度为 129，宽度为 8-bit generate wrapper 提前写好的 Perl 脚本 和 参数化模块 根据实际需求，写配置文件 运行 Perl 脚本，读取配置文件，生成 wrapper 将生成的 wrapper 加入到 project 中 每个步骤的具体实现方法以后再补 ... GPIO 运用模块化的设计思想，提取公共代码，设计子模块，通过子模块实现大模块的设计，虽然参数化以后 GPIO 看起来比较复杂，但是这个模块是很通用的，设计好之后只需要修改参数就可以重复使用了。这在设计期间，修改起来非常方便。 整个 GPIO 由 5 个模块组成： gpio . v ( module gpio ) | ___gpio_params . v ( parameters define ) | ___gpio_reg . v ( module gpio_reg ) | ___gpio_check . v ( module gpio_check ) | ___gpio_sync . v ( module gpio_sync2_reg / gpio_sync3_reg / gpio_sync_pulse ) 具体代码略，直接看书 BusMatrix ... Andes Core N801 ... ARM926EJS ... coreConsultant ... Ref Verilog 编程艺术","tags":"IC","loc":"https://qiangu.cool/posts/ic/configurable_design.html","title":"可配置设计"},{"url":"https://qiangu.cool/posts/ic/summary_of_case_in_verilog.html","text":"学习了 Cummings 大神 的 paper： \"full_case parallel_case\", the Evil Twins of Verilog Synthesis 和 Verilog 编程艺术 总结一下笔记。 Def Syntax: case ( case_expression ) case_item1 : case_item_statement1 ; case_item2 : case_item_statement2 ; case_item3 : case_item_statement3 ; case_item4 : case_item_statement4 ; default : case_item_statement5 ; endcase 等价于 if ( case_expression === case_item1 ) case_item_statement1 ; else if ( case_expression === case_item2 ) case_item_statement2 ; else if ( case_expression === case_item3 ) case_item_statement3 ; else if ( case_expression === case_item4 ) case_item_statement4 ; else case_item_statement5 ; 首先说明一些基本名词的定义： Case statement header header 由 关键字 case / casex / casez + case expression 两部分组成，它们通常写在同一行（上面语法的第一行）。添加 \"parallel_case\" 或者 \"full_case\" 综合指令的方法就是把指令当作注释写在 header 的那一行，后续 case item 之前。 Case expression case 关键字之后，括号中间的内容。它可以是一个常量（如 '1'），也可以是一个表达式，或者更常见的一个 1 bit / n bits 的向量，用来和后面的 case item 做比较。 Case item 可以是单比特、向量、表达式，用来和 case expression 做比较。和高级编程语言（C 语言）不同的是，verilog 中的 case 自带隐含的 break 语句，所以就不用再费心多写代码了。 Case item statement case item 内的语句，多于 1 句时，要用 begin-end 。 Case default 默认分支，虽然这个分支不是强制要求的，但是在所有分支后面加上 default 分支是一个良好的编程习惯。 Casez case 语句的变种，casez 把 expression 或者是 item 中的 \"z\"/\"?\" 忽略，当作不关心的值。 Guideline: Exercise caution when coding synthesizable models using the Verilog casez statement Coding Style Guideline: When coding a case statement with \"don't cares,\" use a casez statement and use \"?\" characters instead of \"z\" characters in the case items to indicate \"don't care\" bits. casex 类似于 casez，不关心的值为 \"z\" / \"?\" / \"x\"。 Guideline: Do not use casex for synthesizable code Process case 的执行过程： 计算 case expression，只计算一次，然后按照代码顺序从上向下和 case item 逐个比较 比较过程中，如果有 default 分支，则暂时先忽略 如果有某个 item 和 expression 匹配，则执行此 item 下的语句 如果匹配失败，有 default 分支，则执行该 default 分支 如果匹配失败，没有 default 分支，则终止 这个按照顺序比较的过程就是可能导致 priority encoder 的原因。 reverse case reverse case 是 case 的一个变形，也叫做 case if true 。这种风格中 case expression 是一个常量，而 case items 是由变量构成的表达式。这种风格通常用在 One-hot FSM 中，并且采用 parallel 方式。 见另外一篇博客： 有限状态机设计 下面讨论 full_case 和 parallel_case 的相关问题。很多人都会使用这两个综合指令，他们的理由是： \"full_case parallel_case\" makes my designs smaller and faster. \"full_case\" removes latches from my designs. \"parallel_case\" removes large, slow priority encoders from my designs. 然而这些理由都不够准确或者说是危险的，因为这两个综合指令有时候完全不影响设计，有时候反而会使设计速度变慢、面积变大，有时候甚至会改变设计的功能。 通常，这些指令都很危险。 所以，Cummings 给他的 paper 起了如下的别名 ... An alternate title for this paper could be: \"How to add $200,000 to the cost and 3-6 months to the schedule of your ASIC design without trying!\" \"full\" case statement \"full\" 的意思就是 expression 的任何取值都有一个 item/default 分支与其对应，否者就不是 \"full case\"。 example1: Non-\"full\" case 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module mux3a ( y , a , b , c , d , sel ); output y ; input [ 1 : 0 ] sel ; input a , b , c ; reg y ; always @ * begin case ( sel ) 2 'b00 : y = a ; 2 'b01 : y = b ; 2 'b10 : y = c ; endcase end endmodule 在这个例子中，当 sel 的取值是 2'b11 时，由于没有定义输出值 y 为多少，仿真器会保持之前的取值，综合器会综合出一个 latch。 （基于 Virtex-4 器件，XST 的 synthesis report 给出的结果是 1 bit latch + 1 bit 3-to-1 multiplexers） HDL full case 从 HDL 仿真器的角度看，full case 语句就是 case item 包含了 expression 可以取的任何值。 Synthesis full case 从综合工具的角度看，full case 语句就是 expression 的每种可能的取值组合都被包含在 item 中。 虽然 Verilog 语法不要求 case 语句必须是 HDL full 或者 synthesis full ，但是我们可以通过手动添加一个 default 分支来使得 case 变为 full。 example2: \"full\" case 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module mux3a ( y , a , b , c , d , sel ); output y ; input [ 1 : 0 ] sel ; input a , b , c ; reg y ; always @ * begin case ( sel ) 2 'b00 : y = a ; 2 'b01 : y = b ; 2 'b10 : y = c ; default : y = 1 ' bx ; endcase endmodule 在这个例子中，因为有了 default 分支，所以它是一个 full case。在仿真时，如果 sel 是 2'b11，那么 y 取值为 x（不确定，unknown），而综合器会把 x 当作 \" 不关心 \"（don't care，有可能为 1，也有可能为 0）。这就导致了仿真和综合不一致。解决这个问题的方法就是给 y 赋值一个常数 or 像其他 item 一样赋值一个输入。 （基于 Virtex-4 器件，XST 的 synthesis report 给出的结果是 1 bit 3-to-1 multiplexers） P.S. 我们可以利用前后仿真不同这一点来帮助我们调试。在设计 FSM 时，default 分支处，next_state 赋值为 x，这样如果存在错误转换，next_state 就会保持为 x，在波形上很方便看到。 还有一种方法是在所有的 item 之前，给输出赋一个默认值，这样即使不是 full，也不会产生 latch： 1 2 3 4 5 6 7 always @( a or b or c or sel ) y = 1 'b0 ; case ( sel ) 2 'b00 : y = a ; 2 'b01 : y = b ; 2 'b10 : y = c ; endcase XST full case 综合指令是一些特殊的可以被综合工具识别，并指导综合工具工作的语句。不同的综合工具的综合指令语法不相同。我用的是 ISE 自带的 XST。查看 XST User Guide 就可以找到 full case 的相关指令： 这个指令与架构（Architecture）无关、只适用于 verilog 的 case 语句： 只对 Verilog 有效 标识所有的取值都被包含在 item 中 阻止 XST 对那些没有被包含的情况生成额外的电路 使用这个指令的方法有很多： Verilog Syntax (* full_case *) 在 case header 的上面一行 or // synthesis full_case 这种方式，注释必须在 case header 的同一行 example3: (* full_case *) casex select 4 ' b1xxx : res = data1 ; 4 ' bx1xx : res = data2 ; 4 ' bxx1x : res = data3 ; 4 ' bxxx1 : res = data4 ; endcase example4: casex select // synthesis full_case 4 ' b1xxx : res = data1 ; 4 ' bx1xx : res = data2 ; 4 ' bxx1x : res = data3 ; 4 ' bxxx1 : res = data4 ; endcase XST Command Line xst run - vlgcase [ full | parallel | full - parallel ] ISE Design Suit Process > Process Properties > Synthesis Options > Full Case. 在 XST User Guide 中： XST automatically determines the characteristics of the case statements and generates logic using multiplexers, priority encoders, and latches that best implement the exact behavior of the case statement. 也就是说，如果我们不添加综合指令，XST 会根据代码自动判断，选择 MUX、priority encoder、latch 来生成最合适的实现电路。 如果生成 MUX，那么 synthesis report 在 Macro Recognition 步骤中会给出 MUX macro 的内容 注意，XST 是否会把 case 推译成 MUX，还取决于器件。对于 LUT4-based 器件，如果输入端口是 4 个，输出是 1 个，那么就会推译出 MUX；对于 LUT6-based 的器件，如 Virtex-5，那么需要输入端口是 8 个以上。 如果生成 Latch，那么 synthesis report 会给出 warning（只要生成 latch，不管是设计有意还是设计失误无意产生的，都会给出 warning，毕竟 latch 是很容易导致错误的） 如上面的例子，如果改成 always @ * begin ; ( * full_case * ) case ( sel ) 2 ' b00: y = a; 2 ' b01: y = b; 2 ' b10: y = c; endcase end 或者是 always @ * begin case ( sel ) // synthesis full_case 2 ' b00: y = a; 2 ' b01: y = b; 2 ' b10: y = c; endcase end 那么就只会生成 1 bit 3-to-1 multiplexers，不会有多余的 latch。 虽然这些指令有好处，但是一定要谨慎使用，而且使用时需要注意： 这些综合指令只对综合工具有用，仿真工具会自动忽略这些指令，所以有可能造成前后仿真不一致的问题 有时候使用指令，会适得其反，导致结果面积变大、速度变慢 一般有迷信的说法：\" 使用 full case 指令，可以消除 latch。\" 这个说法太绝对了，事实上并不总是这样。如果有多个输出需要赋值，而有些分支只忽略了一些赋值，那么即使使用 full_case 指令，也不能避免 latch 的产生。 举例，在下面的例子中，仍然会产生 latch always @ * begin casez ( sel ) // synthesis full_case 3 ' b100: y1 = 3 ' b100 ; 3 ' b010: y1 = 3 ' b010 ; 3 ' b001: y2 = 3 ' b001 ; endcase end 我们使用 full case 指令的目的就是为了避免生成意外的 latch，但是这种方法有以上的各种弊端。其实还有一种更加简单的方法来避免 latch，就是前面说的， 在 case 前，给所有的输出赋一个默认值。 \"parallel\" case statement \"parallel\" 的意思就是 expression 的取值每次有且只有一个 item 与其对应，否则就不是 \"parallel\" case，而匹配的 items 称为 \"overlapping\" case items。 Non-parallel case statements always @ sel begin casez ( sel ) 3 ' b1??: y = 3 ' b100 ; 3 ' b?1?: y = 3 ' b010 ; 3 ' b??1: y = 3 ' b001 ; endcase end 当输入是 3'b011, 3'b101, 3'b110, 3'b111 时，会有多个 item 与 expression 对应，所以不是 parallel 的，会综合出一个 priority encoder。 Parallel case statements 对上面的例子稍微修改一下，就得到了 parallel case： always @ sel begin casez ( sel ) 3 ' b1??: y1 = 1 ' b1 ; 3 ' b01?: y2 = 1 ' b1 ; 3 ' b001: y3 = 1 ' b1 ; endcase end XST parallel case 语法同 full case，只需要将 full_case 替换为 parallel_case 即可。如果 case 本来就是 parallel 的，那么这个指令就完全不起作用，只是一些额外的代码。 不要故意使用 Non-parallel case 来推译 priority encoder，这是不好的编程习惯。如果我们的目的就是要生成 priority encoder，应该使用级联的 if-else 语句，这样更能表达意图。 下面的这些 guideline 可以帮助我们避免 case 生成 priority encoder，从而避免前后仿真不一致： Guideline: Code all intentional priority encoders using if-else-if statements. It is easier for a typical design engineer to recognize a priority encoder when it is coded as an if-else-if statement. Guideline: Case statements can be used to create tabular coded parallel logic. Coding with case statements is recommended when a truth-table-like structure makes the Verilog code more concise and readable. Guideline: Examine all synthesis tool case-statement reports Guideline: Change the case statement code, as outlined in the above coding guidelines, whenever the synthesis tool reports that the case statement is not parallel (whenever the synthesis tool reports \"no\" for \"parallel_case\") Synthesis coding styles 在总结了 full_parallel_case 之后，Cummings 大神给出了建议： Sunburst Design Assumption: it is generally a bad coding practice to give the synthesis tool different information about the functionality of a design than is given to the simulator. Guideline: In general, do not use \"full_case parallel_case\" directives with any Verilog case statements. Guideline: There are exceptions to the above guideline but you better know what you're doing if you plan to add \"full_case parallel_case\" directives to your Verilog code. Guideline: Educate (or fire) any employee or consultant that routinely adds \"full_case parallel_case\" to all case statements in their Verilog code, especially if the project involves the design of medical diagnostic equipment, medical implants, or detonation logic for thermonuclear devices! Guideline: only use full_case parallel_case to optimize onehot FSM designs. 甚至建议要开除写 full_parallel_case 的员工 ... Summary 总结一下所有的 guidelines： Guideline: Exercise caution when coding synthesizable models using the Verilog casez statement Guideline: Do not use casex for synthesizable code Guideline: In general, do not use \"full_case parallel_case\" directives with any Verilog case statements. Guideline: There are exceptions to the above guideline but you better know what you're doing if you plan to add \"full_case parallel_case\" directives to your Verilog code. Guideline: Code all intentional priority encoders using if-else-if statements. It is easier for a typical design engineer to recognize a priority encoder when it is coded as an if-else-if statement. Guideline: Coding with case statements is recommended when a truth-table-like structure makes the Verilog code more concise and readable. Guideline: Examine all synthesis tool case-statement reports. Guideline: Change the case statement code, as outlined in the above coding guidelines, whenever the synthesis tool reports that the case statement is not parallel (whenever the synthesis tool reports \"no\" for \"parallel_case\"). Guideline: only use full_case parallel_case to optimize onehot FSM designs. Coding Style Guideline: When coding a case statement with \"don't cares,\" use a casez statement and use \"?\" characters instead of \"z\" characters in the case items to indicate \"don't care\" bits. Guideline: Educate (or fire) any employee or consultant that routinely adds \"full_case parallel_case\" to all case statements in their Verilog code. Conclusion: \"full_case\" and \"parallel_case\" directives are most dangerous when they work! It is better to code a full and parallel case statement than it is to use directives to make up for poor coding practices. Ref \"full_case parallel_case\", the Evil Twins of Verilog Synthesis Verilog 编程艺术","tags":"IC","loc":"https://qiangu.cool/posts/ic/summary_of_case_in_verilog.html","title":"Verilog 的 case 小结"},{"url":"https://qiangu.cool/posts/book/on_top_of_tides_review.html","text":"暑假加上开学的一段时间看完了《浪潮之巅》，感触颇大 ... 好不容易等到期末放假回家了，记录下一点笔记，希望几年之后毕业的时候还可以坚持这份近乎无知的单纯，老子当年也是一腔热血，准备创业的人 -.- 关于作者 作者吴军，男，清华大学计算机系（本科）和电子工程系（硕士），并于 1993-1996 年在清华任讲师。他于 1996 年起在美国约翰霍普金斯大学攻读博士，并于 2002 年获得计算机科学博士学位。在清华和约翰霍普金斯大学期间，吴军博士致力于语音识别、自然语言处理，特别是统计语言模型的研究。他曾获得 1995 年的全国人机语音智能接口会议的最佳论文奖和 2000 年 Eurospeech 的最佳论文奖。 这是书封面内侧的作者介绍，同时我找到了他在 Google 上的 个人主页 。不得不说同样是人，同样是学生，人和人的差距怎么这么大呢？ 人生就是不停在分岔路口进行选择，而且，根据前面的选择，后来可以面对的选择也是不同的（不知道是否满足马尔科夫性 ...），只是，有的人越走越 nb，而有的人则走偏了，成为了逗 b。大家都是从小学开始，有的人从小就是乖孩子，用现在流行的话说就是 \" 别人家的孩子 \"，学习好，嘴巴甜。什么老师、家长、叔叔、阿姨都喜欢的要死；而有的人打架，跷课，是个 \" 问题王 \"。不过，我觉得小时候还是调皮一点比较好，人生苦短，抓紧时间玩耍才好。借用吴军博士在个人主页上的一句话 \" 我不喜欢做什么，由于生命有限，很多不重要的事只好不做了。\" 只是，他把节省下来的时间学习，钻研，而我却用来玩，甚至现在还在玩，自责 ing... 貌似扯的越来越远，严重跑题了。对不起我的语文老师啊 总之，一句话，NB 的人各有各的 NB，而逗 B 们大体都有相似的硬伤，比如 IQ or EQ。已经走错 N 次路口的我们还有救，能做的就是学习 NB 的人为何这么牛，然后尽量变得和他们一样牛，至少不再那么逗 B。 浪潮之巅 近一百多年来，总有些公司很幸运地、有意识或无意识地站在技术革命的浪尖之上。一旦处在了那个位置，即使不做任何事情，也可以集随波浪顺顺当当地向前漂十几年，甚至更长的时间。在这十几年到几十年间，它们代表着科技的浪巅，直到下一波浪巅的来临。从一百多年前算起，AT&T、IBM 公司、苹果（Apple）公司、英特尔（Intel）公司、微软（Microsoft）公司、思科（Cisco）公司、雅虎（Yahoo!）公司和 Google 公司，或许还有接下来的 Facebook 公司，都先后被幸运地推倒了浪尖。 ...... 虽然对于一个公司来讲，赶上一次浪潮不能保证它长盛不衰，但是，对于一个人来讲，一生赶上这样的一次浪潮就够了。对于一个弄潮的年轻人来讲，最幸运的莫过于赶上一波浪潮。 看完了《浪潮之巅》，作为职业码农，表示收获很大。我对于 AT&T、IBM 公司的认识不再那么肤浅，他们经历的兴衰成败，取得今天的成就是多么的不容易；了解了 IT 领域的罗马帝国 —— 微软公司是如何在十几年间建成罗马的；纵观摩托罗拉、雅虎、SUN、网景等公司的历史，知道了现实中的差之毫厘，失之千里，为他们与机会失之交臂而扼腕叹息 ... 总结以下： 我想通了 CEO 的工资那么高的原因 以前总觉得当 CEO 最舒服了，不用思考那些很枯燥的技术问题，每天开会吃饭就能挣到可观的收入，而且走到哪都受人尊敬。现在明白了其实并不是这样，其实他们的压力更大，当好一名 CEO 的难度很大，他们肩负着更大的责任，他们得设计整个公司的战略，同时对股东和员工们负责，所以高薪是他们应得的。一个工程师在技术上的失误可以通过各种方法来补救，但是一个不乘职的 CEO 会毁掉一家公司，机会都是给有准备的人的，一旦失去，很难遇到下次。纵观书里面的公司，他们大多经历过低谷和巅峰，当 CEO 决策失误时，有可能导致公司由巅峰走向低谷，甚至破产。这时候，如果遇到一个英明乘职的 CEO，他们可以把公司从破产的边缘挽救回来，比如惠普公司的 CEO 马克 · 赫德，GE 公司的韦尔奇，IBM 的郭士纳等等，而遇到一个糟糕的 CEO，那只能准备关门或者别人来收购了 ... 乔布斯在库比蒂诺市的议会上说他的目标不是在福布斯排行榜上排到多少名，或者有多大的名气，而是想办一家传奇公司，这家公司可以一直长盛不衰，比如像惠普一样。排除他恭维市政府官员的因素，根据《乔布斯传》来看，他看中的的确不是金钱和名利。自从他去世，人们就在不停的讨论苹果公司是不是在走下坡路，甚至什么时候衰败为可以被别人收购的二流公司，一如当年乔布斯离开的时候。作为 \" 伪果粉 \" 但愿苹果还能保持他们的独特的魅力。可见成为一名英明的 CEO 是多么的艰难，CEO 对公司又是多么的重要。 计算机工业的生态链 IT 产业是不断变化的，并且有着它自身发展规律，这些规律被总结成为定律（IT Lows）。以前只知道摩尔定律（Moore's Low），最想不通的一件事就是为什么芯片的集成度每 18 个月就翻一番，而我的电脑却越来越慢，甚至不如 n 年以前的电脑。现在知道了安迪 - 比尔定律（Andy and Bill's Low），终于明白了为什么微软的系统越做越臃肿，为什么现在的程序员们不像以前那么精打细算了。用户很反感新软件把硬件提升带来的好处几乎全部消耗光，但是，各个硬件厂商恰恰是靠软件开发商用光自己提供的硬件资源而得以生存，否则就没人愿意花钱买新机器了，旧的已经满足需求了。 了解了产业链结构，许多以前想不通的事也就变得顺理成章。自身的知识决定了眼界啊。 公司运作方式 在搞技术的人眼中，运作公司，搞金融和财务是一件和编代码完全不同的事，应该有很深的门道在里面，很容易产生一种想法：\" 学技术的人都有着不同程度的自闭倾向，我更适合和机器打交道。我不是学管理和财务的，创业、办公司这种事和我绝缘。\" 至少以前我一直是这么认为的。虽然这本书在介绍公司制度，运作方式等方面不是很全面也不权威，但是它给我最深的印象就是 \" 搞技术的人也可以办公司，而且可以办的很好 \"。 科学家在人们心目中一直是带着厚厚镜片，言语木讷，不食人间烟火，在英语中叫 Nerd。其实不然，书中很多我们看到的科学家，都是商业上非常敏锐的人，而很多商业巨子，自己就是科学家。 人的商业知识和眼光不是天生的，需要不断地、有心地学习。Google 早期的时候，创始人拉里 · 佩奇经常一边和我们一起吃饭，一边研究着某个公司的财务报告，一边和我们谈他的体会。Google 不少早期的员工后来成了成功的创始人和投资人，其中包括 Twitter 的创始人威廉姆斯。而佩奇自己也从一个技术专家成长为商业奇才。 一家典型的美国科技公司的成长史，一般都是创始人有着独特的技术或者眼光、点子，和好朋友合伙办一家小公司，然后逐渐成长，自己主动去找风投或者做的足够好，风投主动找他们，然后公司规模越来越大，成立董事会，寻找合适的 CEO，接着就是上市 IPO 等等。不知道在中国办公司是什么样子的呢？以后得多看点别的书，涨姿势了 ... 商业模式、公司基因、中国、天使投资 关于创业，书里面有一个很重要的概念就是 \" 商业模式 \"。比如你准备去找红杉资本，对方首先就问你的商业模式是什么，如果在 5 分钟之内还是解释不清，估计也就没有机会了。商业模式一定要简单，不能太复杂。喝多公司的成功其实是商业模式的成功，比如 Dell 的 \" 直销模式 \" 和 Google 的广告商业模式等等。可以说，一个好的商业模式就是一台印钞机。 还有就是 \" 公司基因 \"，这个很大程度上由创始人和他们的业务决定的。有的公司基因中就存在着创新，比如 3M 公司，Google 等，他们可以很快的转型，做出更多的产品，保持公司的业绩；而有的公司则天生没有这种基因，比如 \" 蓝色巨人 \" IBM，他们以大型机、系统和服务为核心，很难在 PC 市场获得成功。 作为金融小白，只知道红杉资本，KPCB 等有名的 VC，而国内的则不是很了解了，只知道李开复、薛蛮子、雷军、王啸等人。我们学校毕业没有找工作而去创业的人不是没有，但是也不多。考虑到大环境，我觉得应该还是不错的。作为一个 211，连 985 都不是的学校，而且学校的状况真的是每况愈下，真的替学校捉鸡，毕竟，母校就是一个自己可以随意嫌弃，但是别人不能说一句不好的地方。 因为不想写报告，闲的无聊才写的，没想到我竟然这么能扯。此刻还有大干一番事业的雄心壮志，所谓出生牛犊不怕虎，估计到毕业的时候了解的多了，也就没有那个胆量去创业了，找一份自认为还不错的工作，这辈子就奉献给郭嘉了 ... 想想真的是 \" 我不喜欢做什么，由于生命有限，很多不重要的事只好不做了。\" ，以后不能再这么浑浑噩噩下去了，找一些自己感兴趣的、重要的事，坚持做下去，每天进步一小点的感觉其实要比打游戏好的多。","tags":"Book","loc":"https://qiangu.cool/posts/book/on_top_of_tides_review.html","title":"不想当司机的厨子不是好码农 —— 读《浪潮之巅》"},{"url":"https://qiangu.cool/posts/ic/static_timing_analysis_2_xilinx_sta.html","text":"* 总结 Xilinx 时序约束的一些基本内容，基本上是 UG612 Timing Closure User Guide 的翻译和概括。 P.S. 找到一篇 Xilinx 的文章，也很简洁实用： 赛灵思 FPGA 设计时序约束指南 Xilinx STA 按照路径所覆盖的范围，可以将时序路径要求分为 4 大类： Input paths Register-to-register paths Output paths Path specific exceptions 添加约束最有效的方法就是先添加全局约束，然后根据需求考虑是否添加指定路径上的特殊约束。在很多案例中，只需要添加全局约束就可以了。 FPGA 器件执行工具都是由指定的时序要求驱动的。如果时序约束过头的话，就会导致内存使用增加，工具运行时间增加。更重要的是，过约束还会导致性能下降。因此，推荐使用实际设计要求的约束值。 下面分别讨论每种路径上的约束。 Input paths 所谓 \" 输入路径 input paths \"，指的是从 \"FPGA 外部引脚 ---> 内部读取这个数的寄存器 \" 之间的路径。 在输入路径模型中，发送端是一个外部设备（当然也可以是 FPGA），接收端是 FPGA 芯片，输入路径讨论的就是以接收端的 FPGA 为视角，如何正确接收输入的数据。 依据接口类型，可以将输入路径的时序分为 2 类： System Synchronous Inputs Source Synchronous Inputs 而对于输入路径的约束方法就是使用 OFFSET IN 来约束，它约束了 输入数据 和 用于捕获这个数据的时钟沿 之间的关系。（顾名思义，输入路径约束的是方向为 IN 的数据和时钟的相对偏移 OFFSET 的关系） 下面分别对两类输入路径进行讨论： System Synchronous Inputs 所谓 System Synchronous Inputs 其实就是指 \" 发送端 和 接收端 使用同一个系统（system）时钟 \"。布线延时和时钟倾斜会限制这种接口的工作时钟频率，由于这个原因，这种接口一般应用在 SDR 中。 system synchronous SDR 应用示例如下图： 其时序为： 发送器件在某个时钟的上升沿将数据发送出去 FPGA 在下一个时钟的上升沿捕获到数据 对于这种接口的时序，使用 OFFSET IN 是最有效方便的添加约束的方法。对于接口中的每个时钟，都有一个对应的 offset in 约束，这个约束覆盖了所有的使用该时钟来捕获输入数据的路径。 添加约束的方法： 1. 首先对接口的时钟添加周期约束（period constraint） 2. 其次为接口添加全局 offset in 约束（global Offset In） 语法如下： OFFSET = IN value VALID value BEFORE clock ; OFFSET=IN 约束了数据变有效的沿和时钟的捕获数据的沿之间的距离 VALID 约束了数据保持有效的时间长度 举例： 例 1. 在下面理想的 system synchronous SDR interface 时序图中： 数据在时钟沿的前 5 ns 变为有效，并且保持了 5 ns 时间，所以在这个实例中的时序约束应该如下： NET \"SysClk\" TNM_NET = \"SysClk\" ; TIMESPEC \"TS_SysClk\" = PERIOD \"SysClk\" 5 ns HIGH 50 % ; OFFSET = IN 5 ns VALID 5 ns BEFORE \"SysClk\" ; 而且这个约束对于 data1 和 data2 共同有效。 例 2. 不是理想的 system synchronous SDR interface 中，假设时钟周期为 5 ns，并且占空比为 50%，数据在发送时钟上升沿之后的 500 ps 之后变有效，并且持续 4 ns。则时序约束应该如下： NET \"clock\" TNM_NET = CLK ; TIMESPEC TS_CLK = PERIOD CLK 5 . 0 ns HIGH 50 % ; OFFSET = IN 4 . 5 ns VALID 4 ns BEFORE clock ; Source Synchronous Inputs 所谓 Source Synchronous Inputs 其实就是指 \" 发送端重新生成一个时钟信号，并且将数据和时钟信号有着相似的布线，两者的延时基本相同，在接收数据的 FPGA 端，使用这个时钟来捕获这个数据 \"。布线延时和时钟倾斜不再是限制这种接口工作速度的因素，所以这种接口一般应用在双倍数据速率的 DDR 中。 source synchronous DDR 应用示例如下图： 其时序为： 发送器件在某个时钟的上升沿和下降沿都会发送一个独立的数据 接收端的 FPGA 使用发送端传递过来的这个再生时钟来捕获数据 对于这种接口的时序，使用 OFFSET IN 是最有效方便的添加约束的方法。对于接口中的每个时钟，都有一个对应的 offset in 约束，这个约束覆盖了所有的使用该时钟来捕获输入数据的路径。 添加约束的方法： 1. 首先对接口的时钟添加周期约束（period constraint） 2. 其次为时钟的上升沿添加全局 offset in 约束（global Offset In） 3. 最后为时钟的下降沿添加全局 offset in 约束（global offset in） 语法如下： OFFSET = IN value VALID value BEFORE clock RISING ; OFFSET = IN value VALID value BEFORE clock FALLING ; 举例： 例 3. 在下面理想的 source synchronous DDR interface 时序图中： 输入时钟的周期为 5 ns，并且占空比为 50%，两 bit 的数据的有效时间都为 1/2 时钟周期，所以在这个实例中的时序约束应该如下： NET \"SysClk\" TNM_NET = \"SysClk\" ; TIMESPEC \"TS_SysClk\" = PERIOD \"SysClk\" 5 ns HIGH 50 % ; OFFSET = IN 1 . 25 ns VALID 2 . 5 ns BEFORE \"SysClk\" RISING ; OFFSET = IN 1 . 25 ns VALID 2 . 5 ns BEFORE \"SysClk\" FALLING ; 例 4. 不是理想的 source synchronous DDR（数据和时钟的边沿对齐），假设时钟周期为 5 ns，并且占空比为 50%，上升沿和下降沿的数据都保持有效 2ns，并且位于时钟波形的高低电平的中间位置，也就是说，在数据有效的前后各有 250 ps 的空白。 对于上升沿，因为数据相对于捕获它的时钟沿后了 250 ps，并且有效时间持续了 2 ns；对于下降沿，数据也沿后了 250 ps， 并且有效时间持续了 2 ns，所以时序约束如下： NET \"clock\" TNM_NET = CLK ; TIMESPEC TS_CLK = PERIOD CLK 5 . 0 ns HIGH 50 % ; OFFSET = IN - 250 ps VALID 2 ns BEFORE clock RISING ; OFFSET = IN - 250 ps VALID 2 ns BEFORE clock FALLING 例 5. 不是理想的 source synchronous DDR（数据和时钟的中间位置对齐），假设时钟周期为 5 ns，并且占空比为 50%，上升沿和下降沿的数据都保持有效 2 ns，并且时钟沿对齐数据的中间位置，可以得出结论，在数据有效的前后各有 250 ps 的空白。 对于上升沿，因为数据相对于捕获它的时钟提前了 1 ns，并且有效时间持续了 2 ns；对于下降沿，数据也提前了 1 ns，并且有效时间持续了 2 ns，所以时序约束如下： NET \"clock\" TNM_NET = CLK ; TIMESPEC TS_CLK = PERIOD CLK 5 . 0 ns HIGH 50 % ; OFFSET = IN 1 ns VALID 2 ns BEFORE clock RISING ; OFFSET = IN 1 ns VALID 2 ns BEFORE clock FALLING ; Register-to-register paths 这部分讨论寄存器 - 寄存器之间同步路径上的周期约束（period constraint）。 period constraint 定义了时钟域的时序 覆盖了内部寄存器之间的同步数据路径 分析单个时钟域内的路径 分析两个相关联的时钟域之间的所有路径 在分析时考虑了时钟域之间的相位、频率、不确定性因素 同步时钟域的约束可以分为以下 3 类： Automatically Related Synchronous DLL, DCM, PLL, and MMCM Clock Domains Manually Related Synchronous Clock Domains Asynchronous Clock Domains 使用工具对 DCM、PLL 和 MMCM 的输出时钟自动添加时钟关系，并且手动定义外部的相关时钟的关系。通过这种方法，可以保证所有的跨时钟域的同步路径都被正确约束、分析，使用这种方法来添加 period constraint 可以避免再添加额外的跨时钟域约束。 Automatically Related Synchronous DLL, DCM, PLL, and MMCM Clock Domains 最常见的时钟信号就是下面两个： 输入到 DCM、PLL 或者是 MMCM 的时钟信号 从这些单元输出，用来驱动内部的同步路径的时钟信号 推荐的约束方法是 对输入到 DCM、PLL 或者是 MMCM 的时钟信号添加周期约束（period constraint）。 通过对输入时钟添加周期约束，Xilinx 工具会 自动为 DCM、PLL 或者是 MMCM 的输出生成一个新的周期约束 确定输出时钟之间的关系 分析这些同步域之间的任何路径 语法如下： NET \"ClockName\" TNM_NET = \"TNM_NET_Name\" ; TIMESPEC \"TS_name\" = PERIOD \"TNM_NET_Name\" PeriodValue HIGH HighValue % ; 其中 PeriodValue 定义时钟周期 HighValue 定义时钟的占空比 举例： 例 6. 在下图的例子中 输入时钟连接到 DCM 的输入端，因为输入时钟的时钟周期为 5 ns，并且占空比为 50%，所以添加的约束为： NET \"ClkIn\" TNM_NET = \"ClkIn\" ; TIMESPEC \"TS_ClkIn\" = PERIOD \"ClkIn\" 5 ns HIGH 50 % ; 在上面的例子中，我们给出上面的约束条件之后，DCM 会自动为它的两个输出添加约束，并且分析这两个时钟域 Manually Related Synchronous Clock Domains 在有些情况中，Xilinx 工具无法自动分析指定同步时钟域之间的关系（比如相关的时钟信号从两个不同的管脚输入进入到 FPGA）， 这种情形下，Xilinx 推荐的约束方法是： 1. 为每一个输入时钟都创建一个周期约束 2. 手动定义时钟之间的关系 一旦我们定义了时钟约束，工具会自动分析两个同步域之间的所有路径，并且在分析时会把频率、相位、不确定因素都考虑进去。 Xilinx 的约束系统可以通过在周期约束中加入频率和相位信息来添加更加复杂的周期约束（complex manual relationship）。 约束方法： 1. 为主时钟定义周期约束 2. 以主时钟的约束为参考，为其他的相关时钟添加周期约束 语法如下： NET \"PrimaryClock\" TNM_NET = \"TNM_Primary\" ; NET \"RelatedClock\" TNM_NET = \"TNM_Related\" ; TIMESPEC \"TS_primary\" = PERIOD \"TNM_Primary\" PeriodValue HIGH HighValue % ; TIMESPEC \"TS_related\" = PERIOD \"TNM_Related\" TS_Primary_relation PHASE value ; 在 related PERIOD 的约束中，PERIOD 的值定义了相关时钟和主时钟之间的关系（以时钟周期为单位），这种关系用主时钟的 TIMESPEC 形式来定义；PHASE 的值定义了主时钟和相关时钟的上升沿之间的关系。 举例： 例 7. 如下图所示 CLK2X180 的频率是 CLK1X 的 2 倍，所以 PERIOD 的值为 1/2；CLK2X180 的相位相比于主时钟，偏移了 180 度，所以它的上升沿比主时钟的上升沿晚了 1.25 ns；所以这个例子的约束如下： NET \"Clk1X\" TNM_NET = \"Clk1X\" ; NET \"Clk2X180\" TNM_NET = \"Clk2X180\" ; TIMESPEC \"TS_Clk1X\" = PERIOD \"Clk1X7 5 ns HIGH 50%; TIMESPEC \" TS_Clk2X180 \" = PERIOD \" Clk2X180 \" TS_Clk1X / 2 PHASE + 1 . 25 ns ; Asynchronous Clock Domains 异步时钟是指频率或相位有一个不同或者都不相同的时钟。因为时钟是不相关的，所以在进行 setup/hold time 分析时，是无法确定时钟的最终关系的。因此， Xilinx 推荐在设计时使用一些特殊的方法来确保数据能被正确捕获。 然而，有时候设计者希望不考虑频率和相位之间的关系，在孤立的条件下限制数据传输的最大时延。 Xilinx 约束系统允许不考虑源和目的时钟之间的频率、相位关系，直接约束数据路径的最大时延。语法就是使用带 DATAPATHONLY 关键字的 From-To 语句。 约束方法： 1. 为源同步寄存器定义时钟组 2. 为目的同步寄存器定义时钟组 3. 用带 DATAPATHONLY 关键字的 From-To 来约束两个时钟域之间的最大数据时延 语法如下： NET \"CLKA\" TNM_NET = FFS \"GRP_A\" ; NET \"CLKB\" TNM_NET = FFS \"GRP_B\" ; TIMESPEC TS_Example = FROM \"GRP_A\" TO \"GRP_B\" Delay DATAPATHONLY 举例： 例 8. 以前面的图为例，假设 CLKA 输入到第一个寄存器 R1，CLKB 输入到第二个寄存器 R2，R1 的输出连接到 R2 的输入，能忍受的最大的数据时延为 5 ns，则约束为： NET \"CLKA\" TNM_NET = FFS \"GRP_A\" ; NET \"CLKB\" TNM_NET = FFS \"GRP_B\" ; TIMESPEC TS_Example = FROM \"GRP_A\" TO \"GRP_B\" 5 ns DATAPATHONLY Output paths 这部分讨论如何为输出路径添加约束。输出约束覆盖了从 \" 内部同步单元 / 寄存器 ---> FPGA 输出管脚 \" 之间的所有路径。如下图所示： 在输出路径模型中，发送端是 FPGA 芯片，接收端是一个外部设备（当然也可以是 FPGA），输入路径讨论的就是以发送端的 FPGA 为视角，如何将待发送定数据正确发送出去。 和输入路径对应，输出路径使用 OFFSET OUT 来约束以达到时序要求。 OFFET OUT 定义了输出数据和将该数据发送到输出管脚的时钟之间的关系。OFFSET OUT 的分析会自动将影响输出数据 / 输出时钟的内部因素考虑在内： 时钟的频率和相位畸变 时钟的不确定性 数据时延的调整 和输入路径类似，输出路径的时序要求也可以依据接口的类型（system/source synchronous）和数据速率（SDR/DDR）来分类讨论。 System Synchronous Output 在 system synchronous output 中，发送端和接收端使用同一个时钟，所以发送端的 FPGA 只需要发生数据部分就可以了。如下图所示： 对于 system synchronous output 接口，使用全局 OFFSET OUT 是最有效的方法。每个 OFFSET OUT 都约束了一个对应的输出时钟，并且所有使用这个时钟来触发的输出数据路径都被这个约束所覆盖。 约束方法： 1. 为输出时钟定义一个时钟名（TNM）来分组，这个时钟组包含了所有被这个时钟触发的输出寄存器 2. 定义接口的全局 OFFSET OUT 约束 语法如下： OFFSET = OUT value AFTER clock ; 其中 OFFSET = OUT <value> 规定了 \" 接收器件的输入时钟（= 发送端 FPGA 的时钟）上升沿 ---> 发送端 FPGA 输出数据变有效 \" 直接的最大时延。 举例： 例 9. 如下图所示的 System Synchronous SDR output interface 假设发送端的输出数据必须在时钟上升沿之后的 5 ns 内变为有效，则约束如下： NET \"ClkIn\" TNM_NET = \"ClkIn\" ; OFFSET = OUT 5 ns AFTER \"ClkIn\" ; Source Synchronous Output 在 source synchronous output interface，发送端的 FPGA 会重新生成一个时钟信号，并且将时钟信号和数据一起发送出去，如下图所示： 对于 source synchronous output 接口，使用全局 OFFSET OUT 是最有效的方法。每个 OFFSET OUT 都约束了一个对应的输出时钟，并且所有使用这个时钟来触发的输出数据路径都被这个约束所覆盖。 约束方法： 1. 为输出时钟定义一个时钟名（TNM）来分组、，这个时钟组包含了所有被这个时钟触发的输出寄存器 2. 为时钟上升沿添加 global Offset Out 约束 3. 为时钟下降沿添加 global Offset Out 约束 语法如下： OFFSET = OUT <value> 约束了从 \" 输入时钟的上升沿 ---> 发送端 FPGA 输出端口数据变为有效 \" 的最大时延。 关键词 REFERENCE_PIN 约定以重新生成的时钟作为参考，输出数据的 skew 报告就是以这个时钟作为参考生成的。 举例： 例 10. 下图是一个理想的 Source Synchronous DDR interface 时序图 时钟周期为 5 ns，并且占空比为 50%，数据保持有效的时间为 1/2 时钟周期。所以，这个示例的约束如下： NET \"ClkIn\" TNM_NET = \"ClkIn\" ; OFFSET = OUT AFTER \"ClkIn\" REFERENCE_PIN \"ClkOut\" RISING ; OFFSET = OUT AFTER \"ClkIn\" REFERENCE_PIN \"ClkOut\" FALLING Path specific exceptions 通过前面的 3 节的讨论，对输入、寄存器 - 寄存器、输出路径进行约束，大部分时序路径都得到了正确约束，然后在一些情况中，存在少数不适应于全局约束的少数路径，这些例外最常见的就是： False Paths (Paths Between Registers That Do Not Affect Timing) Multi-Cycle Paths 下面分别讨论。 False Paths (Paths Between Registers That Do Not Affect Timing) 如果有些路径不影响时序性能，那么我们就可以将这些路径从时序分析中移除。 最常用的方法就是使用带 time ignore ( TIG ) 关键词的 FROM_TO 约束。 使用这种约束，可以 从源时钟域指定一组寄存器 从目标时钟域指定一组寄存器 将源到目标域的路径从时序分析中移除 约束方法： 1. 在源时钟域指定一组寄存器 2. 在目标时钟域指定一组寄存器 3. 使用带 TIG 关键词的 FROM-TO 来移除这两个域之间的路径 语法如下： TIMESPEC \"TSid\" = FROM \"SRC_GRP\" TO \"DST_GRP\" TIG ; 举例： 例 11. 假设下图中的两个寄存器之间的路径并不影响设计的时序，希望将这条路径从时序约束中移除 则本例的约束如下： NET \"CLK1\" TNM_NET = FFS \"GRP_1\" ; NET \"CLK2\" TNM_NET = FFS \"GRP_2\" ; TIMESPEC TS_Example = FROM \"GRP_1\" TO \"GRP_2\" TIG ; Multi-Cycle Paths 在多周期路径中，从发送端到接收端的同步单元，数据以低于周期约束中的 PERIOD 速率传输。这种情况最常见的场景是同步单元使用一个共同的 clock enable 来门控。 通过定义一个多周期路径（Multi-Cycle path），这些同步单元的约束条件会比默认的周期约束宽松很多。方法就是先给周期约束定义一个标识，然后再声明 Multi-Cycle path 包含多少个时钟周期。然后工具就可以合理分配这些路径的优先级。 定义一个多周期路径的 最常用的方法就是用 clock enable 信号定义一个时钟组，这样我们就可以用这个 clock enable 来定义一个包含了源、目的寄存器的时钟组，然后将多周期约束应用到这些寄存器之间的路径上。 约束方法： 1. 对公用时钟域进行周期约束 2. 定义所有基于同一个 clock enable 信号的寄存器 3. 对新的时序要求进行 From:To(Multi-Cycle) 约束 语法如下： TIMESPEC \"TSid\" = FROM \"MC_GRP\" TO \"MC_GRP\" < value > ; MC_GRP 定义了一组公用时钟的寄存器 所有从 MC_GRP 开始，到 MC_GRP 结束的路径就是需要进行多周期约束的路径 举例： 例 12. 如下图所示的假设情形中 两个寄存器直接的路径被一个共同点 clock enable 控制，并且 clock enable 的变化速率是时钟频率的一半。则本例的时序约束如下： NET \"CLK1\" TNM_NET = \"CLK1\" ; TIMESPEC \"TS_CLK1\" = PERIOD \"CLK1\" 5 ns HIGH 50 % ; NET \"Enable\" TNM_NET = FFS \"MC_GRP\" ; TIMESPEC TS_Example = FROM \"MC_GRP\" TO \"MC_GRP\" TS_CLK1 * 2 ; Summary 通过对这四种类型的 timing path 进行约束，基本上系统内所有路径都得到了合理约束。 Ref Timing Closure User Guide","tags":"IC","loc":"https://qiangu.cool/posts/ic/static_timing_analysis_2_xilinx_sta.html","title":"静态时序分析 STA 2 —— Xilinx STA"},{"url":"https://qiangu.cool/posts/ic/static_timing_analysis_1_basic.html","text":"静态时序分析（Static Timing）是数字 IC 设计中不可避免的话题，也是一个菜鸟成长必须掌握的技术。本文先总结 STA 中常见的定义、名词等。 Clock 时钟是数字电路的动力系统，可以说数字电路中最重要的信号就是时钟信号了。一般时钟信号的时序特性分为： 偏移 Skew 抖动 Jitter 占空比时钟 Duty Cycle Distortion 对于低速设计，基本不用考虑这些特征，但是对于高速设计，由于时钟本身造成的问题越来越普遍，因此有必要关注高速设计中的时序特性。 Skew 时钟信号要提供给整个电路的时序单元，所以时钟信号线非常长，并构成分布式的 RC 网路。它的延时与时钟线的长度、时序单元的负载电容、个数有关，由于时钟线长度及负载不同，会导致时钟信号到达相邻两个时序单元的时间不同，这个时间上的偏差就是 时钟偏移 Skew 。如下图所示： 假设时钟信号达到两个 DFF 的延时分别为 Tc1 和 Tc2，用 Tskew 来表示它们之间的时钟偏移，则计算公式如下： Tskew = Tc2 - Tc1 根据差值可以分为正偏移和负偏移： 当时钟到达 DFF1 的延时更大时，也就是 C1 > C2 时，Tskew 为正 当时钟到达 DFF2 的延时更大时，也就是 C1 < C2 时，Tskew 为负 需要注意到是，时钟偏移永远存在，当其大到一定程度时，就会严重影响电路的时序。 FPGA 在设计架构时，专门针对这种现象进行优化，采用全铜工艺和树状结构，并且设计了专用的时钟缓冲和驱动网络，这么做的目的就是尽量使时钟到达不同时序单元的路径一样长，从而使时钟偏移非常小，可以忽略不计。 所以， Skew 问题的解决方法就是：设计中的主要信号应该走全局时钟网络。 即使采用了这样的设计，在实际电路中，时钟信号到达每个 DFF 的时间也不可能完全相等，Skew 是肯定存在的。所以 STA 仍然需要考虑该因素。在 PAR 之前，STA 只能根据设计的面积来粗略估计 Skew，在 PAR 之后，因为有了更具体的信息（线段长度、宽度、信号分布情况）STA 的估计值更加精确。 Jitter 理想的时钟信号是方波，但是实际中的时钟信号边沿不可能是瞬间变化的，是个斜坡，如下图所示： 时钟抖动 Jitter 的定义很多，最常见的有 3 种： 周期抖动 Period Jitter 实际时钟信号周期与理想时钟周期的差值的变化。这是最早最直接的一种衡量抖动的方式，这个指标说明了时钟信号每个周期的变化。 因为这个差值是个随机变量，并且满足高斯分布，所以可以用期望和方差来描述。一般随机选择很多个周期，然后计算平均周期、标准差、峰峰值。标准差称为 \" RMS 抖动 \"，峰峰值称为 \" Pk-Pk 周期抖动 \"。知道 Pk-Pk 周期抖动，对于恰当配置系统和保持时间很有用。 周期差抖动 Cycle-to-cycle Jitter 两个相邻时钟周期的差值的变化。根据定义可知，对周期抖动做一阶差分，就可以得到周期差抖动。 这个差值也是一个服从高斯分布的随机变量。 相位抖动 Phase Jitter 一个时钟沿相对于基准对齐之后，经过一段时间后，与理想位置的偏差。这个指标说明了周期抖动在各个时期的累计效应。 因为需要累积一段时间，所以这个误差又称为 时间间隔误差（TIE, Timer Interval Error）。 由于 周期抖动 和 周期差抖动 是单个周期或者相邻周期的偏差，所以表征为短期抖动行为。而相位抖动需要累积一段时间，所以表征为长期抖动行为。 时钟抖动的原因就是噪声。 时钟抖动是永远存在的 ，当其大到可以和时钟周期相比拟的时候，会影响到设计，这样的抖动是不可接受的。 Duty Cycle Distortion 占空比失真，即时钟不对称，有脉冲的时间和无脉冲的时间发生了变化。DCD 会吞噬大量的时序裕量，造成数字信号的失真，使过零区间偏离理想的位置。DCD 通常是由信号的上升沿和下降沿之间时序不同而造成的。 Ohters 除去时钟信号，还有一些其他的相关定义。 Fan-out/Fan-out Fan-out 在数字电路中，逻辑门相互连接，组成更加复杂的电路，所以大多数逻辑门的输出端都连接着多个别的单元的输入。所以需要一个术语来描述逻辑门的驱动能力的大小，也就是扇出 Fan-out 。最大扇出数 maximum fan-out 定义为一个逻辑门可以驱动的同类逻辑门的最大数。 大多数 TTL 逻辑门能够为 10 个其他数字门或驱动器提供信号。因而，一个典型的 TTL 逻辑门有 10 个扇出信号。 在一些数字系统中，必须有一个单一的 TTL 逻辑门来驱动 10 个以上的其他门或驱动器。这种情况下，被称为缓冲器（buf）的驱动器可以用在 TTL 逻辑门与它必须驱动的多重驱动器之间。这种类型的缓冲器有 25 至 30 个扇出信号。逻辑反向器（非门）在大多数数字电路中能够辅助这一功能。 模块的扇出 是指模块的直属下层模块的个数。一般认为，设计得好的系统平均扇出是 3 或 4。一个模块的扇出数过大或过小都不理想，过大比过小更严重。一般认为扇出的上限不超过 7。扇出过大意味着管理模块过于复杂，需要控制和协调过多的下级。解决的办法是适当增加中间层次。一个模块的扇入是指有多少个上级模块调用它。扇入越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇入而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇入数高了，但这样的模块内聚程度必然低。这是我们应避免的。 设计得好的系统，上层模块有较高的扇出，下层模块有较高的扇入。其结构图像清真寺的塔，上面尖，中间宽，下面小。 Fan-in 与扇出相对的概念是 扇入 Fan-in ，它描述的是一个逻辑门能够处理的外部输入的能力。扇入大的逻辑门的速度要比扇入小的慢，原因是增加扇入相当于增加逻辑门的输入电容。我们可以用使用多级逻辑门来代替高扇入的设计。 Setup/Hold/Recovery/Removal Time 建立 / 保持时间是在同步设计中的概念： 建立时间 setup time ：触发器在时钟信号上升沿到来以前，要求输入数据必须保持稳定不变一段时间，这段时间就是器件需要的建立时间。如不满足 setup time，这个数据就不能被这一时钟打入触发器。 保持时间 hold time ：触发器在时钟信号上升沿到来以后，要求数据保持稳定不变一段时间，以便能够稳定读取，这段时间就是器件需要的保持时间。如果不满足 hold time，数据同样不能被打入触发器。 恢复 / 撤销时间是在异步设计中的概念： 恢复时间 recovery time : 对于异步信号（比如异步复位 / 置位），信号变无效的边沿和下一个时钟沿之间必须满足一个最小的间隔。其意义在于，如果保证不了这个最小时间，也就是异步信号无效边离时钟边沿太近了，异步信号解除（无效）之后，没有给 DFF 足够的时间来恢复（recovery）到正常状态，那么就不能保证在时钟沿到来时 DFF 可以正常工作。 撤销时间 removal time : 对于异步信号（比如异步复位 / 置位），信号变有效的边沿和前一个时钟沿之间必须满足一个最小的间隔。其意义在于，如果保证不了这个最小时间，也就是异步信号的有效沿离时钟太近了，在时钟信号去除（无效）之前，异步信号提前有效了，可能会造成 DFF 处于不确定状态。 更加详细的总结：锁存器 Latch v.s. 触发器 Flip-Flop 。 STA Intro STA 的 wiki 已经说的很明白了，下面的内容基本就是引用和翻译： Static timing analysis (STA) is a method of computing the expected timing of a digital circuit without requiring simulation. High-performance integrated circuits have traditionally been characterized by the clock frequency at which they operate. Gauging the ability of a circuit to operate at the specified speed requires an ability to measure, during the design process, its delay at numerous steps. Moreover, delay calculation must be incorporated into the inner loop of timing optimizers at various phases of design, such as logic synthesis, layout (placement and routing), and in in-place optimizations performed late in the design cycle. While such timing measurements can theoretically be performed using a rigorous circuit simulation, such an approach is liable to be too slow to be practical. Static timing analysis plays a vital role in facilitating the fast and reasonably accurate measurement of circuit timing. The speedup comes from the use of simplified timing models and by mostly ignoring logical interactions in circuits. It has become a mainstay of design over the last few decades. Definitions STA 中的一些术语定义如下： timing path FPGA STA( 三 ) --- STA 的基本概念 中说的很明白： 在做 STA 时，首先要把电路分解为一条条的 timing path。实际上我们也可以把 timing path 称为 data path，其本质就是指信号传播的途径。每一条 timing path 都具有一个起始点和一个终点。起始点是指电路中信号被时钟沿锁存的点；而信号经过一系列的组合逻辑的通道或者走线后被另外一个时钟沿捕获，这个点被称为终点。信号从起始点到终点所经过的通道就被称为 timing path。 起点有两种： 时序器件的 时钟输入端 电路的 输入端口 终点也有两种： 时序器件的 数据输入端 电路的 输出端口 输入和输出排列组合一共就有 4 种 path： 电路输入端口 -> 触发器的数据 D 端 (Pad-to-Setup) 触发器的 clk 端 -> 触发器的数据 D 端 (Clock-to-Setup) 触发器的 clk 端 -> 电路输出端口 (Clock-to-Pad) 电路输入端口 -> 电路输出端口 (Pad-to-Pad) 如下图所示： critical path 关键路径：从输入到输出，延时最大的那条路径称为 critical path。关键路径是系统中延时最大的路径，它决定了系统所能达到的最大时钟频率。 arrival time 到达时间：信号到达某个特定位置所消耗的时间。一般将时钟信号到达的时刻作为参考的 0 时刻，为了计算到达时间，需要对路径中的所有组件的延时都进行计算。 required time 需求时间：所能容忍的路径最大延时，也就是信号到达的最晚的时间。如果路径上的延时再大一些，则必须降低时钟频率，否则会产生 setup/hold time violation。 slack 时序裕量： slack = required time - arrival time 。如果计算出某条路径的 slack 是正数，说明这条路径的时延是满足要求的；如果计算出某条路径的 slack 是负数，则表示路径上的延时太大了，必须做出修改（修改设计 or 修改约束 or 换芯片），否则包含它的电路不能以预期的频率工作。 Purpose 在同步设计中，数据的流动是统一步伐的，即时钟信号每改变一次，数据跟随改变一次。这种运作方式是基于同步器件（DFF 或者 Latch）来实现的，这类器件以时钟信号作为指示，将其输入端的数据复制到输出端。在同步设计中只存在两种时序错误： setup time violation 输入数据和时钟的关系不满足 setup time 的要求，即在时钟有效沿之前，输入数据没有保持稳定足够长的时间，数据将不能被这个时钟沿记录下来。 hold time violation 输入数据和时钟的关系不满足 hold time 的要求，即在时钟有效沿之后，输入数据没有保持稳定足够长的时间，数据将不能被时钟信号记录下来。 导致数据和时钟不同步的原因很多，比如数据本身和时钟不同步、或者是电路进行了不同的操作，器件的温度、电压、制造工艺等因素也会产生影响。 静态时序分析 STA 的主要目的是在上述可能的电路偏移情况存在的情况下，验证所有信号能够准时到达，并保证电路的正常功能。 Xilinx FPGA 开发实用教程 ： 工作频率对数字电路而言至关重要。提高工作频率意味着更强大的处理能力，但是也带来了时序瓶颈：时序冲突的概率变大，电路的稳定性降低。所以为了使电路的性能达到设计的预期目标，并满足电路工作环境的要求，必须对一个电路设计进行时序、面积、负载等多方面的约束，并自始至终使用这些约束来驱动 EDA 软件工作。 ISE 具有一定的自动优化能力，对于一般的低速设计（处理时钟不超过 100MHz），基本上不需要时序方面的任何手动分析和处理；但是对于高速和大规模设计，需要设计人员自行添加时序方面的控制和处理，通过多次反复操作，根据反馈结果逐步调整设定，直到满足要求为止。 以前小规模 FPGA 设计，只需要做动态的门级时序仿真就课同时完成逻辑功能验证和时序验证；随着 FPGA 设计规模和速度的提升，有必要将逻辑功能验证和时序验证分开：首先，逻辑功能的正确性，可以通过 RTL 级或者门级的功能仿真来验证；其次，时序分析通过 STA（Static Timing Analysis，静态时序分析）验证。 时序分析的主要作用就是查看 FPGA 内部逻辑和布线的延迟，验证其是否满足设计者的约束。 确定芯片最高工作频率 控制工程的综合、映射、布局布线等关键环节，减少逻辑和布线的延迟，从而尽可能提高工作频率。一般情况下，处理时钟高于 100MHz 的时候，必须添加合理的时序约束文件。 检查时序约束是否满足 检查目标模块是否满足约束，若不满足，通过时序分析器定位程序中不满足的部分，并给出具体原因，然后设计人员修改程序，直到满足约束。 分析时钟质量 当采用了全局时钟等优质资源后，仍然不满足目标约束，则需要降低所约束的时钟频率。 确定分配引脚的特性 通过时序分析可以指定 I/O 引脚所支持的接口标准、接口速率和其他电气特性。 STA 的目的就是要保证 DUT（Device Under Test）中所有的路径满足内部时序单位对 setup time 和 hold time 的要求。信号可以及时的从任一时序路径的起点传递到终点，同时要求在电路正常工作所需的时间内保持恒定。 Theory STA 是基于前面介绍的时序路径的，在分析时，计算时序路径上数据信号的到达时间和要求时间的差值，以判断是否存在违反设计规则的错误。 Slack = Trequired_time - Tarrival_time 如果时序裕量 Slack 为正，表示满足时序，负值表示不满足时序。STA 按照上式分析设计中所有路径，如果 Slack 为负值，则该路径为影响设计的关键路径，需要修改设计以达到时序要求。 STA 是通过 \" 穷举法 \" 抽取整个设计电路的所有时序路径，按照约束条件分析电路中是否有违反设计规则的问题，并计算出设计的最高频率。 ========= Update 05/18/2015=========================== 很多笔试题里面都有考计算最大时钟频率的题，看到几篇文章 : Static Timing Analysis 101 Static Timing Analysis 102 : Setup Failures. Static Timing Analysis 103 : Hold Failures. 解释的很清楚，记一下笔记，顺便总结一下。 首先，电路中的元件一般分为两类： 组合逻辑，比如与非门、或非门等组合逻辑 时序逻辑，受时钟驱动的元件，比如 flip-flop 一般时序分析都是分析前面介绍的 Path2 的路径，如下图所示： 在这个图中，第一级的 DFF 的输出经过组合逻辑进入第二级 DFF，图中的时序是满足条件的，电路可以正常工作；但是如果违反 setup / hold time 的话，电路就无法正常工作，下面分别说明： Setup Time Failure 前面已经提到了，对于任何 DFF，都必须满足 setup time 的要求： 数据信号要在时钟信号之前到达 DFF，并保持稳定至少 setup time 时间，才能被成功打入 DFF 。 分类讨论一下： 如果中间的组合逻辑较少，产生的时延很小，那么在下一个时钟沿到来之前，数据满足 setup time，没有问题。 如果中间的组合逻辑较多，产生的时延足够大，导致数据和时钟的关系不满足 setup time，则有问题。 下图是一个 setup time failure 的具体例子： 第一级的 DFF 在时钟的上升沿对输入数据 In 进行采样，并经过一段时间（Tco，clock to output delay）后输出为 FF1_out，输出数据经过中间的组合逻辑变为 FF2_in 输入到第二级 DFF，因为中间的组合逻辑的时延太大，FF2_in 违反了 setup time 的要求（图中橙色线条所示）。由于第二级 DFF 的输入不满足 setup time，所以这个 DFF 会进入亚稳态，它将花费 1 个或多个时钟周期才能脱离亚稳态，在这期间它的输出都是不确定的，那么下游逻辑将会在这期间采样到错误数值，电路会发生错误。 如果中间的组合逻辑过多，产生的时延过大，以至于 FF2_in 的变化落在了第二个时钟沿的后面，这时所然没有违反 setup time 的要求，第二个 DFF 不会进入亚稳态，但是它采样的数据是旧数据，这个数据可能是错误的，同样会导致下游逻辑发生错误。 如果我们将时钟频率降到足够低，那么就可以避免 setup time failure 的问题。 通过上面的分析，可以知道 setup time 限制了中间组合逻辑的最大时延，所以这个 setup time constraint 也叫做 max delay constraint。为了保证在最恶劣的情况下设计仍然能够满足要求，在计算 setup time 时中应该使用最大的数据时延路径。 P.S. 上面的图中还包含了 clock skew，clk1 和 clk2 没有对齐，这加剧了 setup time failure 的机率。在实际中，时钟信号到达各个 DFF 的时间是不同的，设计者必须将这个因素考虑在内。 Hold Time Failure 和 setup time 对应，对于任何时序器件（DFF)，都必须满足 hold time 的要求： 数据信号要在时钟信号达到之后保持稳定至少 hold time 的时间，否则输出是错误 。 下图是一个 hold time failure 的具体例子： 第一级 DFF 在时钟的上升沿对输入数据 In 进行采样，经过一段时间（Tco）后，输出为 FF1_out，输出数据经过中间的组合逻辑变为 FF2_in，输入到第二级 DFF。因为中间的组合逻辑时延非常小，而且由于 clock skew 的原因，导致第二级 DFF 在第一个时钟周期的 hold time 内输入的 FF2_in 发生了变化，违法了 hold time 要求，DFF2 进入亚稳态，它将花费 1 个或多个时钟周期才能退出亚稳态，在此期间输出的是错误数据。 在现实中，导致这个问题的因素有可能是设计的问题（比如两个 DFF 邻接，中间没有其他逻辑），也有可能是器件的原因。 因为传输时延太小，从而导致在第一个时钟沿信号就被 DFF2 采样了，而设计本意是在第二个时钟沿采样，看起来好像是信号跑（racing）的太快了，所以 hold time failure 也叫做 race。 通过上面的分析，可以知道 hold time 限制了中间组合逻辑的最小时延，所以这个 hold time constraint 也叫做 min delay constraint。为了保证在最恶劣的情况下设计仍然能够满足要求，在计算 hold time 时中应该使用最小的数据时延路径。 P.S. 上面的例子中 clock skew 加剧了 hold time failure 的机率，如果两个时钟是对齐的，那么就不会出现 hold time failure，输出也就不会出错。 summary 假设理想的时钟为 clk，它的周期为 T，它连接到 DFF1 和 DFF2 的时钟为 clk1 和 clk2，它们相对于理想时钟的时延分别为 Tc1 和 Tc2；DFF 的参数分别为 Tsu，Th 和 Tco，中间组合逻辑的时延为 Tcomb。 数据的时延：Tc1 + Tco + Tcomb 时钟的时延：Tc2 + T 要满足 setup time 的要求，则有 Tc2 + T - (Tc1 + Tco + Tcomb) >= Tsu，整理一下即： T >= Tsu + Tco + Tcomb - Tskew --Eq1 所以可以确定出系统的最大工作频率： Fmax <= 1 / ( Tsu + Tco + Tcomb - Tskew ) -- Eq2 因为 Tc1, Tc2, Tco, Tsu 都是固定值，所以一个系统的最大工作频率取决 Tcomb。 而对于 hold time，则有不等式：Tc1 + Tco + Tcomb > Tc2 + Th，整理一下就有： Tco + Tcomb - Tskew > Th -- Eq3 上一级 DFF 的输出数据不能传输太快，侵占了下一级 DFF 正在锁存的 hold time，也就是说限制了数据的传输速度的上限。 有了前面的 3 个公式，就可以解决大部分问题了。比如华为某年的笔试题： 下图中时钟周期为 T, 触发器 D1 的建立时间最大为 T1max，最小为 T1min。组合逻辑电路最大延迟为 T2max, 最小为 T2min。问，触发器 D2 的建立时间 T3 和保持时间应满足什么条件 ? 答： 题目中 Tco = 0，Tskew = 0 对于 setup time 的要求，将 Tco = 0，Tskew = 0 代入 Eq1 得： Tsu <= { T - Tcomb } min = T - T2max 对于 hold time 的要求，将 Tco = 0，Tskew = 0 代入 Eq2 得： Th <= { Tcomb } min = T2min Ref Xilinx FPGA 开发实用教程 RF 类 IC demo 板 loadboard 设计参考资料之时钟部分 正确理解时钟器件的抖动性能 技术解析：详解各种抖动技术规范 时间抖动 (jitter) 的概念及其分析方法 锁存器 Latch v.s. 触发器 Flip-Flop TimeQuest 定时分析的基本概念 Static timing analysis Xilinx FPGA 开发实用教程 FPGA STA( 三 ) --- STA 的基本概念 Static Timing Analysis 101 Static Timing Analysis 102 : Setup Failures. Static Timing Analysis 103 : Hold Failures.","tags":"IC","loc":"https://qiangu.cool/posts/ic/static_timing_analysis_1_basic.html","title":"静态时序分析 STA 1 —— 基础知识"},{"url":"https://qiangu.cool/posts/telecom/correlation_coefficient_and_matlab_function.html","text":"Correlation 首先总结一下基础背景知识： 相关 Correlation 是概率论与统计学中用来刻画两个随机变量之间统计关系的强弱和方向的量。在广义的定义下，有很多种类的相关系数（ correlation coefficient ），它们通常用字母 ρ 或者 r 来表示。 我们通常说的相关系数的学名是： 皮尔逊积差系数（Pearson's product moment coefficient） ，这种相关系数只对两个变量的线性关系敏感。 Pearson's product moment coefficient 在统计学中，基于总体的定义如下： Pearson 相关系数使用两个变量的协方差（ covariance ）和标准差（ standard deviations ）来定义： 其中，cov 是协方差，sigma 是标准差。因为 cov 可以写作： 所以 Person 相关系数的定义式可以写作： 根据概率论知识可以得到如下的变形形式： 基于样本来估计协方差和标准差，可以得到定义如下： 通过变形，可以得到下式： Properties wiki : 当两个变量的标准差都不为零，相关系数才有定义。从柯西 - 施瓦茨不等式可知，相关系数的绝对值不超过 1。当两个变量的线性关系增强时，相关系数趋于 1 或 -1。当一个变量增加而另一变量也增加时，相关系数大于 0。当一个变量的增加而另一变量减少时，相关系数小于 0。当两个变量独立时，相关系数为 0. 但反之并不成立。这是因为相关系数仅仅反映了两个变量之间是否线性相关。比如说，X 是区间［－1，1］上的一个均匀分布的随机变量。Y = X2. 那么 Y 是完全由 X 确定。因此 Y 和 X 是不独立的。但是相关系数为 0。或者说他们是不相关的。当 Y 和 X 服从联合正态分布时，其相互独立和不相关是等价的。 当一个或两个变量带有测量误差时，他们的相关性就受到削弱，这时，\" 反衰减 \" 性（disattenuation）是一个更准确的系数。 【总结】matlab 求两个序列的相关性 相关系数只是一个比率，不是等单位量度，无什么单位名称，也不是相关的百分数，一般取小数点后两位来表示。相关系数的正负号只表示相关的方向，绝对值表示相关的程度。因为不是等单位的度量，因而不能说相关系数 0.7 是 0.35 两倍，只能说相关系数为 0.7 的二列变量相关程度比相关系数为 0.35 的二列变量相关程度更为密切和更高。也不能说相关系数从 0.70 到 0.80 与相关系数从 0.30 到 0.40 增加的程度一样大。 对于相关系数的大小所表示的意义目前在统计学界尚不一致，但通常按下是这样认为的： 相关系数 相关程度 0.00-±0.30 微相关 ±0.30-±0.50 实相关 ±0.50-±0.80 显著相关 ±0.80-±1.00 高度相关 复习了基础知识，另外还有两个概念： Cross-correlation 对于连续函数，有下面的定义： 对于离散函数，有下面的定义： 在信号处理中，用 互相关 Cross-correlation 来 衡量两个序列之间的相似程度 ，通常可以用于在长序列中寻找一个特定的短序列（也就是通信系统的同步中）。 在数理统计中，互相关用来两个随机序列的相关性。 从定义式中可以看到，互相关函数和卷积运算类似，也是两个序列滑动相乘，但是区别在于： 互相关的两个序列都不翻转，直接滑动相乘，求和；卷积的其中一个序列需要先翻转，然后滑动相乘，求和。 所以， f(t) 和 g(t) 做相关 = f*(-t) 与 g(t) 做卷积 Autocorrelation 自相关 Autocorrelation 是互相关的一种特殊情况，就是一个序列和它本身做相关，而不是两个序列，它 主要用来衡量一个序列在不同时刻取值的相似程度 。 在数理统计中，自相关的定义式如下： 如果随机过程是一个宽平稳过程，那么均值和方差都不是时间的函数，所以，自相关定义式变为： 在某些学科中，会去掉归一化因子 σ2，使用 自协方差 来代替 自相关。但是归一化因子可以让自相关的取值在 [-1, +1] 之间，不会随着序列的绝对大小而变化。 在信号处理中， 自相关的定义会去掉归一化，即不用减去均值，也不用除以方差。当除以方差时，一般叫做另外一个名字：自相关系数 autocorrelation coefficient 。 对于连续函数，自相关的定义如下： 对于离散函数，自相关的定义如下： 自相关有很多性质，比如对称性、 维纳 - 辛钦定理（Wiener–Khinchin theorem） 等，就不再重复了。 Matlab function xcorr 在 Matlab 中，计算自相关和互相关，可以使用同一个函数： xcorr 。 自相关： c = xcorr ( x ); 互相关： c = xcorr ( x , y ); 因为两个长度为 N 的序列进行相关，可以知道最多有 2N - 1 个非 0 的移位相乘结果，所以 xcorr 的返回结果就是长度为 2N - 1 的向量。（如果其中一个序列的长度小于 N，则会先补零再计算相关） 用 help xcorr 来查看详细的函数说明。 下面举个使用例子： 1 2 3 4 5 6 7 x = [ 1 , 2 , 3 ]; y = [ 4 , 5 , 6 ]; %correlation c1 = xcorr ( x ); c2 = xcorr ( y ); c3 = xcorr ( x , y ); 对于序列 x = [1, 2, 3]，移位相乘、求和，可以得到结果： 3 , 8 , 14 , 8 , 3 对于序列 y 类似。 对于 x、y 的互相关，当两个序列对齐的时候，相关性最高（归一化后为 1，意味着两个序列线性相关） xcorr 默认的返回结果是没有经过归一化的，而通常的应用中都要求归一化以得到精确的估计。解决这一问题的方法就是使用 xcorr 函数提供的 option 选项： 'biased' 有偏估计 'unbiased' 无偏估计 'coeff' 归一化，返回到最大值（对齐时）为理想的 1.0（= xcorr(x)./max(xcorr(x)) ） 'none' 未经归一化的原始数据，默认的返回结果 corrcoef 可以用 corrcoef 函数来求两个序列的相关系数，函数的返回值为一个 2×2 的矩阵，对角线上的值为两个序列的自相关系数，非对角线上的值为两个序列的互相关系数。 在上面的例子中加入下面两句： 1 2 z = [ 3 , 2 , 1 ]; c4 = corrcoef ( x , z ); 返回结果为 1 - 1 - 1 1 因为 z 是 x 的线性函数，且系数为 -1，所以非对角线上的值为 -1。 Ref correlation wiki pearson wiki Cross-correlation Autocorrelation 【总结】matlab 求两个序列的相关性","tags":"Telecom","loc":"https://qiangu.cool/posts/telecom/correlation_coefficient_and_matlab_function.html","title":"相关系数及Matlab函数"},{"url":"https://qiangu.cool/posts/ic/summary_of_hazard_and_glitch.html","text":"Hazards & Glitch 所谓 \" 冒险 \" Hazard ，是指一种数字电路中由于设计或者是外部因素，造成的数字信号错误的现象，而这个错误的信号就叫做毛刺 Glitch 。 Hazard on wiki : In digital logic, a hazard in a system is an undesirable effect caused by either a deficiency in the system or external influences. Logic hazards are manifestations of a problem in which changes in the input variables do not change the output correctly due to some form of delay caused by logic elements (NOT, AND, OR gates, etc.) This results in the logic not performing its function properly. The three different most common kinds of hazards are usually referred to as static, dynamic and function hazards. 根据导致冒险的原因，一般将冒险分类如下： 静态冒险 Static hazards 静态冒险，是指输入信号发生变化前后，输出信号保持不变，但是在输入信号变化时，输出信号可能产生瞬间错误输出。 根据发生的错误的值，可以将静态冒险分为两种： Static-1 Hazard: 输入变化前后，输出应该保持 1，但是在输入变化瞬间输出发生错误，变为 0 Static-0 Hazard: 输入变化前后，输出应该保持 0，但是在输入变化瞬间输出发生错误，变为 1 根据导致冒险的原因分类，可以将静态冒险分为以下两种类型： 逻辑冒险 logic hazard 只有 1 个输入发生变化，导致的静态冒险。 经分析可知产生逻辑冒险的原因是门的延迟。（参考 数字电路与逻辑设计 ） 功能冒险 function hazard 2 个或者 2 个以上的输入发生变化，导致的静态冒险。 经分析可知产生功能冒险的原因是两个或两个以上的输入不可能同时发生变化，它们的变化总有先有后。参考 数字电路与逻辑设计 ） 动态冒险 Dynamic hazards 动态冒险，是指输入信号变化前后，输入信号发生变化，而且在输入信号发生变化时，输出信号会变化 3 次以上 Solution 首先我们应该尽可能避免存在冒险的设计，这样就不存在解决毛刺的问题。 比如在数字电路设计中，常常采用格雷码计数器取代普通的二进制计数器，这是因为格雷码计数器的输出每次只有一位跳变，消除了竞争冒险的发生条件，避免了毛刺的产生。 再比如遵循同步设计原则，即使有毛刺，一般也不会对系统造成危害。（因为同步电路信号的变化都发生在时钟沿，只要毛刺不出现在时钟的沿口并且不满足数据的建立和保持时间，就不会对系统造成危害。一般毛刺很短，多为几纳秒，基本上都不可能满足数据的建立和保持时间） 设计无冒险的电路，会导致电路变复杂，成本上升。对于简单电路中的冒险，我们可以采用以下的方法来解决。 Static hazards 首先判断输入信号是否会同时发生变化，可以分为两种类型： 只有一个输入变化，对应的就是 logic hazards 判断是否存在冒险（ 代数法 or 卡诺图法 ） 代数法比较繁琐，但是适用范围广，对两级以上的电路均适用。注意函数表达式不能化简，否则对应的逻辑电路改变，由电路延迟造成的冒险也随之改变。 卡诺图法方便直观，但是只适用于两级电路。 函数表达式中的积项或和项是和卡诺图中的合并圈一一对应的，由此可知， 函数的最简不一定是最佳的，必要的冗余反而可增加电路工作的可靠性。 解决冒险（ 增加冗余项 / 冗余圈 ） 至少有 2 个输入同时变化，对应的就是 function hazards 判断是否存在冒险 产生功能冒险的充要条件（同时满足以下 3 个条件）： 必须有 P （P >= 2) 个变量同时发生变化 输入变量变化前后函数值相同 由变化的 P 个变量组合所构成的 2&#94;P 个格，既有 1 又有 0 解决冒险（ 选通脉冲 or 滤波电路 ） 只要输入信号不是按照循环码的方式变化，就会产生功能冒险。功能冒险是函数的逻辑功能决定的，所以不能在设计中消除，需要加额外的选通脉冲。 选通脉冲的思路：一般说来，冒险出现在信号发生电平转换的时刻，也就是说在输出信号的建立时间内会发生冒险，而在输出信号的保持时间内是不会有毛刺信号出现的。如果在输出信号的保持时间内对其进行 \" 采样 \"，就可以消除毛刺信号的影响。 需要注意的是必须对选通脉冲的宽度及产生时间有严格的要求。加上选通脉冲之后，电路的输出就不再是电平信号，而是变为脉冲信号。 还有另外一种方法：在对输出波形要求不高的时候，可以在输出端接一个滤波电容来消除冒险，但是这种方法会破坏波形的边沿，所以只适用于低速电路。 比较 3 种消除冒险的方法： 增加冗余只能消除 logic hazards，而不能消除 function hazards； 增加滤波电路虽然简单，但是会破坏波形； 加选通脉冲的方法则对两种类型的冒险都有效。 目前很多中规模集成电路（Medium Scale Integrated, MSI）中都设有使能端，其作用之一就是作为选通脉冲的输入端，待电路稳定之后才使输出有效。 Dynamic hazards 要解决动态冒险，首先就得知道动态冒险产生的原因： 产生动态冒险的原因是输入可以有多条变化路径到达输出，而这些路径的时延都各不相同，显然这就会导致输出变化多次，比如一个输出应该从 1 变为 0，但是实际中却先从 1 变为 0，然后又从 0 变回 1，最终返回到正确值 0。 动态的解决相对比较复杂，但是 只要消除了静态冒险，那么就不会存在动态冒险。 in FPGA Design 本部分来自： 关于毛刺问题的探讨 和 Verilog HDL 程序设计与实践 信号在 FPGA 器件内部通过连线和逻辑单元时，都有一定的延时。延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化 , 往往会出现一些不正确的尖峰信号，即毛刺信号。与分立元件不同，由于 PLD 内部不存在寄生电容电感，这些毛刺将被完整的保留并向下一级传递，因此毛刺现象在 PLD、FPGA 设计中尤为突出。 可以概括的讲， 只要输入信号同时变化，（经过内部走线）组合逻辑必将产生毛刺。将它们的输出直接连接到时钟输入端、清零或置位端口的设计方法是错误的，这可能会导致严重的后果。所以我们必须检查设计中所有时钟、清零和置位等对毛刺敏感的输入端口，确保输入不会含有任何毛刺。 如前所述，优秀的设计方案，如采用格雷码计数器，同步电路等，可以大大减少毛刺，但它并不能完全消除毛刺。 毛刺并不是对所有输入都有危害，例如 D 触发器的 D 输入端，只要毛刺不出现在时钟的上升沿并且满足数据的建立和保持时间，就不会对系统造成危害。因此我们可以说 D 触发器的 D 输入端对毛刺不敏感。但对于 D 触发器的时钟端，置位端，清零端，则都是对毛刺敏感的输入端，任何一点毛刺就会使系统出错，但只要认真处理，我们可以把危害降到最低直至消除。下面我们就对几种具体的信号进行探讨。 clock 时钟信号是系统中非常关键的信号，参见其他 几篇博客 。 set/clear 清除和置位信号要求象对待时钟那样小心地考虑它们，因为这些信号对毛刺也是非常敏感的。正如使用时钟那样，最好的清除和置位是从器件的引脚单直接地驱动。有一个主复位 Reset 引脚是常用的最好方法，主复位引脚给设计项目中每个触发器馈送清除或置位信号。几乎所有 PLD 器件都有专门的全局清零脚和全局置位。如果必须从器件内产生清除或置位信号，则要按照 \" 门控时钟 \" 的设计原则去建立这些信号，确保输入无毛刺。 combinational output 当 PLD 输出引脚给出系统内其它部分的边沿敏感信号或电平敏感信号时，这些出信号必须象内部时钟、清除和置位信号一样小心地对待。只要可能就应在 PLD 输出端寄存那些对险象敏感的组合输出。如果你不能寄存险象敏感的输出，则应符合 \" 门控时钟 \" 中讨论的门控时钟的条件。决不能用多级逻辑驱动毛刺敏感的输出。 asynchronous input 对于异步输入信号导致的毛刺，解决思想就是 同步化。参见 这篇博客 。 Ref Hazard on wiki 数字电路与逻辑设计 Digital Design (4th Edition) Verilog HDL 程序设计与实践 关于毛刺问题的探讨","tags":"IC","loc":"https://qiangu.cool/posts/ic/summary_of_hazard_and_glitch.html","title":"关于冒险和毛刺"},{"url":"https://qiangu.cool/posts/telecom/ifft_and_fft_in_ofdm.html","text":"Intro 在做 OFDM 项目时，发现一个容易犯错的地方： IFFT / FFT 。 在很多介绍 OFDM 的书中，给出结论：在发射机，基带信号的复包络采用值正好是待发射序列的 IDFT，所以在 N 是 2 的指数时，可以采用 IFFT 来快速计算；在接收机，将接收的频带信号解调到基带，采样得到基带复包络，然后做 DFT (FFT) 即可得到原始的发射序列。 这个结论是正确的，但是需要注意的一点是： 调制 / 解调所做的运算的形式和 IFFT/FFT 是相同的，但是有一个功率归一化的系数的差别。 很多书（ 通信原理 ）都给出了公式推导，然而这些公式并不严谨，这些公式只是为了说明做的变换形式是 IFFT/FFT。 有的书（ 宽带无线通信 OFDM 技术 ）则给出了更加详细，严谨的公式推导。 IFFT / FFT IFFT /FFT in OFDM OFDM 中 功率归一化因子 为 1/sqr(N)，而标准的 IFFT 中的系数为 1/N，所以在调用标准 IFFT 函数之后，需要额外乘以一个 sqr(N) ： 1/N × sqr(N) = 1/sqr(N) 而在接收端，也要先除以一个 sqr(N)，然后再进行 FFT 。 Ref 通信原理 宽带无线通信 OFDM 技术","tags":"Telecom","loc":"https://qiangu.cool/posts/telecom/ifft_and_fft_in_ofdm.html","title":"OFDM 中的 IFFT/FFT 注意事项"},{"url":"https://qiangu.cool/posts/telecom/summary_of_snr_and_noise.html","text":"所谓 信噪比（SNR, Signal-to-noise ratio） 就是指 信号的功率 和噪声的功率 的比值。我们可以用它来比较信号的和背景噪声的相对大小，如果比值大于 1（0 dB），说明信号功率比噪声功率强。 SNR Def 信噪比的定义式： 这里 P 表示信号 / 噪声的平均功率。 如果信号和噪声的方差已知，且两者的均值都为 0，则信噪比可以写为下式： 如果信号和噪声是使用相同的阻抗来测量的（功率这个词本来就源于物理，在电子系统中，功率 P = UI = V&#94;2/R ），那么信噪比公式可以用幅度的平方比值来计算： 其中 A 为信号 / 噪声的 均方根（ root mean square, RMS） 一般信号的动态范围都很大，所以通常采用分贝的方式来表示信噪比 把 均方根 带入，就可以得到下面的公式 一般 SNR 指的是 平均 信噪比，因为通常 SNR 的瞬时值是不同的 信噪比的概念也可以这么理解：将噪声的功率归一化为 1（0 dB），看信号的功率可以达到多大 SNR in telecom 在物理学中，交流电信号的 平均功率 = ( 电压 × 电流 ) 的均值，如下式： 但是在信号处理和通信中，一般假设电阻的阻值为 1 欧姆，所以在计算能量、功率时，电阻因子会被忽略。这可能会引起一些困扰。 所以信号的功率表示式简化为下面的公式： （其中， A 是交流信号的幅度） Eb/N0 在数字系统中可以使用 SNR 表示噪声的等级，但是更常用的是 Eb/N0 (energy per bit to noise power spectral density ratio) 。 Eb/N0 是一种归一化的 SNR，称为 \" SNR 每 bit \"，在比较不同的调制方案的 误比特率（BER, bit error rate） 性能时，因为这种方法不考虑带宽的因素，所以很有效。 其中 Eb 是平均比特能量，它表示平均每个 bit 包含的能量。 信号的功率就等于符号中每个比特的功率 Eb × 每个符号所包含的比特数 fb（也就是比特速率）；噪声的能量可以用功率谱密度来计算，N0×B，代入信噪比的定义式，就有下面的换算公式： P.S. 上面的公式左边使用的是载噪比 CNR，在抑制载波的调制方式中，等于信噪比 SNR。 AWGN 高斯分布（ Gaussian distribution ）可以使用 N(μ,σ2 ) 来表示，其中 μ 是均值，σ 是标准差。 对噪声进行建模，最简单的就是 加性高斯白噪声 (AWGN, Additive White Gaussian Noise) 。 加性：叠加在信号之上，而且无论有无信号，噪声都是始终存在 高斯：噪声幅度的取值是随机过程，它的概率密度函数服从高斯分布 白噪声：噪声的功率谱密度函数取值是常数，在坐标系中表现为一条直线，在每个频率点的谱密度都一样，就像白光包含各种频率的光一样，所以叫做白噪声。 同时满足这三个的条件的噪声就叫做 加性高斯白噪声。 高斯白噪声的功率谱函数： P(f) = N0/2 ， 其中 N0 是 单边噪声功率谱密度 ， N0/2 是 双边噪声功率谱密度 。 因为功率谱密度函数的定义域是无穷大的，所以高斯噪声的功率也是无穷大的，它的功率只有在带限时才有意义。 在计算前面 SNR 时，我们可以使用下面两种方法来得到 Pn： 如果均值为 0， Pn = 方差 σ2 = R(0) 如果已知功率谱密度函数 P(f)，那么直接对其定积分 Ref Signal-to-noise ratio Eb/N0 Gaussian noise 关于白噪声功率谱密度和方差的关系","tags":"Telecom","loc":"https://qiangu.cool/posts/telecom/summary_of_snr_and_noise.html","title":"信噪比小结"},{"url":"https://qiangu.cool/posts/tools/learning_vim_bufexplorer_nerdtree_winmanager_powerline.html","text":"BufExplorer 我们可以使用 :ls 命令可以查看打开的 buffer，然后在不同的 buffer 之间切换： : bn 其中 n 是 buffer 的标号。 这种内置的方法效率比较低，尤其是当我们打开很多个 Buffer 之后，问题更加明显。所以就有了各种 buf 类的插件，最有名的就是： BufExplorer 和 MiniBufferExplorer 不同的人使用习惯不同，在 stackoverflow 上有专门讨论两者的优劣的问题： ViM: minibufexpl versus bufexplorer plugins 我个人觉得 BufExplorer 更好一些，主要原因在于 Mini 在打开很多 buffer 时（>8 个），切换 buffer 效率很低，而且 Mini 会占用几行宝贵的屏幕资源。 下面就主要说 BufExlplorer。 Install 使用 Vundle 安装： 在 .vimrc 中添加 Bundle 'bufexplorer.zip' 打开 vim，输入 : BundleInstall Config 查看 help 文档，自定义配置，我的简单配置如下： \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Config BufExplorer \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" let g : bufExplorerDefaultHelp = 0 \" Do not show default help. let g : bufExplorerShowRelativePath = 1 \" Show relative paths. let g : bufExplorerSortBy = ' mru ' \" Sort by most recently used. NERDTree NERDTree 是一款可以提供树形目录的 vim 插件，使用它我们可以在 vim 内以树形结构浏览文件目录。 Install 使用 Vundle 安装： 在 .vimrc 中添加 Bundle 'The-NERD-tree' 打开 vim，输入 : BundleInstall Usage 输入 :NERDTree 打开 NERDTree 窗口 常用快捷键： o 打开 / 关闭光标所在目录 t 在新 tab 中打开文件，并跳转到该 tab T 在新 tab 中打开文件，并不跳转到该 tab p 跳转到父节点 P 跳转到根节点 q 关闭 NERDTree 窗口 Powerline 状态栏也是一个非常重要的窗口，可以为我们提供一些文档的基本信息，我们可以自己 DIY，在 .vimrc 文件中添加相关的设置 set statusline =% F % m % r % h % w \\ [ FORMAT =% { & ff } ] \\ [ TYPE =% Y ] \\ [ POS =% l , % v ][ % p %% ] \\ % { strftime ( \\ \"%d/%m/%y\\ -\\ %H:%M\\\" ) } 也可以使用 Powerline 插件，一款可以提供非常漂亮的状态栏的插件。它会覆盖掉 .vimrc 中对状态的配置，删除插件后配置信息可以重新起作用。 Install 使用 Vundle 安装： 在 .vimrc 中添加 Bundle 'Lokaltog/vim-powerline' 打开 vim，输入 : BundleInstall Config 为了保证状态栏始终显示，在 .vimrc 中添加 set laststatus = 2 设置之后，应该就可以看到漂亮的状态栏了。 查看 help： : help powerline 我们还可以自定义一些选项，比如颜色主题等。 WinManager 我们已经安装很多插件，比如 Taglist，BufExlporer、NERDTree 等，这时候我们就需要一个窗口管理插件来将它们组合起来 —— WinManager Install 使用 Vundle 安装： 在 .vimrc 中添加 Bundle 'winmanager' 打开 vim，输入 : BundleInstall Config 查看 help 文档，我们可以进行简单的设置： \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Config Winmanager \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" let g : winManagerWindowLayout = \" NERDTree|TagList \" let g : NERDTree_title = \" [NERDTree] \" nmap < C - m > : WMToggle < CR > function ! NERDTree_Start () exec ' NERDTree ' endfunction function ! NERDTree_IsValid () return 1 endfunction 这时候我们按下组合键 Ctrl-m 即可切换是否显示 winmanager 窗口布局。 最后附上效果图一张： Ref vi/vim 使用进阶 : 文件浏览和缓冲区浏览 将 Vim 改造为强大的 IDE—Vim 集成 Ctags/Taglist/Cscope/Winmanager/NERDTree/OmniCppComplete（有图有真相） 谁说 Vim 不是 IDE？（三）","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_bufexplorer_nerdtree_winmanager_powerline.html","title":"学习 Vim 之 BufExplorer、NERDTree、WinManager、Powerline 插件"},{"url":"https://qiangu.cool/posts/book/to_live_review.html","text":"寒假前的最后几天，偷懒没有去实验室，在宿舍温暖的被窝里面看完了余华的《活着》。看完之后，有种想说却说不出的难受，或许这就是 \" 活着 \" 的沉重吧。作为代码狗，我的语文水平对不起当年的体育老师，但是还是想写一点胡言乱语，日后回首，不知会是番什么滋味。。。 苦难文学，每个人的一生都是在苦难中度过： 故事是关于一个叫做 福贵 的男人的一生：年少时，他是地主少爷，是吃喝嫖赌的败家子，当他挥霍光全部家产后，父亲被他气死，怀孕的老婆也被接回了娘家，只留下一个老母亲和小女儿。于是他从地主少爷变成了一个佃户，细皮嫩肉的他不得不下地种田，然而苦日子才刚刚开始，后面还有更大的苦难在等着他。从少爷成为一个佃户，再被抓取当壮丁，侥幸没死在战场上，回家和家人团聚后又经历了大跃进和文化大革命，他先后送走了自己的父母，儿子，老婆，女儿，女婿，外孙子，命运给他剩下来的就是一头和他一样被称作 \" 老不死 \" 的老黄牛。 福贵的老婆家珍本来是米行的大小姐，嫁给了败家的福贵，然后陪着他过完了苦难的一生；福贵的儿子有庆年少但是懂事、勤劳，却不想被庸医抽血抽死了；福贵的女儿凤霞从小随父母吃苦，又聋又哑，之后好不容易遇到一个真正爱她的丈夫，没有享受多少好日子就死于难产；福贵的女婿勤快老实，却也在工地上死于意外；留下来的外孙苦根虽然年少，却也知道心疼福贵，为他分忧，但命运仍然没有放过他。 面对苦难的命运，福贵他们选择默默忍受，忍耐是中国老百姓最擅长的，没有抗争命运的动人桥段，但却让人更加为之动容。因为我们是长在这样的环境，这样的文化中，它溶于我们的血液灵魂之中。 故事虽然苦难，但是我们也能从中读出了一丝丝温情。 首先，亲情。输掉家产，让福贵看到父母、老婆的真情所在，幡然悔悟，浪子回头金不换，重新做人。包括后来福贵、家珍对自己儿女简单粗暴的教育、生病的关心，受苦的心疼，儿女小小年纪却非常懂事，正是亲情让他们相互依赖，相互扶持，坚强地活下去。 其次，爱情。作为大小姐家珍面对败家的丈夫毫无怨言，心干情愿地陪着他吃了一辈子的苦，在他输光所有家产后没有离开他，他被抓起当壮丁后仍然坚守着这个家，或许这是福贵一生最大的幸福吧。或许有人会说这是旧社会束缚女性的毒瘤，但是我更愿意称之为爱情。当福贵在村口毫无顾忌地背起家珍，我想家珍心里一定是充满温暖的。而凤霞和二喜的爱情虽然短暂，但仍让人羡慕。 最后，人情。书里面没有大奸大恶之徒，除了那个让人痛恨的庸医，村民、队长、老全、春生他们都是尽最大努力好好地活在这个世界上，他们或许有让人不喜欢的地方，但是他们都算是朴实善良。相比于当前社会人们之间的丑恶，这份淳朴更加让人感动。 活着，一句简单但是充满力量的话，包含着中国老百姓对生命的态度和理解：努力地活下去，去感受、忍受生命带给我们的苦难和幸福，我们每个人何尝不是福贵，生活给我们苦难，磨去我们的棱角，让我们成长，甚至让我们孤独一生，最后只有一头老黄牛相伴，我们也应该像福贵一样地活着，像老黄牛一样活着。 认识苦难，接受苦难，珍惜身边的每个人，更好地、更坚强地活下去 ，我想这也许就是苦难文学最大的意义吧。","tags":"Book","loc":"https://qiangu.cool/posts/book/to_live_review.html","title":"活着 有感"},{"url":"https://qiangu.cool/posts/tools/learning_vim_markdown.html","text":"Vim 和 Markdown 就不多罗嗦了，记录一下最近在 Vim 中摸索使用 Markdown 的经历。 Syntax Hightlight Vim 可以通过插件来提供对 Markdown 语法的支持，网上找到很多这类插件： 官网上的插件： Markdown 我找到的是下面这个： plasticboy/vim-markdown Install 使用 Vundle 管理插件，只需要在 .vimrc 文件中添加： Bundle 'godlygeek/tabular' Bundle 'plasticboy/vim-markdown' 然后打开 Vim，输入命令： : BundleInstall 即可。 File extension Markdown 文件的后缀名可以是 .markdown ， mkd ， mkdn ， md 等，但是 plasticboy 的插件只识别 mkd 和 markdown 两种： Enabling markdown highlighting in Vim 因为我们已经按照 .md 格式写了很多文本了，这时候更好选择当然是修改设置，让 vim 可以识别这种类型的文件，而不是修改文件后缀名。所以我们需要在 vimrc 中设置一下： au BufRead , BufNewFile * . md set filetype = markdown 这样，.md 文件就可以被识别了。 经过上面两步，此时再打开 markdown 文件就可以看到语法高亮了，plasticboy/vim-markdown 还支持一些高级的主题：比如支持 LaTeX 数学公式的高亮，ToC 等，从 github 上可以看到相关设置的介绍说明。 Preview 一些专门的 Markdown 软件、网页编辑器都是提供实时预览，Vim 虽然不提供预览窗口，但是配合浏览器，我们也可以实现实时预览的功能，当然还是依靠万能的插件。 我使用的是： suan/vim-instant-markdown Install 首先要保证已经安装了 node.js npm - v 如果没有，安装 npm sudo apt - get install npm 安装 instant-markdown-d sudo npm - g install instant - markdown - d 确保系统安装了 xdg-utils ，否则 apt-get 安装 使用 Vundle 管理插件 在 .vimrc 中添加 Bundle 'suan/vim-instant-markdown' 打开 vim，输入命令 : BundleInstall Config & Use 如果机器比较老，插件占用的资源过多的话，可以设置 let g : instant_markdown_slow = 1 来降低资源利用。 默认情况下，当我们打开 markdown 文件时，插件会自动打开一个预览的浏览器标签页，如果不想，可以关闭自动打开功能： let g : instant_markdown_autostart = 0 在需要时手动输入命令 :InstantMarkdownPreview 来预览。 存在的问题： Vim 窗口重叠在浏览器窗口之上时，会遮住部分内容；当两个窗口并排时，浏览器窗口无法完全显示全部内容，这在小尺寸屏幕上尤其明显。 打开的预览网页无法实时跟随内容滚动。 最后放一张截图： Ref plasticboy/vim-markdown Enabling markdown highlighting in Vim suan/vim-instant-markdown","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_markdown.html","title":"在 Vim 中写 Markdown 文件"},{"url":"https://qiangu.cool/posts/tools/learning_vim_ctags_cscope_taglist.html","text":"Background tags 文件是一种非常有用的文件，本文的内容都是基于 tag 的，所以首先得了解什么是 tag？ Vim Manual 里面的简单介绍就足够我们进行下面的内容了。查看 Manual： : help tagsrch 使用 tags 文件的步骤： 首先使用 tag 工具（ctags、cscope 等）生成 tags 文件 其次，将 tags 文件路径导入到 Vim 中，让 Vim 知道从哪个 tags 文件中查找。 最后，使用 Vim 的命令查找 tag。 Ctags Intro Ctags 官网 wiki Ctags is a programming tool that generates an index (or tag) file of names found in source and header files of various programming languages. Depending on the language, functions, variables, class members, macros and so on may be indexed. These tags allow definitions to be quickly and easily located by a text editor or other utility. Alternatively, there is also an output mode that generates a cross reference file, listing information about various names found in a set of language files in human-readable form. manpage: man ctags vim Manual： : help 29 . 1 : help ctags 简而言之，Ctags 是一个可以自动提取源文件和头文件中函数、变量、类成员、宏定义等元素的工具，然后它会建立一个 tags 文件，其他编辑器（比如我们使用的 Vim）可以读取这个 tags 文件，从而快速定位代码的位置。 使用 ctags --list-language 可以查看 ctags 支持的语言，使用 ctags --list-maps 可以查看哪些后缀名对应对应的语言。 Install ctags 是 Unix 系统自带的一个工具，但是功能比较少，所以一般使用 Exuberant Ctags。在 Linux 上，Exuberant Ctags 是默认的 Ctags 程序。如果系统中没有安装的话，我们可以从官网上下载源码编译安装，或者直接 apt-get 安装。 sudo apt - get install exuberant - ctags Config 我们要使用 tags，第一步就是生成 tags 文件。生成 tags 文件时，ex-ctags 提供了很多参数供我们控制生成结果，详细内容可以查看其 manpage，这里有 easwy 大神翻译的中文版： Exuberant Ctags 中文手册 我们可以将配置写在 .vimrc 中： set tags = tags ; map < C - F12 > : ! ctags - R --c++-kinds=+p --fields=+iaS --extra=+q .<CR> 这样，我们只需要按 Ctrl-F12 即可自动生成 C++ 项目的 tags 文件。 Usage Vim 提供了接口可以调用 tags 文件，它使用一个栈来记录我们在文件中跳转的位置。ctags 其 manual page 中有说明如何在 Vi 中使用 ctags： vi -t tags 打开 vi，并且将光标停留在 tag 定义的地方 :ta tag 寻找 tag Ctrl-] 寻找光标处 tag 的定义 Ctrl-T 返回到 tag 的前一个位置 tnext 如果某个 tag（比如函数）有多次定义，会匹配到多个结果，本命令跳到下一个结果。 tprevious 同上，跳转到前一个匹配结果 tfirst 跳转到第一个匹配结果 tlast 跳转到最后一个匹配结果 :ts tag 同上，列出所有匹配到 tag 的结果 :tags 显示 tagstack 中的内容，即我们的跳转记录 Cscope Intro Cscope 官网 cscope wiki : cscope is a console mode or text-based graphical interface that allows computer programmers or software developers to search C source code (there is limited support for other languages). It is often used on very large projects to find source code, functions, declarations, definitions and regular expressions given a text string. cscope is free and available under a BSD License. The original developer of cscope is Joe Steffen. man page: man cscope Vim help: : help if_cscop The following text is taken from a version of the cscope man page: Cscope is an interactive screen-oriented tool that helps you: Learn how a C program works without endless flipping through a thick listing. Locate the section of code to change to fix a bug without having to learn the entire program. Examine the effect of a proposed change such as adding a value to an enum variable. Verify that a change has been made in all source files such as adding an argument to an existing function. Rename a global variable in all source files. Change a constant to a preprocessor symbol in selected lines of files. It is designed to answer questions like: Where is this symbol used? Where is it defined? Where did this variable get its value? What is this global symbol's definition? Where is this function in the source files? What functions call this function? What functions are called by this function? Where does the message \"out of space\" come from? Where is this source file in the directory structure? What files include this header file? Cscope answers these questions from a symbol database that it builds the first time it is used on the source files. On a subsequent call, cscope rebuilds the database only if a source file has changed or the list of source files is different. When the database is rebuilt the data for the unchanged files is copied from the old database, which makes rebuilding much faster than the initial build. 简而言之，就是 ctags 的加强版，ctags 只能让我们跳转到某个 tag 的定义之处，但是无法让我们知道这个 tag 还在哪里出现过，或者被哪个函数调用过，这时候就需要 cscope 来大显身手了～ P.S. cscope 对 C/C++ 支持比较好，当然我们也可以自己定制来支持其他语言，比如 Java，Python 等。 Install sudo apt - get install cscope Usage 联合使用 Cscope + Vim 的流程： 使用 cscope 生成数据库文件 cscope - Rbkq 其中参数的含义： -R 递归，对子目录也建立数据库 -b 只生成数据库，不进入 scope 界面 -k 生成数据库时，不搜索 /usr/include 目录 -q 生成 cscope.in.out 和 cscope.po.out 文件，加快查找速度 更详细的参数见 man page。 将数据库导入 Vim 中 cd 到源文件目录下，执行上一步操作，然后打开 vim 输入下面的命令： ： cs add . / cscope 在 Vim 中查找 通用格式为 :cs find -option label 。 option 可以有很多种模式，在 Vim 中使用 :help cscope-find 来查看 option： 0 or s : Find this C symbol 1 or g : Find this definition 2 or d : Find functions called by this function 3 or c : Find functions calling this function 4 or t : Find this text string 6 or e : Find this egrep pattern 7 or f : Find this file 8 or i : Find files # including this file Config Vim 的 cscope 接口提供了一些参数，可以让我们更加灵活地使用 cscope，可以用 help if_cscop 来查看完整的说明，这里有一份前辈翻译的中文版 Cscope 的使用（领略 Vim + Cscope 的强大魅力） 下面我找了几个常用的选项： cscopequickfix vim 提供了 cscopequickfix 选项，让查找结果在 quickfix 的窗口显示。 同时使用 cscope ctags 设置 cst 选项，可以同时查找 cscope 和 ctags，查找顺序有 csto 选项来决定。 :ctags 等同于 :cs find g 为了省事，我们可以将一些参数设置写在 .vimrc 文件中，Vim help 中有推荐设置，下面是我修改过的配置： if has ( \" cscope \" ) set csprg =/ usr / bin / cscope set cscopequickfix = s - , c - , d - , i - , t - , e - \" set cst \" keep the regular tag behavior \" set csto=0 \" keep the regular tag behavior set nocsverb \" add any database in current directory if filereadable ( \" cscope.out \" ) cs add cscope . out \" else add database pointed to by environment elseif $C SCOPE_DB != \"\" cs add $C SCOPE_DB endif set csverb endif nmap < C - _ > s : cs find s < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - _ > g : cs find g < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - _ > c : cs find c < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - _ > t : cs find t < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - _ > e : cs find e < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - _ > f : cs find f < C - R >= expand ( \" <cfile> \" ) < CR >< CR > nmap < C - _ > i : cs find i &#94;< C - R >= expand ( \" <cfile> \" ) < CR > $ < CR > nmap < C - _ > d : cs find d < C - R >= expand ( \" <cword> \" ) < CR >< CR > \" Using 'CTRL-spacebar' then a search type makes the vim window \" split horizontally, with search result displayed in \" the new window. nmap < C - Space > s : scs find s < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space > g : scs find g < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space > c : scs find c < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space > t : scs find t < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space > e : scs find e < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space > f : scs find f < C - R >= expand ( \" <cfile> \" ) < CR >< CR > nmap < C - Space > i : scs find i &#94;< C - R >= expand ( \" <cfile> \" ) < CR > $ < CR > nmap < C - Space > d : scs find d < C - R >= expand ( \" <cword> \" ) < CR >< CR > \" Hitting CTRL-space *twice* before the search type does a vertical \" split instead of a horizontal one nmap < C - Space >< C - Space > s \\: vert scs find s < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space >< C - Space > g \\: vert scs find g < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space >< C - Space > c \\: vert scs find c < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space >< C - Space > t \\: vert scs find t < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space >< C - Space > e \\: vert scs find e < C - R >= expand ( \" <cword> \" ) < CR >< CR > nmap < C - Space >< C - Space > i \\: vert scs find i &#94;< C - R >= expand ( \" <cfile> \" ) < CR > $ < CR > nmap < C - Space >< C - Space > d \\: vert scs find d < C - R >= expand ( \" <cword> \" ) < CR >< CR > Taglist Intro Taglist 官网 使用过 VS 的人都知道，在左侧有一个窗口专门显示当前代码文件中的宏、函数、变量定义，并且随着文件切换自动更新。我们这里介绍的 Taglist 完成的就是类似的功能，让我们可以高效地浏览代码。不过要使用 Taglist，首先要安装前面介绍的 Ctags。 The \"Tag List\" plugin is a source code browser plugin for Vim and provides an overview of the structure of source code files and allows you to efficiently browse through source code files for different programming languages. Install 与前面的 ctags、cscope 不同的是，taglist 是一款 Vim 插件。如果使用 Vundle 来管理、安装插件，在 .vimrc 中添加 Bundle 'taglist.vim' 然后打开 vi，然后输入命令 :BundleInstall 即可。 Config 使用 :help taglist 查看帮助。 使用 :TlistToggle 切换是否显示 Taglist 窗口。 我们可以直接在 .vimrc 中添加以下设置： let Tlist_Show_One_File = 1 let Tlist_Exit_OnlyWindow = 1 let Tlist_SHow_Menu = 1 let Tlist_File_Fold_Auto_Close = 1 Usage 在 taglist 窗口，我们可以使用下面的一些快捷键： = 折叠所有 tag - 折叠单个 tag + 打开一个折叠 x taglist 窗口放大 / 缩小，方便查看 tag u 更新 taglist sapce 显示光标处 tag 的原型定义 P.S. 配合另外一个窗口管理插件 winmanager，我们可以将我们的 Vim 打造成一个伪 IDE :D Ref ctags 的使用及相关参数介绍 Exuberant Ctags 中文手册 vi/vim 使用进阶 : 使用标签 (tag) 文件 cscope 官网 cscope wiki Cscope 的使用（领略 Vim + Cscope 的强大魅力） Taglist 官网 vi/vim 使用进阶 : 使用 taglist 插件","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_ctags_cscope_taglist.html","title":"学习 Vim 之 Ctags/Cscope/Taglist"},{"url":"https://qiangu.cool/posts/ic/doxygen_for_verilog.html","text":"最近学习了 Doxygen，它可以帮助我们生成美观的文档。Doxygen 支持的程序语言中包含 VHDL，但是不包含 Verilog。 那么问题就又来了： 有没有一个支持 Verilog 的类似 Doxygen 的程序？ 答案当然是： 有， Doxverilog 机智的网友早就遇到了和我一样的问题： Documentation generator for Verilog Documenting Verilog (AMS) using Doxygen/Doxverilog Doxverilog has been updated 我搜到了两个工具：一个是 perl 脚本 v2html ，另一个就是 Doxverilog。前者生成的页面美观性实在不敢恭维，理想工具当然是 Doxverilog。 Doxverilog Doxverilog is a nativ verilog parser (Verilog 2001) for Doxygen. After installing this patch you can documentate your verilog project similar to VHDL in Doxygen. Patch against the doxygen-1.7.0 version. Doxverilog 基于 Doxygen ，只是额外添加了对 Verilog 语言的支持。它托管在 sourceforge 上的压缩包貌似是损坏的，不能正常解压，幸好在 Github 上的还是好的： Doxverilog on Github 关于 Doxverilog 的安装使用方法，github 上已经说的很清楚了，下面只记录一下我遇到的问题。 Installation 安装步骤： patch patch - F3 - p0 < linux . patch compile . / configure make make install 写本文时，Doxverilog 的版本号是 2.7，对应的 Doxygen 的版本号是 1.8.1，而 Doxygen 官网上的版本已经更新到了 1.8.9，如果最新版本可能在编译的时候报错。 在 patch 时，可能会遇到询问，一路 y 下去即可。 在 compile 时，可能会报错，我遇到的报错是 vhdlparse.cpp 缺少行末分号的小问题，自己添加就行。 编译安装完成之后，我们应该可以使用一个文档来测试一下，如果生成的配置文件中包含 OPTIMIZE_OUTPUT_VERILOG 这个选项，那么就说明破解安装成功了。 Configuration 在修改配置文档时，除了常规的配置选项之外，对于 Verilog 我们还需要额外注意一下几个选项： OPTIMIZE_OUTPUT_VERILOG = YES 针对 Verilog 进行输出优化 FILE_PATTERNS = *.v 标明选择 verilog 源文件 Documenting Verilog/VHDL 注释规则： 对于 Verilog 的注释规则，和 VHDL 类似，唯一的不同之处在于 VHDL 使用 --! 来开始注释，Verilog 使用 //% 作为注释的开头。 VHDL 中使用单行的 --! 来开始 brief description，使用多行的 --! 开始 detailed description。 Verilog 使用单行的 //% 开始 brief description，使用多行的 //% 开始 detailed description。 所有的注释都在对应代码的前面，只有一个例外：端口的 brie description 可以写在代码后，而且不用像 C++ 中一样修改注释的头部 example: 下面是 Doxygen 官网是 VHDL 注释的例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ------------------------------------------------------- --! @file --! @brief 2:1 Mux using with-select ------------------------------------------------------- --! Use standard library library ieee ; --! Use logic elements use ieee.std_logic_1164. all ; --! Mux entity brief description --! Detailed description of this --! mux design element. entity mux_using_with is port ( din_0 : in std_logic ; --! Mux first input din_1 : in std_logic ; --! Mux Second input sel : in std_logic ; --! Select input mux_out : out std_logic --! Mux output ); end entity ; --! @brief Architecture definition of the MUX --! @details More details about this mux element. architecture behavior of mux_using_with is begin with ( sel ) select mux_out <= din_0 when '0' , din_1 when others ; end architecture ; 生成的 结果 。 我写的 Verilog 的注释： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //% @file mycounter.v //% @brief Implementation file of module mycounter. //% //% @author Qian Gu //% @version 1.0 //% @date 2015-01-20 //% This is a test project, //% it's a increase counter module 256. //% module mycounter ( clk , rst , dout ); // Port Declaratiosn input clk ; //% clock signal input rst ; //% reset siganl, active high output reg [ 7 : 0 ] dout ; //% count result // Main Body of Code always @ ( posedge clk or negedge rst ) begin if ( ! rst ) begin dout <= 8 'b0 ; end else begin dout <= dout + 1 ; end end endmodule Ref doxygen manual doxverilog","tags":"IC","loc":"https://qiangu.cool/posts/ic/doxygen_for_verilog.html","title":"针对 Verilog 的 Doxygen"},{"url":"https://qiangu.cool/posts/ic/drawing_fsm_state_diagram_using_graphviz.html","text":"Graphviz Graphviz 是一个由 AT&T 实验室启动的开源工具包，用于绘制 DOT 语言脚本描述的图形。 wiki : Graphviz (short for Graph Visualization Software) is a package of open-source tools initiated by AT&T Labs Research for drawing graphs specified in DOT language scripts. It also provides libraries for software applications to use the tools. Graphviz is free software licensed under the Eclipse Public License. 根据介绍，我们知道 Graphviz 基于一种叫做 DOT 的图形描述语言，Graphviz 由一组可以处理 DOT 文件的工具组成，最终生成图形。 既然是画图，那么问题就来了：很多软件都可以画图， 为什么偏偏要用 Graphviz 呢？ Graphviz 的优点： 不用鼠标绘制，也不用手动调整坐标。使用 Visio 或者其他的画图工具的人都体验过手动对齐的不便，而且很多时候手动调整根本就对不齐，强迫症患者心中永远的痛 T_T 修改更新方便。手绘的图修改起来很麻烦，而使用 DOT 语言的话，只需要修改脚本就 Ok 了。 Graphviz 的缺点：要想用好，需要投入时间和精力去学习使用方法。 Graphviz 可以帮助我们画数据结构图、模块图、流程图等，是程序猿的画图利器。这里我们只用它来画简单的 流程图 / 状态图 ，所以只要有基本的图论知识，不涉及高级主题，所以学习起来是很轻松的。 因为在 前面一篇博客 中我们已经简单介绍了 Graphviz 这个工具软件的安装方法，所以下面直接进入正题： 如何使用 Graphviz 画 FSM 的状态转移图。 Usage 下面的内容是我精简出来了的最小学习方法，使用方法的详细攻略请看 Graphviz 官网上的 Documentation 。 DOT DOT 语法在 Documentation 里面有介绍，它的定义方法和 C/C++ 中的 struct 类似。由图论的基本知识，我们知道描述一个图，只要用节点（ node )、边（ edge ） 这两个要素就能描述清楚，而 DOT 语言也就是利用这两个信息来描述一个图的。下面用几个基本的例子来说明。 无向图 由 3 个节点组成的一个无向图。 脚本（example1.dot）： graph example1 { node1 -- node2 node2 -- node3 node3 -- node4 } 结果： 有向图 还是上面的例子，不过修改为有向图。 脚本（example2.dot）： digraph example2 { node1 -> node2 node2 -> node3 node3 -> nod31 } 结果： 添加属性 我们还可以控制 node 的属性（节点形状、颜色、边箭头的形状等），来产生不同的结果。 脚本（example3.dot）： digraph example3 { node1 -> node2 node2 -> node3 node3 -> node1 node1 [ shape = circle , label = \"state1\" , fillcolor = \"#123456\" , style = filled ] node2 [ shape = triangle , label = \"state2\" , fillcolor = \"#345678\" , style = filled ] node3 [ shape = box , label = \"state3\" , fillcolor = \"#567890\" , style = unfilled ] } 结果： 标注 上面的结果和我们的状态转移图相比，还差一点就是转移箭头边上的标注，我们可以在 edge 后面加上 label 属性来标注信息。 脚本（example4.dot）： digraph example4 { node1 -> node2 [ label = \"condition1\" ] node2 -> node3 [ label = \"condition2\" ] node3 -> node1 [ label = \"condition3\" ] } 结果： 以上的 4 个例子就足够我们画 FSM 的状态转移图了。更加详细的说明参考官方文档和一篇文章： Graphviz - 用指令來畫關係圖吧！ Command Graphviz 的命令格式为 cmd [ flags ] [ input files ] 其中，cmd 可以是它包含的几个工具 dot 、 neato 、 circo 、 fdp 、 osage 、 sfdp 、 twopi ，我们可以查看 man 来看它们的区别，也可以直接运行看结果中的区别。 其中，flags 可以设置相关属性，比如 -Tformat ，如果我们需要产生 PNG 图片，那么这里就应该是 -Tpng ；再比如 -o 设置输出目的地。 所以我们上面 example1 的命令格式为 dot example1 . dot - Tpng - o exampl1 . png example2，example3，exampl4 同理。 Example 下面是实际程序中的一个例子： dot 脚本： digraph fsm { \"a\" -> \"a\" [ label = \"0/0\" ] \"a\" -> \"b\" [ label = \"1/0\" ] \"b\" -> \"c\" [ label = \"0/0\" ] \"b\" -> \"d\" [ label = \"1/0\" ] \"c\" -> \"a\" [ label = \"0/0\" ] \"c\" -> \"d\" [ label = \"1/0\" ] \"d\" -> \"e\" [ label = \"0/0\" ] \"d\" -> \"f\" [ label = \"1/1\" ] \"e\" -> \"a\" [ label = \"0/0\" ] \"e\" -> \"f\" [ label = \"1/1\" ] \"f\" -> \"f\" [ label = \"1/1\" ] \"f\" -> \"g\" [ label = \"0/0\" ] \"g\" -> \"a\" [ label = \"0/0\" ] \"g\" -> \"f\" [ label = \"1/1\" ] } 使用 dot 生成的结果： 使用 circo 生成的结果： Ref 使用 Graphviz 生成自动化系统图 Graphviz - 用指令來畫關係圖吧！ Graphviz 使用简介 ( 中文乱码的问题 ) 使用 DOT 來描述你的狀態機","tags":"IC","loc":"https://qiangu.cool/posts/ic/drawing_fsm_state_diagram_using_graphviz.html","title":"利用 Graphviz 画 FSM 状态图"},{"url":"https://qiangu.cool/posts/tools/doxygen_cpp_comment_style.html","text":"本文内容参考自网上博客内容 C++ 标准注释原则 - 基于 doxygen 的 C++ 注释 Doxygen C++ 注释规范及生成帮助文档配置步骤 Doxygen 详细介绍（三）（Doxygen 注释风格） 重新整理排版了一下。写本文的主要目的是备忘，当作快速参考来查。 Doxygen 若想用 Doxygen 生成漂亮的文档，我们必须在以下几个地方添加 Doxygen 风格的注释： 文件头（包括 头文件 .h 和 源文件 .cpp） 主要用于版权声明，描述本文件的功能，以及作者、版本信息等。 类的定义 主要用于描述类的功能，同时也可以包含使用方法、注意事项的 brief description。 类的成员变量定义 对该成员变量进行 brief description。 类的成员函数定义 对该成员函数的功能进行 brief description。 函数实现 对函数的功能、参数、返回值、需要注意的问题、相关说明等进行 detailed description。 C++ Comment Style Doxygen 支持多种注释风格，比如 JavaDoc-like 风格，Qt 风格等。在写 C++ 代码时，我们应该遵守 C++ 的行注释风格，所谓行注释风格，是指一般 C++ 程序员避免使用 C 风格的注释符号 /* */ ，而是使用 3 个连续的 / 作为注释的开头。除了这个区别之外，其他部分和 JavaDoc 风格类似： 一个对象的 brief description 用单行的 /// 开始，并且写在代码前面。一般 brief 写在头文件中，对象的声明之前。 一个对象的 detailed description 用多于两行的 /// 开始，并且写在代码前面。如果注释长度不足两行，第二行的开头仍要写出。一般 detailed 写在源文件中，对象的定义之前。 如果一段代码既是声明也是定义，则 brief 和 detailed 写在一起。使用 \\brief 命令，并且使用空行将两者分开。一般 brief 写在头文件中，对象的声明之前。 1 2 3 4 /// \\brief A brief description. /// /// A detailed description, it /// should be 2 line at least. 下面是代码模板： License 使用 DoxygenToolKit 自动生成的 Lisence 即可。 File header 1 2 3 4 5 6 7 8 /// \\file file_name.h /// \\brief Head file for class Ctest. /// /// A detailed file description. /// /// \\author author_name /// \\version version_number /// \\date xxxx-xx-xx Namespace namespace 的注释方式： 1 2 3 4 5 6 7 8 /// \\brief A brief namespace description. /// /// A detailed namespace description, it /// should be 2 lines at least. namespace test { } Class class 的定义和声明都在头文件中，所以使用下面这种 brief 和 detailed 结合的方式： 1 2 3 4 5 6 7 8 /// \\brief A brief class description. /// /// A detailed calss description, it /// should be 2 lines at least. class test { } member function 对于成员函数， 若是在头文件的声明处，使用 brief 若是在源文件的定义处，使用 detailed 若是在头文件处，声明和定义重合，使用 brief + detailed member variable 对于成员变量，在行末使用 ///< 。 Function brief: 单行的 /// 注释： 1 /// A brief function description. detailed: 至少两行 /// 的注释： 1 2 /// This is the detailed description, it /// should be 2 lines at least. 在 detailed description 中还可以添加一些 structural command ，常用的有 \\param 、 \\return 、 \\see 、 \\note 、 \\warning 等： 1 2 3 4 5 6 7 8 9 /// This is the detailed description, it /// should be 2 lines at least. /// /// \\param p1 Brief description for p1 /// \\param p2 Brief description for p2 /// \\return Brief description for return value /// \\note something to note. /// \\warning Warning. /// \\see See-also brief + detailed: 如果函数声明和定义重合，则 brief 和 detailed 合在一起，并且使用 \\brief 命令，格式如下： 1 2 3 4 5 6 7 8 9 /// \\brief A brief function description. /// /// A detailed description, it /// should be 2 lines at least. /// /// \\param p1 Description for p1. /// \\param p2 Description for p2. /// \\return Description for return value. bool test ( int n1 , char c1 ); 在 Doxgyen 的 manual 里面有： Unlike most other documentation systems, doxygen also allows you to put the documentation of members (including global functions) in front of the definition. This way the documentation can be placed in the source file instead of the header file. This keeps the header file compact, and allows the implementer of the members more direct access to the documentation. As a compromise the brief description could be placed before the declaration and the detailed description before the member definition. Doxygen 允许注释出现在对象的定义之前，所以我们可以将注释写在源文件中，而不是头文件中。这样做的好处是使头文件更加紧凑、代码的实现者阅读起来也更加直观。所以我们采用的方案是： 在函数声明前写 brief，在函数定义前写 detailed。 对于 inline 函数，使用 brief，尽量保持简洁，不要多于一行。 Variable 变量一般使用 ///< 方式即可： 1 2 int m_a ; ///< brief description for variable m_a double m_b ; ///< brief description for variable m_b 如果需要进行详细描述，则采用类似函数注释的方法（brief + detailed）： 1 2 3 4 5 /// \\brief A brief description. /// /// A detailed description, it /// should be 2 lines at least. float m_c ; Enum & Struct 类似于 Variable 的注释方式： 1 2 3 4 5 6 7 8 9 10 /// \\brief A brief description. /// /// A detailed description, it /// should be 2 lines at least. enum Tenum { em_1 ; ///< enum value em_1 em_2 ; ///< enum value em_2 em_3 ; ///< enum value em_3 } emVar ; ///< enum variable. Others TODO 命令： 1 2 /// \\todo Task1 to do /// \\todo Task2 to do BUG 命令： 1 2 /// \\bug Bug1 to be fixed /// \\bug Bug2 to be fixed P.S. 从网上找到一个 Doxygen for C 的示例： Doxygen usage example (for C) 里面有一些注释方法很有借鉴意义，可以当作模板来用。 P.P.S 又找到一份注释规范的文档，写的挺好，值得一看。 C++ 注释规范 Ref","tags":"Tools","loc":"https://qiangu.cool/posts/tools/doxygen_cpp_comment_style.html","title":"基于 Doxygen 的 C++ 注释风格"},{"url":"https://qiangu.cool/posts/tools/learning_vim_doxygentoolkit.html","text":"前面一篇博客 已经介绍过 Doxygen 了，Doxygen 的确是一个非常给力的工具，但是为了生成文档，我们必须在注释上花费很大的时间和精力。 那么问题又来了： 如何才能既享受 Doxygen 的强大功能，同时又避免大量的重复性的注释内容？ 解决思路： 让编辑器来替我们写那些格式和内容固定的部分，我们只负责写真正的有效内容。 所以，答案就是： Vim + DoxygenToolKit.vim 插件 DoxygenToolKit DoxygenToolKit 是 Vim 的一款插件，用它可以很方便地添加 Doxygen 风格的注释，可以节省大量时间和精力，提高写代码的效率。 DoxygenToolKit Official Website 官网上介绍，目前定义了 5 个功能： Generates a doxygen license comment. The tag text is configurable. Generates a doxygen author skeleton. The tag text is configurable. Generates a doxygen comment skeleton for a C, C++ or Python function or class, including @brief, @param (for each named argument), and @return. The tag text as well as a comment block header and footer are configurable. (Consequently, you can have \\brief, etc. if you wish, with little effort.) Ignore code fragment placed in a block defined by #ifdef ... #endif (C/C++). The block name must be given to the function. All of the corresponding blocks in all the file will be treated and placed in a new block DOX_SKIP_BLOCK (or any other name that you have configured). Then you have to update PREDEFINED value in your doxygen configuration file with correct block name. You also have to set ENABLE_PREPROCESSING to YES. Generate a doxygen group (begining and ending). The tag text is configurable. Installation 如果我们使用 Vundle 管理插件，安装步骤就非常简单了： 在 Vundle 中加入： Bundle 'DoxygenToolkit.vim' 打开 Vim，输入命令： : BundleInstall Vundle 会自动完成安装 :-D Configuration for c++ 我们有两种方法可以修改设置，方法一是直接在 DoxygenToolKit.vim 脚本文件中修改相关变量；方法二是在 ~/.vimrc 里面修改。显然方法二更加好一点，因为如果用方法一直接改原脚本，可能还得保存备份才能恢复默认值。 因为平时写的 C++ 程序比较多，所以针对 基于 Doxygen 的 C++ 注释风格 ，我们需要进行以下几步： 在 .vimrc 中我特别配置了以下命令： let g : DoxygenToolkit_briefTag_funcName = \" yes \" \" for C++ style, change the '@' to '\\' let g : DoxygenToolkit_commentType = \" C++ \" let g : DoxygenToolkit_briefTag_pre = \" \\\\ brief \" let g : DoxygenToolkit_templateParamTag_pre = \" \\\\ tparam \" let g : DoxygenToolkit_paramTag_pre = \" \\\\ param \" let g : DoxygenToolkit_returnTag = \" \\\\ return \" let g : DoxygenToolkit_throwTag_pre = \" \\\\ throw \" \" @exception is also valid let g : DoxygenToolkit_fileTag = \" \\\\ file \" let g : DoxygenToolkit_dateTag = \" \\\\ date \" let g : DoxygenToolkit_authorTag = \" \\\\ author \" let g : DoxygenToolkit_versionTag = \" \\\\ version \" let g : DoxygenToolkit_blockTag = \" \\\\ name \" let g : DoxygenToolkit_classTag = \" \\\\ class \" let g : DoxygenToolkit_authorName = \" Qian Gu, guqian110@gmail.com \" let g : doxygen_enhanced_color = 1 \" let g:load_doxygen_syntax = 1 即使前一步中设置了 C++ 风格，但是生成的 Lisence 仍然是 // ，而不是我们想要的 /// ，所以我们还需要修改原脚本（line 362~363）为： let g : DoxygenToolKit_startCommentBlock = \"/// \" let g : DoxygenToolKit_interCommentBlock = \"/// \" Usage 官网上也给出了使用方法： License 将光标放在需要生成 License 的地方，然后输入命令 :DoxLic Author 将光标放在合适的地方，然后输入命令 :DoxAuthor Function / Class 将光标放在 function 或者 class 的名字所在的一行，然后输入命令 :Dox Ignore code fragment (C/C++ Only) 如果想忽略调试部分的代码，那么只需要执行命令 :DoxUndoc(DEBUG) 即可 Group 输入命令 DoxBlock 来插入一个注释块 为了方便使用，我们可以自定义一些 map，省去输入命令的繁琐。 Example 同样是官网上的例子： 假设有个函数如下 1 2 3 4 5 6 7 int foo ( char mychar , int myint , double * myarray , int mask = DEFAULT ) { //... } 那么执行 :Dox 命令之后会生成以下内容 1 2 3 4 5 6 7 8 9 10 /** * @brief * * @param mychar * @param myint * @param myarray * @param mask * * @return */ Ref DoxygenToolKit.vim","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_doxygentoolkit.html","title":"学习 Vim 插件 DoxygenToolKit.vim"},{"url":"https://qiangu.cool/posts/tools/how_to_analyse_code_elegantly.html","text":"当我们来接手一个别人的工程时，阅读别人的代码是一件很痛苦的事。成千上百的函数，糟糕的代码风格，不知所云的注释，这些都是让人抓狂。那么，问题就来了： 如何优雅地分析别人的代码？ 答案就是： Doxygen + Graphviz 整个工作流程很简单，我们在写程序时按照 Doxygen 约定的格式注释代码（不注释也可以），Doxygen 会对代码进行分析，然后列出程序中的变量、类定义、数据结构、函数表用关系等，然后调用 Graphviz 将结果用图形化的形式表现出来。 这个功能在自动生成文档、代码分析时非常强大，下面分别简单介绍一下。 P.S. 在 Linux 环境下，Vim 有插件 DoxygenToolKIt.vim 可以帮助我们很方便地写出 Doxygen 风格的代码。这里只介绍 Doxygen + Graphviz，DoxygenToolKit.vim 在另外一篇中介绍。 Graphviz What is Graphviz? Graphviz official website : Graphviz is open source graph visualization software. Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. It has important applications in networking, bioinformatics, software engineering, database and web design, machine learning, and in visual interfaces for other technical domains. Installation 官方网站上有各个平台（Windows/Unix/Linnux/Mac）的安装文件和源码，在 Ubuntu 13.10 saucy 下，直接使用 apt-get 安装即可： sudo apt - get install graphviz More 更多详细的介绍见官网的 About、Documentation、Wiki、FAQ。 Doxygen What is Doxygen Doxygen Official website : Doxygen is the de facto standard tool for generating documentation from annotated C++ sources, but it also supports other popular programming languages such as C, Objective-C, C#, PHP, Java, Python, IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL, Tcl, and to some extent D. 简而言之，Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。只要我们在写注释的时候按照它制定的规则写，那么它就可以为我们生成漂亮的文档。 Installation 官网上的 Manual 中有详细的介绍，对于不同平台，采用不同的安装方式（从源码编译安装、二进制文件安装），下面仅记录我在 Ubuntu 下使用源码编码的方式安装过程。 下载源代码 git clone https : // github . com / doxygen / doxygen . git cd doxygen 安装 . / configure make make install 安装成功之后，在 /usr/bin/ 或者 /usr/local/bin 目录下可以查看到二进制 doxygen 文件。 P.S. 若 configure 出错，检查依赖关系，安装需要系统中有 GNU 工具（flex, bison, libiconv and GNU make, and strip）和 Perl 支持。 因为 Doxygen 要调用 Graphviz，所以先安装 Graphviz，然后编译安装 Doxygen Getting Started Getting Started : 检查 Doxygen 是否支持你项目所使用的语言 Doxygen 支持 C, C++, C#, Objective-C, IDL, Java, VHDL, PHP, Python, Tcl, Fortran, D 创建一个配置文件 Doxygen 使用一个配置文件来工作，，每个项目都应该有一个自己对应的配置文件。我们可以使用 doxygen -g 来让 Doxygen 自动生成一个参考配置文件，然后修改其中个别配置即可 . doxygen - g < config - file > 常用配置： PROJECT_NAME = \"Test Project\" 配置项目名称 PROJECT_NUMBER = 1.0 配置项目版本号 OUTPUT_DIRECTORY = ./doxygen-output 配置输出结果目录 OPTIMIZE_OUTPUT_FOR_C = YES 设置针对哪种语言进行优化 EXTRACT_ALL = YES 默认是 NO ，即默认只对有标准注释的文件进行分析。如果我们希望对一个没有按照标准格式注释的项目进行分析，那么就要改为 YES ，这在接手一个旧项目，分析代码时尤其有效。 HAVE_DOT = YES 设置 Doxygen 调用 dot 工具（graphviz 的一部分） DOT_PATH = /usr/local/graphviz 指定 graphviz 的路径 运行 Doxygen doxygen < config - file > 如果前一步没有指定配置文件的名字的话，直接运行 doxygen 即可。 运行完之后，就可以在指定的输出目录中看到结果，用浏览器可以看到 HTML 版本的结果。 按照 Doxygen 格式注释代码 这一步应该在最前面，即先按照 Doxygen 风格格式注释好代码，然后再进行分析。官网上针对不同的编程语言，有详细的举例说明： Documenting the code Documenting the code 这部分虽然在最后，事实上应该是第一步，也就是说我们先按照规定添加 Doxygen 风格的注释，然后再配置、调用 Doxygen 来生成文档。 Doxygen 官网 上有详细的注释 格式说明 ，下面是我搬运来学习，自己翻译的。 我们在 C/C++ 风格注释块中加入一些特殊符号，这样 Doxygen 就知道需要把这段注释分析生成在文档中，这样的注释在官网中叫做 Special comment blocks 。下面详细介绍类 C/C++ 语言（C/C++/C#/Objective-C/PHP/Java）的注释，其他语言（Python, VHDL, Fortran, Tcl）见官网。 对于代码中的任何实体（ entity ），都有两种注释，它们一起工作，完成注释功能，但至少得有一个： a brief description ：单行的简短注释 a detailed description ：多行的详细注释 对于 方法 methods 和 函数 functions ，还有额外的第三种注释： in body description 对于详细注释（detailed description），可以用以下的几种风格来进行： JavaDoc Style 即在 C 风格注释块开始使用两个星号 * ： /** * ... text ... */ Qt Style 即在 C 风格注释块开始处添加一个叹号 ! ： /*! * ... text ... */ C++ Comment Style 使用连续两个以上的 C++ 注释行组成注释块，并且每行要多写一个 / 或者 ! ： /// /// ... text ... /// or //! //! ... text ... //! 第四种格式，有的人喜欢让自己的注释更加醒目一些： ///////////////////////////////////////////////// /// ... text ... ///////////////////////////////////////////////// 对于简单注释（brief description），也有以下的几种方案： 可以选用以上其中一种风格，然后加入 \\brief 命令来标明 brief 的开始。这种方式以段落的结尾作为结束。所以在 brief 后要写 detailed 的话，需要空一行。 /* \\brief Brief description. * Brief description continued. * * Detailed description starts here. */ 如果选择 JavaDoc 的风格，并且在配置文件中设置 JAVADOC_AUTOBRIEF = YES 的话，Doxygen 会自动将第一句话作为 brief description，这个句子以 . + 空格 / 空行 结束。 /** Brief description which ends at this dot. Details follow * here. */ 这种方式对多行的 C++ 特殊注释风格也有效： /// Brief description which ends at this dot . Details follow /// here . 第三种方法是使用不多于一行的特殊 C++ 风格注释，下面是两个例子： /// Brief description . /** Detailed description. */ 或者：（这种情况下，必须用空行把 brief 和 detailed 分开，同时 JAVADOC_AUTOBRIEF = NO ） //! Brief description . //! Detailed description //! starts here . Doxygen 和其他的文档系统的一个不同之处就是它允许把注释写在实体的定义（包括全局函数）之前。这样，就可以把注释直接写在源文件里面而不是头文件中，从而使头文件更加紧凑，而且功能的实现人员也更容易阅读注释。 所以，一个折衷方案就是在声明前写 brief description，在定义前写 detailed description。 Putting documentation after members 在注释结构体、类、枚举类型等时，有时习惯将注释写在代码的后面，而不是前面。因为 Doxygen 默认注释是解释后面的代码，所以这时候就需要在注释中添加一个额外的 < 来标明是注释前面的内容。 example： Qt 风格的注释： int var ; /*!< Detailed description after the member */ 或者： int var ; /**< Detailed description after the member */ 或者： int var ; //!< Detailed description after the member //!< 一般来说，我们通常在后面添加的注释都是 brief description 而不是 detailed description，所以更常见的格式如下： int var ; //!< Brief description after the member 或者： int var ; ///< Brief description after the member Warning: 这种添加 < 的方法只能用在 成员（ member ）和 参数（ parameter ）中，不能用在描述文件、类、联合体、名字空间和枚举本身。此外 , 在后面提到的结构化命令（如 \\class ）在这种注释段中是无效的。 Examples 官网上提供了一个例子，分别用 Qt 和 JavaDoc 的风格注释一段相同的 C++ 代码： Qt style: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //! A test class. /*! A more elaborate class description. */ class Test { public : //! An enum. /*! More detailed enum description. */ enum TEnum { TVal1 , /*!< Enum value TVal1. */ TVal2 , /*!< Enum value TVal2. */ TVal3 /*!< Enum value TVal3. */ } //! Enum pointer. /*! Details. */ * enumPtr , //! Enum variable. /*! Details. */ enumVar ; //! A constructor. /*! A more elaborate description of the constructor. */ Test (); //! A destructor. /*! A more elaborate description of the destructor. */ ~ Test (); //! A normal member taking two arguments and returning an integer value. /*! \\param a an integer argument. \\param s a constant character pointer. \\return The test results \\sa Test(), ~Test(), testMeToo() and publicVar() */ int testMe ( int a , const char * s ); //! A pure virtual member. /*! \\sa testMe() \\param c1 the first argument. \\param c2 the second argument. */ virtual void testMeToo ( char c1 , char c2 ) = 0 ; //! A public variable. /*! Details. */ int publicVar ; //! A function variable. /*! Details. */ int ( * handler )( int a , int b ); }; 生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/qtstyle/html/class_test.html JavaDoc style: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * A test class. A more elaborate class description. */ class Test { public : /** * An enum. * More detailed enum description. */ enum TEnum { TVal1 , /**< enum value TVal1. */ TVal2 , /**< enum value TVal2. */ TVal3 /**< enum value TVal3. */ } * enumPtr , /**< enum pointer. Details. */ enumVar ; /**< enum variable. Details. */ /** * A constructor. * A more elaborate description of the constructor. */ Test (); /** * A destructor. * A more elaborate description of the destructor. */ ~ Test (); /** * a normal member taking two arguments and returning an integer value. * @param a an integer argument. * @param s a constant character pointer. * @see Test() * @see ~Test() * @see testMeToo() * @see publicVar() * @return The test results */ int testMe ( int a , const char * s ); /** * A pure virtual member. * @see testMe() * @param c1 the first argument. * @param c2 the second argument. */ virtual void testMeToo ( char c1 , char c2 ) = 0 ; /** * a public variable. * Details. */ int publicVar ; /** * a function variable. * Details. */ int ( * handler )( int a , int b ); }; 生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/jdstyle/html/class_test.html Documentation at other places 我们之前的例子中注释都是在文件、命名空间、类的声明或者定义之前，或者在它们的成员的前 / 后。虽然一般来说这是很正常的，但是有时候我们需要把代码写在在文档的其他地方。对于文件的注释更是如此，因为对于文件来说，根本就不存在在它之前的地方（\"in front of a file\"）。 Doxygen 允许你把注释写在任何地方（例外情况是在函数体内 or 在 C 风格注释块内）。你需要付出的代价就是要在注释块内部多写一些结构化命令（ structural command ）来标明。所以， 一般来说，我们应该尽量避免使用结构化命令，除非是有其他的特殊要求这样做。 结构化命令以一个 \\ 或者 @ （JavaDoc 风格）开始，后面接一个命令名字 + 一个（多个）参数。举例如下： /*! \\class Test \\brief A test class. A more detailed class description. */ 这个例子中的 \\class 指示这个注释块中包含一个 Test 类的文档。其他常用的命名如下： \\structure \\union emun fn var def \\typedef \\file \\namespace \\package \\interface 完整的命令和说明在这里： special commands 对 C++ 类成员进行注释的时候，必须先注释这个类，对于命名空间来说也是如此。对 C 的全局函数、 typedef、enum、 preprocessor definition 进行注释，必须先注释包含它们的文件（通常是头文件）。 Attention: 在重复一下容易出错的地方： 在注释全局对象时，必须先注释它们所在的文件。 也就是说，必须包含以下两者之一： /* \\file */ 或者 /* @file */ 下面是官网上的一个 C 头文件的例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /*! \\file structcmd.h \\brief A Documented file. Details. */ /*! \\def MAX(a,b) \\brief A macro that returns the maximum of \\a a and \\a b. Details. */ /*! \\var typedef unsigned int UINT32 \\brief A type definition for a . Details. */ /*! \\var int errno \\brief Contains the last error code. \\warning Not thread safe! */ /*! \\fn int open(const char *pathname,int flags) \\brief Opens a file descriptor. \\param pathname The name of the descriptor. \\param flags Opening flags. */ /*! \\fn int close(int fd) \\brief Closes the file descriptor \\a fd. \\param fd The descriptor to close. */ /*! \\fn size_t write(int fd,const char *buf, size_t count) \\brief Writes \\a count bytes from \\a buf to the filedescriptor \\a fd. \\param fd The descriptor to write to. \\param buf The data buffer to write. \\param count The number of bytes to write. */ /*! \\fn int read(int fd,char *buf,size_t count) \\brief Read bytes from a file descriptor. \\param fd The descriptor to read from. \\param buf The buffer to read into. \\param count The number of bytes to read. */ #define MAX(a,b) (((a)>(b))?(a):(b)) typedef unsigned int UINT32 ; int errno ; int open ( const char * , int ); int close ( int ); size_t write ( int , const char * , size_t ); int read ( int , char * , size_t ); 上面这个例子中的每个注释块都包含了一条结构化命令，所以这些注释可以放在文件的其他位置或者放在其他文件中，不会影响到最终生成的文档。这种方法的坏处在于我们实际上写了两遍原型，当做修改时我们必须同时修改代码和注释。因此，我们在使用前应该仔细考虑是否真的需要结构化命令，并且尽可能避免使用它。一个常见的现象就是在函数前的注释块中包含了 \\fn 命令，显然这是冗余的，除了导致错误，这个命令毫无作用。 如果我们对以 .dox, .txt, .doc 结尾的文件注释，那么 Doxygen 会自动忽略这些文件。 如果我们有一个 Doxygen 无法解析的文件，但是仍然像注释它，那么就使用 \\verbinclude 这个命令： /*! \\file myscript.sh * Look at this nice srcipt. * \\verbinlcude mycript.sh */ 还要确定在配置文件中 INPUT 变量显式地说明这个脚本文件，或者 FILE_PATTERNS 变量必须包含 .sh 文件扩展名并且可以通过 EXAMPLE_PATH 变量寻找到这个文件。 Anatomy of a comment block 前面介绍了如何对代码进行注释，并且讨论了两种不同的注释：brief 和 detailed，还讨论了如何使用结构化命令。 下面我们分析注释块本身。 Doxygen 支持很多种格式的注释，最简单的就是文本文件，适用于比较短的注释。对于比较长的注释，我们需要清单、表格等更加结构化的元素，对于这种情况，Doxygen 支持 Markdown 语法，可以直接读取 Markdown 文件，详细内容看这里： Markdown Support 。 (Markdown 源自邮件的文本格式，语法非常简洁，并且功能很强大，这篇文章本书就是用 Markdown 语法写的，语法细节见官网，这里不再赘述。) P.S. 找到一篇博客，详细介绍了基于 Doxygen 的 C++ 注释风格： C++ 标准注释原则 - 基于 doxygen 的 C++ 注释 最后展示一张我的效果图： Ref. linux doxygen 的安装和使用 Doxygen Graphviz doxygen 使用简介（C,C++ 为代码作注释）","tags":"Tools","loc":"https://qiangu.cool/posts/tools/how_to_analyse_code_elegantly.html","title":"如何优雅的分析代码"},{"url":"https://qiangu.cool/posts/telecom/tail_bitting_convolutional_code_implementation_in_matlab_and_c_and_fpga.html","text":"Tail Bitting 咬尾卷积编码是一种特殊的卷积编码，它通过将编码器的移位寄存器的初始值设置为输入流的尾比特值，使得移位寄存器的初始和最终状态相同。和普通的卷积编码相比，咬尾的方案最大的优点是克服了编码时的码率损失，并且适合迭代译码，不过付出的代价是译码复杂度的增加。在 LTE 的标准中，咬尾卷积编码是一种备选的信道编码方案。 通常以 (n, k, K) 来描述卷积编码，其中： k 表示编码器的 输入码元数 n 表示编码器的 输出码元数 K 表示编码器的 约束长度 由输入的 k 个信息比特，得到 n 个编码结果，所以 编码效率 = k/n 约束长度 K 的意思是，编码结果不仅取决于当前输入的 k 比特信息，还取决于前 (K-1) 段时间内的信息位。在 k = 1 的条件下，编码器需要的 移位寄存器级数 m = K - 1。 LTE 标准中编码器的结构如下图所示： 假设输入的比特流为 c1, c2, c3, ... 得到的编码结果为 d1, d2, d3, ... 其中移位寄存器 D 从左到右一次是 S0, S1, ... S5。对其初始化时，S0 = Ck-1, S1 = Ck-2, ... S5 = Ck-6。 进行编码时，有抽头的寄存器之间进行模 2 加法（即异或）运算。每次对一个输入信息完成编码之后，移位寄存器右移一位，抛弃最右端的移位结果，采用前一个输入作为最左端的信息位。 当最后的比特进行编码完之后，寄存器又回到了设定的初始状态，就像一条蛇咬住了自己的尾巴，所以称为 咬尾 Tail Bitting。 图中的 G1，G2, G3 是 生成式 。 以上的内容已经提供了足够的信息供我们实现，关于更多的卷积编码、LTE 标准等请查阅 wiki 和专业书籍。 Matlab Implementation Matlab 的 Communications System Toolbox 中提供了大量的常用函数，其中就有卷积编码函数 convenc 。我们就是基于这个函数实现 LTE 中的咬尾卷积编码。 通过 help convenc 和 hlep browser，可以查到这个函数的用法，简单解释如下 : convenc 函数有几种方式来调用： CODE = convenc ( MSG , TRELLIS ) CODE = convenc ( MSG , TRELLIS , PUNCPAT ) CODE = convenc (..., INIT_STATE ) 第一个参数 MSG 是待编码的信息比特 第二个参数 TRELLIS 是编码器的栅格描述 TRELLIS 是 Matlab 内部定义的一种数据结构，它的值可以按照语法定义，更方便的方法是通过 poly2trellis 这个函数，由多项式描述方式转化得到。 查阅 poly2trellis 的 help 就可以看到它的用法。 trellis = poly2trellis ( ConstraintLength , CodeGenerator ) 其中， ConstraintLength 是个 1×k 维的向量，表示编码器的约束长度； CodeGenerator 是个 k×n 维的向量，表示编码器中各个寄存器的抽头。 help 中以一个 2/3 码率的编码器为例，其结构如下图所示： 两组寄存器的长度分别为 4 和 3，所以 constraintlength 的取值为 [5, 4]；将每路输出的抽头用 8 进制来表示，即可得到 codegenerator 的取值 [27, 33, 0; 0, 5, 13]，表示第一路输出由第一组寄存器的 27 组合方式 + 第二组寄存器的 0 组合方式得到，第二路输出由第一组寄存器的 33 组合方式 + 第二组寄存器的 5 组合方式得到，第三路同理。 应用到我们的编码器中，很容易写出其栅格描述 tre = poly2trellis ( 7 , [ 133 , 171 , 165 ]); 第三个参数 INIT_STATE 是移位寄存器的初始值 INIT_STATE 用来设定寄存器的初始状态，其取值就是寄存器的值。 在下面的程序中，我们的测试向量的最后 6 bit 为 010110，所以对应的 init = 22 ; 综上，可以写出 matlab 程序来实现咬尾卷积编码，如下： 1 2 3 4 5 6 7 8 9 clear ; % using a to test coder a = [ 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 ]; % describe the coder tre = poly2trellis ( 7 , [ 133 , 171 , 165 ]); % init state is depend on a init = 22 ; % encode b = convenc ( a , tre , init ); 得到的编码结果是： 0 1 0 1 0 1 1 1 0 0 1 1 0 1 1 1 0 0 1 1 0 1 0 0 数据的格式是将 3 位并行结果串行输出： d00, d01, d02, d10, d11, d12, ... C Implementation C 的实现很简单 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void encode_signal ( int * coded_bits , int * origin_bits , int origin_bits_len ) { int * LSR = ( int * ) malloc ( sizeof ( int ) * 6 ); // initialize the LSR for ( int i = 0 ; i < 6 ; ++ i ) { LSR [ i ] = origin_bits [ origin_bits_len - 1 - i ]; } for ( int i = 0 ; i < origin_bits_len ; ++ i ) { coded_bits [ i * 3 ] = origin_bits [ i ] &#94; LSR [ 1 ] &#94; LSR [ 2 ] &#94; LSR [ 4 ] &#94; LSR [ 5 ]; coded_bits [ i * 3 + 1 ] = origin_bits [ i ] &#94; LSR [ 0 ] &#94; LSR [ 1 ] &#94; LSR [ 2 ] &#94; LSR [ 5 ]; coded_bits [ i * 3 + 2 ] = origin_bits [ i ] &#94; LSR [ 0 ] &#94; LSR [ 1 ] &#94; LSR [ 3 ] &#94; LSR [ 5 ]; // shift the regs for ( int j = 5 ; j > 0 ; -- j ) { LSR [ j ] = LSR [ j - 1 ]; } LSR [ 0 ] = origin_bits [ i ]; } free ( LSR ); } Verlog Implementation 用 verilog 来实现编码器就相对简单直观的多，毕竟只有一组移位寄存器和一些抽头的异或运算。 module & testbench module testbench simulation 如下图所示 和 matlab 中结果对比，结果是一致的。 Summary 一个简单的咬尾卷积编码花费了一上午的时间才搞定，最大的收获就是：心态很重要，欲速则不达。没有认真看 help 就写程序，本来想节省时间，结果却相反 =.= 戒骄戒躁！！！ Reference 通信原理 无线通信新协议与新算法","tags":"Telecom","loc":"https://qiangu.cool/posts/telecom/tail_bitting_convolutional_code_implementation_in_matlab_and_c_and_fpga.html","title":"LTE 咬尾卷积编码器的 Matlab 、C 语言及 FPGA 实现"},{"url":"https://qiangu.cool/posts/ic/delay_in_fpgas.html","text":"Delay in circuits 从模拟电路的知识，我们可以知道 电路中存在很多类型不同的延时。 比如： propagation delay 我们通常假设信号在电平之间变化时瞬间完成的，但是实际情况并不是瞬间完成，电路需要花费一段时间才能完成电平的转化。晶体管的开关特性对于不同的变化有不同的表现： 上升延时 ( rising delay )，输出变为 1 下降延时 ( falling delay )，输出变为 0 关闭延时 ( turn-off delay )，输出变为高阻 Z 输出变为 X 的时延 原因就是（ Digital Design (Verilog): An Embedded Systems Approach Using Verilog ）： One factor that causes signal changes to occur over a nonzero time interval is the fact that the switches in the output stage of a digital component, illustrated in Figure 1.15, do not open or close instantaneously. Rather, their resistance changes between near zero and a very large value over some time interval. However, a more significant factor, especially in CMOS circuits, is the fact that logic gates have a significant amount of capacitance at each input. 这个答案也解释了为什么在设计中要避免大扇出信号：因为大扇出意味着输出端并联着很多电容，电容负载较大时造成连接信号转换相对较慢的原因。 The total capacitive load is thus the sum of the individual capacitive loads. The effect is to make transitions on the connecting signal correspondingly slower. For CMOS components, this effect is much more significant than the static load of component inputs. 我们可以把对晶体管的讨论推广到其他的数字元件： A similar argument regarding time taken to switch transistors on and off and to charge and discharge capacitance also applies within a digital component. Without going into the details of a component's circuit, we can summarize the argument by saying that, due to the switching time of the internal transistors, it takes some time for a change of logic level at an input to cause a corresponding change at the output. We call that time the propagation delay , denoted by tpd , of the component. wire delay 另外一种延时是信号在导线上传播时产生的延时，一般我们都把这种延时假设也 0，也就是说导线时理想的导体，信号经由导线的传输没有任何延迟。如果导线很短，或者芯片上不超过 1mm 的导线来说，这种假设是合理的。但是当设计高速电路时，不能忽略这种导线存在的寄生电容和电感，这时候导线应该被视为传输线，必须精心设计。 至于如何设计应该属于模拟电路的部分，这里不讨论。 关于上面的两种延时， FPGA-Based System Design 里面有详细讨论如何建模、如何计算具体时延的值。 即使对于同一种信号跳变，延时也分为不同的类型： 最小值 ( minimum ) 典型值 ( typical ) 最大值 ( maximum ) Models in Verilog HDL 为了对电路中的时延现象进行建模，Verilog HDL 定义了延时语法。 对于上升、下降、关闭时延，可以使用逗号按照顺序将三者分开： 1 2 assign #( 1 , 2 ) A_xor_wire = eq0 &#94; eq1 ; assign #( 1 , 2 , 3 ) A_xor_wire = eq0 &#94; eq1 ; 第一句表示一个异或门上升时延为 1，下降时延为 2，关闭和 X 时延为两者中的最小值，即 1； 第二句表示一个异或门的上升、下降、关闭时延分别是 1，2，3，X 时延为 3 者中的最小值，即 1。 对于最小值、典型值、最大值可以使用分号按照 min:typ:max 的顺序，将 3 者分开： 1 assgin #( 2 : 3 : 4 , 3 : 4 : 5 ) A_xor_wire = eq0 &#94; eq1 ; 表示上升时延的 min:typ:max = 2:3:4，下降时延的 min:typ:max = 3:4:5。 需要注意到一点是， 当延时出现在 wire 信号的定义处时，会和普通的赋值语句中的延时稍有不同。 1 wire # 10 wireA ; 这个叫做 net delay ，它是和 wireA 绑定的，对 wireA 进行的任何赋值必须延迟 10 个时间单位之后才有效。当在连续赋值语句中，延时是属于连续赋值语句的一部分，而不属于 net，所以只在这一句中有效，对其他赋值语句没有影响。 一般来说，assign 语句中的延时特性会被综合工具忽略。 因为综合工具需要完成的功能就是将代码描述映射为逻辑电路，而逻辑电路中的延时是由最基本的单元库和走线延时决定的，用户是无法对逻辑单元指定延时长度的，只能在综合、实现时添加时序约束条件，使工具尽量满足要求。 Implement Verilog HDL 中的延时语法不可综合并不代表就不能在实际电路中实现延时。 在实际电路中，不同的情况下需要采用不同的方法来实现延时：一般来说，异步电路的时延通过门延时来完成，比较难预测，而同步电路的时延通过触发器或者计数器来实现。 in ASICs 在早期的逻辑电路图设计阶段，有且设计者养成了手工加入 Buffer 或者非门调整数据 延时的习惯，以保证本级模块的时钟对上级模块数据的建立及保持时间的要求。这些做法目 前主要应用于两种场合： 分离电路 使用分立逻辑单元（如 74 系列）搭建数字电路一般为复杂度比较低、系统灵活性比较低的场合。使用分立元件时，由于可以使用的元件比较少，而且一般设计频率比较低，时序裕量比较大，所以采用 Buffer、非门等单元来调整时延时可以接受的。 ASIC 领域 在 ASIC 中采用这种方法，是以严格的仿真和时序约束为前提的。 in FPGAs 在 ASIC 中采用的添加 Buffer、非门的设计方法并不适合 FPGA/CPLD 等可编程逻辑，在 FPGA 中应该尽量避免这种设计。 The Art of Hardware Architecture ： Delay chains occur when two or more consecutive nodes with a single fan-in and a single fan-out are used to cause delay. Often inverters are chained together to add delay. Delay chains generally result from asynchronous design practices, and are sometimes used to resolve race conditions created by other combinational logic. In both FPGA and ASIC, delays can change with each place-and-route. Delay chains can cause various design problems, including an increase in a design's sensitivity to operating conditions, a decrease in a design's reliability, and difficulties when migrating to different device architecture. Avoid using delay chains in a design, rely on synchronous practices instead. 总结下来主要就是 3 个原因： 设计的可靠度低 Buffer、非门都是组合逻辑，组合逻辑最大的问题就是容易出现毛刺，电路可靠度不高，这种方法的时序裕量小，对环境敏感（特别是温度），一旦外界环境发生变化，时序可能就会完全紊乱、导致电路瘫痪。 设计的移植难度大 一旦芯片换代，或者需要将设计移植到不同的器件上时，就必须对延时进行重新调整，电路的可维护性和扩展性差。 信号通过多级非门时，综合器可能会将其优化掉。 虽然可以在代码中添加约束，防止综合器将其优化掉，但是不推荐这种方法，理由见前两条。 Xilinx FPGA 高级设计及应用 介绍了 FPGA 中应该采用的方法： 专门的延时器件 在 FPGA/CPLD 内部延时电路结构由一种标准的宏单元描述。虽然各家芯片的宏单元描述不同，但总的来说都是 一些逻辑 + 一个 / 两个触发器构成 。 Altera FPGA 中可以对信号加一个或多个 LCELL 来产生一个延时。（Xilinx 的没有查到 ...） 虽然厂家提供了延时单元，但是这种延时并不稳定，会随着外界环境（比如温度）的变化而变化，所以并不提倡这种方法。 网上有人讨论这种方法的应用： fpga 内部的延时单元 触发器 or 计数器 如果延时相对较小，可以使用高频时钟来驱动一个移位寄存器，将待延时的信号当作输入，按照需要的延时来设置移位寄存器的级数，最后的输出即延时的结果。 如果延时相对较大，可以使用计数器来延时输出。 ====================== Update 01/31/2015 ======================== Simulation 我们知道，仿真器使用 \" 事件 \" ( event ) 来模拟实际的电路行为，但是毕竟软件和硬件还是不同的，而 Verilog 语言又是很灵活的，如果不加注意，很可能不能对电路进行正确的建模。Clifford E. Cummings 大神写了一篇 paper 介绍了 Verilog HDL 中应该如何正确使用延时，才能保证建模的正确性： Correct Methods For Adding Delays To Verilog Behavioral Models 下面我的笔记，摘录一部分内容和结论： 要讨论正确的延时的代码风格，首先要了解仿真器在对延时进行建模时，通常使用的两种不同类型的 Delay 模型： Inertial delay 模型 惯性时延，专门描述一些特殊信号传播到输出端口所耗费的时延，这部分信号特殊在于：输入信号必须保持稳定一段时间（等于或大于传播时延）。如果输入信号的变化时间间隔小于过程赋值延时 / 连续赋值延时 / 门延时（也就是说在计算出一个结果并且还没有来得及输出，输入信号又发生了变化），那么前一时刻值的旧事件会被新值的事件代替，重新触发计算，并输出。 Transport delay 模型 传播时延，用来描述当任何一个输入信号一旦发生变化后，所有信号到输出的延时。所有的输出变化值会按照顺序排队输出。 有了上面两个延时的概念之后，我们就可以分类讨论下面三种情况下应该如何添加延时了。 Blocking assignment 在阻塞赋值中，通常添加延时的方法有两种： left-hand-side 1 # 5 y = ~ a ; right-hand-side 1 y = # 5 ~ a ; 但是这两种方法都有可能存在问题： 以描述一个输出延迟为 12ns 的加法器，如果我们在左边添加延时， 1 2 always @( a or b or ci ) # 12 { co , sum } = a + b + ci ; 在下图时序中可以看到，当 t = 15 时，a 发生变化，触发 always 块，模块计算新的求和结果。但是，在接下来的 t = 15 ~ 24 内，a、b、ci 分别发生了变化，所以当从触发开始，到 12ns 过后该输出结果时，计算结果的值使用的是当前最新的值（可以看到，ci 的变化和输出之间仅仅有 3ns < 12ns），而非触发时刻的值。 事实上，在任何阻塞赋值的左边添加延时都会存在类似的问题。 Modeling Guideline: do not place delays on the LHS of blocking assignments to model combinational logic. This is a bad coding style. Testbench Guideline: placing delays on the LHS of blocking assignments in a testbench is reasonable since the delay is just being used to time-space sequential input stimuls events. 如果我们在右边添加延时，同样也会有问题。 1 2 always @( a or b or ci ) { ci , sum } = # 12 a + b + ci ; 假设在 t = 15 时刻，a 发生变化，触发 always 块，模块会对当前的值进行采样，并且在 12ns 之后将采样结果输出，而在这 12ns 期间，输入端的任何变化都会被忽略，这意味着错误的旧值会一直保持下去，直到有新的变化重新触发。 Modeling Guideline: do not place delays on the RHS of blocking assignments to model combinational logic. This is a bad coding style. Testbench Guideline: do not place delays on the RHS of blocking assignments in a testbench. General Guideline: placing a delay on the RHS of any blocking assignment is both confusing and a poor coding style. This Verilog coding practice should be avoided. Non-blocking assignment 在非阻塞赋值中，同样有两种方法来添加延时： left-hand-side 1 # 5 y <= ~ a ; right-hand-side 1 y <= # 5 ~ a ; 仍然使用上面加法器的例子，如果我们在左边添加延时，会和阻塞赋值存在一样的问题： 1 2 always @( a or b or ci ) # 12 { co , sum } <= a + b + ci ; 当 t = 15 时，触发 always 块，但是输出时结果时，使用的是最新时刻的值。 事实上，在任何非阻塞赋值的左边添加延时都会存在类似的问题。 Modeling Guideline: do not place delays on the LHS of nonblocking assignments to model combinational logic. This is a bad coding style. Testbench Guideline: nonblocking assignments are less efficient to simulate than blocking assignments; therefore, in general, placing delays on the LHS of nonblocking assignments for either modeling or testbench generation is discouraged. 在非阻塞赋值的右边添加延时，会准确地描述前面介绍的 transport delays ： 1 2 always @( a or b or ci ) { co , sum } <= # 12 a + b + ci ; 当 t = 15 时刻，a 发生变化触发 always 块，此时会立刻对输入进行采样，然后等待 12ns 之后输出；在将这一时间存放在时间队列之后，always 块会被下一个变化时间重新触发，这意味着输出会随着输入的变化在 12ns 之后变化，如下图所示： Recommended Application: Use this coding style to model behavioral delay-line logic. Modeling Guideline: place delays on the RHS of nonblocking assignments only when trying to model transport output-prapagation behavior. This coding style will accurately model delay lines and combinational logic with pure transport delays ; however, this coding style generally causes slower simulations. Testbench Guideline: This coding style is ofen used in testbenches when stimulus must be scheduled on future clock edges or after a set delay, while not blocking the assignment of subsequent stimulus events in the same procedural blocks, Modeling Guideline: in general, do not place delays on the RHS of nonblocking assignments to model combinational logic . This coding style can be confusing and is not very simulation efficient. It is a common and sometimes useful practice to palce delays n the RHS of nonblocking assignments to model clock-to-output behavior on sequential logic . Testbench Guideline: there are some multi-clock design verification suites that benefit from using multiple nonblocking assignments with RHS delays; however, this coding style can be confusing, therefore placing delays on the RHS of nonblocking assignments in testbenches is not generally recommended. Continuous assignment 连续赋值语句中，只能在左侧添加延时，在右边添加延时是非法的： 1 assign # 5 y = ~ a ; 在连续赋值语句的左边添加延时，会准确描述惯性延时（ inertial delay ），一般推荐使用这种方式。 以上面的加法器为例： 1 assign # 12 { co , sum } = a + b + ci ; 如下图，在 t = 15 时刻，a 发生变化触发 assign 语句，应该在 t = 27 时刻输出结果，但是在 t = 17, 19, 21 时刻，a，b 分别发生了变化，这会导致有 3 个新的值，最终会只输出最后一个值（在 t = 21 + 12 = 33 时刻）。 因为连续赋值语句不会排队输出这个概念，它只会跟踪输出结果，所以，连续赋值语句中的延时是对惯性延时（ inertial delay ）的建模。 混合方式：无延时的 always 块 + 连续赋值语句 1 2 3 4 always @( a or b or ci ) tmp = a + b + c ; assign # 12 { co , sum } = tmp ; 仍然会准确描述组合逻辑中的 inertial delay。在每个输入变化时，tmp 的值都会改变，在 tmp 改变的 12ns 之后，连续赋值的输出发生变化。tmp 一旦发生变化，assign 会重新赋值，重新延时，所以这种方式会准确描述组合逻辑的 inertial delay。 Modeling Guide: Use continuous assignments with delays to model simple combinational logic. This coding style will accurately model combinational logic with inertial delays. Modeling Guide: Use always blocks with no delays to model complex combinational logic that are more easily rendered sing Verilog behavroral constructs such as \"case-casez-casex\", \"if-else\", etc. The outputs from the no-delay always blocks can be driven into continuous assignments to apply behavioral delays to the models. This coding style will accurately model complex combinational logic with inertial delays. Testbench Guideline: Continuous assignments can be used anywhere in a testbench to drive stimulus values onto input port and bi-directional port and bi-directional ports of instantiated models. Conclusions always 块中的任何延时都无法准确对真实硬件的行为进行准确建模，应该避免这种延时建模。有一个例外：在非阻塞复制的右边添加延时，来描述 transport delay，但是这种方式是以仿真性能的下降为代价的。 在 连续赋值语句 / 无延时的 always + 连续赋值语句 中添加延时，这两种方式都会对 inertial delays 建模，推荐使用这种方式来对组合逻辑建模。 Reference Digital Design (Verilog): An Embedded Systems Approach Using Verilog FPGA-Based System Design 设计与验证 Verilog HDL Xilinx FPGA 高级设计及应用 The Art of Hardware Architecture: Design Methods and Techniques for Digital Circuits","tags":"IC","loc":"https://qiangu.cool/posts/ic/delay_in_fpgas.html","title":"FPGA 中的延时"},{"url":"https://qiangu.cool/posts/ic/counter_design_summary.html","text":"Introduction 计数器 在数字电路设计 和 计算机程序设计 中都应用非常广泛，其功能顾名思义，就是用来计数。这里只讨论数字电路设计中的计数器。 通常，将包含触发器 flip-flop 的电路（即使含有组合电路部分）认为是时序电路。时序电路通常不以电路命名，而是以功能进行分类，分别是 寄存器 和 计数器 。 计数器 counter 从本质上来说也是寄存器，不过它是在预先设定好的状态序列中转移，尽管计数器是寄存器的一种特殊形式，通常还是以不同的名称来加以区分。 Type 按照不同的标准来划分，计数器可以有不同的划分方法： 触发方式 同步 / 异步 计数器 计数增减 加法 / 减法 / 可逆计数器 因为第二种方法没有明确显示计数器的计数方式，所以一般使用第一种方法。 这里总结了一些常见的计数器： Basic Binary Counter BCD Counter Ring Counter Johnson Counter Ripple Counter 计数器在数字电路中的用途非常广，可以作为定时器、实用计数器、状态机等。在具体实现时，有前面总结的不同的计数器类型可供选择，每种计数器由其特点决定了适用场合，我们要做到就是在不同计数器类型和配置之间进行权衡，选择正确的设计，以节省大量逻辑资源，并提高性能。 下面分别讨论各种计数器的特点和 HDL 实现。 Implement Binary Counter 最简单、最基本的计数器就是 二进制计数器 Binary Counter。它的计数方式就是从 0 开始每个脉冲进行 \"+1\" 操作，直到最大值，然后重新从 0 开始。 FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version 里面有个例子，这里稍作修改就可以当作通用模块，供其他模块调用了。 Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 module free_run_bin_counter ( clk , rst , max_tick , q ); parameter N = 8 ; input clk ; input rst ; output reg max_tick ; output reg [ N - 1 : 0 ] q ; // count always @( posedge clk ) begin if ( rst ) begin // reset q <= 0 ; end else begin q <= q + 1 ; end end // max_tick always @( posedge clk ) begin if ( rst ) begin max_tick <= 0 ; end else begin if ( q == { N { 1 'b1 }}) begin max_tick <= 1 ; end else begin max_tick <= 0 ; end end end endmodule BCD Counter (mod-m counter) 人类更习惯使用十进制进行计数，十进制一共有 10 个符号，我们只需要从 4 bit 的二进制计数器中选取 10 个数字，只使用这 10 个数字进行计数即可，通常去掉 1010 ~ 1111 这 6 个数字，即使用 8421BCD 码 来对十进制数进行编码、计数，即 BCD Counter。 将十进制进行推广，我们就可以写出任意的 模 m 的计数器，在下面的例子中，M 表示计数器的模值（默认为 10），N 表示计数器需要的位数（默认为 4）。在例化时如果要修改，则需要手动计算这两个参数进行赋值。 Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 module bcd_counter ( clk , rst , max_tick , q ); parameter N = 4 , // number of bits in counter M = 10 ; // mod-M input clk ; input rst ; output reg [ N - 1 : 0 ] q ; output reg max_tick ; always @( posedge clk ) begin if ( rst ) begin // reset q <= 0 ; end else begin if ( q == ( M - 1 )) begin q <= 0 ; end else begin q <= q + 1 ; end end end always @( posedge clk ) begin if ( rst ) begin // reset max_tick <= 0 ; end else begin if ( q == ( M - 1 )) begin max_tick <= 1 ; end else begin max_tick <= 0 ; end end end endmodule Ring Counter 基于线性移位寄存器 LFSR (Linear feedback shift register) 可以衍生出两种计数器： 环形计数器 (ring counter) 和 扭环计数器（约翰逊计数器）。 将 LFSR 中存储的数字设置为独热码的形式，即只有一位为 1，其他位为 0。然后把最后一级的输出直接反馈到第一级的输入，这样，输入和输出组成了一个环形，所以称为 环形计数器。4 bit 的环形计数器电路图如下： (ref: http://electronics-course.com/ring-counter) Adv 相比于 binary counter，ring counter 不需要后者必需的加法器来实现计数，所以它在电路上占用的资源要更少。 因为没有额外的加法器，所以 ring counter 也不存在加法器带来的进位时延，它的最大时延是固定值，和计数器的模值无关。所以它的时序性能也比 binary counter 好。 因为 ring counter 的汉明距离为 2，所以它可以检查单比特翻转的错误。 Disadv Ring counter 最大的缺点就是它的低密度码，同样适用 N 个寄存器，binary counter 可以计数到 2&#94;N，而 ring counter 只能计数到 N，经过改良后的 Johnson counter 也才能到 2N。所以，如果寄存器比组合逻辑更加珍贵的情况下，不适合使用 ring counter。 Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 module ring_counter ( clk , rst , max_tick , q ); parameter N = 10 ; input clk ; input rst ; output reg max_tick ; output reg [ N - 1 : 0 ] q ; always @( posedge clk ) begin if ( rst ) begin // reset q <= 0 ; q [ N - 1 ] <= 1 'b1 ; end else begin q <= { q [ 0 ], q [ N - 1 : 1 ]}; // right shift end end always @( posedge clk ) begin if ( rst ) begin // reset max_tick <= 0 ; end else begin if ( q [ 0 ] == 1 ) begin max_tick <= 1 ; end else begin max_tick <= 0 ; end end end endmodule Johnson Counter 在 ring counter 的反馈链路中加入一个反相器，就好象把一个环扭了一下，所以称为 扭环计数器 (Johnson Counter) 4 bit 的 Johnson Counter 如下图所示： Adv 最大的优点就是它可以计数的范围和 ring counter 相比，扩大了一倍，达到了 2N。 Disadv 最大的缺点就是一旦它进入了错误状态，则永远无法返回到正确状态，除非外界干预。 Code 首先，将前面例子第 行的反馈语句修改一下， 1 q <= { ~ q [ 0 ], q [ N - 1 : 1 ]}; // right shift 同时，计数器的终点也要进行相应的修改， 1 2 3 4 5 6 if ( q [ N - 1 ] == 1 && q [ N - 2 : 0 ] == 0 ) begin max_tick <= 1 ; end else begin max_tick <= 0 ; end Ripple Counter 前面总结的这些计数器都是同步计数器，组成它们的 flip-flop 是由同一个脉冲信号触发的。还有一种计数器是异步计数器，它内部的 flip-flop 不是由同一个脉冲信号触发的。由于 FPGA 特殊的结构原因，在 FPGA 中应该使用同步设计，所以一般 FPGA 不会使用这种计数器。 ripple counter 的每个 flip-flop 使用前一级的 flip-flop 的输出信号作为触发信号，所以后一级的触发器必须等到前一级的触发器输出之后才能工作，所以对于一个长度为 N 的触发器链，从输入时间开始，要等 N 个触发器依次工作完之后才能输出有效结果。 示意图： (ref: http://www.eecs.tufts.edu/~dsculley/tutorial/flopsandcounters/flops6.html) Adv 面积小（不需要电路来实现 \"+1\" 功能） 功率少（因为面积小） 所以在一些对面积、成本、功率敏感的应用中，ripple counter 很有用。比如：一个电子时钟，因为秒 s 对于纳秒 ns 来说是很缓慢的，所以可以忍受这种累积误差的。 Dis 所有的 flip-flop 不是同时触发的，每个 flip-flop 的时延会累积到输出，当所有的时延累积到一起，有时候（很长的 flip-flop 级联在一起）相对于时钟信号而言，就不能忽略这种时延了，严重时会导致系统出错。 Code 代码在 Hdl Chip Design: A Practical Guide for Designing, Synthesizing & Simulating Asics & Fpgas Using Vhdl or Verilog 里面有介绍。 Gray Code Counter Gray 码和普通的二进制编码相比，优势就是它相邻数字之间只有一位不同，这样在计数时，就避免的多位不是同时变化导致的毛刺。 Gray Code wiki : A typical use of Gray code counters is building a FIFO (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.[10] The updated read and write pointers need to be passed between clock domains when they change, to be able to track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a \"wrong\" binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used. 在大神 Clifford E. Cummings 的论文 synthesis and scripting techniques for designing multi-asynchronous clock designs 中有详细介绍如何设计一个 Gray Code Counter 的过程，其基本思想就是利用一个 binary counter 来实现目的，计数器的计数功能由内部的 binary counter 实现，将 binary 的计数结果通过一个 binary2gray 的转换电路转化为 gray code 后再输出；输出的 gray code 反馈回计数器之前，再通过一个 gray2bianry 的电路转化回 binary 形式，以供内部的 binary counter 使用。模块示意图如下： 代码略 ... Reference FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version Hdl Chip Design: A Practical Guide for Designing, Synthesizing & Simulating Asics & Fpgas Using Vhdl or Verilog synthesis and scripting techniques for designing multi-asynchronous clock designs Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology)","tags":"IC","loc":"https://qiangu.cool/posts/ic/counter_design_summary.html","title":"计数器设计小结"},{"url":"https://qiangu.cool/posts/book/the_pomodoro_technique_practices.html","text":"忙里偷闲，学习一下大名鼎鼎的 番茄工作法 。 Intro 番茄工作法 ( Pomodoro Technique ) 是由 Francesco Cirillo 创建的一种时间管理方法。他自己上大学时为了克服无法集中精力认真学习这个问题而发明了这种方法，后来他整理完成了一本书来介绍这种方法： The Pomodoro Technique \"Pomodoro Technique\" 这个名字起源于一种厨房用的、番茄形状的计时器，其中 Pomodoro 是意大利语，意思是番茄。 至于为什么是番茄工作法，而不是白菜工作法呢？这是因为 Francesco Cirillo 当时在厨房找到的那个计时器是番茄形状的 :P 还有另外一本书，是另外一个人自己实践番茄工作法总结出来的经验，而且自己画了一些生动的插图和脑图在里面，很有帮助： Pomodoro Technique Illustrated Summary 首先，网上贴张别人总结好的 Mind Map ( 出处见水印 )： 番茄工作法非常简单，具有非常强的可操作性，这也是它能风靡世界的原因吧。 番茄工作法一共包含 5 个步骤： 其中有一些必须遵守的法则： 也可以用一张图总结出什么是番茄工作法： 综上，找一只笔和几张纸，列出要完成的工作，然后设定计时器，开始工作！就这么简单。 My Practice GTD 和 pomodoro 可以相互补充，达到最好的效果： GTD 侧重项目之间的管理，通过收集、处理、组织，使我们胸有成竹，做到 mind like water；Pomodoro 则侧重时间管理，每天到底应该如何提高效率，通过和自己约定的倒计时，把一个个行动落实，把握生命中的每一分钟，全力以赴我们心中的梦，不经历风雨怎么能见彩虹（不对 ...） Tools 番茄法的工具（5 个）： A pen A Kitchen Timer Activity Inventory Sheet Todo Today Sheet Record GTD 的工具：（6 个）： Project List Next Action List Waiting For List Someday / Maybe List Calendar Reminder / Memo 所以，综合一下两者的优势，就有了下面的组合： Project List 运用 GTD 的收集、整理的优势，把我们的长期目标放在这里。 Someday / Maybe List 这里放目前不紧急，将来某个时候会做的事。 Activity Inventory List 短期目标 Todo Today List 计划每天做的事，一定要尽力完成（因为这是我们作出的承诺）。 Calendar 有日历帮助，我们可以更好地计划、实现一件复杂的事。 Reminder / Memo 记录生活中的小事、杂事，某时的突发奇想。 A Pomodoro 设置一个番茄时间，开始做！ Tips 番茄的大小，根据我们自己的实际情况而定，不过一开始可以用默认的 25 mins，过一段时间后如果真的不适合自己再进行修改。 Todo Today List 内容一定要实际可行，根据自己平时完成的番茄总量、预估计任务量来安排，尽最大努力完成清单，因为这是我们对自己的承诺。 按时休息。有时候我们可能正在起劲的时候，番茄钟响了，这时候最好停下手头的工作（即使你正在编程的紧要关头，文思如泉涌，有个新想法正想试试），原因很简单，避免长时间的工作，现在的休息是为了之后更长时间、更有效率地工作。即使有个好点子，先把它写下来，等休息好了再来评估、实现这个想法。 一定要严格遵守约定。类似 \" 破窗效应 \"，一旦我们有某次打破了番茄的规定，那么就很容易打破第二次、第三次。失去了约束力，这个方法也就没有作用了。 考研的苦逼日子最大的收获就是学会了用 calendar + checklist 来规划自己的学习生活。计划好一个长期目标，精确到每天的任务，这样每天结束时，如果完成了心情真是不要太开心，如果没有完成则对第二天也是一个激励，要提高效率把前一天的补上。我的这个 \" 土 \" 方法现在看来就是 GTD + Pomodoro 的简化版，是时候好好改进一下了。 TODO Self Observation 非常重要！每天坚持完，留一个番茄来回顾自己这一天的收获和效率情况，这样我们会对自己有个清楚的认识。 回顾收获 制定第二天的计划 分析、提高自己的效率","tags":"Book","loc":"https://qiangu.cool/posts/book/the_pomodoro_technique_practices.html","title":"番茄工作法 总结 + 实践"},{"url":"https://qiangu.cool/posts/book/getting_things_done_review.html","text":"最近了解学习了 GTD，总结一下。 Intro 所谓 GTD 就是 Getting Things Done 的缩写。最早有一个叫做 David Allen 的美国人写的一本书，名字就是 : Getting Things Done: The Art of Stress-Free Productivity 他是 GTD 系统的发明人，主要介绍了时间和任务管理的相关方法，后来这套系统越来越流行，于是大家就把相关的方法、工具统称为 GTD。 网上有很多介绍 GTD 方法论的博客： 小强的时间管理博客 学无止境 @ 一点一滴 褪墨・时间管理 这些大多是专业的培训师之类的人写的博客，里面的内容很全面也很详细（总共可能有 100+ 的文章），但是阅读体验却不好。我想主要原因是他们作为培训师、讲师身份，只有复杂、系统地介绍才能衬托出他们的专业。而作为一个普通人，我相信很多人都体验都是：好大一碗成功学鸡汤 =.= 所以，作为一个普通的学生、总结一下我在一周的空余时间内学习 GTD 的心得，保证简单。 学习步骤： 阅读 Getting Things Done: The Art of Stress-Free Productivity ，还是英文版靠谱，网上的翻译质量实在无法恭维。 阅读几篇博客即可，主要是吸收、了解别人和自己的理解 总结（形式随意，如写 blog、画 mind map），实践应用！ GTD Reason 现在的人的生活、工作压力都很大，如果没有一个有效的方法来组织管理自己的事物，会越忙越乱。 比如作为一个学生，一想到自己的论文还没有头绪，项目也看不到希望，还有码农的编程技能没有完全 get，眼看就要毕业了，找工作的压力也逐渐越来越大，着急却越忙越乱，总有一些事盘旋在脑袋里，不经意间提醒你 \" 还有没有做好的事！\" 这时候，各种管理的方法就出现了，而 GTD 就是其中一种。 Aim GTD 书里面最终目的就是帮助我们达到所谓的 \" 黑带 \" black belt 级别，标志就是做到 \" 心静如水 \" Mind Like Water 。 所谓心静如水，是从武学中借鉴过来的词（也就是功夫熊猫里面浣熊师父教给胖纸的武术家的追求 —— inner peace ），GTD 的目的就是通过这一套系统方法让我们达到这种境界： 掌控一切，不慌不忙，全身心投入到每一件事中。 Workflow Methodology GTD 的方法其实并不高深，它实际上主要就是解决了两个问题： 很多事之间该如何处理 某一件事该如何进行下去 Horizontal Focus 为了解决第一个问题，GTD 提出了 5 个横向管理方法 horizontal five-stage method ： Collect 把所有的 \" 原始材料 \"（ stuff ）都收集（ collcet ）到一个地方，比如一个货真价实的篮子，或者是文件夹、电脑上的某个文件夹中（或者它们的组合），这个地方就称为 in-basket 。 关键：一定要保证把所有的事全部收集起来，不能漏掉一个，这样我们就可以只专注于这个 in-basket，而不用考虑其他乱七八糟的东西。 Process 收集到 in-basket 之后，按照前面的 workflow 对其中的内容进行处理（ process ）。 关键：按照顺序，一次一件事地进行分类处理，处理完之后不要放回 in-basket 中，有条理地进行可以避免重复工作。 Organize 前一步只是将 in-basket 中的内容进行了分类，但结果仍然是一堆事情的集合，这时候就需要我们将其组织管理（ organize ）成各种有序的清单（ list ），比如 项目清单（ project list ） 日历（ calendar ） 下一步行动清单（ next action list ） 等待清单（ waiting for list ） 将来某时清单（ someday/may list ） 关键：建立一个 完备正交的分类集。 Review 在建立起各种清单之后，我们需要对其进行跟踪维护。根据事件的重要程度，每天、每周、每月、每年地不断坚持更新我们的清单。虽然简单，但也是最难做到的地方。或许 3 分钟热情可以持续一段时间，但是大多数人都没有恒心将一件事坚持下去。 关键：恒心！！！ Do 我们清单都列好了，但是当我们每天在确切的某个时间做什么确切的事呢？GTD 并没有给出答案，毕竟某件事重不重要只有我们自己才知道。但是它给出了 3 个模型来对一件事情的重要、紧急情况进行评估，以便我们安排工作顺序。安排工作顺序可以按照不同的属性进行排序： 地点：宿舍、实验室、教室 时间：早中晚、工作日、周末 花费的精力：看书、编程、发邮件、整理文档 重要程度：人生目标、工作计划、当前工作 实际上，我觉得在 do 这个方面，或许其他的方法更有效，比如 \" 番茄工作法 \" 等可以帮助我们有效地安排工作时间，提高注意力。 以上。 就是这么简单，和我们平时自己琢磨出来的方法没有太大差别，这几个步骤的目的就是管理我们的工作，让我们不再是乱糟糟一团的感觉，而是 \" 清单在手，天下我有 \" 的掌控全局的感觉，这也是我们能进入 mind like water 状态的前提。 Vertical Focus 为了解决第二个问题，GTD 提出了 5 个纵向管理方法 vertical five-phase method ： Defining purpose & principles Outcoming & visioning Brainstorming Organizing Identifying next actions 这几个步骤其实就是很自然而然的从上到下（ top to down ）的方法： 首先确定目标（ purpse & principles ），避免盲目努力，然后再展望做完时的美好景象（ outcoming & visioning ），这时候我们干劲十足，通过头脑风暴（ brainstorming ）找到合适的工作方法，之后就是确切地组织（ organizing ）人员，确认如何下手（ identifying next action ），开始干活了了。 步骤说起来空洞无味，但是在实际中面对不知如何下手的事情，可以参考这个步骤。关于如何做好一件事，涉及到不同的人和不同的工作类型，所以我认为这里的方法只能作为一个参考吧。 以上。 Tools 书里面还介绍了一些小技巧，就不再重复了。不过根据我的实践来看，工具其实也是一个至关重要的因素。 选择标准： 选择合适的而不是功能最全的工具。 现在有很多 GTD 类的软件，比如 thinkrock、remember the milk、any.do 等等，功能很全很强大，但是我最终还是选择了简单的 Google xxx + Evernote 的组合。 什么是合适的工具呢，我认为只要满足 简单 够用 这两个条件就好。 简单的功能可以帮助我们集中注意力，Google 的很多产品都遵循这个原则，比如 Calendar、Task、Keep、Translate 等，而 Evernote 虽然功能强大，但是有时候让我无从下手，不想打开；当然关键功能必须要有，比如最近很火的一款应用 Todist，作为一款 todo list 类型的软件，免费版本却没有提醒功能，他们是有多想挣钱啊 =.= Review 这年头不可避免地看了一些成功学的书，喝了不少鸡汤，这本久负盛名，最近越来越火的书，从我的体验来说，比其他同类的书要好很多，还是有干货的。虽然没有给我非常的大的质的改变，但是也解决了不少我的疑惑。书里没有提出多么惊天动地的方法，很多都是我们日常生活中在使用的技巧，这本书把这些总结整理成一套系统方法，也算是一大成就吧。 毕竟，实践才是检验真理的唯一标准，等过段时间再评价吧。 My GTD 作为学生党的 GTD 实践： Name Tools Project List Evernote Daily Plan Evernote Waiting For List Evernote Someday/Mayble List Evernote Calendar Google Calendar Reminder & Memo Google Keep 说明一下选择 EN 的最大的理由：它的跨平台性，Windows + *nix + Andriod，基本涵盖了我校园（宿舍 + 实验室）的生活，至于 Google 就不用说了，Gmail + Calendar + Keep + Drive 的组合别说有多舒服了～ 关于 \"Next Action List\"，我个人觉得并不是特别适合我，就平时的事（学习 + 项目 + 杂事）而言，学习和项目很难用 Next Action 来做计划，而杂事都是一些鸡毛蒜皮的小事，用不着分步骤来完成。我每天都活动基本上是固定的，哪个时间段干什么早就形成了一种模式，所以我将 \"Next Action List\" 改为 \"Daily Plan\"。 Mind Map 最后贴上一张我总结的 MM： Reference GTD | snow MindMapper","tags":"Book","loc":"https://qiangu.cool/posts/book/getting_things_done_review.html","title":"GTD 书评 + 总结"},{"url":"https://qiangu.cool/posts/ic/clock_dividers.html","text":"在 时钟设计 中提到过： Guideline： 尽量避免使用分频时钟 如果要进行分频，可以使用 PLL/DLL 来实现，但是对于时钟要求不高的基本设计，通过语言进行时钟的分频相移仍然非常流行，首先这种方法可以节省芯片内部的锁相环资源，再者，消耗不多的逻辑单元就可以达到对时钟操作的目的。另一方面，通过语言设计进行时钟分频，可以看出设计者对设计语言的理解程度。 如果一定要使用分频时钟： 对于资源比较丰富的 FPGA 使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频 / 分频）和相位，这样的分频时钟是最稳定的。 对于无法使用 PLL/DLL 的 FPGA 对于这些情况，首先检查是否可以用 CE (clock enable) 来代替分频时钟，如果不行，则使用下面讨论的分频方法。 Counter 时钟分频一般都是通过计数器 counter 来实现的，计数器是分频的基础。 计数器可以分为很多种， Counter on wiki ，这里不再跑题展开了，关于计数器的讨论见： Counter in FPGAs Clock divider even clock divider 偶数分频是最简单的情况，使用计数器就可以完成。比如，产生一个分频系数为 N（偶数）的 50% 占空比的分频器一般有两种方法： 计数器计数到 (N/2-1) 时，将输出翻转，同时将计数器复位到 0，重新开始计数 计数器从 0 计数到 (N/2-1) 时，输出 1/0，从 N/2 计数到 (N-1) 时，输出 0/1 方案一只能实现固定的 50% 占空比，方案二则可以实现可以有限调整占空比。 odd clock divider 如果对占空比没有要求，那么使用和偶数分频类似的方法，一个计数器就可以解决；如果要求占空比是 50%，则可以使用以下的方法： The Art of Hardware Architecture : Conceptually, the easiest way to create an odd divider with a 50% duty cycle is to generate two clocks at half the desired output frequency with a quadrature-phase relationship (constant 90° phase difference between the two clocks). The output frequency can then be generated by exclusive-ORing the two waveforms together. Steps 创建 ref_clk 上升沿触发的 0 ~ (N - 1) 的计数器 cnt（N 为奇数） 使用两个 T flip-flop，分别产生各自的 enable tff1_en: 当 cnt = 0 时，使能 tff2_en: 当 cnt = (N + 1) / 2 时，使能 产生以下信号 div1：在 ref_clk 上升沿 触发 tff1 div2：在 ref_clk 下降沿 触发 tff2 异或 div1 和 div2，得到输出 clk_out 在 The Art 中，举例介绍了 3 分频的情况： Schematic: Timing: half integer clock divider 这种分频系数为 (N+1/2)，应该归类到小数分频中，但是因为它的小数部分是特殊的 1/2，所以可以在前面的讨论的基础上得到。 The Art 中分类讨论了半整数分频： 50% Duty Cycle 以 1.5 分频为例， Schematic: Timing: 这种方法在仿真的时候是没有问题的，但是综合时可能会产生致命的问题：在切换时钟时，如果两路时钟信号的时延不相等，那么切换的时候就会产生毛刺。 (Xilinx 提供的原语 BUFGMUX 有去除切换时钟时候的毛刺的功能，但是它只适用于全局时钟网络 ) Non 50% Duty Cycle 如果占空比不是 50%，则可以通过以下的方法得到： 从 N + 1 / 2 = ( 2 N + 1 ) / 2 可知，N+1/2 分频也就是要求在 (2N+1) 个时钟周期内产生两个脉冲即可，这两个脉冲必须是等间隔分布的。 首先，可以采用长度为 (2N+1) 的移位寄存器，这些寄存器中只有一个是 1，其他都是 0，然后在时钟的驱动下循环移位，则就有了 (2N+1) 个时钟周期的计数。 其次，两个脉冲可以从这个移位寄存器中选取两个作为输出，但是不能简单地直接使用，因为无论怎样选择，这两个脉冲都不是等间隔分布的（一共 2N+1 个计数，抽取 2 个，剩余 2N-1 个计数，那么 2N-1 是个奇数，无法平分为两部分，所以不是等间隔的）。所以难点就在于如何得到两个等间隔的分布。The Art 的解决方法如下，以 4.5 分频为例： Timing: 从图中可以看到，当选择了两个连续的寄存器 (A, B) 相或作为第一个脉冲输出之后，再选取相隔 N 的两个连续的寄存器 (C, D)，把它们移动半个时钟周期后，和原始的 D 相或，作为第二个脉冲输出，容易分析，它们是等间隔的。 fraction divider 大概有两种方法吧： 整数逼近法 多次分频 方法一： 小数分频，最普通的方法是采用整数分频逼近法，比如 50 MHz 的时钟分频为 880 Hz，那么分频计数器 : 50000000 / 880 = 56818 . 18182 那么就用 56818 来近似，但是这种方法只有在分频系数很大时才比较好，分频系数越小，则误差越大。 方法二： 参考一篇博文： verilog 实现小数分频（小数分频器） 通过可变分频和多次平均的方法，然后通过控制单位时间内两种分频比出现的不同次数来获得所需要的小数分频值。 假设分频系数为 N+A/B，其中 N, A, B 都是整数，N 代表整数部分，A/B 表示小数部分。 由 NB + A = N * ( B - A ) + ( N + 1 ) * A 可知，通过 (B-A) 次 N 分频 + A 次 (N+1) 分频即可得到 N+A/B 分频。 到此还没有结束，还需要对这两种分频方式进行均匀的放置。可以借助一个计数器到达这个目的：每进行一次分频，计数值为 10 减去分频系数的小数部分，各次计数值累加。若累加结果小于 10，则进行 N +1 分频，若大于或等于 10，则进行 Ｎ 分频。 不同时钟分频组合时，\" 按照累积量和 10 比较 \" 原理： 当采用一种分频比，小数部分累积量大于 10，则表示小数部分累积达到了可以向整数部分进位的大小，这时候就应该插入另外一种分频比将小数部分积累的误差去掉，否则结果就不是均匀周期的时钟信号了。 举个例子： 比如 8.7 分频 87 = 8 * 3 + 9 * 7 所以可以用 3 次 8 分频 + 7 次 9 分频得到 8.7 分频。因为 10 -7 = 3 ，前 3 次累积之和都小于 10，所以前 3 次进行 9 分频，第四次累积值为 12，去除进位后余 2，待下次继续累积，第四次结果 12 > 10，所以进行 8 分频。分频方案如下图所示： Summary 本文总结了一些常用的时钟分频技术，虽然不推荐使用逻辑来对时钟信号进行分频，但是在一些要求比较的的情况下，使用逻辑分频不仅可以满足要求，还能降低资源消耗，不失为一种好方法。而且时钟分频也可以训练我们的设计能力。 Reference The Art of Hardware Architecture FPGA 高手设计实战真经 100 则 使用 VHDL 进行分频器设计 verilog 实现小数分频（小数分频器） 任意分频的 verilog 语言实现","tags":"IC","loc":"https://qiangu.cool/posts/ic/clock_dividers.html","title":"时钟分频器"},{"url":"https://qiangu.cool/posts/ic/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html","text":"Problem 在前面一篇总结 Latch V.S. Flip-flop 的博文中，已经解释了 flip-flop 的一些参数：建立时间 setup time 、保持时间 hold time 、恢复时间 recovery time 、撤销时间 removal time 。 如果不满足这些参数的要求，则会发生所谓的 亚稳态 Metastability 的问题。下面是 Altera 官方的一篇关于亚稳态的 white paper，详细介绍了亚稳态的产生原因、它是如何导致设计出现问题、以及描述它的参数 MTBF (Mean Time Between Failures) 如何计算。 Understanding Metastability in FPGAs 我们知道，一般只涉及单时钟域的设计并不多见，尤其是对于一些复杂的应用，FPGA 往往需要和多个时钟域的信号进行通信，而这些时钟之间的关系一般都是频率不同、相位也不同，也就是不同频不同相的多异步时钟域设计 Mulit-Asynchronous Clock Design 。 因为这些时钟信号之间的关系一般既不同频也不同相，所以一个时钟域的信号对于另外一个时钟域来说是异步信号，那么就无法保证进入新时钟域的信号和新的时钟信号之间满足 setup/hold time 的要求，自然就会引起亚稳态的问题。 在 Clifford E. Cummings 大神的 paper： Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs 里面就举例说明了这种现象： Reason \"When sampling a changing data signal with a clock ... the order of the events determines the outcome. The smaller the time difference between the events, the longer it takes to determine which came first. When two events occur very close together, the decision process can take longer than the time allotted, and a synchronization failure occurs.\" Illustation 1: Illustation 2: 如果不加处理，亚稳态产生的错误值将会传播到设计的其他部分，导致更加严重的问题 Synchronous Design 多时钟域导致的亚稳态的问题的根本原因就是：信号和时钟是异步的，也就是设计不是同步设计 Synchronous Design 。 同步化设计思想 是 FPGA 中非常重要的原则： Asynchronous Circuits 同步电路的核心逻辑是用 组合逻辑 combination logic 实现的，比如异步 FIFO/RAM 读写信号、地址译码等电路。电路的主要信号、输出信号不依赖任何一个时钟信号，不是由时钟信号驱动 flip-flop 产生的。 异步电路最大的缺点就是容易产生毛刺。 Synchronous Circuits 同步电路的核心逻辑是用 时序逻辑 sequential logic 实现的。电路的主要信号、输出信号是由某个时钟沿驱动 flip-flop 产生的。 同步电路可以很好的避免毛刺。 Synchronous V.S. Asynchronous Xilinx FPGA 高级设计及应用 从 ASIC 设计的角度来看，大约需要 7 个门来实现一个 D 触发器，而一个门即可实现一个 2 输入与非门，所以一般来说，在 ASIC 设计中，同步时序电路比异步电路占用更大的面积。但是，由于 FPGA 是定制好的底层单元，对于 Xilinx 器件，一个底层可编程单元 Slice 包含两个触发器（FF）和一个查找表（LUT）。其中触发器用以实现同步电路，查找表用以实现组合电路。FPGA 最终使用率用 Slice 来衡量。所以对于某个选定器件，其可实现的同步电路和异步电路的资源数量和比例是固定的，这点造成了过度使用查找表会浪费触发器资源，反之亦然。因而对于 FPGA，同步时序设计不一定比异步设计多消耗资源。单从节约资源的角度考虑，应该按照芯片配置的资源比例实现设计，但是设计者还要时刻权衡同步设计没有毛刺、信号稳定等优点， 所以对于 FPGA 设计推荐采用同步设计。 无论是用离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字逻辑，为了成功操作，可靠的时钟是非常关键的。 ... 因为，FPGA 同步设计中最好的时钟解决方案是由专用全局时钟输入引脚驱动单个主时钟去控制设计项目中的每一个触发器。系统中各个功能模块使用同一同步复位信号。 ... FPGA 同步设计中，时序电路应尽量采用同步电路，尽可能使用同步器件，尽量减小或不使用门控时钟（为了降低系统功耗以外）。设计中不用系统主时钟经过逻辑运算得到控制信号，避免使用非时钟信号作为触发器的时钟输入。 下面提到的所有方法，就是同步化思想的应用，其核心目的就是将本时钟域外的 异步信号同步化 。 Solution Solution 1: Daul Rank Synchronizer 通常使用 MTBF (Mean Time Between Failures) 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。 以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×109 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。 理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。 如图所示： 通常，同步器 synchronizer 由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。 为了让 synchronizer 正常工作，从某个 时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入 synchronizer。之所以这样要求，是因为 synchronizer 的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过 synchronizer，给新时钟域后续逻辑一个虚假的信号。 synchronizer 有很多设计方法，因为一种方法不能满足所有的应用需求。synchronizer 的类型基本上分为 3 种： level synchronizer edge-detecting synchronizer pulse synchronizer 下面分别讨论： level synchronizer Schematic: 电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 paper 中有更详细的图解说明： Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 module LVLSYNC ( input clk_src , input rst_src , input dat_src , input clk_dst , input rst_dst , output reg dat_dst ); ///////////////////////////////////////////////////////////// // source time domain ///////////////////////////////////////////////////////////// reg dat ; always @( posedge clk_src ) begin if ( rst_src ) begin dat <= 1 'b0 ; end else begin dat <= dat_src ; end end //////////////////////////////////////////////////////////// // destination time domain //////////////////////////////////////////////////////////// reg dat_r ; // using two level DFF to synchronize the din_q always @( posedge clk_dst ) begin if ( rst_dst ) begin dat_r <= 1 'b0 ; dat_dst <= 1 'b0 ; end else begin dat_r <= dat ; dat_dst <= dat_r ; end end endmodule RTL: Restriction: 使用 level synchronizer 的要求是： 源时钟域的信号应先通过源时钟域的一个 DFF 后输出，然后直接进入目的时钟域的 synchronizer 的第一级 DFF。这样做的 这么做到原因是：synchronizer 的第一级 DFF 对组合逻辑产生的毛刺（glitch）非常敏感。如果一个足够长的毛刺刚好满足了 setup/hold time，那么 synchronizer 会将其放行，产生一个虚假的信号。 跨域时钟域的这个信号持续时间 >= 2 个新时钟域时钟周期。 虽然 Crossing the abyss: asynchronous signals in a synchronous world 中是这么写的，但是我觉得这个条件应该是保险条件，而不是最低条件。level synchronizer 的最低条件应该和 edge-detecting synchronizer 相同： 输入信号的宽度 >= 目标时钟域周期 + 第一个 flip-flop 的 hold time。 首先，待同步到信号宽度 > 源时钟周期，这样它才能被源时钟域的 DFF 采样到，然后输出； 其次，源时钟域采样输出端信号的宽度当然是源时钟周期的整数倍，它的宽度 > 目标时钟域周期 + 第一个 flip-flop 的 hold time，这样它才能被目的时钟域的时钟采样到，然后进行同步。 所以，保险一点的条件是：待同步到信号有效时间至少是目的时钟周期的 2 倍。 level synchronizer 是其他两种同步器的基础： edge-detecting synchronizer 边沿检测同步器 是在 level synchronizer 的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。 Schematic: Code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 module EDGESYNC ( input clk_src , input rst_src , input dat_src , input clk_dst , input rst_dst , output dat_dst ); ///////////////////////////////////////////////////////////// // source time domain ///////////////////////////////////////////////////////////// reg dat ; always @( posedge clk_src ) begin if ( rst_src ) begin dat <= 1 'b0 ; end else begin dat <= dat_src ; end end //////////////////////////////////////////////////////////// // destination time domain //////////////////////////////////////////////////////////// reg [ 2 : 0 ] sync_reg ; always @( posedge clk_dst ) begin if ( rst_dst ) begin sync_reg <= 3 'b0 ; end else begin sync_reg <= { sync_reg [ 1 : 0 ], dat }; end end // AND to get the output assign dat_dst = sync_reg [ 1 ] && ( ~ sync_reg [ 2 ]); endmodule RTL: ... Restriction: 使用 edge-detecting synchronizer 的要求是： 输入信号的宽度 >= 目标时钟域周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。 实际上，因为在源时钟域，要先用 DFF 寄存一下再输出，所以源时钟域输出的信号的宽度是其时钟周期的整数倍，它肯定是 > 目标时钟周期的，因为 edge-detecting synchronizer 只能工作在慢时钟域到快时钟域的情况下。 edge-detecting synchronizer 在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用 pusle synchronizer。 pulse synchronizer 脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。 源时钟域的单时钟宽度的脉冲不是直接输出的，而是先经过一个源时钟域的翻转电路。这个翻转电路在每次输入一个脉冲时，它的输出会在高、低电平之间翻转。 而在目的时钟域，翻转电路的输出先通过一个 level synchronizer，其输出到达异或门的一个输入端，而这个输出再经过一个 DFF，延时一个时钟周期后进入异或门的另外一个输入端。最后异或门的输出即最终的同步结果： 源时钟域每有一个单时钟脉冲（源时钟），synchronizer 的输出端产生一个单时钟宽度（目的时钟）的脉冲。 Schematic: Code: module PULSESYNC ( input clk_src , input rst_src , input pulse_src , input clk_dst , input rst_dst , output pulse_dst ) ; /////////////////////////////////////////////////// // source time domain /////////////////////////////////////////////////// reg toggle_reg ; always @ ( posedge clk_src or posedge rst_src ) begin if ( rst_src ) begin toggle_reg <= 1 ' b0; end else begin if ( pulse_src ) begin toggle_reg <= ~ toggle_reg ; end end end /////////////////////////////////////////////////// // destination time domain /////////////////////////////////////////////////// reg [ 2 : 0 ] sync_reg ; always @ ( posedge clk_dst ) begin if ( rst_dst ) begin sync_reg <= 3 ' b0; end else begin sync_reg <= { sync_reg [ 1 : 0 ], toggle_reg } ; end end // XOR to generate the pusle_dst assign pulse_dst = sync_reg [ 1 ] &#94; sync_reg [ 2 ] ; endmodule RTL: ... Restriction: 使用 pusle synchronizer 的要求是： 输入脉冲之间的最小间隔 >= 2 个同步时钟周期。如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻，形成一个比单时钟周期宽的输出脉冲。 实际上，在一些情况下，少于 2 个时钟周期（> 1 个时钟周期）也是可以同步上的。只要 synchronizer 的两个 DFF 的值不一样即可同步上，也就是说异步信号在连续的两个目的时钟采样的值不同即可，由于异步信号和时钟的相位关系不确定，所以在没有对齐的情况下，大于 1 个时钟时也能满足两个采样值不同的条件。 一般为了保险起见，要求其保持至少两个时钟宽度。 Timing synchronizer 需要花费 1～2 个时钟周期来完成同步，所以粗略的估计可以认为 synchronizer 会造成目的时钟域的 2 个周期的延迟，我们在设计时需要考虑 synchronizer 对时序产生的影响。 Summary 总结 3 种同步器的特点，有下表： 虽然还有其他类型的 synchronizer，但是这 3 种基本上就可以解决设计中遇到的多数问题了。 synchronizer 仅适用于简单的数据跨时钟域传输的同步，除了简单的信号之外，还有数据、地址、控制总线信号等也要跨时钟域。对于这些需求，可以使用其他的工具，比如握手协议、FIFO 等。 Solution 2: Handshaking Handshaking allows digital circuits to effectively communicate with each other when the response time of one or both circuits is unpredictable. For example, an arbitrated bus allows more than one circuit to request access to a single bus, such as PCI or AMBA (Advanced Microcontroller Bus Architecture), using arbitration to determine which circuit gains access to the bus. Each circuit signals a request, and the arbitration logic determines which request \"wins.\" This winning circuit receives an acknowledgment indicating that it has access to the bus. It then discontinues its request and begins the bus transaction. 大意就是：对于（单边 / 双边）电路响应时间不确定的应用，握手协议可以有效地传输信号。比如（PCI、AMBA）总线仲裁电路，有多个电路申请访问总线时，每个电路都发出请求，由仲裁电路来决定哪个有访问权。\" 获胜 \" 的电路会收到确认信号，然后才可以访问总线。 这种交互方式就是握手协议，简而言之就是双方首先要握手达成一致，然后才能传输数据。 有两种基本握手协议： Full-handshaking Partial-handshaking 这两种握手协议都要用到 synchronizer，每种都有各自的优缺点，下面分别讨论： full handshaking 如图所示，全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路 A 声明它的请求信号，然后接收方电路 B 检测到该请求有效后，声明它的效应信号；当电路 A 检测到响应信号有效之后，中止自己的请求信号；最后，当电路 B 检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非 A 检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路 A 必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。 这种类型的握手使用了 level synchronizer。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端 A 需要 5 个周期，接收端 B 需要 6 个周期。 全握手鲁棒性很好，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。 partial handshaking 另一中类型是部分握手。部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。 部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。 有两种类型的部分握手： 第一种握手方法中，电路 A 以有效电平声明其请求信号，电路 B 以一个单时钟宽度脉冲作为响应。此时，电路 B 并不关心电路 A 何时中止它的请求。 但是为了这种方法成立，电路 A 中止请求信号至少要 1 个时钟周期长度，否则，电路 B 就不能区别前一个和后一个新的请求。 在这种握手方式下，电路 B 为请求信号使用一个 level synchronizer；电路 A 为响应信号使用一个 pusle synchronizer。只有当电路 B 检测到请求信号时才发出响应脉冲，这样电路 A 控制请求信号的时序，就能控制自己 synchronizer 接收到的脉冲间隔。 同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路 A 需要花费 3 个时钟周期，接收端 B 需要花费 5 个时钟周期。 第二种握手方法中，电路 A 使用一个单时钟宽度脉冲发出它的请求，电路 B 也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。 这种握手使用的是 pusle synchronizer。完整的时序是：电路 A 需要花费 2 个时钟周期，电路 B 需要花费 3 个时钟周期。 summary 因为 handshaking 内部采用了 synchronizer，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的 synchronizer 和握手信号，就有了前面介绍的 3 种不同的 handshaking： full handshaking 是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。 partial handshaking 是对 full 的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的 partial shandshaking。 partial I 精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了 1 次半的握手。而且修改了 full 中 level synchronizer 的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路 A 则必须使用 pusle synchronizer 来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的 synchronizer，partial I 就比 full 方式节约了很多时间。 partial II 则更进一步，在 partial I 的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成 1 次握手。而且两部分电路的 synchronizer 同时修改为 pusle 方式。这样子进一步减少了握手花费的时间。 partial 和 full 的本质区别不在于 synchronizer 的类型和握手信号的多少，而在于握手的方式。 partial 不用再等待对方的回答，就继续进行自己的下一步操作，而 full 必须等到对方的回复才进行下一步的操作，所以从某种意义上，full 方式才是真正的 \" 握手 \"，而 partial 并不符合 \" 握手 \" 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手 =.= 在许多应用中，跨时钟域传送的不只是简单的信号，数据总线、地址总线、控制总线都会同时跨域传输。因为 synchronizer 需要花费的时间是不确定的（1 or 2 个时钟周期），所以对于这些多 bit 的数据，synchronizer 无法完成同步功能，通常采用其他的方法，比如使用 FIFO。 Solution 3: Datapath Design 在进行信号同步时，有一个重要的原则： 不应该在设计中的多个地方对同一信号进行同步，即禁止单个信号扇出至多个同步器。 因为 synchronizer 要花 1~2 个时钟周期，设计者不能确切预测到每个信号何时跨越时钟域，此外，在新时钟域中一组经过同步后的信号其时序是不定的，因为 synchronier 的延迟可以是 1～2 个时钟周期，这种情况下各个同步信号间形成一种 \" 竞争状况 \"，这种竞争状况在需要跨域时钟域传输的多组信号间也会发生，例如数据总线、地址总线、控制总线等。因此， 不能对组中的每个信号单独使用 synchronizer，也不能对数据 / 地址总线的每一位单独使用同步器 ，因为在新的时钟域中，要求每个信号同时有效。 problem Clifford E. Cummings 在他的文章中举例说明了几种常见的错误： A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. Simply using synchronizers on all control signals is not always good enough as will be shown in the following examples. If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs. Problem - Two simultaneously required control signals a register in the new clock domain requires both a load signal and an enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded. Solution - Consolidating control signals before passing Problem - Two phase-shifted sequencing control signals The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop. Solution - Logic to generate the proper sequencing signals solution 有一种解决这个问题的方法是： 使用一个保持寄存器 + 一个握手信号 。 保持寄存器保持信号总线的数据，握手信号指示目标时钟域何时可以对总线进行采样，源时钟域何时可以更换当前寄存器中保存的内容。 In this design, the transmitting circuit stores the data (signal bus) in the holding register as it asserts the request signal. These two actions can happen at once because the request signal takes at least one clock cycle before the receiving circuit detects it (the minimum handshake-synchronization delay). When the receiving circuit samples the data (signal bus), it asserts the acknowledgment signal. 仔细分析一下，其实这里采用的原理类似于握手协议。 当有一组新的数据出现在数据总线上需要跨时钟域时，额外添加一对握手信号 request/acknowledge，这对信号对于两个时钟域来说分别是异步信号（接收电路不知道何时会收到 request，发送电路也不知道何时会获得 acknowledge），可能会产生亚稳态的问题，所以在两个时钟域对它们分别用 synchronizer 进行同步。 和 request 一起送过来的还有数据总线 上的数据信号，但是对于数据信号，不能简单地对每一位使用 synchronizer 来同步（原因前面已经说过了）。虽然对于接收电路来说，数据总线上的数据也是异步的，但是我们可以强制要求在握手过程中，数据保持不变，这样虽然数据是异步的，只要发送端满足保持寄存器数据在握手过程中不变化这一条件，那么即使数据总线上的数据到达接收时钟域有一些小的偏差 skew，但是不会超出 1 个时钟周期，在 synchronizer 最好的状态下，只花费了 1 个时钟周期就同步到了握手请求 request，这时候数据总线上的数据已经是稳定不变的有效数据了，所以可以采样到正确的有效数据，不会存在亚稳态的问题。 采用这种方法可以避免亚稳态的出现的原因就是它规定了异步信号（保持寄存器）什么时候可以变化，虽然是异步信号，但是在采样的时候人为地确保了它保持稳定，满足 setup/hold time 的要求，所以不会有亚稳态的问题。 这里的握手机制可以采用 full handshaking，也可以采用 partial handshaking，设计者应该根据实际需求来选择。 在 The Art of Hardware Architecture 这本书中，有详细的时序图来说明了一种握手机制下，这种机制采用了 full handshaking 中等待对方的方法，但是对握手信号进行了精简（partial II 类型）。如下图： 如果发送端的数据速率很快 / 无法控制发送端发送数据的速度，那么就有可能无法满足握手机制中要求数据保持稳定这一要求，这时候这种方法就不再适用，而应该采用其他的方法，比如 FIFO。 Solution 4: Advanced Datapath Design 有时候，数据在跨时钟域时需要 \" 堆积 \" 起来，这时候只使用单个的寄存器就无法完成工作。比如某个传输电路突发式地发送数据，接收电路来不及采样，为了保持数据不丢失，就必须先把数据存储起来；还有一种情况是接收电路的采样速率比发送速度快，但是位宽却不够，仍然需要将没有采样的数据先暂存起来，这时候就需要使用 FIFO。 基本上，使用 FIFO 的目的有两个： 速度匹配 宽度匹配 FIFO 的实现可以直接使用 IP core，也可以自己写代码实现。 如果是自己写代码实现，那么异步信号的问题还是需要我们在实现 FIFO 是仔细考虑的；如果是采用 IP core 的方式，那么可以很大程度地缓解我们的压力，因为事实上我们是把异步信号的问题交给了设计 IP core 的人来处理 ... 这些 IP core 在内部针对异步数据读写的问题作了非常严谨复杂的设计，对外提供了非常简单的接口。采用这种方式虽然轻松，但是相应的地也有缺点：耗费更多的资源。 在 Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs 和 Crossing the abyss: asynchronous signals in a synchronous world 两篇 paper 和 The Art 中都有一些实现 FIFO 使用的相关技术的介绍，比如指针逻辑的处理，内部 gray code 计数器的实现等。这里就偷懒不细说了（以后再补） :P =============Update March/12/2015=========================== FIFO 的目的在于解决数据跨时钟域传输的问题，但是在实现 FIFO 本身时，一些内部的握手信号也需要跨时钟域，这时候需要用到之前讨论过的 dual rank synchronizer 等技术。 比如 FIFO 内部的地址计数器，如果使用 dual rank synchronizer 来同步，计数器的不同的 bit 可能会在不同的时钟周期内传递过去，这时接收到的数据就是错误的，对导致致命性的问题。 而对应这个问题的解决方法就是使用 gray code。 ==============end of update================================== 关于跨时钟域 papaer1 中还有一些其他方面的技巧，可以帮助我们更好的实现设计。 Design Partitioning Guideline: Only allow one clock per module. Reason: Static timing analysis and creating synthesis scripts is more easily accomplished on single-clock modules or groups of single-clock modules. guideline: Create a synchronizer module for each set of signals that pass from just one clock domain into another clock domain. Reason: It is given that any signal passing from one clock domain to another clock domain is going to have setup and hold time problems. No worst-case (max time) timing analysis is required for synchronizer modules. Only best case (min time) timing analysis is required between first and second stage flip-flops to ensure that all hold times are met. Also, gate-level simulations can more easily be configured to ignore setup and hold time violations on the first stage of each synchronizer. 采用这种设计方式的原因如上所示，可以减少不必要的时序验证，而且脚本也更容易写，总之可以使时序验证工作更容易。 举例如下图所示： Clock Name Conventions Guideline: Use a clock naming convention to identify the clock source of every signal in a design. Reason: A naming convention helps all team members to identify the clock domain for every signal in a design and also makes grouping of signals for timing analysis easier to do using regular expression \"wild-carding\" from within a synthesis script. 作者还举例说明了一个这样的例子：1995 年为 In Focus projectors 设计 video ASIC 时，他们就采用了这样的方法，对于 mircroprocessor 的时钟命名为 uClk，对于 video 的时钟则命名为 vClk。对应的时钟域中的信号的名字也添加了对应的前缀，比如 udata，uwrite，uadder 等。 使用了这样的策略后，整个设计团队的攻城狮们都可以很方便地确定某个信号是否为异步信号，如何处理。当时有个攻城狮没有按照这种策略，使用了自己的命名方式，在一次会议之后，大家墙裂建议他修改命名，结果也证明修改之后遇到的问题、出错的概率都小了很多。 Gated Clock 虽然 FPGA 可以用来为 ASIC 搭建原型，但是一些 ASIC 中的技术并不适用于 FPGA，比如 gated clock。一般也没有必要在 FPGA 中模拟 ASIC 的低功耗优化。事实上，由于 FPGA 时钟资源的的粗颗粒度性，并不是总能模拟成功。 下面简单讨论一下 ASIC 中 gated clock 的问题。（更详细的内容见 gated clock 文章，未写） dedicated clock module guideline : 将全部的 gated clock 时钟放在一个专门的时钟模块中，并将其从功能模块中分离出来 reason : 约束更加容易处理 FPGA 设计修改起来更容易（比如通过 #define 来选择编译 ASIC 还是 FPGA 设计，选择两者各自的实现代码） gating removal 在 FPGA 上建立模型时，有很多巧妙的方法去除 gated clock。比如下面这个例子就是最直观，但也是最繁琐的方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 `define FPGA // `define ASIC module clock_blocks (...) `ifdef ASIC assign clock_domain_1 = system_clock_1 & clock_enable_1 ; `else assign clock_domain_1 = system_clock_1 ; `endif ... endmodule 这种方法的缺点是当做出改动时，需要对 FPGA 和 ASIC 代码都作出修改。很多人对这种方式很不爽，因为他们必须写两种不同的 RTL 代码。 一种更加高级的方法是依靠工具，现代的很多综合工具都可以通过适当的约束，通过将条件并到数据通路，来自动消除 gated clock。 比如下面的这段代码： 1 2 3 4 5 6 7 8 9 10 11 12 module clockstest ( output reg oDat , input iClk , input iEnable , input iDat ); wire gated_clock = iClk & iEnable ; always @( posedge gated_clock ) oDat <= iDat ; endmodule 如果不打开自动消除的开关，产生的 gated clock 电路如下： 如果打开自动消除的开关，产生的没有 gated clock 电路如下： 现在大多数器件都提供了一个时钟使能（clock enable）端口 如果器件提供了这种接口，那么就没有必要使用上述方法； 如果器件没有提供这种端口，那么使用这种技术虽然可以消除 gated clock，但是付出的代价是增加了 data path 的 delay。 Summary 以上，就是一些在多时钟域设计中处理异步数据的常用方法，总结如下： 对于简单的单比特的数据，根据实际情况选择对应的 synchronizer 即可 对于其他的信号，比如数据总线、地址总线、控制总线等数据，可以使用握手协议 总线上的数据要求同时到达新的时钟域，所以不要对总线上的信号分别进行同步，而要采用一个保持寄存器 + 握手信号的方式 还可以采用 FIFO 来处理异步数据的问题 分块设计，尽可能保证一个模块只有一个时钟域，对于跨时钟域信号，写独立的同步模块，这样可以减轻时序验证的工作 采用良好的命名习惯，如前缀的方式，可以帮助设计 注意 ASIC 和 FPGA 中对时钟信号的不同处理方法 Reference Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs Crossing the abyss: asynchronous signals in a synchronous world Xilinx FPGA 高级设计及应用 FPGA 高手设计实战真经 100 则 ASIC 中的异步时序设计 跨越鸿沟：同步世界中的异步信号 Understanding Metastability in FPGAs The Art of Hardware Architecture Advanced FPGA Design: Architecture, Implementation, and Optimization","tags":"IC","loc":"https://qiangu.cool/posts/ic/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html","title":"FPGA 时钟设计 3 —— 跨时钟域设计"},{"url":"https://qiangu.cool/posts/ic/latch_versus_flip_flop.html","text":"根据 Wiki: Flip-flop (electronics) 上的介绍 In electronics, a flip-flop or latch is a circuit that has two stable states and can be used to store state information. A flip-flop is a bistable multivibrator . The circuit can be made to change state by signals applied to one or more control inputs and will have one or two outputs. It is the basic storage element in sequential logic. Flip-flops and latches are a fundamental building block of digital electronics systems used in computers, communications, and many other types of systems. 区别一下名字： Flip-flops can be either simple (transparent or opaque) or clocked (synchronous or edge-triggered). Although the term flip-flop has historically referred generically to both simple and clocked circuits, in modern usage it is common to reserve the term flip-flop exclusively for discussing clocked circuits; the simple ones are commonly called latches. Using this terminology, a latch is level-sensitive, whereas a flip-flop is edge-sensitive. That is, when a latch is enabled it becomes transparent, while a flip flop's output only changes on a single type (positive going or negative going) of clock edge. 所以按照现在的约定习惯区分，latch 指的是电平触发的触发器，翻译为 \" 锁存器 \"；flip-flop 指边沿触发的触发器，就叫 \" 触发器 \"。 [TOC] History 翻译自 wiki : 第一个电子触发器 (electronic flip-flop) 由 William Eccles 和 F. W. Jordan 于 1918 年发明的。它最早被称为 ： Eccles–Jordan trigger circuit ，由两个真空管组成。虽然现在由逻辑门 (logic gates) 组成的触发器很常见，但是在集成电路 (intergrated circuits) 中，这种元件及它的晶体管版本仍然也很常见。早期的触发器常用来构成触发电路或者多谐振荡器 (multivibrators)。 根据一个 JPL 的工程师，P. L. Lindley 介绍，Montgomery Phister 于 1954 年在 UCLA 的 computer design 的课程上第一次对触发器进行了分类的讨论（RS、D、T、JK），然后在他的书 Logical Design of Digital Computers 中也进行了讨论。Lindley 当时在 Hughes Aircraft 的 Eldred Nelson 手下工作，而 Nelson 命名了 JK 触发器。其他的名字则是 Phister 命名的。Lindley 解释说他是从 Nelson 口中得知 JK 触发器的故事的，当时 Hughes Aircraft 使用的触发器都是 JK 触发器。在设计逻辑系统时，Nelson 给触发器的输入命名为 A&B、C&D、E&F、G&H、J&K。在 1953 年 Nelson 申请专利时，采用了 J&K 的命名方案。 Implementation Flip-flops can be either simple (transparent or asynchronous) or clocked (synchronous); the transparent ones are commonly called latches. The word latch is mainly used for storage elements, while clocked devices are described as flip-flops. 不会翻译了 ... 大意就是说 flip-flop 可以分为两类： simple 也可以说是 透明的 (transparent) 或者是 异步的 (asynchronous)，通常称为 锁存器 Latch clocked 也可以说是 同步的 (synchronous)，称为 触发器 flip-flop 下面分类讨论： Latch Latch 可以由一对真空管、三极管、场效应管组成，在实际应用中也可以用逻辑门组成 latch。 SR Latch 当使用逻辑门搭建模块时，最基本的 latch 就是 SR latch (set-reset latch)，所有的 latch 和 flip-flop 都是建立在它的基础之上。 SR latch 的实现可以有两种方案： SR NOR Latch 使用或非门搭建： 功能表： S'R' NAND Latch 使用与非门搭建： 功能表： D Latch Latch 是 透明的 (transparent) ，就是说输入的变换立即就能传递到输出端口，当几个透明的 latch 级联时，输入端的信号也能立即传递到输出端。当给 latch 添加额外的逻辑电路（比如使能信号 enable 无效时），就会使它变为 不透明的 (non-transparent) 。下面的 D latch 就是这样的例子。 仔细观察 SR latch 的功能表，就可以发现，R 的取值为 S 的补。D latch 利用了这一特点，而且避免了 SR latch 中的禁止状态的出现。 因为 SR latch 的实现有两种，所以 D latch 的实现也对应有两种： NOR D Latch NAND D Latch D latch 的功能表： D latch 也称为 non-transparent、data latch、gated latch。它有一个数据输入端和一个使能端 enable(clock、control)。之所以叫透明，是因为当它使能时，输入端口的信号立刻就能传递到输出端口。 Flip-Flop 如果 D latch 的控制端口加入时钟信号，就得到了基本触发器，只要时钟信号 CP = 1，则触发器就会受到触发，当 CP 保持为 1 时，数据输入端口的任何变化都将影响到 latch 的状态。 latch 的这个特点应用到 时序电路中，就会出现比较严重的问题： 一般时序逻辑的输出会经过组合电路的反馈通道，返回到时序逻辑的输入。当时钟信号有效时，latch 的输出通过组合电路反馈到 latch 的输入端，如果经过组合逻辑后，反馈的信号和之前的信号不同，则反馈信号会导致 latch 的输出变为新的值。在时钟信号有效的期间内，latch 的输出一直在变化，出现了不可预测的结果，这是不可靠的工作。 latch 的 问题 就在于： 它在时钟有效期间内一直在被触发，这种触发时间过长。 这个问题的 解决方法 就是： 将触发条件变为时钟沿触发，这样就得到了触发器 flip-flop D flip-flop 将 latch 改造为边沿敏感的触发器，最简单的就是 D flip-flop (data or delay)，搭建电路最经济有效的方法就是使用 DFF，因为它需要的门电路最少，其他类型的触发器都是在 DFF 的基础上得到的。 实现 DFF 可以有两种方法： Classical positive-edge-triggered D flip-flop Master–slave edge-triggered D flip-flop clk = 1 时，master D-latch 使能，D 传递到输出端 Q； clk = 0 时，slave D-latch 使能，输入 D (master D-latch 的输出 Q) 传递到输出 Q； 可以看到，当 clk 从 1 变为 0 时，输入端的 D 才传递到输出端 Q，也就是说在时钟的下降沿才触发，其他时刻都保持输出不变。（如果需要上升沿触发，只需要在 clk 输入端键入一个反相器） DFF 的特点就是在时钟信号的特定点触发（上升沿 or 下降沿），功能表： JK flip-flop 在 DFF 的基础上，可以得到 JK FF。 JK FF 的特点和 SR latch 类似，可以将 J 看作是 S，K 看作是 R，它和 SR latch 的区别在于它是边沿触发，并且将 S = R = 1 状态设置为 翻转 (toggle) ，也就是在下一个时钟边沿，输出取反。当 J = K = 0 时，得到的并不是 DFF，而是保持输出不变。 功能表： T flip-flop 将 JK FF 的输入端 J 和 K 连接到一起，就可以得到 T FF (toggle flip-flop)。 当 T = 0 (J = K = 0) 时，输出保持不变，时钟边沿不影响状态；当 T = 1 (J = K = 1) 时，在时钟边沿输出反相，也就是翻转。 功能表： 可以看到 TFF 有 1/2 分频的作用，这一特点在很多电路中得到了应用。 Timing considerations Metastability 伴随着 flip-flop 的一个问题是 亚稳态 Metastability 。当两个输入端口 ( 比如 data 和 clk，或者 reset 和 clk) 同时变化时，就会发生亚稳态的问题，需要消耗更长的时间来使输出达到稳定状态，而且这个稳定状态是不可预测的，有可能是 1，也有可能是 0。 在计算机系统中，如果发生亚稳态，如果在下一个时钟使用数据时，还没有达到稳定状态，会导致数据传输错误或者程序崩溃。如果有两条路径同时用到了这个数据，有可能一条将它当作 1，另一条把它当作 0，这样会导致系统进入不一致的状态。 Setup, hold, recovery, removal times Setup time is the minimum amount of time the data signal should be held steady before the clock event so that the data are reliably sampled by the clock. This applies to synchronous input signals to the flip-flop. Hold time is the minimum amount of time the data signal should be held steady after the clock event so that the data are reliably sampled. This applies to synchronous input signals to the flip-flop. Synchronous signals (like Data) should be held steady from the set-up time to the hold time, where both times are relative to the clock signal. 如图所示，对于同步信号 ( 同步信号的意思是想对于时钟信号而言，它的变化和时钟是同步的，比如 data)，必须满足 setup time 和 hold time 要求。 在有效时钟沿到来之前的 setup time 时间段内，同步信号必须保持稳定，在有效时钟沿到来之后的 hold time 时间段内，同步信号也必须保持稳定，也就是说从 setup time 到 hold time 之间，它必须保持稳定不变化，这样才能让时钟信号采样到正确的值。 同理，对于异步信号，有类似的要求： Recovery time is like setup time for asynchronous ports (set, reset). It is the time available between the asynchronous signals going inactive and the active clock edge. Removal time is like hold time for asynchronous ports (set, reset). It is the time between active clock edge and asynchronous signal going inactive. 找到一个更清晰的解释： Recovery time is the minimum length of time an asynchronous control signal, for example, and preset, must be stable before the next active clock edge. The recovery slack time calculation is similar to the clock setup slack time calculation, but it applies asynchronous control signals. Removal time is the minimum length of time an asynchronous control signal must be stable after the active clock edge. The TimeQuest analyzer removal time slack calculation is similar to the clock hold slack calculation, but it applies asynchronous control signals. recovery time specifies the time the inactive edge of the asynchronous signal has to arrive before the closing edge of the clock. Removal time specifies the length of time the active phase of the asynchronous signal has to be held after the closing edge of the clock. 也就是说 Recovery / Removal time 类似于 Setup / Hold Time，不过是用于异步信号，比如 set，reset 信号。 如图所示，在时钟沿到来之前的 recovery time 之前，异步信号必须释放 ( 变无效 )，在时钟沿到来之后的 removal time 之后，异步信号才能变有效，也就是说在从 recovery time 到 removal time 这段时间内，异步信号是不能有效的。 如果使 flip-flop 的输入满足 setup time 和 hold time，那么就可以避免亚稳态的出现，一般器件的手册上都会标明这些参数，从几 ns 到几百 ps 之间。根据 flip-flop 内的组织情况而定，有时候可以将 setup time 或者 hold time 两者中的一个（只能是其中之一）变为 0 甚至是负数。 但是，并不是总能满足这一标准，因为有可能 flip-flop 的输入端连到了外界的，设计者无法控制的一个不断变化的信号，这时候设计者所能做的事就是根据电路要求，将发生错误的概率降低到一个确定的水平。通常使用的方法就是将信号通过一条链在一起的 flip-flop 组，这样子可以将发生亚稳态的概率降低到一个可以忽略的程度，但是还是不等于 0。链中的 flip-flop 越多，这个概率就越趋近于 0，通常的情况是采用 1 个或者两个 flip-flop。 即使现在出现了所谓的 metastable-hardened flip-flops ，它可以尽可能地减小 setup time 和 hold time，但是仍然无法完全避免问题的出现。 这是因为亚稳态并不是简单的设计方法上的问题。 当时钟信号和其他信号在相隔很近的时间内变化，flip-flop 必须判断哪一个先发生变化，哪一个后发生变化，无论我们的器件速度有多快，仍然有可能出现两者相隔的太近，以至于无法判断。所以理论上是不可能造出一个完美避免亚稳态的 flip-flop。 Propagation delay flip-flop 还有一个参数叫做 clock-to-output delay (common symbol in data sheets: tco ) 或者是 propagation delay ( tp )，表示的是 flip-flop 从有效时钟沿开始到输出发生变化所消耗的时间。有时候从高电平变为低电平的时间 (high-to-low transition, tPHL)) 和从低电平变为高电平的时间 (low-to-high transition, tPLH) 不相等。 当用同一时钟来驱动级联的 flip-flop ( 比如移位寄存器 shift register) 时，必须保证前一级的 tco 要大于后一级的 th。这是因为必须要保证前一级的数据能够正确移位到后一级中。当有效时钟沿到来时，前后两级的 ff 在同时变化，采样前一级的输出作为本级的输入，然后经过 tco 输出更新的值。当后一级 ff 在 tsu 到 th 段内采样时，必须保证前一级的输出保持不变，也就是说前一级 ff 的响应速度不能太快，至少要等后一级正确采样完成之后才能变化，即 tco > th 。如果采用物理构造完全相同的 ff，那么通常是可以保证这一条件的。 in FPGA latch 和 flip-flop 的特点决定了它们各自的应用场景 latch 的优点： 面积比 ff 小 门电路是构建组合逻辑电路的基础，而锁存器和触发器是构建时序逻辑电路的基础。门电路是由晶体管构成的，锁存器是由门电路构成的，而触发器是由锁存器构成的。也就是 晶体管 -> 门电路 -> 锁存器 -> 触发器，前一级是后一级的基础。latch 完成同一个功能所需要的门较触发器要少，所以在 asic 中用的较多。 速度比 ff 快 用在地址锁存是很合适的，不过一定要保证所有的 latch 信号源的质量，锁存器在 CPU 设计中很常见，正是由于它的应用使得 CPU 的速度比外部 IO 部件逻辑快许多。 latch 的缺点： 电平触发，非同步设计，受布线延迟影响较大，很难保证输出没有毛刺产生 latch 将静态时序分析变得极为复杂 flip-flop 的优点： 边沿触发，同步设计，不容易受毛刺的印象 时序分析简单 flip-flop 的缺点： 面积比 latch 大，消耗的门电路比 latch 多 目前 latch 只在极高端的电路中使用，如 intel 的 P4 等 CPU。而在 PLD / FPGA 中，基本单元 LE 是查找表 LUT 和触发器 FF 组成的，如果要实现 latch，反而需要更多的资源。 一般的设计规则是： 在绝大多数设计中避免产生 latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch 最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用 DFF 的地方，就不用 latch。 Reason & Solution to unexpected latch 在电路设计中，要对 Latch 特别谨慎，如果综合出和设计意图不一致的 Latch，会导致设计错误，包括仿真和综合。因此，要避免产生意外的 Latch。 Reason 如果组合逻辑完全不使用 always 语句，那么就不会产生 latch，比如 1 assign dout = din ? x : y ; 电路不需要保存 dout 的前一个值，所以不会产生 latch。 如果组合逻辑使用了 always 语句，那么就有可能产生 Latch ： 不完整的 if-else code: 1 2 3 4 5 always @( din_a or din_b ) begin if ( din_a ) begin dout = din_b ; end end RTL Schematic: 不完整的 case code: 1 2 3 4 5 6 always @( din_c or din_a or din_b ) begin case ( din_c ) 2 'b00 : dout = din_a ; 2 'b01 : dout = din_b ; endcase end RTL Schematic: Solution 知道了原因，那么解决方法也就显而易见了： 使用完整的 if-else code: 1 2 3 4 5 6 7 8 always @( din_a or din_b ) begin if ( din_a ) begin dout = din_b ; end else begin dout = din_a ; end end RTL Schematic: 使用完整的 case，添加 default 分支 code: 1 2 3 4 5 6 7 always @( din_c or din_a or din_b ) begin case ( din_c ) 2 'b00 : dout = din_a ; 2 'b01 : dout = din_b ; default : dout = 2 'b00 ; endcase end RTL Schemtatic: Application 《Verilog HDL 程序设计与实践》 笔记： latch 作为一种电路单元 , 必然有其存在的理由以及应用场景 , 并不像目前的很多书籍简单地将锁存器列为 \" 头等敌人 \"。其实在实际中 , 有些设计是不可避免地要用到锁存器 , 特别是在总线应用上 , 锁存器能提高驱动能力、隔离前后级。例如 , 常见的应用包括地址锁存器、数据锁存器以及复位信号锁存器等。但在更多的情况下 , 很容易在代码中产生未预料到的锁存器 , 使得逻辑功能不满足要求 , 浪费了大量的调试时间 , 从而使得大多数设计人员 \" 闻虎色变 \"。 因此较好的应用规则是 : 要学会分析是否需要锁存器以及代码是否会产生意想不到的锁存器。只有这样才能灵活运用锁存器。 下面通过实例来给予说明。 example1 : 通过 Verilog HDL 实现序列最大值搜索程序，并保持检测到的最大值 module latch_demo ( din , dout ) ; input [ 7 : 0 ] din ; output [ 7 : 0 ] dout ; reg [ 7 : 0 ] dout ; always @ ( din ) begin if ( din > 127 ) dout = din ; end endmodule 上述代码在 ISE 中的综合结果会给出设计中包含 Latch 的警告。但实际上，abmax_tmp 锁存器正是我们需要的，所以，虽然有警告，但是代码设计是没有问题的。将上述代码的 if 语句补全： if ( a > abmax_tmp ) abmax_tmp = a ; else abmax_tmp = abmax_tmp ; 经过综合后，仍然有 Latch 的警告。无论 Latch 是否是用户需要的，ISE 都会给出警告，主要原因就是 Latch 对整个设计的时序性能影响较大。所以，在设计中要尽量避免 Latch，但是确实需要使用的情况，也可以使用。 example2: 用 Verilog HDL 实现一个锁存器，当输入数据大于 127 时，将输入数据输出，否则输出 0 不期望的 latch 指的是与设计意图不符，产生的 Latch。主要问题在于设计人员没有合理使用 Verilog HDL 语言，常见的原因是对条件语句（if、casse）的分支描述不完整，导致电路的功能不是预期的，发生了错误。 module latch_demo ( din , dout ) ; input [ 7 : 0 ] din ; output [ 7 : 0 ] dout ; reg [ 7 : 0 ] dout ; always @ ( din ) begin if ( din > 127 ) dout = din ; end endmodule 综合后的结果，在比较器后面级联了锁存器，这是因为 if 语句缺少 else 分支造成的。查看仿真结果，当输入小于 127 时，输出保持了上次的 127，不是 0，没有达到设计要求。修改方法很简单，就是将 if-else 补全。 if ( din > 127 ) dout = din ; else dout = 0 ; 在 ISE 中综合后的结果中，可以看到补全 if-else 后，在比较器后面级联了与门，代替原来的锁存器，仿真结果也正确。 Conclusion 锁存器 latch 是一种基本电路单元 , 会影响到电路的时序性能 , 应该尽量避免使用 , 但出现锁存器造成设计和原始意图不符的情况 , 则是由于设计人员代码输入不正确造成的。 Reference Flip-flop (electronics) --wikipedia 数字设计 Verilog HDL 程序设计与实践 锁存器、触发器、寄存器和缓冲器的区别","tags":"IC","loc":"https://qiangu.cool/posts/ic/latch_versus_flip_flop.html","title":"锁存器 Latch v.s. 触发器 Flip-Flop"},{"url":"https://qiangu.cool/posts/ic/vhdl_notes_2_system_design.html","text":"总结 packege , component , function , procedure 的相关知识。 这些组成部分添加到代码主体部分，目的是为了实现常用代码共享。通常这些代码被放在 library 中，我们可以将自己设计的一些常用代码添加到 library 中，这有利于使一个复杂设计具有更清晰的结构。 总之，经常使用的代码可以以 component , function , procedure 的形式放到 package 中，然后被编译到目标 library 中。 Packages and Components Package 除了 component , function , procedure 之外，package 中还可以包含 TYPE , CONSTANT 的定义。 syntax 1 2 3 4 5 6 7 PACKAGE package_name IS ( declarations ) END package_name ; [ PACKAGE BODY package_name IS ( FUNCTION and PROCEDURE descriptions ) END package_name ; ] 可以看到，语法包括两部分， PACKAGE 和 PACKAGE BODY 。 PACKAGE 是必需的，包括所有的声明语句 PACKAGE BODY ：可选，当第一部分包含一个 / 多个 FUNCTION，PROCEDURE 声明时，这部分必须包含相应的描述代码。 example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 --------- package define------------- LIRRARY IEEE ; USE IDEE.STD_LOGIC_1164. ALL ; PACKAGE my_package IS TYPE state IS ( st1 , st2 , st3 , st4 ); CONSTANT vec : STD_LOGIC_VECTOR ( 7 DOWNTO 0 ) := \"11111111\" ; END my_package ; --------- main code ------------------ LIBRARY IEEE ; USE IEEE.STD_LOGIC_1164. ALL ; USE work.my_package. all ; -- declaration ENTITY ... ... ARCHITECTURE ... ... -------------------------------------- Componet VHDL 中的 component 和 Verilog HDL 中的 module 类似： 一个 component 是一段完整的代码（包括 library, entity, architecture 这些组成部分），如果将这些代码声明为一个 component，那么就可以被其他电路调用，从而使代码具有了层次化的结构。 使用 component 必须先声明这个元件，然后再例化这个元件（类似 C++，变量先声明，在定义）。声明和例化都必须在 architecture 中进行。 declaration syntax 1 2 3 4 5 6 COMPONENT component_name IS PORT ( port_name : signal_mode signal_type ; port_name : signal_mode signal_type ; ...); END COMPONENT ; instantiation syntax 1 label : component_name PORT MAP ( port_list ); 可以看到： 声明时，component 和 entity 相似，必须声明端口的模式和类型 例化时，必须添加一个标号，就像 Verilog HDL 中例化 module 必须给个名字一样 声明元件时，可以有两种方法： 上面的方法，先声明再例化 使用 package 进行声明，将 component 的声明放在 package 中，则可以避免每次元件例化都要重复声明 这两种方法的区别类似于使用 C++ 中的 namespace 时的不同方法 方法一：每次使用 STL 都添加作用域 1 std :: cout << \"hello world!\" << std :: endl ; 方法二：声明一次作用域 1 using namespace std ; port map 同 Verilog HDL 一样，两种端口映射的方法：位置映射、名字映射。 位置映射书写简单，但是容易出错；名字映射书写繁琐，但是不易出错，端口连接也更清晰，未连接的端口要使用关键词 open 。 example 1 2 3 4 5 -- positional U1 : inverter PORT MAP ( x , y ); -- nominal U1 : inverter PORT MAP ( x => a , y => b ); generic map generic 功能类似于 Veriog HDL 中的 parameter，所以在例化时 component 时，可以重载参数，使设计更方便灵活。 syntax 1 label : component_name GENERIC MAP ( param . list ) PORT MAP ( port list ); 也就是说，在例化时，添加一段 GENERIC MAP (param.list) 就可以了。 Functions and Procedure function 和 procedure 统称为 子程序，它们和 process 相似，内部包含的都是顺序描述的代码，通常使用相同的顺序描述语句。但是，function 和 procedure 的存在主要是为了建库，以达到代码重用和共享的目的，当然它们也可以直接建立在主代码中。 Function 一个 function 就是一段顺序描述的代码。 在写代码的过程中，我们通常会遇到一些有共性的问题，我们希望实现这些功能的代码可以被共享和重用，从而使代码变得简洁，易于理解，function 的建立和使用就能达到这个目睹。 function 中可以使用 if , case , loop 等语句，但是不能有 signal 和 component 。 function 的使用方法：先创建函数体本身，再调用函数。 Function Body 1 2 3 4 5 FUNCTION function_name [ < parameter list > ] RETURN data_type IS [ declarations ] BEGIN ( sequential statements ) END function_name ; 其中， 指函数的输入参数： < parameter list > = [ CONSTANT ] constant_name : constant_type ; < parameter list > = SIGNAL signal_name : signal_type ; 参数可以是 constant, signal，但是不能是 variable；参数的个数可以是任意个，类型也任意。 Function Call 函数可以单独构成表达式，也可以作为表达式的一部分。 1 2 3 --example x <= conv_integer ( a ); if x > maximum ( a , b ) ... Function Location 函数可以存放在两个地方： Package 中，这时候，函数声明在 package 中，函数定义在 package body 中 Main Code 中，既可以在 entity 中，也可以在 architecture 中 Procedure procedure 和 function 类似，目的也相同，不同之处在于 procedure 可以有多个返回值。 与 function 类似，procedure 也需要定义和调用两个过程。 Procedure Body 1 2 3 4 5 PROCEDURE procedure_name [ < parameter list > ] IS [ declarations ] BEGIN ( sequential statements ) END procedure_name ; 其中， 指出了 procedure 的输入输出参数： 1 2 3 < parameter list > = [ CONSTANT ] constant_name : mode type ; < parameter list > = SIGNAL signal_name : mode type ; < parameter list > = VARIABLE variable_name : mode type ; 参数可以有任意多个，可以是 in, out, inout 模式的 signal, variable, constant。 和 function 一样，procedure 内部的 wait 语句，signal 声明，component 调用都是不可综合的。 Procedure Call procedure 的调用就是它自己。 1 2 3 --example compute_min_max ( in1 , in2 , in3 , out1 , out2 ); divide ( dividend , divisor , quotient , remainder ); Procedure Location procedure 的存放和 function 类似，通常放在 package 中，当然也可以放在主代码中。 FUNCTION versus PROCEDURE Summary function 有任意个输入参数和一个返回值，输入参数只能是 constant, signal procedure 有任意个输入 / 输出 / 双向参数，可以是 signal, variable, constant function 可以作为表达式的一部分，procedure 直接调用 function 和 procedure 内部，wait 和 component 都不可综合 function 和 procedure 的存放位置相同，经常位于 package 中，也可以在主代码中 Reference Circuit Design with VHDL","tags":"IC","loc":"https://qiangu.cool/posts/ic/vhdl_notes_2_system_design.html","title":"VHDL 笔记 2 —— 系统设计"},{"url":"https://qiangu.cool/posts/ic/vhdl_notes_1_circuit_design.html","text":"Code Structure 一段独立的 VHDL 代码一般至少由 3 部分组成： LIBRARY declarations 、 ENTITY 、 ARCHITECTURE Library 用来设计重用和代码共享，使代码结构更清晰 1 2 LIBRARY library_name ; USE library_name.package_name.package_parts ; 常用的 3 个 Library： ieee 、 std 、 work 其中 std 和 work 是默认可见的，不需声明，ieee 需要明确的声明 Entity 描述电路的输入 / 输出引脚 1 2 3 4 5 6 ENTITY entity_name IS PORT ( port_name : signal_mode signal_type ; port_name : signal_mode signal_type ; ...); END entity_name ; singal_mode 可以是 4 种类型： in out inout buffer OUT 模式无法回读到电路内部， Buffer 模式可以，但是 buffer 不能连接到其他类型的端口，即不能把该模块作为子模块例化，一般使用中间缓冲信号，解决回读问题。 Architecture 描述电路的行为和实现的功能 Architecture 包含两部分：声明部分和代码部分 声明部分（可选）用来声明信号、常量等 代码部分（begin ... end）描述电路行为 注释行用 -- 开始 VHDL 不区分大小写 Data Types 前面的 Entity 中的端口定义： 1 port_name : signal_mode signal_type ; 还有其它地方声明的信号 signal : 1 signal name : type [ range ] [ := initial_value ]; 还有 常量 constant 声明： 1 constant name : type := value ; 还有 变量 variable 声明： 1 variable name : type [ range ] [ := initial_value ]; 这些声明中都包含了数据类型字段。一个信号 / 常量 / 变量的数据类型决定了它能取到什么样的值，还有可以进行什么样的操作。 Pre-defined Data Types IEEE 1164 标准中包含了一些预先定义的数据类型。 std 库中的 standard 包集 (package) 定义了： bit 、 boolean 、 integer 、 real 类型 ieee 库中的 std_logic_1164 包集定义了： std_logic 、 std_ulogic 类型 ieee 库中的 std_logic_arith 包集定义了： signed 、 unsigned 类型，还有一些数据类型转换函数 ieee 库中的 std_logic_signed 和 std_logic_unsigned 包集：包含一些函数，可以使 std_logic_vector 类型的数据可以像 signed 和 unsigned 一样进行运算 bit & bit_vector 用 '0' 和 '1' 赋值 1 2 3 4 5 signal x : bit ; signal y : bit_vector ( 3 downto 0 ); x <= '1' ; y <= \"0011\" std_logic & std_logic_vector ieee 1164 标准中引入的 8 逻辑值系统 不同于 bit 类型，可以取 8 种不同的值，但只有 0 、 1 、 Z 是可综合的，其他 5 种用来仿真 std_ulogic & std_ulogic_vector ieee 1164 标准中定义的具有 9 种逻辑值的数据类型 std_logic 是 std_ulogic 的子集 boolean 只有两种取值： true 、 false integer 32 位的整数 (-2 147 483 647 ~ +2 147 483 647) natural 非负整数 (0 ~ +2 147483 647) real 实数，不可综合 physical literal 表示物理量，不可综合 character 单一 / 一串 ASCII 字符 signed & unsigned ieee 库中的 std_logic_arith 包中定义的数据类型 和 std_logic_vector 类似，但是可以支持与整数类似的算术运算。 User-defined Data Types 1 2 3 4 5 6 -- integer TYPE student_grade IS RANGE 0 TO 100 ; -- enumerated TYPE state IS ( idle , forward , backward , stop ); TYPE color IS ( red , green , blue , white ); Subtypes 1 2 SUBTYPE my_color IS color RANGE red TO blue ; -- my_color = (red, green, blue); Arrays 可以认为 VHDL 预定义的数据类型只有 scalar (single bit) 和 vector (one-dimensional array of bits) 两种类型。 这两种类型中只有一下类型是可综合的： scalars: bit, std_logic, std_ulogic, boolean vectors: bit_vector, std_logic_vector, std_ulogic_vector, integer, signed, unsigned syntax: 1 TYPE type_name IS ARRAY ( specification ) OF data_type ; example: 1 2 3 4 --1D array TYPE matrix IS ARRAY ( 0 TO 3 ) OF STD_LOGIC_VECTOR ( 7 DOWNTO 0 ); --2D array TYPE matrix2D IS ARRAY ( 0 TO 3 , 7 DOWNTO 0 ) OF STD_LOGIC ; Port Array 有时在定义端口时，需要把端口定义为矢量阵列。但是在 Entity 中不允许使用 type 定义，所以我们必须自己定义包集 (package)，然后使用 use 声明使用该用户自定义的包集，最后才能在 Entity 中使用这种新定义的类型。 Signed and Unsigned Data Types ieee 库中的 std_logic_arith 包中定义了有符号数 ( signed ) 和无符号数 ( unsigned ) 两种数据类型。 只有先声明使用这个库下的包，才能在代码中使用 signed/unsigned 1 2 3 4 use ieee.std_logic_arith. all ; signal x signed ( 7 downto 0 ); signal y unsigned ( 0 to 3 ); 使用它们主要是为了进行算术运算，但是它们不支持逻辑运算。( std_logic_vector 不支持算术运算，但是支持逻辑运算 ) 如果信号的类型只能是 std_logic_vector，那么通过其他方法也是可以进行算术运算的，解决方案就是声明使用 ieee 的 std_logic_unsigned 和 std_logic_signed 两个包集，声明之后，std_logic_vector 就可以像 signed/unsigned 一样进行算术运算了。 1 2 3 4 5 6 7 8 9 use ieee.std_logic_signed. all ; -- use ieee.std_logic_unsigned.all; signal a in std_logic_vector ( 7 downto 0 ); signal b in std_logic_vector ( 7 downto 0 ); signal x out std_logic_vector ( 7 downto 0 ); x <= a + b ; --legal, arithmetic x <= a and b ; --legal, logiccal 需要注意的是，这两个包不能同时存在于同一份代码中，因为这样会引入二义性。比如上面例子中的 \"+\" 运算，如果我们同时包含了这两个包集，那么编译器不知道我们定义的运算到底应该重载哪一个，综合时会报错。 Data Conversion 在 VHDL 中，不同类型的数据是不能直接进行算术 / 逻辑运算的，所以必要时必须进行类型转换操作。 有两种方法实现类型转换： 使用包中预定义的数据类型转换函数 手动写一段专门用于数据类型转换的代码 std_logic_arith 中包含了很多数据类型转换函数，可以实现不同数据之间的转换。 Operators and Attributes VHDL 语法虽然枯燥无味，但是只有对数据类型、运算操作符及其属性有了深刻认识，才能写出高质量和高效率的代码。 Opreators VHDL 提供了 6 种预定义的预算符： 赋值 assignment 逻辑 logical 算术 arithmetic 关系 relational 移位 shift 并置 concatenation assignment 一共 3 种： <= 用于给 signal 对象赋值 := 用于给 variable , constant , generic 赋值，还可用于赋初值 => 用于给矢量 (vector) 对象的某些位赋值，常和 others 一起使用 logical 进行逻辑运算，操作数必须是 bit , std_logic , std_ulogic 类型或者它们的扩展，即 bit_vector , std_logic_vector , std_ulogic 类型。 NOT , AND , OR , NAND , NOR , XOR arithmetic 操作数是 signed , unsigned , integer , real ，其中 real 类型是不可综合的 如果声明了 std_logic_signed 或者 std_logic_unsigned ，则 std_logic_vector 类型也可以进行加减运算。 + , - , * , / , ** , MOD , REM , ABS comparison 一共有 6 种： = , /= , > , < , >= , <= shift VHDL93 中引入的操作，语法： 1 < left operand >< shift operator >< right operand > ; left operand 必须是 bit_vector 类型 right operand 必须是 integer 类型 shift operator 有： sll , srl , sla , sra , rol , ror concatenation 用于位的拼接。 操作数：任何支持逻辑运算的数据类型 操作符： & , (, , ,) Attributes VHDL 中的属性语句可以获得相关数据 / 对象 的信息，使代码更加灵活。 Pre-defined 内置的预定义属性可以分为两大类：数值类属性 和 信号类属性。 data attributes signal attributes 大多数信号类属性都是不可综合的，只有 s'event 和 s'stable 是可综合的。 User-defined 也可以用户自己定义一个新的属性，并描述某个对象的这个属性的值是多少，之后就可以使用这个属性了。 syntax 1 2 ATTRIBUTE attribute_name : attribute_type ; -- declaration ATTIRBUTE attribute_name OF target_name : class IS value ; -- specification example： 1 2 3 4 ATTRIBUTE number_of_inputs : INTEGER ; ATTRIBUTE number_of_inputs OF nand3 : SIGNAL IS 3 ; input <= nand3 'number_of_inputs ; 首先定义了一个新的属性，名字叫 number_of_inputs ，表示输入端口的个数，然后针对对象 nand3 (3 输入的与非门 ) 这个对象，描述它的这个属性的类型为 signal 类型，取值为 3；最后，使用这个属性，将 nand3 的这个属性的值赋值给 input 对象。 Operator Overloading 用户不仅可以自定义属性，还可以自定义操作符。预定义的操作符的操作数必须是特定的类型，对于某些类型，我们可以自定义操作符对应的操作。 VHDL 中的自定义操作符作用和 C++ 中的操作符重载 方法、目的都很类似。首先构造一个函数，然后调用这个函数即可。 GENERIC generic 必须在 ENTITY 中声明，它可以指定常规参数，所指定的参数是 静态的 ， 全局的 。感觉类似于 Verilog 中的 define 吧，但是显然 Verilog 中的 parameter 是更好的设计，因为全局变量 / 常量很不安全。 syntax 1 GENERIC ( parameter_name : parameter_type := parameter_value ); example 1 2 3 4 ENTITY my_entity IS GENERIC ( n : INTEGER := 8 ); PORT (...); END my_entity ; Concurrent Code 从本质上讲，HDL 是 描述 (Description) 语言，对应的是硬件电路，而硬件电路是时刻工作的，所以，它的代码是并发执行的。只有 process ， function ， procedure 中的代码是顺序执行的，而且当这些模块作为一个共同的整体时，它们之间也是并行的。 在并发代码中可以使用下列各项： 运算操作符 when 语句（when/else 和 with/select/when） generate 语句 block 语句 仔细观察可以发现，其实 when, generate, block 语句和运算语句相比，只是添加了一些条件判断，它们主要的核心还是运算操作符组成的运算，所以，并行代码的核心就是这些并行的运算语句。 when When/else syntax: 1 2 3 assignment WHEN condition ELSE assignment WHEN condition ELSE ...; with/select/when syntax: 1 2 3 4 WITH identifier SELECT assignment WHEN value , assignment WHEN value , ...; generate 功能类似于 Verilog HDL 中的 generate，它常和 for/if 一起使用。 因为描述的对象是电路，最终的电路是固定的，功能也是静态的，所以，对于 generate，它的循环操作的上下界必须是静态的，否则代码是不可综合的。 实际上，引入 generate 的主要目的是为了写出更加通用的代码，达到修改最少代码，实现不同设计的目的，也就是动态编译。而引入 for 循环，只是为了减少代码量。 block VHDL 中存在两种类型的块 block：简单块 (simple block) 和 卫式块 (guarded block): simple block simple block 只是对原有代码进行了区域分割，目的也仅仅是为了增强代码的可读性和可维护性。 syntax: 1 2 3 4 5 label : BLOCK [ declarative part ] BEGIN ( concurrent statement ) END BLOCK label ; guarded block guarder block 是一种特殊的 block，它比 simple block 多了一个表达式，叫做 guard expression ，只有当这个表达式为 True 时，这个 block 才会执行。 syntax: 1 2 3 4 5 label : BLOCK ( guard expression ) [ declarative part ] BEGIN ( concurrent guarded and unguarded statements ) END BLOCK label ; Sequential Code VHDL 本质是并发执行的代码，但是在 process , function , procedure 内部的代码是顺序执行的，当它们作为一个整体时，相互之间也是并发执行的。 顺序代码并非只能与时序逻辑 ( sequential logic ) 对应，同样也可以用它们来实现组合逻辑 ( combinational logic )。 顺序代码也称为描述代码 ( behavioral code )。 这里主要讨论顺序代码，也就是这 3 个块中的代码，包括 if , wait , case , loop 语句。 process 作用类似于 Verilog HDL 中的 always 语句。 syntax 1 2 3 4 5 [ lable : ] PROCESS ( sensitivity list ) [ VARIABLE name : type [ range ][ := initial_value ;]] BEGIN ( sequential code ) END PROCESS [ label ] ; if syntax 1 2 3 4 5 IF conditions THEN assignments ; ELSIF conditions THEN assignments ; ... ELSE assignments ; END IF ; wait 如果在 process 中使用了 wait 语句，那么 process 就不能含有敏感信号列表了，所以此时 wait 必须是 process 的第一条语句。 syntax1 1 WAIT UNTILL signal_condition ; syntax2 1 WAIT ON signal1 [, signal2 , ...]; syntax3 1 WAIT FOR time ; --simulation only case case 和 when 的区别在于，case 允许在每个测试条件下执行多个赋值操作，而 when 只能执行一个赋值操作。 syntax 1 2 3 4 5 CASE identifier IS WHEN value => assignment ; WHEN value => assignment ; ... END CASE ; loop syntax1: FOR/LOOP repeat a fix number of times 1 2 3 [ label : ] FOR identifier IN range LOOP ( sequential statements ) END LOOP [ label ] ; syntax: WHILE/LOOP 1 2 3 [ label : ] WHILE condition LOOP ( sequential statements ) END LOOP [ label ] ; syntax3: EXIT 1 [ label : ] EXIT [ label ] [ WHEN condition ]; syntax4: NEXT 1 [ label : ] NEXT [ loop_label ] [ WHEN condition ]; Signals & Variables VHDL 提供了 signal 和 variable 两种对象来处理非静态数据；提供了 constant 和 generic 来处理静态数据。 constant 和 signal 是全局的，可以在顺序执行的代码中，也可以在并发执行的代码中； variable 是局部的，只能值顺序代码中，并且它们的值是不能向外传递的 ( 如果想传递出去，必须先把这个变量值传递给一个信号，再由这个信号传递出去 )。 constant constant 可以定义在 package, entity, architecture 中，对应的作用域也不同。 定义在 package 中的 constant 是真正的全局的，可以被所有调用该 package 的 entity 使用 定义在 entity 中的 constant 对于该 entity 的所有 architecture 而言是全局的 定义在 architecture 中的 constant 仅在该 architecture 中是全局的 syntax 1 CONSTANT name : type := value ; signal VHDL 中的 signal 代表的是逻辑电路中的 \" 硬 \" 连线，既可以用于电路的输入输出端口，也可以用于 内部单元之间的连接。 syntax 1 SIGNAL name : type [ range ] [ := initial_value ]; 和 Verilog HDL 的 always 中的 reg 类似，VHDL 的 process 中的 signal 也是在进程结束时更新值。 对同一个信号多次重复赋值，结果取决于编译器。(Xilinx XST 不报错，认为最后一次赋值是有效的 ) variable 相比于 signal 是局部的，variable 只能在 process，function，procedure 中使用，而且对它的赋值是立即更新的，新的值可以在下一行代码中立即使用。 syntax 1 VARIABLE name : type [ range ] [ := initial_value ]; Reference Circuit Design with VHDL","tags":"IC","loc":"https://qiangu.cool/posts/ic/vhdl_notes_1_circuit_design.html","title":"VHDL 笔记 1 —— 电路设计"},{"url":"https://qiangu.cool/posts/ic/the_clock_design_in_fpga_2_clock_design.html","text":"无论是离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字设计，为了成功地操作，可靠的时钟是非常关键的。 设计不良的时钟在极限的温度、电压或者制造工艺的偏差情况下将导致错误的行为，并且调试困难、花销很大。 总结一下 FPGA 中的时钟设计原则。 Clock Design 在 FPGA/CPLD 中通常采用几种时钟类型： 全局时钟 门控时钟 多级逻辑时钟 波动式时钟 多时钟系统能够包括上述 4 种时钟类型的任意组合。 上面是 《Xiliinx FPGA 高级设计及应用》 中的分类方法，个人觉得并不是很清晰，我总结了一下，大概可以分为下面的这 4 种： 全局时钟 Global Clock 门控时钟 Gated Clock 逻辑时钟 Logic Clock 分频 / 倍频时钟 Divied/Multiplied Clock Gloabl Clock 关于全局时钟，前面一篇 blog FPGA 时钟设计 1 —— 时钟资源总结 中有总结。 对于一个项目来说，全局时钟是 最简单 、 最可预测 的时钟。 在 PLD/FPGA 项目中 最好的时钟方案 是：由专用的全局时钟输入引脚驱动的单个主时钟去钟控设计项目中的每一个触发器。只要可能就应该尽量在设计中采用全局时钟 PLD/FPGA 都具有专门的全局时钟引脚，它直接连接到器件中的每一个寄存器，这种全局时钟提供最短的时钟到输出的延时。 Gated Clock 门控时钟的意思是通过组合逻辑，控制、禁止或允许时钟输入到寄存器和其他同步原件上的一种方法。因为它能够有效地降低功耗，所以被广泛地应用于 ASIC 设计中。但是，它不符合 同步设计 的思想，可能会影响系统设计的实现和验证，所以， 在 FPGA 设计中应该避免使用门控时钟。 因为 ASIC 和 FPGA 结构设计上的区别，两者对待门控时钟的态度是完全不同的： Gated clocks and clock enables in FPGA and ASICS 往往可以将门控时钟转化为全局时钟以改善项目设计的可靠性。 方法一 就是使用寄存器 时钟使能 (clock enable, CE) 端口。 单纯从功能来看，使用使能时钟代替门控时钟是一个不错的选项，但是使能时钟在使能信号关闭时，时钟信号仍然工作，它无法像门控时钟那样降低系统的功耗。 推译带使能端的触发器的代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 always @( posedge clk or posedge rst ) begin if ( rst ) begin dout <= 0 ; end else begin if ( ce ) begin dout <= din ; end else begin dout <= dout ; end end end 得到的结果就是原语 FDCE // FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and // Clock Enable (posedge clk). 方法二 使用 多路选择器（mux） 将组合逻辑从时钟通路搬移到数据通路。如下图所示 如果在设计中无法避免门控时钟，那么只要保证满足下面两个条件就可以使门控时钟和全局时钟一样可靠地工作： 驱动时钟的逻辑必须只包含一个与门（或门），而且这个与门（或门）必须只有两个输入端。如果采用任何附加逻辑，则会出现竞争产生的毛刺。 逻辑门的一个输入端为实际时钟。 这些条件的目的就是为了避免组合逻辑中的竞争带来的毛刺。 根据数字电路的知识，我们知道可以通过添加 \" 冗余逻辑 \" 的方法来消除组合逻辑的冒险，但是，FPGA 的编译器在 综合时会去掉这些冗余逻辑，所以不能采用这种方法。 Logic Clock 有时候会用到组合逻辑的输出作为时钟信号或者复位信号，但是这种时钟信号有两个非常重要的缺陷： 组合逻辑产生的信号不可避免地会出现毛刺，会导致系统运行失败。 组合逻辑产生的时钟信号使用的是通用布线资源，和专用时钟布线相比，延迟长、时钟偏移大，满足时序要求会更加困难。如果大量的逻辑使用了这种时钟，这个问题会更加突出。 （看到书上提出一个解决方案是：使用系统专用的时钟信号，将组合逻辑的输出打一拍，避免组合逻辑的直接输出，达到同步的效果。但是我个人认为这个方案不是非常好。） 综上，对于 FPGA 来说，还是应该 尽量避免使用组合逻辑的输出作为时钟 。 Divide/Multiplied Clock Guideline： 尽量避免分频时钟 在我们的设计中，一般都不止一个时钟频率。如果不加注意，随意使用分频时钟，这叫做时钟满天飞，是非常不好的设计风格。 如果一定要使用分频时钟： 对于资源比较丰富的 FPGA 使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频 / 分频）和相位，这样的分频时钟是最稳定的。 对于无法使用 PLL/DLL 的 FPGA 对于这些情况，首先检查是否可以用 CE (clock enable) 来代替分频时钟，如果不行，则使用 时钟分频器 中讨论的分频方法。 Other Tips 只使用时钟的单个边沿 除了一些特殊的电路（如 DDR）外，设计应该只使用单个边沿（上 / 下边沿）。使用两个边沿的问题是时钟占空比不一定是 50%，这会对电路的正常工作产生影响。 使用差分时钟 通常认为频率高于 100 MHz 就属于 高频 。建议在高频下使用差分时钟，因为差分时钟的抗噪声性能更好。 检测时钟缺失 使用 DCM/MMCM 的 locked 输出，在使用时钟前先检查时钟是否锁定。 Reference Xilinx FPGA 高级设计及应用 FPGA 高手设计实战真经 100 则 Xilinx FPGA 开发实用教程 深入浅出玩转 FPGA","tags":"IC","loc":"https://qiangu.cool/posts/ic/the_clock_design_in_fpga_2_clock_design.html","title":"FPGA 时钟设计 2 —— 时钟设计"},{"url":"https://qiangu.cool/posts/telecom/digital_signal_processing_and_matlab.html","text":"学了这么多年的通信，却还是对信号处理的知识一知半解，应付考试还可以，但在实际应用中还是感到力不从心，很多知识都忘了。翻了一下午的 《信号与系统》、《数字信号处理》，简单总结一下。 《信号与系统》算是通信专业最基础的专业课了。 信号部分主要介绍信号的相关定义、分类、常用信号和三大变换：傅立叶变换、拉普拉斯变换和 z 变换。 系统部分主要从时域和频域使用不同的方法分析线性时不变系统（LTI）的性质。 《数字信号处理》算是前一门课的深入，现在利用计算机处理信号，首先就是要将模拟信号数字化，然后进行处理。这门课也就是讲相关的知识。 一般教材就讲两大部分：第一部分首先承接《信号与系统》，时域的连续信号要在计算机中处理就必须采样，变为时域离散信号，这部分就讲离散时间信号的处理，比如 z 变换 和离散傅立叶变换。第二部分讲数字滤波器的设计，包括 FIR 和 IIR 两种。 Signal Processing 这部分是我串联的这两本书中很小的一部分知识，算是一个备忘的笔记吧，作为一名学渣，一个月不看也会忘记不少 =.= 从 《信号与系统》 中我们可以知道： 周期信号 （连续）傅立叶级数 （CFS） 首先，由高数知识可以知道：只要满足 Dirichlet 条件，周期信号就可以进行傅立叶级数分解，可以得到幅度频谱和相位频谱。 时域信号是周期的、连续的，频域信号是离散的。 非周期信号 （连续）傅立叶变换 （CFT) 周期信号的周期无限增大，就可以将周期信号转化为非周期信号，从而得到非周期信号的傅立叶变换。 得到的频率域的结果为连续信号，计算结果为时域信号的频谱密度函数，简称频谱函数。 周期信号 （连续）傅立叶变换 （CFT) 对于周期信号，因为它不满足绝对可积的条件，所以从非周期信号无法直接推广。但是借助 奇异函数 （如冲激函数）的概念，可以使许多不满足绝对可积的信号（如周期信号）存在傅立叶变换。 周期信号的傅立叶变换结果由一些冲激函数组成，冲激函数的强度是对应的傅立叶级数的 2pi 倍，频谱是离散的。 这样，周期信号和非周期信号的傅立叶分析得到了统一。 接下来，就要进入《数字信号处理》部分了： 离散时间信号傅立叶变换 （DTFT) 时域连续信号经过采样，得到离散时间信号，对于离散时间信号，可以从 z 变换中引出 DTFT 的定义。 DTFT 是一种特殊的傅立叶变换（FT），它满足所有的傅立叶变换的性质。 离散傅立叶变换 （DFT） 虽然 DTFT 解决了信号在时域的连续问题，但是变换结果仍然是连续信号，也就是说在频域仍然是连续的，这样计算机仍然是无法处理的。所以，就引出了离散傅立叶级数（DFS) 和离散傅立叶变换（DFT）。 时域信号的周期性对应着频域的离散化，而且时域信号的离散化对应着频域的周期性。由这两点，可以知道周期的离散信号具有离散的、周期的频谱，也就是离散傅立叶级数（DFS）。 把时域和频域的数据长度都限定在主周期，那么就得到了标准的离散傅立叶变换（DFT）。 经过分析，可以知道，DFT 是 z 变换的取样，也是 DTFT 的取样结果。 DFT 因为是离散的，长度有限，所以很适合计算机计算，而且人们发明了高效地计算 DFT 的方法 —— FFT 。 知乎上还有一篇专栏的文章，得到了非常多人的赞同，可以进一步参考。 傅里叶分析之掐死教程（完整版）更新于 2014.06.06 Matlab basic 分析各种变化，可以得到以下的关系： N 点的 DFT（FFT），其结果对应的 数字角频率 w 为 [0, 2pi) 模拟角频率 Ω 为 [0, Ωs) 模拟频率 f 为 [0, fs) 所以对于 N 点 FFT 的结果，对应的横坐标频率的范围为 [0, fs)。 matlab 提供了函数 fft 和 fftshift 直接完成变换。 adv 我们在对一个信号进行采样分析时，首先需要确定两个参数：参数有采样频率 Fs ，采样点数 N ，这两个因素决定了之后可以得到的时频域效果。 假设我们的采样频率为 Fs （采样周期为 T = 1/Fs），一共采了 N 个点，那么相当于对信号进行了截断，截断长度为 L = N * T 秒。这 3 个参数就决定了我们的最终结果。 在信号处理中存在下面的 3 个问题： 频谱混叠。如果信号不是带限的，那么为了减小频谱混叠的影响，我们应该 尽可能提高采样频率 Fs ，而且 Fs 越大，时频域分辨率也越高。 频率分辨率和栅栏效应。因为 DFT 是 DTFT 的等间隔采样，那么 N 越大，采样点数越多，栅栏就越小。为了提高频率分辨率 f0 = Fs/N ，我们应该 尽可能增大 N ，而且为了提高计算效率，N 等于 2 的 M 次方）。 截断效应和频谱泄漏。如果信号是无限长的，那么必须把它截断到长度 L = N*T = N/Fs 。截断会带来吉布斯效应，并且引入窗函数的频谱，造成频谱泄漏。应该 使得 L 包含信号的绝大部分 。 下面举例说明非周期信号和周期信号的分析： 非周期信号 假设我们要分析 tau = 1 的矩形窗函数，我们知道它的频谱，且取第一零点 1/tau = 1 为最高频，假设 8 倍采样，即 Fs = 8 Hz，假设频谱分辨率小于 0.1 Hz 即达到需求，则可以得到 N = 128，此时验证 L = 16 满足条件。由 tau 和 Fs 得到采样点包含 8 个 1 和 120 个 0，所以： 1 2 3 4 5 6 7 8 Fs = 8 ; N = 128 ; x = [ ones ( 1 , 8 ), zeors ( 1 , 120 )]; X = abs ( fftshift ( fft ( x ))); f = [ 0 : N - 1 ] * Fs / N - Fs / 2 ; plot ( f , X ); grid on ; xlabel ( 'f / Hz' ); ylabel ( 'Amplitude Response' ); title ( 'tau = 1 rectangle window' ); 结果如下图： 周期信号 假设信号为 x = 1 + 1/2 cos(2 pi 15 t) + 2 sin(2 pi 40 t)，包含一个直流分量和 f1 = 15, f2 = 40 Hz 的分量，fm = f2 = 40 Hz，若 8 倍采样，有 Fs = fm*8，若 fdelta < 0.1 hz，有 N = 4096，所以： 1 2 3 4 5 6 7 8 9 10 11 12 f1 = 15 ; f2 = 40 ; Fs = f2 * 8 ; w1 = 2 * pi * f1 / Fs ; w2 = 2 * pi * f2 / Fs ; n = 0 : N - 1 ; x = 1 + 1 / 2 * cos ( w1 * n ) + 2 * sin ( w2 * n ); X = abs ( fftshift ( fft ( x ))); f = [ 0 : N - 1 ] * Fs / N - Fs / 2 ; plot ( f , X ); grid on xlabel ( 'f / Hz' ); ylabel ( 'Amplitude Response' ); title ( 'x = 1 + 1/2*cos(w1*n) + 2*sin(w2*n)' ); 结果如下： 综上，我们就有分析一个信号的 通用步骤 ： 首先确定 Fs ：信号的频率信息对于我们是未知的，我们最多只知道信号的带宽，根据信号带宽，我们就可以确定一个采样率 Fs，比如 8 倍采样 确定了 Fs，实际上的 w 就已经确定了，只是我们是不知道它的具体值（因为不知道 fm） 下一步应该确定 N ：由公式 1 和公式 2 可以推出 N = Fs/fm*k 。当 Fs 最小为奈奎斯特采样速率，k = 1 时，N 取到最小值 2，这种情况下虽然没有混叠，但是 fdelta 太大了，不利于观察频谱，应该由 fdelta = Fs/N 决定 N 的最小值 ====================================== 补充一下 FFT 补零 ======================================== 验证程序：假设一个 sin 信号，f = 125， 8 倍采样有 Fs = 1000， N = 8，结果如图： N = 8，补零到 64 点，结果如图： N = 64，结果如图： 直接给结论（上面的图也证明了这些结论）： 在时域的采样序列后面添加后缀 0 ，等效在频域内插。频域内插只能从已有的样点推算，因为采样点数不够丢失的原始信号的信息无法通过内插来补偿。 时域补零实际上改变了采样序列的，所以频域结果和原始信号不同， 补零无法提高频率分辨率，内插出的新分量不是真正物理意义上的频率，是 \" 假频 \"，真正的频率分辨率并没有提高。频率分辨率只能由提高采样点数来提高。 Reference 信号与系统引论 数字信号处理 数字信号处理教程 ——MATLAB 释义与实现","tags":"Telecom","loc":"https://qiangu.cool/posts/telecom/digital_signal_processing_and_matlab.html","title":"数字信号处理和相关matlab函数总结"},{"url":"https://qiangu.cool/posts/ic/xilinx_fft_core_notes.html","text":"关于 FFT 的背景介绍就不再赘述，通原书和网上的教程、课件很多；关于这个 IP 核的介绍也就不再粘贴复制了，原版的 datasheet 必然是最全面的，仅记录我的使用时遇到的问题和需要注意到细节。 IP 核的接口示意图： Timing START / RFD port datasheet 中没有专门描述 start 信号和其他信号的时序关系，只是简单介绍： FFT start signal (Active High): START is asserted to begin the data loading and transform calculation (for the Burst I/O architectures). For Streaming I/O, START begins data loading, which proceeds directly to transform calculation and then data unloading. 在我最开始的测试小程序中，是先判断 rfd 信号，根据 rfd 来给 start 赋值。 思路是：首先必须等 IP core 准备好接收新数据时，才能开始 1 2 3 4 5 6 7 8 9 if ( rfd ) begin start <= 1 ; end else if ( busy ) begin start <= 0 ; end else begin start <= start ; end 但是仿真出来的结果显示 IP core 根本就没有工作，后来改了这两个信号的先后关系， 新思路：程序将输入 start 置有效，通知 IP core 需要调用，然后 IP core 根据自己的状态给出标识信号（rfd / busy），外部电路等到 rfd 有效时才输入需要变换的信号。 1 2 3 4 5 6 7 8 9 10 11 12 13 always @( posedge clk or posedge rst ) begin if ( rst ) begin start <= 1 ; end else begin if ( busy ) begin start <= 0 ; end else begin start <= 1 ; end end end 这样子程序就可以正常运行了。 RFD / DV port 在 datasheet 中给出的时序图如下所示（Burst I/O Solutions with Natural Order Output） 实际仿真图： 实际仿真结果和示意图有一点点小差别：datasheet 中的时序图显示 rfd 必须在等 unload 阶段结束之后才能变有效，输入新的数据；但是实际的仿真图显示，在 unload 的后半段时间，rfd 已经变有效了，开始载入新的数据。 从理论上分析，采用 Burst I/O with Natural Order Output 方案，总共需要 3N 个时钟周期，load 阶段需要 N 个周期载入数据，processing 阶段需要 N 个时钟变换，unload 阶段需要 N 个周期来输出数据。 从仿真结果来看，unload 阶段和下一帧的 load 阶段有部分是重叠的，这样实际上的周期是少于 3N 个时钟的。 虽然功能上是不影响下一帧的数据的，毕竟和预期的时序不同，不知道是否会影响时序设计，有待继续观察。 Port NFFT port 这个 FFT core 是可以设置为 动态重配置的，可以在运行时改变做运算的点数，非常方便，不过有一点需要注意到是重配置的点数是有范围限制的，比如我测试时设置的最大点数为 4096 点，那么运行重配置时，最小的点数为 64。可以选择 64 ~ 4096 之间的任何一个 2 的指数。 由于我一开始忽略了这一点，重配置为 16 点，迷糊了半天，重新打开 IP core 设置时才发现是自己看文档不够仔细 =.= CP port 这个 FFT core 专门提供了一个端口可以设置循环前缀的长度，循环前缀 (cyclic prefix) 在通信中（尤其是 OFDM）是很有用的。 在向导中设置了 cyclic prefix insertion，并且在程序重配置时设置了 CP length = 10，但是仿真结果却没有出现 CP，和 CP = 0 时的结果相同。 仔细看了两遍程序和 datasheet，没有发现问题 ... 待解决！ Update 09/03/2014 又仔细看了两遍 datasheet，终于发现了原因所在。在关于 CP length 部分，最有一小段话一直被我匆匆忽略了： The initial value and reset value of CP_LEN is 0 (no cyclic prefix). The core uses the log2(point size) MSBs of CP_LEN for the cyclic prefix length. So, when the point size decreases, the leftover LSBs are ignored. This effectively scales the cyclic prefix length with the point size, keeping them in approximately constant proportion. However, all bits of CP_LEN are latched into the core on CP_LEN_WE and are used in later transforms if the point size increases. 仔细读了一遍才明白，CP_LEN 起作用的是高位的数据 —— 从 MSB 起共 log2(point size) 位。比如我测试程序设置的最大点数为 4096，这是 CP_LEN 的位宽为 12 比特，但是在程序运行过程中，我重配置为 64 点，所以这时候应该从 CP_LEN 的最高位数起，共 log2(64) = 6 比特数据起作用。如果我想设置 CP 的长度为 8 点，则应该如下 1 cp_len <= 12 'b001000 _000000 ; 这时候，如下图所示，结果与预期相符。 FFT/ IFFT 在 FFT 的测试程序中，一切都正常工作，但是切换为 IFFT 模式，却出现了问题。 datasheet 中介绍，控制正反变换的信号一共有两个： fwd_inv 和 fwd_inv_we 。前者取 1 时为 FFT，取 0 为 IFFT；后者是前者的写使能信号。 因为 FFT 的程序可以正常工作，说明程序逻辑是没有问题的。但是只配置这两个端口，就是有问题。自己研究无果，只能 Google，还真的找到以前有人也遇到同样的问题，并且给出了解决方法（不得不说，还是 Google 好，某度搜出来的结果都是广告和没有用的链接） IFFT of FFT module does not work IFFT in System Generator (blogspot 需翻墙 ) 转原博客部分内容： By default, the FFT block is configured to calculate DFT. The setup and timing of control/data signals for IDFT are the same as DFT except for two things: The FFT block needs to be set up for IDFT by setting fwd_inv_we signal to 1 and fwd_inv signal to 0 before the start of the transform. The FFT output needs to be manually scaled to account for the factor 1/N in Equation 2 above. The scaling can be done either by using the scaling schedule input or shifting the FFT output if the FFT block is set to \"unscaled\". 问题关键就在于第二条，需要手动设置数据缩放，给结果乘以 1/N。 原因就是这个 IP core 在计算 FFT 和 IFFT 时，利用两者表达式上的相似点，使用相同的结构，但是却缺少给 IFFT 的结果乘以 1/N 的步骤，需要用户自己添加。 在 datasheet 中介绍说 The inverse FFT (IFFT) is computed by conjugating the phase factors of the corresponding forward FFT. 但是却没有提到这个额外的 1/N 需要用户自己手动设置，应该算是 Xilinx 的坑。修正这个倍数关系以后，结果就与预期相符了～ （其实如果仔细分析对比 FPGA 和 Matlab 的结果，就能发现两者的差别就是这个 1/N 的倍数关系，只是自己对数字不敏感，又懒得仔细观察 =.=） P.S. Test program FFT IP core 设置 page1: channel = 1 Transform Length = 4096 Radix-4, Burst I/O run time configurable transform length page2: Fix Point Input data width = 24 Phase factor width = 24 block floating point natural output cyclic prefix insertion input data timing - no offset page3: use 3-multiplier structer use CLB logic to implement butterfly arithmetic 运行时重配置 变换长度为 64 点，cp 长度为 10 Matlab 1 2 3 4 5 6 x = [ 0 : 63 ]; y = fft ( x ); re = real ( y ); im = imag ( y ); fprintf ( '%f' , re ); fprintf ( '%f' , im ); Conclusion FFT IP core 仿真结果： 对比 Matlab 中的结果，可以看到 IP core 的计算结果是正确的（除了 CP 的问题）。","tags":"IC","loc":"https://qiangu.cool/posts/ic/xilinx_fft_core_notes.html","title":"Xilinx FFT IP core 笔记"},{"url":"https://qiangu.cool/posts/ic/the_clock_design_in_fpga_1_summary_of_clock_resource.html","text":"关于一款芯片，最权威、最新的资料当然是厂家的官方文件。很多大牛都推荐直接阅读原厂的 datasheet 和 user guide。根据我的体验，这确实是最好的途径。原因有两个： 首先，市面上的书一般都落后业界的步伐，我们看到的很多书上的资料都是过时的。 其次，市面上书（尤其是国内）很多都是简单的翻译手册而来的，而且虽然作者标的是某某大学的教授，事实上都是教授手下的研究生替老师干活翻译的，不能保证翻译的正确性。 实验室有的芯片是 Xilinx 的 Virtex-5 系列，Virtex-5 的 User Guide 是 UG190 ，以下内容都是从中摘抄的笔记。 Three Types of clock resource Global Clocks 为了时钟目的，每个 Virtex-5 系列的器件内部都被分成不同的区域（regions），随着器件的尺寸不同，最小的有 8 个区域，最大的有 24 个区域。 全局时钟资源（Global I/O）和局部时钟资源可以完成所有的复杂的 / 简单的时钟要求。 不推荐使用其他的非时钟资源（比如局部布线资源）来完成时钟功能。 每个 Virtex-5 系列的器件都有 32 条全局时钟线 （global clock line），可以驱动片上的所有时序资源（CLB、BRAM、CMTs、I/O），也可以驱动其他的逻辑信号。 这些全局时钟线可以用在任何一个区域中。 全局时钟线只能由全局时钟缓冲器（global clock buffer）驱动。 全局时钟缓冲器一般由时钟管理块（Clock Management Tile, CMT）驱动，以减少时钟布线延时或者调整和另外一个时钟的相对延时。 全局时钟的个数比 CMTs 多，但是一个 CMT 可以驱动多个全局时钟。 Regional Clocks 每个区域（region）含有 2 个局部时钟缓冲器（regional clock buffer）和 4 个局部时钟树（regional clock tree）。 除了处于芯片中心列的组（bank）外，一个 Virtex -5 I/O bank 恰好横跨一个区域。大小和区域完全相同的每个组含有 4 个 clock-capable 的时钟输入。 每个输入可以差分驱动或单端驱动同一组或区域中的四个 I/O 时 钟（I/O clocks）和两个区域时钟（regional clock）。 I/O clocks 第三种时钟资源是 I/O clocks，可以达到非常高的速度，用于局部的 I/O 串行器 / 解串器。 Global Clocking Resources 全局时钟（global clocks）是个专用网络，是专为覆盖对 FPGA 中各种资源的所有时钟输入设计的。 全局时钟资源包括 Global Clock Inputs Global Clock Buffers Clock Tree and Nets-GCLK Clock Regions Global Clock Inputs Virtex-5 FPGA 包含专用的全局时钟输入位置，这些输入位置即使不用作时钟输入，也可用作常规用户 I/O。 每个器件有 20 个全局时钟输入。 时钟输入可以按任意 I/O 标准配置，包括差分 I/O 标准。每个时钟输入可以是单端输入，也可以是差分输入。 Global Clock Input Buffer Primitives IBUFG，单端输入全局缓冲 IBUFGDS，差分输入全局缓冲 Global Clock Buffers 每个 Virtex-5 器件有 32 个全局时钟缓冲器。 每半个晶片 （上半 / 下半）包含 16 个全局时钟缓冲器。 全局时钟缓冲器允许各种时钟源 / 信号源接入全局时钟树和网。可以输入全局时钟缓冲器的源包括： Global clock inputs Clock Management Tile (CMT) outputs including: Digital Clock Managers (DCMs) Phase-Locked Loops (PLLs) Other global clock buffer outputs General interconnect 全局时钟缓冲器只能由同半个晶片 （上半 / 下半）中的源驱动。 但是，在一个时钟区域中仅能驱动十个不同的时钟。 一个时钟区域 （20 个 CLB）是由上十个 CLB 行和下十个 CLB 行组成的时钟树的一个 枝。 一个时钟区域仅横跨器件的一半。 Global Clock Buffer Primitives BUFGCTRL、BUFG、BUFGCE、BUFGCE_1、BUFGMUX、BUFGMUX_1、BUFGMUX_CTRL 其他所有原语均出自 BUFGCTRL 的软件预设置。 BUFG 全局缓冲 BUFGCE 带有时钟使能（CE）的全局缓冲（BUFG） BUFGMUX 全局时钟选择缓冲 BUFGP = IBUFG + BUFG BUFGDLL 全局缓冲延迟锁相环（舍，被 DCM 代替） Clock Tree and Nets - GCLK Virtex-5 时钟树是为低歪斜和低功耗操作设计的。 任何未用分枝都不连接。 当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。 所有全局时钟线和缓冲器都以差分形式实现，这有助于大大改善占空比和共模噪声抑制能力 在 Virtex-5 架构中，全局时钟线的引脚接入不仅限于逻辑资源的时钟引脚。全局时钟线不用局部互连即可接入 CLB 中的其他引脚。 Clock Regions Virtex-5 器件通过使用时钟区域改善时钟控制分配。 每个时钟区域最多可有十个全局时钟域。 这十个全局时钟可以由 32 个全局时钟缓冲器的任意组合驱动。 How to use global clock Xilinx 芯片全局时钟资源的使用方法主要有 5 种： IBUFG + BUFG 最基本的全局时钟资源使用方法，也称为 \" BUFGP 法 \" IBUFGDS + BUFG 当时钟信号为差分形式时，需要用 IBUFGDS 代替 IBUFG IBUFG + DCM + BUFG 最灵活的使用方法（一般外部提供的时钟都需要倍频、分频、移相等操作以后才可以使用，所以中间需要 DCM） Logic + BUFG BUFG 的输入可以是普通信号，当某个信号（时钟、使能、快速路径）的扇出非常大、要求抖动延迟最小时，可以使用 BUFG 来驱动这个信号，使这个信号利用全局时钟资源。 Logic + DCM + BUFG DCM 的输入也可以是普通信号，所以上面的例子中的信号需要倍频、分频等操作时，需要在中间添加 DCM 。 在具体使用这些组合方式时，有两种例化方式： 在设计中直接例化全局时钟资源 比较简单，按照需求例化上面 5 种组合方式即可。 在综合阶段 / 实现阶段通过约束文件的方式实现 随着综合工具 / 布局布线工具的不同而变化，大多数综合工具会自动分析时钟信号的扇出数目，在全局时钟资源富裕的情况下，使扇出数目最大的信号自动指定使用全局时钟资源。这时候我们必须保证满足下面的原则，否则会报错。如果不能满足，则必须在约束文件中明确声明该信号不使用全局时钟资源。 1 NET \"CLK\" CLOCK_DEDICATED_ROUTE = FALSE ; Principle in Using global clock 原则： 使用 IBUFG / IBUFGDS 的必要条件是信号从全局时钟引脚输入。 也就是说，如果某个信号从全局时钟引脚输入，不管它是否为时钟信号，必须使用 IBUFG/IBUFGDS；如果对某个信号使用了 IBUFG/IBUFGDS，则这个信号必须从全局时钟引脚输入。 原因： 由 Xilinx FPGA 内部结构决定的，IBUFG/IBUFGDS 的输入端仅和芯片的全局时钟引脚有物理连接，与普通的 I/O 和其他内部 CLB 等没有物理连接。 P.S. 第二全局时钟资源 在看其他资料时，看到一种新的时钟资源 —— 第二全局时钟资源。官方的文档我还没有找到，所以就直接摘抄书上的笔记了 =.= 第二全局时钟资源属于长线资源，长度和驱动能力仅次于全局时钟资源，也可以驱动芯片内部的任何一个逻辑，抖动和延时仅次于全局时钟。 在设计中，一般将高频率、高扇出的时钟使能信号以及高速路径上的关键信号指定为全局第二时钟信号。 使用全局时钟资源并不占用逻辑资源，也不影响其他布线资源；第二时钟资源占用的是芯片内部的资源，占用部分逻辑资源，各个部分的布线会相互影响，所以建议在设计中逻辑占用资源不超过 70% 时使用。 使用方法 可以在约束编辑器中的专用约束 Misc 选项中，指定所选信号使用低抖动延迟资源 \"Low Skew\" 来指定，也可以在 ucf 文件中添加 \"USELOWSKEWLINES\" 约束命令。 1 2 3 NET \"s1\" USELOWSKEWLINES ; NET \"s2\" USELOWSKEWLINES ; NET \"s3\" USELOWSKEWLINES ; Regional Clocking Resources 区域时钟网络是一组独立于全局时钟网络的时钟网络。 与全局时钟不同，区域时钟信号 (BUFR) 的跨度限于三个时钟区域，而 I/O 时钟信号只驱动一个区域。 Virtex-5 时钟控制资源和网络由以下通路和组件构成： Clock Capable I/O I/O Clock Buffer (BUFIO) Regional Clock Buffer (BUFR) Regional Clock Nets Clock Capable I/O 典型时钟区域中有四个 clock-capable I/O 引脚对 （中心列有例外）。 有些全局时钟输入也是 clock capable I/O。 每个组中有四个专用 clock capable I/O 区。 当用作时钟输入时，clock-capable 引脚可以驱动 BUFIO 和 BUFR。 这些引脚不能直接连接到全局时钟缓冲器。 I/O Clock Buffer - BUFIO I/O 时钟缓冲器 (BUFIO) 是可以在 Virtex-5 器件中使用的一种时钟缓冲器。 BUFIO 驱动 I/O 列内一个独立于全局时钟资源的专用时钟网。 BUFIO 只能由位于同一时钟区域的 clock capable I/O 驱动。 典型的时钟区域中有四个 BUFIO。 BUFIO 不能驱动逻辑资源 （CLB、Block RAM 等），因为 I/O 时钟网络只能覆盖同一组或时钟区域内的 I/O 列。 BUFIO Primitive BUFIO 其实就是一个时钟输入和时钟输出缓冲器。输入与输出之间有一个相位延迟。 Regional Clock Buffer - BUFR 区域时钟缓冲器 (BUFR) 是可以在 Virtex-5 器件中使用的另一种时钟缓冲器。 BUFR 将时钟信号驱动到时钟区域内一个独立于全局时钟树的专用时钟网。 每个 BUFR 可以驱动其所在区域中的四个区域时钟和相邻区域 （最多三个时钟区域）中的四个时钟网。 与 BUFIO 不同，BUFR 不仅可以驱动其所在时钟区域和相邻时钟区域中的 I/O 逻辑，还可以驱动其中的逻辑资源 （CLB、Block RAM 等）。 典型的时钟区域 （四个区域时钟网络）中有两个 BUFR。中心列没有 BUFR。 BUFR Primitive BUFR 是一个具有输入时钟分频功能的时钟输入 / 时钟输出缓冲器。 Regional Clock Nets 除了全局时钟树和网（global clock trees and nets），Virtex-5 器件还包含区域时钟网（Regional Clock Nets）。 这些时钟树也是为低歪斜和低功耗操作设计的。 未用分枝都不连接。 当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。 区域时钟网的传播并非遍及整个 Virtex-5 器件，而是仅限于一个时钟区域。 一个时钟区域包含四个独立的区域时钟网。 要接入区域时钟网，BUFR 必须例化。 一个 BUFR 最多可以驱动两个相邻时钟区域中的区域时钟。 Clock Management Technology Virtex-5 系列的芯片内部含有的时钟管理模块（Clock Management Tiles，CMTs）可以提供灵活的、高性能的时钟信号。 每个 CMT 由 2 个 DCM 和 1 个 PLL 组成。 DCM DCM 原语有两个：DCM_BASE、DCM_ADV DCM_BASE 提供基本的功能，比如去歪斜、频率合成、固定相移；DCM_ADV 提供更高级的功能，比如动态重配置。 两个原语都有各自的输入输出端口、属性设置和状态标识 DCM 可以连接到芯片上的其他时钟资源，包括专用时钟 I/O，时钟缓冲器和 PLL ==================Update (09/12/2014) 看到一篇介绍 DCM 的 文章 ，很有意思 ================================= About DCM DCM 的内部是 DLL (Delay Lock Loop) 结构，对时钟偏移量的调节是通过长达延时线形成的。 DCM 会把输入时钟 clkin 和 反馈时钟 clkfb 相比较，调节 clkin 和 clk_1x 之间的延时线的数目，直到 clkin 和 clkfb 之间的相位差等于所设置的参数 PHASESHIFT 。如果 clk_1x 和 clkfb 不相关的话，那么就永远不能锁定了。 这个从一开始的不等于到等于所花费的时间就是输出时钟锁定的时间，锁定之后， locked 信号才会变高。 DCM 的常用方法 将其输出 clk_1x 连接到 BUFG 的输入，通过 BUFG 之后的输出一条支路是反馈到 DCM 的反馈时钟引脚 clkfb 上，另外一条支路则输出驱动其他单元。 DCM 消除 skew 问题： DCM 的输出开始走线到达寄存器，这段路程导致的 skew 是永远存在的，DCM 为什么可以消除呢？ 答案： 为说明方便起见 , 我们将 BUFG 的输出引脚叫做 clk_o , 从 clk_o 走全局时钟布线到寄存器时叫做 clk_o_reg , 从 clk_o 走线到 DCM 的反馈引脚 CLKFB 上时叫 clkfb , 如上图所示。实际上 clk_o, clk_o_reg, clkfb 全部是用导线连在一起的。 所谓时钟 skew, 指的就是 clk_o 到 clk_o_reg 之间的延时。如果打开 FPGA_Editor 看底层的结构 , 就可以发现虽然 DCM 和 BUFG 离得很近 , 但是从 clk_o 到 clkfb 却绕了很长一段才走回来 , 从而导致从 clk_o 到 clk_o_reg 和 clkfb 的延时大致相等。 总之就是 clk_o_reg 和 clkfb 的相位应该相等。所以当 DCM 调节 clkin 和 clkfb 的相位相等时 , 实际上就调节了 clkin 和 clk_o_reg 相等。而至于 clk_1x 和 clk_o 的相位必然是超前于 clkin, clkfb, clk_o_reg 的 , 而 clk_1x 和 clk_o 之间的延时就很明显 , 就是经过那个 BUFG 的延迟时间。 对时钟 skew 的进一步讨论 最后 , 说一说时钟 skew 的概念。 时钟 skew 实际上指的是时钟驱动不同的寄存器时 , 由于寄存器之间可能会隔得比较远 , 所以时钟到达不同的寄存器的时间可能会不一样 , 这个时间差称为 时钟 skew 。这种时钟 skew 可以通过 时钟树 来解决 , 也就是使时钟布线形成一种树状结构 , 使得时钟到每一个寄存器的距离是一样的。很多 FPGA 芯片里就布了这样的时钟树结构。也就是说 , 在这种芯片里 , 时钟 skew 基本上是不存在的。 说到这里 , 似乎有了一个矛盾 , 既然时钟 skew 的问题用时钟树就解决了 , 那么为什么还需要 DCM + BUFG 来解决这个问题？ 另外 , 既然时钟 skew 指的时时钟驱动不同寄存器之间的延时 , 那么上面所说的 clk_o 到 clk_o_reg 岂非不能称为时钟 skew？ 先说后一个问题。在一块 FPGA 内部 , 时钟 skew 问题确实已经被 FPGA 的时钟方案树解决 , 在这个前提下 clk_o 到 clk_o_reg 充其量只能叫做 时钟延时 delay , 而不能称之为时钟 skew。 至于第一个问题，个人不认同原博主的答案： 可惜的是 FPGA 的设计不可能永远只在内部做事情 , 它必然和外部交换数据。例如从外部传过来一个 32 位的数据以及随路时钟 , 数据和随路时钟之间满足建立保持时间关系 (Setup Hold time), 你如何将这 32 位的数据接收进来？如果你不使用 DCM, 直接将 clkin 接在 BUFG 的输入引脚上 , 那么从你的 clk_o_reg 就必然和 clkin 之间有个延时 , 那么你的 clk_o_reg 还能保持和进来的数据之间的建立保持关系吗？显然不能。相反 , 如果你采用了 DCM, 接上反馈时钟 , 那么 clk_o_reg 和 clkin 同相 , 就可以利用它去锁存进来的数据。可见 ,DCM + BUFG 的方案就是为了解决这个问题。而这个时候 clk_o 到 clk_o_reg 的延时 , 我们可以看到做内部寄存器和其他芯片传过来的数据之间的时钟 skew。 我认为这个答案有两个问题： 外部数据和芯片不同源，算是异步问题，应该用同步化来解决。 随路失踪一般不驱动芯片的整个时钟网络。 所以，我认为答案应该是： 要使用全局时钟网络，必须通过 BUFG 才行，所以才会用到 BUFG；而之所以用到 DCM 是因为它可以实现时钟的闭环控制，而且可以把时钟映射到 PCB 上，用于同步外部芯片，减少了对外部芯片的要求，将时钟控制一体化，利于系统设计。 注意 如果在一片 FPGA 中使用两个 DCM，需要注意两点： 设置 DCM 使用的时钟输入 clk_in 是源自 FPGA 内部的，此时不能直接连接引脚的信号，需要加入缓冲器。 应该手动例化一个 IBUFG，然后把 IBUFG 的输出连接到两个 DCM 的输入端。 如果没有这么做，而是完全按照单个 DCM 的流程使用，那么因为时钟引脚和两个 DCM 的路径长短不同，无法做到输入时钟、两个 DCM 的输出信号的相位对齐，输入时钟只能和其中一个对其，如果对相位有要求，则必须手动调整 DCM 在芯片中的位置。 PLL Virtex-5 芯片最多包含了 6 个 CMT 模块，每个 CMT 模块包含一个 PLL，PLL 主要用来广谱频率的合成，并且与 DCM 配合最为外部 / 内部时钟的抖动滤波器。 PLL 也有两个原语：PLL_BASE、PLL_ADV PLL_BASE 提供基本的功能，比如时钟去歪斜、频率合成、精确相移、占空比调整；PLL_ADV 提供更高级的功能，比如时钟切换、动态重配置等。 MMCM 不同系列的芯片内部的时钟管理模块是不同的，比如在 Virtex-5 系列后的芯片就含有了 混合模式时钟管理器 MMCM 。 具体实现时该如何选择 DCM、DLL、PLL、MMCM ？找到一篇介绍 Xilinx 时钟资源的文章： 如何正确使用 FPGA 的时钟资源 Other Tips 一般来说，外部提供的时钟信号都需要进行倍频 / 分频才可以使用，这时候需要组合各种时钟缓冲器和 DCM、PLL 等模块，我们有两种方法： 代码中例化原语，手动组合各种时钟缓冲器和 DCM、PLL 使用 IP core 向导，创建时钟管理器（可以发现 IP core 生成的代码就是上面 5 种组合方式） 个人感觉使用第二种方法应该更加简洁、方便，不容易出错吧。（如果在代码中没有明确声明使用 buffer，ISE 综合属性、IP core 属性设置里面默认会给所有的输入输出自动加上缓冲器） 对 FPGA 设计而言，全局时钟是最简单最可预测的时钟，最好的时钟方案是：由专用的全局时钟输入引脚驱动单个全局时钟，并用后者去控制设计中的每个触发器。全局时钟资源是专用布线资源，存在与全铜布线层上，使用全局时钟资源不影响芯片的其他布线资源，因此在可以使用全局时钟的时候尽可能使用。 Summary 虽然各个芯片都不尽相同，但是了解相关的基本知识有利于我们快速掌握芯片的时钟资源、快速上手。 Xilinx 的所有器件上的时钟资源可以分为前面说的 3 类：全局时钟（global clock）、局部时钟（regional clock）、I/O 时钟（I/O clock），但是不同的器件内部含有的时钟管理模块是不同的，具体到每一款芯片，应该以对应的 User Guide 为准。 Reference Virtex 5 User Guide Xilinx FPGA 开发使用教程 Xilinx FPGA 高级设计及应用 FPGA 高手设计实战真经 100 则 如何正确使用 FPGA 的时钟资源 FPGA DCM 时钟管理单元的理解","tags":"IC","loc":"https://qiangu.cool/posts/ic/the_clock_design_in_fpga_1_summary_of_clock_resource.html","title":"FPGA 时钟设计 1 —— 时钟资源总结"},{"url":"https://qiangu.cool/posts/ic/parameterization_modeling_in_veriog.html","text":"和写软件程序一样，我们也希望 Verilog 的模块也可以重利用。要使模块可以重复利用，关键就在于避免硬编码 (hard literal)，使模块参数化。 参数化建模的好处是可以使代码清晰，便于后续维护和修改。 Verilog 的参数化建模是有一定限制的，它的参数值是编译时计算的，不会引入任何实际的硬件电路。参数必须在编译时确定值。也就是说只能达到动态编译，固态运行，而非软件的动态编译，动态运行。 这主要是因为它是描述 (Description) 硬件的语言，而非软件设计 (Design) 语言。 比如一个计数器，我们可以设置一个参数来指定它的计数周期 ( 动态编译 )，但是这个计数周期在综合之后就是固定值了 ( 固态运行 )，不能在运行的时候动态地改为另外一个值 ( 除非电路综合时同时产生了多个计数器，这种情况不算真正意义上的动态运行，而且也达不到真正意义上的动态运行，因为不可能把所有可能的计数器都实现了备用，耗费资源而且没有实际意义 )。 参数化建模的主要目的是： 提高模块的通用性，只需要修改参数，不用修改其他代码就可以适用于不同的环境中。 总结一下我找到的资料，具体的参数化建模方法一共就 3 种： `define 宏定义 parameter 模块参数化 `ifdef 等 条件编译 下面详细说明 Define Macro Substitution `define 是编译器指令，功能是全局宏定义的文本代替。它类似于 C 语言中的 #define ，用法如下： 1 2 3 4 5 // define `define WORD_REG reg [31:0] // using `WORD_REG reg32 ; Problem `define 定义的宏的作用域是全局的，这种机制会导致两个问题 可能会有在不同文件中发生重定义的问题 编译顺序有要求 file-order dependent，必须确保使用前，宏定义有效，所以每个使用到宏定义的源文件必须包含这个头文件，这会导致多重包含的问题。 Solution 对于第一个问题，尽可能把所有的宏定义放在同一个头文件中，比如 \"global_define.vh\" 对于第二个问题，和 C++ 类似，头文件应该使用头文件保护符。 1 2 3 4 5 6 // global_define.vh head file `ifndef GLOBAL_DEFINE_VH `define MAX = 8 `define SIZE = 4 // ... `enif Guideline 只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义 对于那些只限于模块内的常量，不要使用 define 尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件 不要使用 `undef Parameter Parameter 应该避免硬编码设计 hard literal ，使用参数 parameter 来代替。举个例子 1 2 3 4 5 6 7 8 // use parameter parameter SIZE = 8 , MAX = 10 ; reg [ SIZE - 1 : 0 ] din_r ; // DO NOT use hard literal reg [ 7 : 0 ] din_r ; Localparam Verilog-2001 中添加了一个新的关键字 localparam ，用来定义模块内部的、不能被其他模块修改的局部常量，概念类似于 C++ 中 class 的 protect 成员。 虽然 localparam 不能被外部模块修改，但是它可以用 parameter 来初始化。 1 2 parameter N = 8 ; localparam N1 = N - 1 ; Parameter Redefinition 在 Verilog-2001 出现之前，Verilog-1995 中只有两种方法实现参数重定义： 使用 # 符号，顺序列表重定义 使用 defparam 逐个讨论 1. Uisng # Syntax 举个栗子，模块 myreg 1 2 3 4 5 6 module myreg ( q , d , clk , rst ); parameter Trst = 1 , Tclk = 1 , SIZE = 4 ; // ... endmodule 在上一层的模块中传递参数例化这个模块 1 2 3 4 5 6 module bad_warpper ( q , d , clk , rst ) // legal parameter passing myreg #( 1 , 1 , 8 ) r1 (. q ( q ), . d ( d ), . clk ( clk ), . rst ( rst ) ); // illegal parameter passing // myreg #(,,8) r1(.q(q), .d(d), .clk(clk), .rst(rst) ); endmodule Pro 虽然每次例化都要说明所有的参数值，但是比第二种方法好 Con 每次例化都要说明所有的参数值。 2. Using defparam Syntax 1 defparam path . name = value ; 比如在上面的例子中 1 defparam r1 . SIZE = 8 ; Pro 可以放在任何文件的任何地方，不用再重复没有修改的参数值 Con 因为 defparam 有这么 \" 强 \" 的功能，反而会导致一系列的问题 Hierarchical deparam. 比如顶层模块使用 defparam 修改子模块的参数，子模块中又使用 defparam 修改顶层模块要传递进来的参数，形成一个环，这样子可能导致综合时不提示错误，但是结果与预期不符。 Multiple defparams 在 单个文件 / 多个文件 中重复定义 defparam，会有微妙的问题，Verilog-1995 中没有定义这种现象，实际结果依赖于使用的综合工具。 因为 defparam 有这么多缺点，所以在 2001 年之前，Synopsys 是不支持 defparam 的，网上很多转载的博客都说 defparam 是不可综合的，实际上在后来，Synopsys 在压力之下添加了对其的支持。而我用 XST 也证明是支持 defparam 可综合。 综上原因，Verilog Standards Group (VSG) 倡议大家抵制使用 defparam，大神 Clifford E. Cummings 在论文中建议综合工具如果用户坚持使用 defparam 语句，必须添加以一个参数 +Iamstupid ... \"The Verilog compiler found a defparam statement in the source code at (file_name/line#). To use defparam statements in the Verilog source code, you must include the switch +Iamstupid on the command line which will degrade compiler performance and introduce potential problems but is bug-compatible with Verilog-1995 implementations. Defparam statements can be replaced with named parameter redefinition as define by the IEEE Verilog-2001 standard.\" 总结一下，可以发现 Verilog-1995 中的两种方法都不怎么好，显然 VSG 也发现了这个问题，所以在 Verilog-2001 中，出现了第三种方法，并且墙裂推荐使用这种新方法。 3. Using named parameter redefinition Syntax 类似于模块例化时端口连接的方式，比如上例中只想改变 SIZE 的值 1 myreg #(. SIZE ( 8 )) r1 (. q ( q ), . d ( d ), . clk ( clk ), . rst ( rst ) ); Pro 结合了前两种方法的有点，既显示说明了哪个参数值改变了，也将参数传递放在了实例化的语句中。这种方法是最干净的 (cleanest) 方法，不依赖于任何综合工具。 Con 貌似没有～ Guideline 不要使用 defparam，应该使用 named parameter redefinition。 Example clock cycle definition 因为时钟是一个设计中最基本的常量，它不会在随着模块变化，所以应该用 `define 来定义，并且将它放在顶层的头文件中。 FSM 在一个设计中可能有不止一个 FSM，而通常 FSM 有一些共同的状态名字，比如 IDLE、READY、READ、WRITE、ERROR、DONE 等，所以应该用 localparam 来定义这些常量。 Conditional Compilation Verilog 的条件编译和 C 也十分类似。前面介绍 define 时，已经用到了条件编译中的 `ifdef 。条件编译一共有 5 个关键字，分别是： ` ifdef ` else ` elsif ` endif ` ifndef 条件编译一般在以下情况中使用 选择一个模块的不同部分 选择不同的时序和结构 选择不同的仿真激励 Syntax 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // example1 `ifdef text_macro // do something `endif // example2 `ifdef text_macro // do something `else // do something `endif // example3 `ifdef text_macro // do something `elsif // do something `else // do something `endif // example4 `ifndef text_macro // do something `else // do something `endif 条件编译是一个非常好的技术，它可以帮助我们更好的管理代码。 举个栗子，比如我们写了一个程序，在 debug 阶段，在程序中添加了很多显示中间变量的语句，到最后 release 时，当然要去掉这些语句。最差的方法当然是删掉这些代码，但是如果以后我们还想 debug 时，又得手动写，而且时间长了，我们自己都记不清该加哪些语句了。稍微好点的方法是把它们注释起来，但是同样，时间长了，哪些该注释，那些不该注释又混淆了。最好的方法就是用条件编译。我们可以定义一个宏 DEBUG 1 2 3 4 5 6 7 8 `define DEBUG // conditional compilation `ifdef DEBUG // debug `else // release `endif 这样，我们只需要选择是否注释第一行的宏定义就可快速在 debug 和 release 之间切换。 再比如在 Verilog 的模块中，针对不同的应用环境，我们要实现不同的模块，这时候也可以使用条件编译选择具体综合哪段代码。 Summary 总结一下，就是一下几点 Guideline 只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义 对于那些只限于模块内的常量，不要使用 define 尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件 不要使用 `undef 不要使用 defparam，应该使用 named parameter redefinition。 需要时使用条件编译 Reference IEEE Std 1364-1995 IEEE Std 1364-2001 New Verilog-2001 Techniques for Creating Parameterized Models ( 原创 ) 如何使用参数式模组 ? (SOC) (Verilog) (C/C++) (template) 艾米电子 - 参数与常量，Verilog Verilog 代码可移植性设计","tags":"IC","loc":"https://qiangu.cool/posts/ic/parameterization_modeling_in_veriog.html","title":"Verilog 中的参数化建模"},{"url":"https://qiangu.cool/posts/ic/fpga_digital_processing_basic_2.html","text":"讨论 FPGA 中无符号数 unsigned 和有符号数 signed 的问题。 Basic Knowledge 整数的分类： 无符号数 unsigned 和 有符号数 signed 。 数制： 10、2、8、16 进制 机器数： 机器数的意思是数字在机器中的表示方式。主要有 3 种 原码 sign-magnitude 、 反码 one's complement 、 补码 two's complement 以前写过的一篇总结： 原码、反码、补码 计算机系统： 采用二进制、补码系统。 FPGA 中是如何表示数字的呢？ 以前写过一篇总结， FPGA 数字处理基础 (1) 本文算是上面文章的续吧。 (un)signed in Verilog Integer 标准格式： <null|+|-><size><sign:s|S><base:d|D|h|H|o|O|b|B><0~9|0～f|0~7|0~1|x|z> 其中 size 和 base 可选。 所以就有两个格式： 一串 0～9 组成的数字，前面可能有 +/- 符号，默认解释为有符号数 <size>'<s><base><value> ，默认是无符号数，除非明确使用 s 字段 第一个参数 size 表示用多少个 bit 来存储这个整数，这个参数的取值应该是一个非 0 的无符号十进制数。若没有给出，默认最小是 32 bit 第二个参数 s 表示这个数是有符号数，这个字段只影响编译器如何解释这个数。若没有这个字段，则将这个数解释为无符号数 第三个参数 base 表示使用什么进制来表示这个数，若没有给出，默认是十进制 第四个参数 value 表示这个数的大小，取值应该是一个无符号的符合 base 的数 在 FPGA 也采用补码系统 ，即在综合时，综合工具会将有符号数翻译为补码，在硬件中存储起来。 1 2 3 4 4 'd5 // 占用 4 bit，存储的值为无符号数 5 的原码 0101，综合工具将其视为无符号数 5 4 ' sd5 // 占用 4 bit，存储的值为无符号数 5 的原码 0101，综合工具将其视为有符号数 +5 - 4 'd5 // 占用 4 bit，存储的值为有符号数 -5 的补码 1011，综合工具将其视为无符号数 11 - 4 ' sd5 // 占用 4 bit，存储的值为 1011 Register Verilog 中数据的基本类型： wire 、 reg 、 integer 在 Verilog-1995 中，规定所有的 wire、reg 都是 unsigned 类型，只有 integer 是 signed 类型。但是 integer 的宽度是固定的 ( 与宿主机的字是一样的，最小为 32 位 )，这样子，造成了很大的不方便和浪费。 在 Verilog-2001 中，添加了 wire、reg 也可以是 signed 类型了。 1 2 reg [ 8 : 0 ] a ; // unsigned reg signed [ 8 : 0 ] b ; // signed Problem 数据可以是 signed 和 unsigned，寄存器也可以是 signed 和 unsigned，那么综合时，是以哪个为准呢？ 这个问题一开始自己没有搞清楚，迷惑了一下午，后来写了几个小测试程序，最后发现这个结论： Conclusion 以变量类型为准 即 reg/wire 为哪种，那么综合时就以这个为标准进行综合。比如当 reg 为 unsigned 类型，当我们给它赋值为 signed 类型的数据 -5 ( -4'd5 ) 时，综合出来的结果为 reg 存储的是 -5 的补码 1011 , 但是解释为 unsigned 类型的 +11 。这时候就结果和我们的预期是不一样的，出现了误差，一定要注意！另一种情况类似。 如果参与运算的变量混合有 signed 和 unsigned 类型，那么会将 signed 转换为 unsigned 类型。( 应该避免这种情况 ) ========================================= 以下为详细的分类讨论 ================================== 编写一个简单的测试程序，查看综合结果和仿真波形，就可以知道综合时的策略。 module: test_signed.v testbench: tb_test_signed.v 1. unsigned reg & unsigned value 定义 reg 为 unsigned 类型 1 2 reg [ SIZE - 1 : 0 ] i ; // unsigned reg [ SIZE - 1 : 0 ] flag ; // unsigned 赋值为 unsigned 类型 1 flag <= 8 'd10 ; // unsigned 那么可以从 RTL Schematic 中看到，综合出来的比较器是 unsigned 类型。 2. unsigned reg & signed value 定义 reg 为 unsigned 类型 1 2 reg [ SIZE - 1 : 0 ] i ; // unsigned reg [ SIZE - 1 : 0 ] flag ; // unsigned 赋值为 signed 类型 1 flag <= - 8 ' sd10 ; // signed 那么综合出来的比较器是 unsigned 类型。 3. signed reg & signed value 定义 reg 为 signed 类型 1 2 reg signed [ SIZE - 1 : 0 ] i ; // signed reg signed [ SIZE - 1 : 0 ] flag ; // signed 赋值为 signed 类型 1 flag <= - 8 ' sd10 ; // signed 那么综合出来的比较器是 signed 类型。 4. signed reg & unsigned value 定义 reg 为 signed 类型 1 2 reg signed [ SIZE - 1 : 0 ] i ; // signed reg signed [ SIZE - 1 : 0 ] flag ; // unsigned 赋值为 unsigned 类型 1 flag <= 8 'd10 ; // unsigned 那么综合出来的比较器是 signed 类型。 5. signed reg & unsigned reg 如果参与运算的两个变量一个是 signed，另一个是 unsigned。（注意这种现象应该避免，一般我们是不会将两种不同类型的数据混在一起进行计算的） 定义 i 为 unsigned 类型，flag 为 signed 类型 1 2 reg [ SIZE - 1 : 0 ] i ; // unsigned reg signed [ SIZE - 1 : 0 ] flag ; // signed 给 flag 赋值为 signed 的 -5 1 flag <= - 4 'd5 ; // sigend 综合出来的比较器为 unsigned 类型。 P.S. 变量 integer 也是也可综合的。在上例中，如果将 flag 的类型改为 integer 也是可综合的，但是，因为只用到了低 8 位，所以在综合时会提示高 24 位是未连接 unconnected，但是因为 integer 是一个整体，所以即使未连接也不能优化掉，这就是在 Verilog-1995 中 integer 不够灵活的体现，好在 Verilog-2001 中已经添加了支持 reg/wire 为 signed 的类型，而且综合工具 (XST) 也是支持的。 ======================================= 分割线结束 ========================================== 以前只知道硬件上最基本的一些运算单元，比如加法器 (adder)、减法器 (subtractor)、比较器 (comparator) 等，完成的功能是固定的，电路是不会检查输入数据的类型的。涉及到 signed 和 unsigned 类型，就出现一个问题：对于基本运算单元 ( 比如加法器 )，运算单元并不知道输入的数据是哪种数据，对于 unsigned 和 signed 类型，必然出现适合一种时不适合另外一种的问题。 所以可以推断出 对于不同的数据类型，同样是个加法器，底层的硬件电路是不一样的 。 如果我在程序中定义了 signed 和 unsigned 类型的数据，那么综合工具是否足够智能，能够根据数据的类型综合出正确适合的电路？ 答案是肯定的，即 综合器足够智能 。 上面的程序证明了这一点，从 RTL 图中可以看到综合出的比较器是 signed 还是 unsigned 类型，仿真波形也可以看到，最终下载到板子上测试也符合预期。这些都证明 综合器足够智能。后来看到 UG627(v14.5): XST User Guide ，才发现里面已经非常清楚地写着 Chapter 3: Signed and Unsigned Support in XST When using Verilog or VHDL in XST, some macros, such as adders or counters, can be implemented for signed and unsigned values. To enable support for signed and unsigned values in Verilog, enable Verilog-2001 as follows: + ISE® Design Suite Select Verilog 2001 as instructed in the Synthesis Options topic of ISE Design Suite Help + XST Command Line Set -verilog2001 to yes. 花费了大量时间上网找资料，在论坛里问别人无果，最后自己动手写程序测试，最后才发现原来官方资料里面早就写的清清楚楚 =.= Conclusion 说了这么多，总结下来就是下面这几句话： 经验： 遇到问题，先不要急着上网求助，上网求助这个方法虽然简单，但是是最不好的，一方面别人的话不一定可靠，另一方面，放弃思考直接上网求助对学习无益。 找资料的技巧很重要。虽然我大概能够猜测到 Xilinx 官方的文档中肯定有说明，但是就是懒得去下载文档，再去找。认为网上肯定有人也有相同的困惑，所以直接 Google。结果找到一堆没有帮助的网页，浪费了时间，最后还是要看文档。 实践是检验真理的唯一标准，到底行不行，写测试程序，在板子上跑跑，验证一下是最有力的证明。 知识： Verilog-2001 已经支持 signed 类型的 wire 和 reg，所以我们代码中如果涉及到有符号数，那么像 C 语言一样直接定义、赋值、使用即可，综合工具会综合出正确的有符号数的运算电路。不必再像以前一样手动进行补码转换，自己来处理有符号数的补码计算的细节。 综合时的原则是按照寄存器的类型进行综合 ( 即上面的分类讨论的结论 )。 仔细对比 signed 和 unsigned 类型的综合结果，可以发现 Technology Schematic 是一样的，之所以和 \" 理论上硬件电路是应该不一样 \" 矛盾，我认为原因在于 FPGA 的实现是基于查找表的。以上面的例子来说明，这个比较器的功能最终是在一个 LUT6 的查找表上实现的，所以，ASIC 上硬件电路的不同映射到 FPGA 中就是 LUT 的内容不同。","tags":"IC","loc":"https://qiangu.cool/posts/ic/fpga_digital_processing_basic_2.html","title":"FPGA 数字处理基础 (2)"},{"url":"https://qiangu.cool/posts/tools/sublime_text_2_and_verilog.html","text":"Sublime Text 代码编辑器之于程序员，就如同剑之于战士。程序员关于代码编辑器的争论从来就没有停止过，每个程序员都有自己熟悉的编辑器，他们热爱自己的 \" 武器 \"，甚至可以形成 \" 宗教 \"，比如 Vim 和 Emac 的战争。 如今，这个无休止的争论中要加入一个新成员了，她就是 Sublime Text 。其实她也不是 \" 新 \" 成员了，早在 2011 年她就诞生了，不过经过不断的改进，终于人们不得不正视这个新人，不仅仅因为漂亮的外在美，还有强大的内在美 :-P 个人感觉，ST 的出现恰到好处，她兼具了 Vim 的强大功能和普通编辑器的易用性。虽然 Vim 轻巧、强大，但是 Vim 的门槛比较高，要想用好 Vim 是需要长期练习的，而 ST 可以说是老少皆宜，你是小白，不会用 Vim？没关系，她可以像普通的编辑器一样，即使你 0 基础也可以使用；你是老手，习惯 Vim？也没关系，她可以 开启 Vim 模式 ，还是原来的配方，还是熟悉的味道～ 虽然她不是开源项目，有收费，但是我们有免费无限制无限期的试用权，而且她绿色小巧，不用安装，解压即可使用，跨平台，支持各种编程语言的代码补全和语法高亮。如果对现有的插件不满意，我们甚至可以自己定制插件。 简单说一下我在使用过程中的一些问题，更加详细的使用官方和非官方的网站上都有详细的说明，还有别人总结的技巧请自行 Google。 Official docs Unofficial docs Others: Sublime Text 2 - 性感无比的代码编辑器！程序员必备神器！跨平台支持 Win/Mac/Linux P.S. 我使用的是 Sublime Text 2，虽然已经有 3 了，但是 3 还在 Beta 阶段，大家貌似对 3 不是很满意 Vim Mode ST 是自带 Vim 模式的（Vintage Mode），但是这个模式默认是没有开启的，毕竟对于大多数普通人来说， Vim 实在是不太友好 ... 打开 ST 的 Preferences/Setting - Defalut ，在最后一行有句 \"ignored_packages\" : [ \"Vintage\" ] 只需要将方括号中的 Vintage 去掉就可以了。推荐在 Setting - User 中修改。 官方说明 Package Control ST 的一个强大之处就在于可以安装各种插件，要安装插件有两种方法： 手动下载，解压到指定目录 安装 Package Control 插件，自动管理安装插件 第一种方法虽然麻烦，但是在没有网络的环境下，我们可以从别人那拷贝过来即可；第二种方法最方便了，不过要求有网络。 Installation ST 默认是没有安装 Package Control 的，需要我们手动安装： Ctrl ~ 调出控制台 在控制台中粘贴以下命令 import urllib2 , os ; pf = 'Package Control.sublime-package' ; ipp = sublime . installed_packages_path (); os . makedirs ( ipp ) if not os . path . exists ( ipp ) else None ; urllib2 . install_opener ( urllib2 . build_opener ( urllib2 . ProxyHandler ())); open ( os . path . join ( ipp , pf ), 'wb' ) . write ( urllib2 . urlopen ( 'http://sublime.wbond.net/' + pf . replace ( ' ' , '%20' )) . read ()); print 'Please restart Sublime Text to finish installation' 安装完成之后，重启 ST 即可 Using 按下 Ctrl + Shift + P ，在弹出的命令面板，输入 package ，就会自动弹出相关的命令，可以选择 Install 、 Remove 、 Disable 、 Enable 、 List 、 Update 等命令。 sublime wbond 上列出了 Package Control 可以找到的所有的插件，有详细的安装和使用说明。 网上也有很多文章介绍了大量的常用插件，我们可以按照需求自己挑选需要的插件进行安装。 Verilog HDL 常用的插件，比如括号匹配、智能补全、自动对齐、Tags、注释生成、Terminal、Build、Git 等插件就不再赘述了，说一下网上介绍的比较少，但我自己使用比较多的关于 Verilog 的插件。 可以通过 Package 下载到两个插件， Verilog 和 Verilog-Automatic 。第一个插件主要功能是支持 Verilog 的代码高亮和补全，第二个插件可以帮助我们自动生成模块例化、端口添加连接等功能。 其中，第一个插件的 Snippet 并不太让人满意，在原 Snippet 的基础上，我添加了一些我常用到的 Snippets。 always 因为插件作者只添加了异步高有效复位方式的 always 块，而我们同步和异步两种方式都可能会用到，所以，我添加同步复位的 Snippet ST 2 的 Package 都存放在 /home/.config/sublime-text-2/Packages 目录下面，我们需要修改的就是这个目录下的 Verilog/Snippets 下的 .tmSnippet 文件。修改后的结果如下： always_async.tmSnippet <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/Prop ertyList-1.0.dtd\"> <plist version= \"1.0\" > <dict> <key> content </key> <string> always @(posedge clk or ${ 1 : posedge } ${ 2 : rst } ) begin if ($2) begin // reset $3 end else if ($4) begin $0 end end </string> <key> name </key> <string> always_async </string> <key> scope </key> <string> source.verilog </string> <key> tabTrigger </key> <string> always_async </string> <key> uuid </key> <string> 026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC </string> </dict> </plist> always_sync.tmSnippet <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/Prop ertyList-1.0.dtd\"> <plist version= \"1.0\" > <dict> <key> content </key> <string> always @(posedge clk) begin if ( ${ 1 : rst } ) begin // reset $2 end else begin $0 end end </string> <key> name </key> <string> always_sync </string> <key> scope </key> <string> source.verilog </string> <key> tabTrigger </key> <string> always_sync </string> <key> uuid </key> <string> 026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC </string> </dict> </plist> 修改之后的结果如下图所示： if-else 原来的 if snippet 没有 else 分支，所以，添加了一个有 else 分支的 if 语句。 if.tmSnippet < ? xml version = \" 1.0 \" encoding = \" UTF-8 \" ? > <! DOCTYPE plist PUBLIC \" -//Apple//DTD PLIST 1.0//EN \" \" http://www.apple.com/DTDs/Prop ertyList-1.0.dtd \" > < plist version = \" 1.0 \" > < dict > < key > content </ key > < string > if ( $1 ) begin $0 end </ string > < key > name </ key > < string > if </ string > < key > scope </ key > < string > source . verilog </ string > < key > tabTrigger </ key > < string > if </ string > < key > uuid </ key > < string > 1 ADE2F84 - DDB8 - 4878 - 8 BFC - B7FC2F391C6C </ string > </ dict > </ plist > if-else.tmSnippet < ? xml version = \" 1.0 \" encoding = \" UTF-8 \" ? > <! DOCTYPE plist PUBLIC \" -//Apple//DTD PLIST 1.0//EN \" \" http://www.apple.com/DTDs/Prop ertyList-1.0.dtd \" > < plist version = \" 1.0 \" > < dict > < key > content </ key > < string > if ( $1 ) begin $2 end else begin $0 end </ string > < key > name </ key > < string > if_else </ string > < key > scope </ key > < string > source . verilog </ string > < key > tabTrigger </ key > < string > if_else </ string > < key > uuid </ key > < string > 1 ADE2F84 - DDB8 - 4878 - 8 BFC - B7FC2F391C6C </ string > </ dict > </ plist > 修改后的结果如下图： parameter 原来是没有 parameter 的 snippets 的，拷贝一份其他的 snippet，修改其中的一些设置，即可 parameter.tmSnippet <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/Prop ertyList-1.0.dtd\"> <plist version= \"1.0\" > <dict> <key> content </key> <string> parameter $1 = $2, $3 = $0 </string> <key> name </key> <string> parameter </string> <key> scope </key> <string> source.verilog </string> <key> tabTrigger </key> <string> parameter </string> <key> uuid </key> <string> 1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C </string> </dict> </plist> 修改后的结果如下图所示： case 原来是没有 case 的 snippet，方法同上，可以修改出我们想要的 case snippet case.tmSnippet < ? xml version = \" 1.0 \" encoding = \" UTF-8 \" ? > <! DOCTYPE plist PUBLIC \" -//Apple//DTD PLIST 1.0//EN \" \" http://www.apple.com/DTDs/Prop ertyList-1.0.dtd \" > < plist version = \" 1.0 \" > < dict > < key > content </ key > < string > case ( $1 ) $2 : begin $3 end $4 : begin $5 end $6 : begin $7 end $8 : begin $9 end default : begin $10 end endcase </ string > < key > name </ key > < string > case </ string > < key > scope </ key > < string > source . verilog </ string > < key > tabTrigger </ key > < string > case </ string > < key > uuid </ key > < string > 026 B3DA6 - E1B4 - 4 F09 - B7B6 - 9485 ADEF34DC </ string > </ dict > </ plist > 修改后的效果如下： SublimeText in Vivado 代码编辑器之于程序员就像武器之于战士，其重要性不需赘述，本文记录一下设置 SublimeText 为 Vivado 的代码编辑器的过程。 Ref: How to setup an external text editor in Xilinx ISE & EDK 是讲 ISE 和 EDK 的设置，同理可以将其推广到 Vivado 中，其实 Vivado 已经将常见的编辑器列出来了，其中就包含 Sublime，但是因为我没有将 Sublime 包含在系统路径中，所以需要选择 custom editor 选项： D : / Sublime_Text_3 / sublime_text . exe [ file name ] : [ line number ] 即可。 上面仅仅说了非常基本的几个设置，和我在写 Verilog 时自己添加的几个 snippet，其他的 ST 的使用技巧官方和非官方的 ref 有非常详细的介绍，另外其他人也有很多文章介绍～","tags":"Tools","loc":"https://qiangu.cool/posts/tools/sublime_text_2_and_verilog.html","title":"Sublime Text 2 和 Verilog HDL"},{"url":"https://qiangu.cool/posts/ic/the_art_of_reset_design_in_fpga.html","text":"复位信号在系统中的地位和时钟信号几乎同等重要，我们想尽量把系统设计为可控，那么最基本的控制信号就是复位信号了。 复位信号的设计需要考虑的因素，各种书刊、论文、白皮书、网上论坛都有相关讨论，但是至今对于给定 FPGA 设计中使用哪种复位方案仍然没有明确答案。本文总结了一些大神的经典论文和网上的许多博客，尽可能用简单的图说明选择某种设计方案及其理由，涉及的更深入的原理请自行 Google :-P Understanding the flip-flop reset behavior 在开始详细讨论之前，首先得理解 FPGA 的基本单元 Slice 中的 FF 的复位方式。Xilinx 的 Virtex 5 系列的芯片中的 FF 的类型都是 DFF (D-type flip flop)，这些 DFF 的控制端口包括一个时钟 CLK，一个高有效的使能 CE，一个高有效的置位 / 复位 SR。这个 SR 端口可以配置为同步的置位 / 复位，也可以配置为异步方式的置位 / 复位。如下图所示 例化（ instantiation ）和 推译（ inference ）是在 FPGA 设计中使用元件的两种不同方法。综合器是通过 HDL 代码 推译（ infer ） 最终的电路，所以我们写的 RTL 代码风格会影响最终综合出来的 FF 类型。 如果代码的敏感列表中包含复位信号，那么就会综合出一个异步复位的 DFF，SR 端口将被配置为置位或者复位端口 (FDPE & FDCE primitive)。当 SR 变高时，FF 的输出值立即变为代码中的复位时设定的值 SRVAL。 同理，如果代码的敏感列表中不包含复位信号，那么就会综合出一个同步复位的 DFF，SR 端口将被配置为置位 / 复位端口 (FDSE & FDRE primitive)。当 SR 变高时，FF 的输出值在下一个时钟的上升沿变为 SRVAL。 虽然 FPGA 的 FF 可以配额为 preset/clear/set/reset 等不同的结构，但是在实现时，只能配置为其中的一种，如果在代码中多于一个 preset/clear/set/reset，那么就会产生其他的逻辑，消耗 FPGA 资源。 另外，基于 SRAM 的 FPGA 可以设定上电初始化的值：如果我们在定义 reg 变量时给它一个初始值，那么 FPGA 在上电配置 (GSR 变高 ) 时，载入这个值。 Active low V.S. Active high 大多数书籍和博客都推荐使用 \" 低电平有效 \" 的复位方案，却没有明确说明为什么使用 \" 低电平有效 \"。 目前大多数书籍中都使用 低电平复位，网上给出的理由是 ASIC 设计大多数是低电平复位 大多数厂商使用低电平复位多一些 (Xilinx 基本全是高电平复位，这也叫大多数？) 低电平复位方式，在上电时系统就处于复位状态 Verilog Verilog 嵌入式数字系统设计教程 说明了原因： One reason for using active-low logic is that some kinds of digital circuits are able to sink more current when driving an output low than they can source when driving the output high. If such an output is used to activate some condition for which current flow is required, it would be better to use a low logic level rather than a high logic level. 也就是说目前推荐的 \" 低电平有效 \" 更多的是 IC 设计的传统，然而根据我查到资料来看，对于 Xilinx FPGA 这条传统并不适用。Xilinx 的器件全部是高电平复位端口，他们的 white paper 中的例子也都是高电平复位方式。而且，从综合结果来看，如果非要使用低电平复位，那么就会额外添加一个反相器，然后将反向得到的高电平连接到 FF 的复位端口，从而导致复位信号的传输时延增加，芯片的利用率下降，同时会影响到时序和功耗。 How do I reset my FPGA 中也证实了这一点，文中提到对于 Xilinx 器件，尽可能使用高有效复位，如果实在没有办法控制系统的复位极性，那么最好在系统的顶层模块中将输入的低有效复位翻转极性，这样做的好处是反向器将被吸收到 IO logic 中，不会消耗 FPGA 内的逻辑和布线资源。 Conclusion 应该参考器件决定使用那种方式 对于 Xilinx 器件，应该使用高电平复位方式 Synchronous V.S. Asynchronous 因为 DFF 有两种复位端口，所以对应的有两种复位方式：同步复位 和 异步复位。两种复位方式各有特点，适用于不同的应用场景。下面先分别总结两种方案的优劣，最后总结当前流行的的主流复位方案。 Synchronous Reset Coding Style 同步复位的假设前提：只有在时钟信号的有效沿，复位信号才能影响寄存器的状态。 通常把 reset 信号作为组合逻辑的一部分连接到寄存器输入端口 D，从而对寄存器起作用。因此同步复位的 coding style 应该是： 模块的 sensitivity list 中不包含 rst 信号，并且 reset 信号应该在 if-else 的最前面（if 分支），以便于优先考虑，其他组合逻辑位于后面（else 分支）。 1 2 3 4 5 6 7 8 always @( posedge clk ) begin if ( rst ) begin q <= 1 'b0 ; end else begin q <= d ; end end 对应的 RTL Schematic 如下： 其中 fdr 是 Xilinx 的原语，表示 Singal Data Rate D Flip-Flop with Synchronous Reset and Clock Enable (posedge clk) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and // Clock Enable (posedge clk). // All families. // Xilinx HDL Language Template, version 13.3 FDRE #( . INIT ( 1 'b0 ) // Initial value of register (1'b0 or 1'b1) ) FDRE_inst ( . Q ( Q ), // 1-bit Data output . C ( C ), // 1-bit Clock input . CE ( CE ), // 1-bit Clock enable input . R ( R ), // 1-bit Synchronous reset input . D ( D ) // 1-bit Data input ); // End of FDRE_inst instantiation 有时候，有些器件不带同步复位专用端口，那么综合器一般会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。 Problem 如果没有遵守这样的 coding style，可能会引起下面的两个问题： 在一些基于逻辑表达式计算的仿真器上，一些逻辑可能会阻止复位信号作用到寄存器上 注意：只存在于仿真器的问题，硬件上没有问题。 相对于时钟信号而言，因为复位树（reset tree）上有着非常高的扇出，所以复位信号可能是一个晚到底信号（late arriving signal） 明智之举是：即使在复位树上加入 buffer，一旦复位信号进入到局部逻辑区域（local logic），那么就要限制复位信号到达寄存器所经历的逻辑数量，以减少延迟。 使用同步复位还有一个问题是： 综合工具无法很轻松地从其他逻辑信号中识别出复位信号。（这可能导致一些仿真的问题，注意只是仿真问题，实际电路会正常工作，正确复位） solution: synposys 提供了综合指令 sync_set_reset // synposys sync_set_reset \"rst\" 这个指令的作用是告诉综合工具指定的信号是同步 set/reset，那么综合工具就会尽量把这个信号放在靠近寄存器的位置，以防前面说仿真问题。 P.S. 通常，只有在综合指令是不许的而且是紧要的时候，我们才使用它们。 我们应该遵守这一原则，因为综合指令的使用可能导致前后仿真的不一致。 但是 sync_set_reset 是个例外情况，因为它不会影响逻辑行为，只影响设计的功能实现。 所以明智的设计者在项目开始的时候就把 sync_set_reset 添加到 RTL 代码中，以避免以后的多次综合。由于每个模块对这条指令只要求使用一次（模块只有一个复位信号），所以推荐为每个模块添加这条指令。 如果觉得每个模块都添加这种方式太繁琐，还有另外一种方法：在读取 RTL 代码前，设置综合变量 hdlin_ff_always_sync_set_reset 为 true ，可以达到同样的效果。 Advantage 保证设计是 100% 同步，有利于时序分析，也利于仿真 降低亚稳态出现的几率，时钟起到过滤毛刺的作用 ( 如果毛刺发生在时钟沿附近，那么仍然会出现亚稳态的问题 ) 在某些设计中，复位信号是由内部逻辑产生的，推荐使用同步复位，因为这样可以避免逻辑产生的毛刺 Disadvantage 并不是所有的 ASIC 库里面都有带同步复位端的寄存器，不过这个问题并不严重，因为同步复位信号只是另外一个数据输入信号，所以综合工具很容易把复位信号综合到寄存器外部的逻辑中。 同步复位需要保证复位信号具有一定的脉冲宽度 (pulse stretcher)，使其能被时钟沿采样到，尤其是多时钟域的设计中。这是需要重点考虑到，可以使用一个小岛计数器，以保证复位脉冲信号保持一定数量的时钟周期。 在仿真过程中，同步复位信号可能被 X 态掩盖 (? 不懂 ...) 同步复位信号需要时钟信号正常工作。在一些设计中这个条件可能不是问题，但是在一些设计中就比较让人恼火了。比如，为了节省功耗使用了门控时钟（gated clock），在复位信号有效时，时钟信号还处于禁止状态（disabled），而在时钟恢复时，复位信号已经被撤销了。这种情况就会导致电路无法复位（异步复位则无此问题）。 如果设计中含有三态总线，为了防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位 如果逻辑器件的目标库内的 FF 只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。 有很多教材和博客都直接说 \" 同步复位会产生额外的逻辑资源 \"，可能他们是基于 Altera 的 FPGA 这么做的，如下图所示： 但是根据我实际的测试结果，对于 Virtex 5 系列的芯片，它的原语里面已经含有各种带同步、异步复位端口的 FF，ISE 自带的 XST 也已经很智能了，它会根据代码分析，自动选择合适的 FF。所以上面同步复位综合出来的 RTL Schematic 中没有所谓的 \" 多余的逻辑资源 \"。 所以，是否占用多余的资源，还得针对具体的芯片分析。 Asynchronous Coding Style 虽然异步复位信号是电平有效，但是敏感列表必须在异步复位信号的前沿激活： 1 2 3 4 5 6 7 8 always @( posedge clk or posedge rst ) begin if ( rst ) begin q <= 1 'b0 ; end else begin q <= d ; end end 对应的 RTL Schematic 如下： 其中 fdc 是 Xilinx 的原语，表示 Single Data Rate D Flip-Flop with Asynchronous Clear and Clock Enable (posedge clk) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and // Clock Enable (posedge clk). // All families. // Xilinx HDL Language Template, version 13.3 FDCE #( . INIT ( 1 'b0 ) // Initial value of register (1'b0 or 1'b1) ) FDCE_inst ( . Q ( Q ), // 1-bit Data output . C ( C ), // 1-bit Clock input . CE ( CE ), // 1-bit Clock enable input . CLR ( CLR ), // 1-bit Asynchronous clear input . D ( D ) // 1-bit Data input ); // End of FDCE_inst instantiation Problem 由于复位信号相对于时钟信号来说是异步的，所以可能导致两个问题： 复位信号违反 recovery time recovery time 是复位信号撤销的沿到时钟有效沿之间最小的时间间隔（类似于同步信号中的 setup time），如果违反 recovery time，寄存器的输出会出现亚稳态。 对于不同的寄存器，复位信号的撤销（removal）可能发生在不同的时钟周期内 由于复位信号和时钟在传输延迟的轻微差别，导致有的寄存器的复位信号早于时钟信号，在时钟沿之前寄存器就被先复位；有些复位信号晚于时钟信号，在时钟沿之后寄存器才复位，从而有些寄存器先于其他寄存器退出复位状态。 异步复位和同步复位是互补，一个的优点（缺点）即使另外一个的缺点（优点）： Advantage 单元库中肯定是包含异步复位的寄存器的，所以异步复位最大的优点是不需要额外的逻辑，可以保持数据路径（data path）的干净。这在数据路径时序很紧张的情况下非常有用。 脉冲宽度没有限制，可以快速复位 没有时钟的时候也可以将电路复位 ( 使用 gated clock，同步复位无法工作，而异步复位是可以的 ) EDA 工具 route 起来更容易，对于大型设计，能显著减少编译时间 Disadvantage 不是同步电路，不利于时序分析，设计者要正确约束异步复位信号比同步复位复杂 复位信号容易收到毛刺的干扰，板上或者系统复位上的噪声或者毛刺会导致假的复位 异步复位最大的问题是容易在复位信号的起效（assert）和失效（deassert）是异步的，起效异步没有问题，但是失效异步可能导致亚稳态。( 撤销的时候 (release) 不满足 removal time 时序要求，从而产生亚稳态 ) Reset Synchronizer 两种复位方式各有优缺点，设计者应该根据实际情况选择合适的复位方法。目前，很多文献书籍中都推荐一种 \" 异步复位，同步释放 \" 的方法。这种方法可以将两者结合起来，取长补短。 它的原理如下图所示 需要注意到是，上图的复位是传统的低电平有效方式，对于 Xilinx 器件，原理图稍有不同，其复位按钮接到了 FF 的置位端，第一级 FF 的输入也由 Vcc 变为 GND 。 How do I reset my FPGA 介绍了对应的 RTL Schematic ： 对于 Xilinx 器件，用代码具体实现 Coding Style 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 module SYSRST ( clk , rst_pb , sys_rst ); input clk ; input rst_pb ; output sys_rst ; reg sys_rst ; reg rst_r ; always @( posedge clk or posedge rst_pb ) begin if ( rst_pb ) begin // reset rst_r <= 1 'b1 ; end else begin rst_r <= 1 'b0 ; end end always @( posedge clk or posedge rst_pb ) begin if ( rst_pb ) begin // reset sys_rst <= 1 'b1 ; end else begin sys_rst <= rst_r ; end end endmodule 对应的 RTL Schematic 如下： 其中， rst_pb 是系统的复位按钮， sys_rst 是同步化的结果。可以看到综合结果和上图是一致的。 Simulation: 所谓 \" 异步复位 \"，如上图 ( 由于连接到了置位端，叫 \" 异步置位 \" 更合适 )，一旦复位信号 rst_pb 有效，那么输出端口 sys_rst 立即被置为 1 ，否则输出为 0 。 所谓 \" 同步释放 \"。如上图，当复位信号 rst_pb 释放时 ( 从有效变为无效 )，输出端口 sys_rst 不是立即变化，而是被 FF 延迟了一个时钟输出，从而使其和时钟同步化。 是否存在亚稳态？ 答案：不存在。 分析：第一个寄存器的输入和输出在复位变有效前后是不一致的，当复位信号很靠近时钟信号时，可能违反 recovery time，其输出可能存在亚稳态。但是到了第二个寄存器，因为它的输入和输出在复位信号有效前后是一致的，所以它的输出没有机会在两个电平之间抖动，所以不存在亚稳态。 可以看到，这种 \" 异步复位，同步释放 \" 的方法既解决了同步复位对脉冲宽度的要求，又解决了异步复位可能导致的亚稳态问题。 Guidelien: Every ASIC using an asynchronous reset should include a reset synchronizer circuit!! Conclusion 知道了这点，选择复位信号的策略就很明显了： 尽可能使用同步复位，保持设计 \" 同步化 \" 如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了 (CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步 / 异步复位端口 ) 如果不带有同步复位端口，那么就需要异步复位时，必须包含同步器 在详细讨论了复位的有效电平、复位方式之后，我们开始讨论稍微复杂一点的复位设计：包括系统的复位方案、多时钟域的复位方案、复位信号的去除毛刺等。 Think Local V.S. Think Global 我们使用复位信号的一个目的就是为了使电路可控，当上电时或者系统出错时，可以通过复位的方式回到正常状态。为了达到完全可控，传统的做法是对系统内的每个 FF 都连接复位信号，这样就造成了复位信号的高扇出，而高扇出会导致一系列的问题。 Xilinx 有个 White Paper， Get Smart About Reset: Think Local, Not Global ，提出一种新的复位思路： 能不用全局复位时，尽量不要使用，这样可以降低复位信号的扇出。 这个原则和我们平时的理解和习惯是相反的，它不使用全局复位的原因主要有三个： 随着时钟速率的提高，GSR 逐渐变为时序关键路径 如果电路中没有反馈环路，那么上电初始化已经足够了，很多设计中的 reset 信号都可以省去 如果没有反馈环路，比如移位寄存器，即使开始状态是错误的，当数据流进入到一段时间，错误数据将被冲刷出去，所以没有必要保留 reset 信号。如果系统中有反馈环路，比如状态机，当初始状态不对或者状态跑飞时，无法回到正常状态，那么 reset 信号是有必要保留的。 代码中简单的添加一个 reset 端口，在底层实现时要消耗很多我们想不到的资源。 全局复位会和设计中的其他单元竞争布线资源，全局复位一般来说肯定有非常高的扇出，因为它需要连接到设计中的每一个 FF。这样，它会消耗大量的布线资源，使芯片利用率下降，同时也会影响时序性能。 所以，有必要使用其他的不依靠全局复位的方法。 如图所示，Xilinx FPGA 在配置 / 重配置的时候，每个 FF 和 BRAM 都会被初始化一个预先设定的值 ( 大部分器件的默认值是 0, 也有例外 )，所以，上电配置和全局复位有着类似的功能，将每个存储单元配置为一个已知的状态。 系统在上电配置时，内部有个信号叫 GSR (Global Set/Reset)，它是一种特殊的预布线的复位信号，能够在 FPGA 配置的过程中让设计保持初始状态。在配置完成后，GSR 会被释放，所有的触发器及其它资源都加载的是 INIT 值。除了在配置进程中自动使用 GSR，用户设计还可以通过实例化 STARTUP 模块并连接到 GSR 端口的方法来访问 GSR 网。使用该端口，设计者可以重新断言 GSR ，相应地 FPGA 中的所有存储元件将返回到它们的 INIT 属性所规定的状态。 设定初值的语法很简单，只需要在定义变量时给它初始值就可以了： 1 reg tmp = 0 ; 和 reg 类似，BRAM 也可以在配置的时候初始化，随着嵌入式系统的 BRAM 逐渐增大，BRAM 初始化非常有用：因为预先定义 RAM 的值可以使仿真更容易，而且无需使用引导序列为嵌入式设计清空内存。 使用 GSR 的好处是 可以解决复位信号高扇出的问题 ，因为 GSR 是预布线的资源，它不占用每个 FF 和 Latch 的 set/reset 端口，如下图所示。很多资料都推荐将设计中的 reset 按钮连接到 GSR，以利用它比较低的 skew。 既然 GSR 这么好，那么是不是只使用 GSR 就可以了，不必再用 FF 和 Latch 的 set/reset 端口了呢？ 答案当然是否定的。由于 GSR 的释放是异步方式，所以，如果我们只使用 GSR 作为系统的唯一复位机制，那么可能导致系统不可靠。所以还是需要显式地使用同步复位信号来复位状态机、计数器等能自动改变状态的逻辑。 所以，应该使用 GSR + explict reset 的解决方案： 给系统中的 reg 赋初值，对于没有环路的电路节省 reset，利用 GSR 实现复位的功能；对于有环路的电路，使用显示的复位信号。 Upate: 07/01/2014 关于 initialize 代替 reset 这几天看 resest 相关问题时，又在 stackoverflow 上发现一个关于 是否应该使用 initialize 代替 reset 的问题 。 支持用 initialize 代替 reset 的人提出的方案是尽量不要使用全局复位信号，使用初始化值代替复位，对于一些必须要求复位的模块，使用 local 的复位信号。 反对者认为，用 initialize 代替 reset 的想法只是学院派的不切实际的想法。一般只有基于 SRAM 的 FPGA 才会使用到初始化。而这样做的目的只是为了节省布线资源，降低时序要求，但是现代 FPGA 有很多布线资源和没有使用的全局网络，所以，复位信号一般不是时序关键路径。即使遇到问题，可以通过手动例化一个时钟 BUF 来解决。使用这种无复位的设计虽然在某些情况是可行的，但是当你把你的设计和其他系统连接起来时，通常会感到非常痛苦，因为大多数系统都会要求有个复位信号。在由 FPGA 转 ASIC 时也比较方便，因为只有基于 SRAM 的 FPGA 才可以使用这种 initialize 代替 reset 的技术，而 ASIC 不行。 关于 GSR 网上有很多人都推荐将我们用户定义的复位信号连接到 GSR 信号上，以便利用 GSR 提供的低抖动性，包括 How do I reset my FPGA 也推荐使用 GSR 信号。但是在 Xilinx 的另一份文档 UG626: Synthesis and Simulation Design Guide 中说不推荐使用 GSR 来作为系统的复位 Although you can access the GSR net after configuration, Xilinx does not recommend using the GSR circuitry in place of a manual reset. This is because the FPGA devices offer high-speed backbone routing for high fanout signals such as a system reset. This backbone route is faster than the dedicated GSR circuitry, and is easier to analyze than the dedicated global routing that transports the GSR signal. 而这个矛盾早就有人在 Xilinx Forum 上提问了 What does GSR signal really mean and how should I handle the reset signal properly ，还有 FPGA Power On Reset! 。 Conclusion 应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。 P.S. 事实上没有一个通用的、适合所有器件的复位方案，我们应该首先了解所使用的器件和工具，针对它们的特点进行复位方案的设计。 Shift Register Reset 并不是每一个设计，器件中的每一个寄存器都需要复位的。最好的做法是只将复位连接到那些需要复位的寄存器。一个典型特例就是移位寄存器的复位。 如果一个模块内部含有一组触发器 ( 移位寄存器 )，这些寄存器可以分为两类： resetable flip-flops 第一个 ff，它是需要复位信号的 follower flip-flops 后续的 ff，仅作为简单的数据移位寄存器，不含复位端 那么在设计时应该只复位第一个触发器，后续的触发器仅作为数据寄存器使用，不能对它们进行复位。 这里体现出来的一个原则就是：能节省 reset 时，尽量节省。 原因就是 reset 作为一个实际存在的物理信号，需要占用 FPGA 内部的 route 资源，往往 reset 的 fanout 又多得吓人。这就很容易造成 route 难度上升，性能下降，编译时间增加。因此，在 FPGA 设计中能省略的复位应尽量省略。 比较好的设计风格，不同类型的 FF 不应该组合进单个 alway 块中。也就是说，不要把这两种 FF 写在同一个 always 块中，而应该每个 always 模块只对一种 FF 建模。 Bad Style: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 module BADSTYLE ( clk , rst , d , q ); input clk ; input rst ; input d ; output q ; reg q ; reg tmp ; always @( posedge clk ) begin if ( rst ) begin tmp <= 1 'b0 ; end else begin tmp <= d ; q <= tmp ; end end endmodule RTL Schematic: 如下图，复位信号 rst 对于第二个 ff 来说，是一个片选信号 ce ，这样的设计产生额外的逻辑，是不好的。 Good Style: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 module GOODSTYLE ( clk , rst , d , q ); input clk ; input rst ; input d ; output q ; reg q ; reg tmp ; always @( posedge clk ) begin if ( rst ) begin tmp <= 1 'b0 ; end else begin tmp <= d ; end end always @( posedge clk ) begin q <= tmp ; end endmodule RTL Schematic: 如下图，复位信号 rst 对于两个 ff 来说，都是复位信号，不需要额外的逻辑，这样的设计是比较好的。 Reset Distribution Tree 复位信号的 reset distribution tree 和 时钟信号的 clock distribution tree 差不多同等重要，因为在设计中，几乎每个器件都有时钟端口和复位端口 ( 同步 / 异步 )。 reset distribution tree 和 clock distribution tree 如下图所示： 系统中的主复位信号经过 reset distribution tree 达到每个元件，实现复位。 reset distribution tree 和 clock distribution tree 最大的区别就是它们对 skew 的要求不同。由上面的讨论可知，复位信号和时钟的关系最好是 \" 同步释放 \"，不像时钟信号的要求那么严格，复位信号之间的 skew 不需要那么严格，只要复位信号的延迟足够小，满足能在一个时钟周期内到达所有的复位负载端，并且满足各个 reg 和 flip-flop 的 recovery time 即可。 in ASIC 在 ASIC 设计中，两种 tree 的关系有以下两种方式： 方案一： 驱动 reset tree 最安全的方法就是使用 clock tree 的叶子节点的时钟信号来驱动，如下图所示。如果采用这种方法且时序分析是满足的，那么就没有问题。 分析以下情况：clock tree 中的一路叶子时钟信号驱动 reset synchroinzer ，得到的复位信号 masterrst_n 穿过 reset tree，输入到 DFF 的复位端口；clock tree 的另外一路叶子时钟信号直接连接 DFF 的时钟端。 理想情况下（时钟速率不高），reset 支路即使经过 reset synchronizer 和 reset tree，仍然满足 slack 为正，满足时序，电路可以正常工作。 但是，在大多数情况下，时钟信号的频率都比较高，这些操作产生的延时太大，无法在一个时钟周期内完成，导致 slack 为负，此时无法满足时序要求。 方案二： 为了加速 reset 信号到达系统内的 DFF，使用进入 clock tree 之前的时钟信号来驱动 reset synchronizer，如图所示。这时候 reset 和 clock 是异步的，所以必须在 PAR 之后进行 STA ，以保证 若系统使用异步复位方式，则经过 reset tree 的复位信号释放 (release) 满足 恢复时间 (recovery time) 若系统使用同步复位方式，则经过 reset tree 的复位信号满足 建立时间 (setup time) 和 保持时间 (hold time) 。 一般来说，只有最后完成布局布线之后，才能根据具体情况进行分析调整 clock tree 和 reset tree。 对于 synchronou/asynchronous 两种 tree，可以用两种技术来进行优化： synchronous reset distribution tree 如下图所示，在 reset tree 中嵌入 DFF，在每个模块中，输入的 reset 信号首先经过一个 DFF，然后把经过 DFF 延迟输出的复位信号用作复位信号来复位逻辑、驱动子模块。这样 reset 信号就不必在一个时钟周期内到达每一个 DFF 的复位端口，从而可以把 reset 信号的时序要求降得很低。 通过这种技巧，复位信号就被当作了普通的数据信号，而且时序分析要简单的多（因为 reset tree 的每一部分 stage 都有合理的扇出）。 所以每个 module 里面都含有以下代码： code 1 2 3 4 input reset_raw ; // synposys sync_set_reset \"reset\" always @( posedge clk ) reset <= reset_raw ; reset_raw 是本模块的输入复位信号，reset 为经过 DFF 后的本地（local）复位信号，同时也连接子模块 reset_raw 的输入。 Advantage 降低 reset 的时序要求 降低 reset 的扇出 利于时序工具分析 Disadvantage 需要多个时钟周期才能复位 asynchronous reset distribution tree 和同步复位类似，异步复位也可以采用相同的策略，如下图所示： 利用前面讨论过的 reset synchronizer 将异步复位信号同步到每个子模块当中。 和 synchronous reset 一样，在 reset tree 中加入 synchronizer 之后，复位功能需要多个时钟周期才能完成。 Problem 因为不同的子模块深度不同，所以不同模块可能不是同时复位的（同一个时钟周期）。这种情况是否会引起问题，依应用情况而定，大多数设计都没有问题，但是如果要求一定要在同一时钟周期复位，那么就要平衡不同子模块内的 synchronizer 数量，无论是 synchronous 还是 asynchronous 都是一样的。 Advantage 前面讨论的 reset tree 和 clock tree 主要问题就是两者是异步的，一定要保证 reset 的释放满足 recovery time，在 P&R 之后，时序分析如果不满足的话，设计者需要手动调整时序，然后重新 P&R，时序分析直到满足为止。 作为对比，如果采用这里插入 synchronizer 的方法，则免去了手动调整的工作，让综合工具完成时序分析和调整工作。经过调整之后，全局（global）复位信号就变为本地（local）复位信号了。（synchronous 也一样，变为 local reset） in FPGA 对于 FPGA，因为系统的 clock tree 是预先布线好的，而全局主复位信号一般也使用时钟布线资源，所以不存在两棵 tree 之间关系的调整问题，所以只需要采用上面的 synchronou/asynchronous reset distribution tree 即可。 Multi-clock Reset 在一个系统中，往往有多个时钟，每个时钟域都应该有独立的 synchronizer 和 reset tree，这么做的目的是为了保证每个时钟域的每个寄存器都能满足 removal time。 因为只有一个全局复位的话，它与系统的时钟都没有关系，是异步复位信号，要求这个信号满足所有时钟域的 recovery 和 removal 时序不是一件容易的事情，因此为每个时钟域分配复位是有必要的。 根据实际情况的不同，有两种方案可以采用： Non-coordinated reset removal 对于多时钟域的设计，很多时候不同时钟域之间复位信号的先后顺序没有要求，尤其是在有 request-acknowledge 这样握手信号的系统中，不会引起硬件上的错误操作，这时候下图所示的方法就足够了。 Sequenced coordination of reset removal 对于一些设计，要求复位信号的释放顺序有一定顺序，这时候应该使用下图所示的方法 How do I reset my FPGA 在文中提供了一张图来说明典型的系统复位方案，图中 MMCM 的 lock 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。 Reset Glitch Filtering 最后讨论一下复位信号毛刺的问题。 使用异步复位信号时，考虑到异步复位信号对毛次比较敏感，所以在一些系统中需要处理毛次，下图显示了一种简单但是比较丑陋的方法 ( 时延不是固定的，会随温度、电压变化 ) 需要注意的是 毛刺 Glitch 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论待续 不是所有的系统都需要过滤毛刺，设计者要先研究需求，再觉得是否使用延时来过滤毛次 Summary 本文是读书笔记，总结了参考资料中的复位信号的设计方法和需要注意的问题，包含了底层的 DFF 复位方式、高 / 低电平有效、同步 / 异步复位、和系统级的复位方案选择、设计。 应该参考器件决定使用那种方式 对于 Xilinx 器件，应该使用高电平复位方式 尽可能使用同步复位，保持设计 \" 同步化 \" 如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了 (CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步 / 异步复位端口 ) 如果不带有同步复位端口，那么就需要使用异步复位同步化 应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。 采用 synchronou/asynchronous reset distribution tree 可以降低 reset 信号的时序要求，减小扇出 每个时钟域都应该有一个同步器来同步复位信号。 总而言之，一句话：我们想象中的，简单的，统一的复位方案是 ... 不存在的 =.= Reference Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use? Asynchronous & Synchronous Reset Design Techniques - Part Deux Get Smart About Reset: Think Local, Not Global How do I rest my FPGA FPGA 复位电路的实现及其时序分析 深入浅出玩转 FPGA 100 Power Tips for FPGA Designers Advanced FPGA Design by Steve Kilts","tags":"IC","loc":"https://qiangu.cool/posts/ic/the_art_of_reset_design_in_fpga.html","title":"FPGA 中的复位设计"},{"url":"https://qiangu.cool/posts/embedded/learn_arduino_series_3_intel_galileo_linux.html","text":"Linux on Galileo Board Galileo 不是简单的 Arduino 板子，实际上它运行着一个 Linux 操作系统。把它看作是 \" 兼容 Arduibo 接口的板子 \" 或许更合适一些。 Galileo 板子上容量为 8 MB 的 SPI Flash 中已经烧写了一个精简版的 Linux 系统，因为容量的限制，这个系统去掉了一些不常用的模块，比如 wi-fi 驱动，python 支持等。 Galileo 也支持从 SD 卡启动系统，并且 Intel 提供了一个基于 Yocto 项目，已经制作好的完整版 Linux 系统。当精简版系统不能满足我们的要求时（添加外设等），我们可以下载这个完整版系统镜像，烧录到 SD 卡中，并从 SD 卡中启动即可。（也可以自己基于 Yocto 项目按照自己的需求制作系统镜像） 我们并不仅仅满足于通过 Arduino IDE 对 Galileo 进行操作，放着一个操作系统，为什么不去使用呢：-P 那么怎么才能登录到这个 Linux 系统中呢？ Using Ethernet Intel 论坛的一个帖子列举了几种登录到 Galileo Linux 的方法 Connecting to Galileo via Linux Console Use the UART connector Use the LAN connection direct to your PC Use the LAN connection and connect to your local network You can also connect using WiFi 考虑到我们目前有的材料 Galileo 开发板 Galileo 电源 micro USB 线 5 类网线 运行着 Linux (Ubuntu) 的 PC 因为没有串口线，所以我们采用第 2 种方案，即直接连接 PC 和 Galileo，通过 Ethernet 登录。 Summary Galileo 默认是不开启 Lan 的，也不开启 Telnet 服务，所以我们需要做的事就是写一个 sketch ，启动 Lan 连接服务和 Telnet 服务，然后分别给 PC 和 Galileo 一个属于同一子网的静态 IP 地址，这样就可以使用 PC 通过 Telnet 协议登录到 Galileo 上的 Linux 系统中。 Setp 1: Write sketch 代码需要完成的功能一共有 3 个： 开启 telnet 服务 1 system ( \"telnetd -l /bin/sh\" ) ; 设置 IP 地址 1 system ( \"ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up\" ) ; 将板子的以太网配置状态显示在 serial monitor 中 1 system ( \"ifconfig eth0 > /dev/ttyACM0\" ) 全部代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void setup () { // put your setup code here, to run once: // Initial serial prot Serial . begin ( 9600 ); // Start telnet service on board system ( \"telnetd -l /bin/sh\" ); // Assign the IP address '169.254.1.1' to it system ( \"ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up\" ); } void loop () { // put your main code here, to run repeatedly: // Show the IP detial in the serial monitor of IDE system ( \"ifconfig eth0 &> /dev/ttyGS0 &\" ); sleep ( 10 ); } Step 2: Connect，Upload 网线直连 PC 和 Galileo，设置 PC 的 IP 地址为 link-local only 给 Galileo 供电 连接 USB 打开 Arduino IDE， Upload 上面的 sketch Step 3: Login 打开 IDE 的 serial monitor，可以看到 Galileo 的 ethernet 配置信息 查看 PC 的网络配置 1 $ ifconfig eth0 查询结果 打开 PC 的终端 Terminal，使用 telnet 登录 1 telnet 169 .254.1.1 登录结果，如图 可以看到，这个精简版的 Linux 系统是不支持 Python 的。 Using UART About serial port 如果有串口线的话，我们也可以通过串口来登录，包括 SPI 和 SD 卡上的系统。 关于串口线，说明一下。估计是为了节省板子的面积，Intel 在板子上设置的是音频接口 (AV jack)，所以，这里需要额外的一个将音频接口转接为串口的器件。有两种方法： 上网买一个 自己 DIY 一个 如果上网买的话，注意 Galileo 用的是 RS232 电平，不要买错成 TTL 电平的。如果是自己 DIY 的话，Intel Galileo Get Started 里面有介绍串口线的接法，他们的论坛上也有相关的讨论： UART cable pin-out RS 232 DE-9 port Linux Platform 我在 Ubuntu 下使用的终端软件是 gtkterm 。 Step 1: Burn the full-linux sytem Intel 官网提供的完整版 Linux 镜像是基于 Yocto 项目裁剪出来的，取名叫 Claton ，目前 (2014-6-13) 的版本号为 1.0.0 ，但是这个版本在我的 SD 卡中是无法启动的，浪费了大量时间，最后终于发现 0.7.5 版本可以 ... 还有就是 Get Started 中推荐不要使用 PC 操作系统提供的格式化功能，更好的选择应该是专业格式化软件，比如 SDFormatter 。但是我实际使用时，发现反而是 SDFormatter 制作的不能启动 ... Step 2: Connect 插入 SD 卡 配置串口 选择正确的端口（因为我使用的串口线是 AV-RS232-USB ，所以下面选择的端口是 ttyUSB0 ）； Baud Rate = 115200 ， Bits =8 ， Stopbits = 1 ， Parity = none ， Flow control = none 先不要接 USB 下载线，给板子上电 Step 3: Login 这时候我们应该就可以从串口看到板子上电后 grub 程序和系统启动的相关信息了。 上电后， grub 引导启动哪个系统 登录到 SPI Flash 中的 Linux 中 如图，这个精简版的系统不支持 python 登录到 mirco-SD card 中的 Linux 中 如图，SD 卡中的系统是支持 python 的 Windows Platform 我在 Windows 下使用的终端软件是 Putty 。 Step 1: Burn the full-linux system 与 Linux 平台下相同。 Step 2: Connect 插入 SD 卡 配置串口 同样，选择正确的端口和波特率。 先不要接 USB 下载线，给板子上电 Step 3: Login 这时候我们应该就可以从串口看到板子上电后 grub 程序和系统启动的相关信息了。 上电后， grub 引导启动哪个系统 登录到 SPI Flash 中的 Linux 中 如图，这个精简版的系统不支持 python 登录到 mirco-SD card 中的 Linux 中 如图，SD 卡中的系统是支持 python 的 Another method 如果你觉得插网线、配置 IP 地址太麻烦，甚至懒得自己 DIY 串口线，也没有钱去买一个，别担心，因为 \" 天空飘来五个字，这都不是事～\" 因为你可以借鉴下面这位大神的方法，只需要像下载普通 sketch 一样，将他提供的 sketch 下载到 Galileo 中就可以了，然后通过 IDE 的 serial monitor 就可以登录到 Linux 系统中： Poor man's telnet for Galileo 他的 sketch 的原理就是使用 system() 函数将我们在 serial monitor 中的命令传到到 Linux shell 中 ，并将命令的结果返回到 serial monitor 中 。 不过这种方法的缺点是每个命令传递到 Galileo 后会开辟一个新的进程，当命令执行完返回结果时，这个进程自动结束，所以会产生一些 \" 问题 \"：当我们 cd 到某个子目录后，返回结果之后，我们又回到的之前的目录，举例 1 2 3 4 $ cd home $ pwd // result is root dirctory 解决方法就是将命令写在一行 1 2 3 $ cd home ; pwd // result is home directory Reference Connecting to Galileo via Linux Console Tutorial 3: Connecting to Linux through telnet Using Galileo Linux over Ethernet(Telnet) Poor man's telnet for Galileo","tags":"Embedded","loc":"https://qiangu.cool/posts/embedded/learn_arduino_series_3_intel_galileo_linux.html","title":"学习 Arduino #3 Intel Galileo Linux"},{"url":"https://qiangu.cool/posts/ic/fsm_design.html","text":"有限状态机是数字电路中经常出现、非常重要的电路，设计一个安全、高效的状态机有一套程序化的方法，我们在数字电路课中就学习过了。搬运以前写的博客，总结一下相关知识，温故而知新～ 写在前面的废话： 这篇博客是在我以前在 CSDN 上写的两篇博客的基础上，参考了其他各位大神、博主的文章，写的总结。欢迎批评、讨论，毕竟写博客的意义就在于给自己一个总结知识的机会、并且在和别人讨论的过程中进步 :-D What is FSM FSM on wiki 有限状态机 (Finite State Machine, FSM) 有时候也简称为 状态机 (state machine) ，它是一种数学模型，通常用来设计电脑程序或者时序电路。它被构思设计为一个抽象的机器，并且某个时刻只能处于一个有限数字代表的状态之下。 有限状态自动机在很多不同领域中是重要的，包括电子工程、语言学、计算机科学、哲学、生物学、数学和逻辑学。有限状态机是在自动机理论和计算理论中研究的一类自动机。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。( 这里讨论的只限于电子工程里的状态机 ) 组成元素： 输入、状态、状态转移条件、输出 描述方式： 状态转移图 状态转移表 HDL 描述 分类： 状态机的框图如下： 按照输出的产生方式，可以将状态机分为两类： Moore 它的输出只取决于当前状态，而与输入无关。Moore 状态机最重要的特点就是将输入与输出信号隔离开来，而且输出与时钟信号同步的。 Mealy 它的输出不仅和当前状态有关，而且和输入也有关。Mealy 有限状态机对输入的响应发生在当前时钟周期，比 Moore 有限状态机对输入信号的响应要早一个周期。因此，输入信号的噪声可能影响在输出的信号。 How to Design a FSM 关于如何设计一个状态机，这在数字电路和逻辑设计的书里有详细介绍。简单地总结一下步骤： 逻辑抽象，建立原始状态转移图：确定输入、输出、状态变量、画状态转移图 状态简化，得到最简的状态转移图 ( 卡诺图 ) 状态分配，选择编码方案 (Binary、Gray、One-Hot) 画逻辑图，检查能否自启动，得到了最终的状态机模型 How to implement a FSM 当设计好之后，就要使用 HDL 语言来实现这个 FSM 了。 语言： Verilog HDL 综合工具： XST (Xilinx Synthesis Tools) Coding goals 我们的代码需要达到的目的应该是： The FSM coding style should be easily modified to change state encodings and FSM styles The coding style should be compact The coding style should be easy to code and understand The coding style should facilitate debugging The coding style should yield efficient synthesis results Template 为了达到目的，总结出了下面的这个三段式的模板（使用 index one-hot + reverse case + synopsys FSM 语法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 parameter [ 4 : 0 ] // synopsys enum code IDLE = 5 'd0 , S1 = 5 'd1 , S2 = 5 'd2 , S3 = 5 'd3 , ERROR = 5 'd4 ; // synopsys state_vector state reg [ 4 : 0 ] // synopsys enum code CS , NS ; always @( posedge clk ) begin if ( rst ) begin CS <= 5 'd0 ; CS [ IDLE ] <= 1 'b1 ; end else begin CS <= NS ; end end always @ * begin NS = 5 'b0 ; case ( 1 'b1 ) // synopsys full_case parallel_case CS [ IDLE ] : begin if () //... else if () //... else NS [ ERROR ] = 1 'b1 ; end CS [ S1 ] : begin if () //... else if () //... else NS [ ERROR ] = 1 'b1 ; end CS [ S2 ] : begin if () //... else if () //... else NS [ ERROR ] = 1 'b1 ; end CS [ S3 ] : begin if () //... else if () //... else NS [ ERROR ] = 1 'b1 ; end CS [ ERROR ] : begin if ( restart ) NS [ IDLE ] = 1 'b1 ; endcase end always @( posedge clk ) begin if ( rst ) begin // reset end else begin // default output case ( 1 'b1 ) NS [ IDLE ] : begin // ... end NS [ S1 ] : begin // ... end NS [ S2 ] : begin // ... end NS [ S3 ] : begin // ... end NS [ ERROR ] : begin // ... end endcase end end 需要注意的是 synopsys FSM 的语法： parameter 定义的两端都要定义位宽，不能省略 注释 // synopsys ... 的位置不能随意改变 即使改用其他的综合工具，前面的 FSM 定义的综合指令不影响，需要修改的只有 case 综合指令（如 XST 改为 // synthesis full_case parallel_case ）。 下面逐个讨论为什么这么写，以及需要注意的问题。 Always Block 状态机一般有三种写法，他们在速度、面积、代码可维护性等各个方面互有优劣。 一段式： 只有一个 always block，把所有的逻辑（输入、输出、状态）都在一个 always block 中实现 优点：看起来很简洁 缺点：不利于维护，如果状态复杂一些就很容易出错。 不推荐这种方法，但是在简单的状态机可以使用。 二段式： 有两个 always block，把时序逻辑和组合逻辑分隔开来。时序逻辑里进行当前状态和下一状态的切换，组合逻辑实现各个输入、输出以及状态判断。 优点：便于阅读、理解、维护，而且利于综合器优化代码，利于用户添加合适的时序约束条件，利于布局布线器实现设计 缺点：输出是组合逻辑，可能含有毛刺 解决输出毛刺的问题，最简单的方法就是用寄存器打一拍，但很多情况不允许插入寄存器节拍，此时使用三段式描述。其优势在于能够根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而不需要额外插入时钟节拍。 三段式： 有三个 always block，一个时序逻辑采用同步时序的方式描述状态转移，一个采用组合逻辑的方式判断状态转移条件、描述状态转移规律，第三个模块使用同步时序的方式描述每个状态的输出。这 3 个 always block 正好对应图示的 3 个子模块，更加容易理解。 优点：代码容易维护，时序逻辑的输出解决了两段式组合逻辑的毛刺问题 缺点： 代码量大、资源消耗多一些 一段 or 三段？ 一般来说，三段式的效果更好，唯一的缺点是占用的资源稍微多一点 ( 对于拥有丰富的触发器资源的 FPGA 来说，这个缺点可以忽略吧 )。所以除非是非常简单的状态机用一段式实现，其他情况下三段式更简单。 localparam 尽量使用 localparam 而不是 define 和 parameter 。这个原则不仅仅限于 FSM，其他模块也应该遵守。 Reason 不使用 define ：在设计中很可能有多个 FSM，而且它们很可能包含有相同的状态名，使用 define 定义的状态名是全局可见的，那么这些 FSM 之间会相互影响（C++ 解决这个问题的方法是 namespace） 不使用 parameter ：虽然 parameter 定义的参数是局部的，但是它可以被其他模块通过参数修改。FSM 中的状态定义应该是内部可见的，外部模块应该是不能修改的（类似于 C++ 中 class 的 private 成员）。 综上，使用 localparam 是更好的选择。 Reset FPGA 上电时，GSR(Global Set/Reset) 拉高，对所有 寄存器 /RAM 进行复位，此时配置于 FPGA 的逻辑并未生效，所以不能保证 FSM 进入正确的初始化状态。 解决方法： 一般，FSM 使用用户定义的复位 ( 同步 or 异步 )。 1 2 3 4 5 6 7 8 9 // Synchronous Reset always @( posedge clk ) begin if ( rst ) begin CS <= IDLE ; end else begin CS <= NS ; end end 还有一种方法，是将初始状态编码为全 0 ( 带 0 的 One-Hot 编码方式 )，这样当 GSR 复位后，状态机自动进入初始状态。 State encode 状态机的状态的编码，通常有 Binary 、 One-Hot 、 Gray 码等几种。 Binary 码 采用最简单的递增的编码方式对状态进行编码，对于 n 个状态的状态机，共需要 log2(n) 个触发器表示所有的状态。 优点：在状态很多的情况下，可以大大减少触发器的数量，对设计的面积有积极的作用。 缺点：但是在状态跳转过程中，很可能出现多位同时变化的情况，容易在 next state 的生成逻辑上产生毛刺。同时，输出也是所有状态位的译码，译码逻辑多数很复杂，往往成为整个设计的关键路径。 Gray 码 类似 Binary，但是采用了格雷码的编码方式，每两个相邻的状态只有一位信号变化。 优点：避免了 next state 上毛刺的产生。同时两个相邻状态的输出译码变得简单了，避免了复杂组合逻辑的产生。 缺点；格雷码的这些优点都是建立在状态跳转是顺序执行的基础上的。如果状态机有很多随机跳转和分支，格雷码的实际效果和二进制码相差无几，优势荡然无存。 One-Hot 码 当前设计中最常用的状态机编码方式。One-Hot 编码在一组 0 中只有一个 1，对一个 n 个状态的 FSM 设计，需要 n 个触发器。 优点：在任意两个状态之间跳转都只有两位状态位变化，不会产生非常复杂的组合逻辑。各个状态之间的译码也相对简单。 缺点：对状态编码需要的寄存器比其他方式多，不过这个缺点基本可以忽略吧 :-P 结论： Binary、Gray 编码使用最少的触发器，较多的组合逻辑。而 One-Hot 编码反之。由于 CPLD 更多的提供组合逻辑资源，而 FPGA 更多的提供触发器资源，所以 CPLD 多使用 Gray，而 FPGA 多使用 One-Hot 编码。另一方面，对于小型设计使用 Gray 和 Binary 编码更有效，而大型状态机使用 One-Hot 更高效。 (XST 的选项 FSM encoding algorithm 值默认为 auto ，编写程序测试发现，它会根据代码中状态的多少，FSM 的复杂度，自动选择合适的编码方式对状态进行编码。) P.S. one-hot 和 reverse case 相结合，可以得到一种更加简洁的电路（如模板所示的 index one-hot），这种方式和传统的 one-hot 相比，它不再是对比整个状态向量的值，而是逐 bit 对比，从而简化了状态译码电路。 利用前面的模板和结尾附录的模板，对参考文章 Steve Golson State machine design techniques for Verilog and VHDL 中的状态机例子进行综合测试，实际结果证实了 index 方式要更加节省资源（如果状态机更加复杂一些的话，两者的差别应该更大）： index one-hot style: index.v non-index one-hot style: non-index.v ======================== 分割线 ============================= 使用 XST 综合上面的 index one-hot + reverse case 风格的 FSM，结果 XST 并没有识别出 FSM，而 Synplify 我没有破解版本，只能作罢 =.= 虽然 XST 没有识别出 non-index 的 FSM，但是 Modelsim 是可以识别出来的，可以在 Modelsim 中查看最终综合出来的 FSM 如下： 补上普通的 one-hot + case 的模板，这个模板是可以被 XST 识别出来的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 parameter [ 4 : 0 ] // synopsys enum code IDLE = 5 'b00001 , S1 = 5 'b00010 , S2 = 5 'b00100 , S3 = 5 'b01000 , ERROR = 5 'b10000 ; // synopsys state_vector state reg [ 4 : 0 ] // synopsys enum code CS , NS ; always @( posedge clk ) begin if ( rst ) begin CS <= IDLE ; end else begin CS <= NS ; end end always @ * begin NS = 5 ' bx ; case ( CS ) // synopsys full_case parallel_case IDLE: begin if () //... else if () //... else NS = ERROR ; end S1: begin if () //... else if () //... else NS = ERROR ; end S2: begin if () //... else if () //... else NS = ERROR ; end S3: begin if () //... else if () //... else NS = ERROR ; end ERROR: begin if ( restart ) NS = IDLE ; endcase end always @( posedge clk ) begin if ( rst ) begin // reset end else begin // default output case ( NS ) IDLE: begin // ... end S1: begin // ... end S2: begin // ... end S3: begin // ... end ERROR: begin // ... end endcase end end ======================== 分割线 ============================= Safe FSM 所谓 \" 安全 \" 的状态机，就是说即使因为某些意外原因，状态机跑飞了，仍然可以自动回复到正常状态。 举例：可能出现的不安全情况 比如，我们采用 One-Hot 编码方式，对于 8 个状态，总共使用了 8 bit 的寄存器，那么这个状态寄存器向量可以取到的值一共有 2&#94;8 = 256 种。如果我们只对需要的 8 种状态进行了说明，而忽略了剩余的 248 种，此时综合工具 (Synplify、XST) 会对设计进行 \" 优化 \"，将没有用到的状态去掉。但是，有时候这种 \" 优化 \" 反而不好，如果状态机进入未定义的全 0 状态，那么它就会卡在这个未定义的状态，无法自动回复正常工作状态。 解决方法 有两种方法： 如果我们对状态向量的所有取值情况都显式地进行了说明，那么这个状态机就是安全的，否则就是不安全的。书写完备的 case 语句。在代码中对每一种可能的取值对进行描述，对于不使用的状态编码，一定要有 default 分支进行说明。 在第二段 always 中， 1 2 3 default : begian NS = IDLE ; end 这里应该赋值 8'bx 更合理，因为状态机上电时处于未知状态，所以应该赋值 x 更符合实际，但是这样赋值必须有个条件，就是必须所有的状态编码都全部被使用了，不然就会出现锁死现象，FSM 无法返回工作状态。我们前面使用的是 One-Hot 编码方式，有大量无效状态，所以这里不能赋值为 x 。 XST 支持状态机编码的完备属性 —— case implementation style 但是这个设置可能会导致前后仿真不一致的问题，一般不使用。我们应该在代码中满足条件，而不是依靠综合工具。 XST 的选项 safe implementation 值默认为 None ，如果应用环境要求 FSM 必须能恢复任何错误，比如航天、医疗、汽车等，这时我们可以打开这个设置，这时综合工具会添加额外的逻辑，保证 FSM 可以从无效状态恢复过来。 即使使用第一种方法，似乎我们的状态机已经是 perfect 了，但是真的是这样么？考虑这种情况：一个状态机有 8 个状态，采用 One-Hot 编码方式，代码含有 default 分支处理未定义的状态向量可能取到的值。现在把这个状态机放在卫星中，接受宇宙射线的辐射，导致状态向量的值发生了变化，进入了无效状态，然后状态机自动恢复到正常状态 (Good Job)，但是！状态机的外围电路并没有随着状态机恢复，它还在等 FSM 输出某个信号呢。 所以，仅仅是回到正常状态并不够，最好的设计应该有个错误状态专门来与外围电路通信，当 FSM 进入错误状态时，外围电路会检测到这个错误状态，并采取合适的措施（如重启、复位 FSM）。 结合上面讨论的 index one-hot 编码方式，就有了两种方案： 显式地定义定义一个 ERROR state 如模板所示。 比如一个 FSM，有 4 个状态，分别是 IDLE、S1、S2、S3，那么额外定义一个 ERROR 状态机的框图如下： parameter [ 4 : 0 ] IDLE = 5 'd0, S1 = 5' d1 , S2 = 5 'd2, S3 = 5' d3 , ERROR = 5 ' d4 ; 在每个 case item 中，最后添加一个 else 分支且 NS[ERROR] = 1'b1 ，并且多加一个 case item CS [ ERROR ]: begin if ( restart ) NS [ IDLE ] = 1 ' b1; end zero-idle 在状态定义时，不用显式地定义一个 ERROR 状态，而是用全 0 状态表示 ERROR 状态： parameter [ 4 : 1 ] IDLE = 5 'd1, S1 = 5' d2 , S2 = 5 'd3, S3 = 5' d4 ; 多加一个 case item： ~| CS : begin if ( restart ) NS [ IDLE ] = 1 ' b1; end 对比两种方式，我觉得第一种更能体现出设计意图，所以在模板中选择这种方式。 case(CS) 使用 case 的原则： 尽量不要使用综合指令 full_case 和 parallel_case，而是代码本身满足 full、parallel 的条件（因为综合指令可能导致前后仿真不一致的问题） 下面根据状态编码方案分类讨论： 如果使用 \" 非 index one-hot + 非 reverse case\" 的方法，那么在第二个 always block 中，在 case 前给 NS 一个默认值（如下） NS = 8 ' bx ; 这是个很有用的小技巧，它可以帮助我们在综合前发现状态是否完备：如果状态完备，则在下面的 case 中会给 NS 合适的值；如果状态不完备，则状态机会进入错误状态，输出不定，仿真时可以很快的发现。而且，综合工具对于 x 采取的态度是 don't care ，综合时会自动将其忽略，生成的电路最简洁。 如果使用 index one-hot + reverse case 的方式： NS 必须赋值为全 0： NS = 8 ' b0 ; 使用 synopsys 综合指令 一般的原则是尽量不要使用综合指令，这里是个特殊情况。 // synopsys full_case parallel_case default 分支 使用了综合指令，则 default 分支在综合时就没有必要，但是仿真器并不能识别综合指令，所以在行为仿真的时候仍然需要 default 分支，所以可以用下面的方法： // synopsys translate_off default : $ display ( \"FSM is dead!\" ); // synopsys translate_on 采用 index one-hot + reverse case 的方式，这里违背了 case 语句本身满足 full_case、parallel_case 的原则，使用了综合指令、并且省掉了 default 分支，是唯一的例外情况，其他情况下都应该遵守这一原则！ Ouput 避免 Latch 在第三个 always 中，在 case 前，所有的输出都有默认的值，这样做的好处是可以消除 Latch 的出现，而且，可以减少在后面每种状态下重复相同的赋值，而且强调显示了 case 内哪个输出发生了变化。 另外一种避免 latch 的方法：书写完备的 if-else 和 case 语句。 消除输出毛刺 对于三段式，因为输出是寄存器输出，所以解决了输出毛次。 讨论一下采用寄存器输出的方式对设计的影响 输出采用寄存器驱动可以优化 FSM 的时序性能 影响一个时序电路运行速度的主要因素是两个寄存器之间的组合逻辑路径的长度，越长的组合逻辑路径，其时序性能越差。一个电路中的最长组合逻辑路径决定了这个电路最高运行速率，该路径就是这个电路的关键路径（ critical path ）。所以，切断最长的组合逻辑路径可以提高局部电路的运行速度，切断多个较长的组合逻辑路径可以提高整体电路的运行速度。切断组合逻辑路径的工具就是寄存器。所以，添加寄存器可以提高电路的性能，但是会增加资源的消耗，这也是速度（speed）和面积（area）互为矛盾的原因。 在考虑 FSM 的时序问题时，不能独立的考虑 FSM 本身，需要综合考虑 FSM 模块和下游模块构成的电路。在 FSM 不采用输出寄存时，在 FSM 模块和下游模块的接口处，是两部分组合逻辑直接相连。关键路径由两部分组合逻辑构成；在 FSM 采用输出寄存时，两个模块的组合逻辑被分隔成两部分，可能的关键路径被切断了。同步寄存器输出和组合逻辑输出就是采用资源优化还是速度优化的问题。组合逻辑表面上会提高电路的速度，看似节省了资源而且提高了速度，其实不然（对 FPGA 结构来说，节省寄存器不等于节省 LE；对同步设计来说，异步输出速度上的优势是可以忽略的）。 输出采用寄存器驱动会降低输出队输入信号变化的响应速度？ 到底应不应该采用 FSM 输出寄存器？是否必须在时序性能和响应速度之间做出取舍？在同步设计中，答案是必须牺牲一定的响应速度以换取更佳的时序性能，只考虑响应速度会带来潜在的时序性能损失。 在考虑 FSM 的响应速度时，不能独立的考虑 FSM 本身，需要综合考虑 FSM 模块和上、下游模块构成的电路。采用输出寄存器的电路可以运行在更高的时钟频率下，所引入的响应时延与更高的运行频率相比是可以牺牲的。 case (NS) vs case (CS) 采用二段式实现状态机，它的输出是组合逻辑，可能存在竞争和冒险，产生毛刺，要消除毛刺就要对输出用寄存器打一拍，但是很多时候，是不允许插入寄存器节拍的。 这时候可以采用三段式实现，三段式的输出是寄存器输出，所以消除了毛次；同时，如果三段式的第三段判断输出采用 1 2 3 4 5 6 7 8 9 case ( NS ) IDLE: begin // .... end // ... default : begian // ... end endcase 就可以提前判断下一状态的输出，节省了一个节拍，使输出和状态变化同步。 example 设计一个简单的 FSM，测试使用 case(CS) 和 case(NS) 的结果： FSM 设计：一共有 4 个状态 (IDLE、S1、S2、S3)，只有一个输入 ( jump 信号 )，两个输出 ( dout_p 、 dout_q )。 跳转规律：状态机开始处于 IDLE 状态，当 jump 变高时，从 IDLE 跳转到 S1 状态，同时内部的一个 4 bit 计数器开始计数，当计数到 4'b1111 时，跳转到 S2，当再次计数到 4'b1111 时跳转到 S3，当再次计数到 4'b1111 时，跳转到 IDLE，等待 jump 再次变高。状态转移图： 程序： 状态机源文件 fsm.v 测试平台 testbench tb_fsm.v 仿真结果：使用 NS 判断，结果如下图，可以看到，当 CS 发生变化时，输出同时改变。 使用 CS 判断，结果如下图，可以看到，当 CS 发生变化时，输出变化相对于状态变化延时一个时钟周期。 Ref Clifford E. Cumming State Machine Coding Styles for Synthesis Clifford E. Cumming The Fundamentals of Efficient Synthesizable Finite State Machine Design using NC-Verilog and BuildGates Steve Golson State machine design techniques for Verilog and VHDL Verilog HDL 学习心得 foreveryoung 《状态机设计》 云创工作室《 Verilog HDL 程序设计与实践》","tags":"IC","loc":"https://qiangu.cool/posts/ic/fsm_design.html","title":"有限状态机 FSM 设计"},{"url":"https://qiangu.cool/posts/embedded/learn_arduino_series_2_intel_galileo_development_board.html","text":"Preface Arduino 有很多开发板，分别针对不同的应用环境含有不同的模块。学习一款 Intel 推出的开发板 —— Intel Galileo Development Board 。 Intel Gailileo Development Board 是 Intel 进入 Arduino 领域的试水产品，它含有一颗 Quark Soc X1000 CPU，这是一款 32 位、x86 构架、低功耗的 SoC 芯片，它的主频可以达到 400 MHz，内部有 512 KB 的 SRAM，同时 Galileo 有丰富的接口 (USB, JTag, RS232, Ethernet, mPCIE...)，支持很多外围设备。 Galileo 试图达到的目标是融合 Arduino 对硬件操作的便利和 Linux 系统对硬件操作完整支持。所以，Galileo 也兼容 Arduino 接口，你可以很方便的把 Arduino 项目移植到 Galileo 上运行，使用常用的一些 Arduino 库 (Ethernet, Wi-Fi, SD, EEPROM...) 也可以获得内部 Linux 系统的完整功能 (Python, SSH, Telnet， OpenCV...)。 总结一下我学习这块板子的知识，不仅仅为 Arduino 开发做准备，也为后面的一个竞赛 ( 基于 Yocto 项目 ) 开发积累知识～ Official Arduino Boards Arduino 官网上列出所有了官方开发板，其中也包含了官方认证过的开发板 (Intel Galileo)，和一些推荐的第三方产品 Arduino Products 还详细列出了这些开发板上的微控制器的区别 Compare boards specs 官方的开发板的核心都是 Atmel 的微控制器，基于市场战略的需求，看到数莓派、Arduino 发展的热火朝天，Intel 也坐不住了 ( 瞎猜的 =.=)，推出了新的基于 Intel 架构 (x86)、可以和 Arduino 兼容的开发板。Galileo 是这个家族中的第一款，目前 Intel 又推出了一款新的开发板，取名叫 Edison。(Intel 这是要把所有科学家的名字都取个遍么 ) Intel Galileo Board Arduinco.cc 在 Arduino 官网上有一篇简单介绍 Galileo 的网页 Intel Galileo on arduino.cc Intel Official Introduction Arduino 官网上的介绍只是非常简单的介绍，Intel 自己的官网上有关于 Galileo 全部的详细资料 Galileo Maker Quark Board 关于 Galileo 的全部文档，包括 Datasheet、Schematic、Quick Start、User Guide 等： Intel Galileo Development Board Documents Other Introductions 首先 送上一篇非常好的介绍文章（来自 Ifanr.com），介绍了在 Maker 眼中，这个板子到底可以 hack 到什么程度～ x86 版的 Arduino 来了，Intel Galileo 开发板的体验、分析和应用【超长文多图】 再 附上一篇完爆我的总结的教程～ Galileo Getting Started Guide 这篇教程基本就是按照 Intel 官方的 Getting Started 流程写的，总结一下我遇到的问题 (Windows 7 & Linux Ubuntu)。 Arduino 官方的 IDE 中 Board 选项中没有 Galileo，所以我们应该从 Intel 下载定制过的 IDE。 Windows IDE 闪退 这个 IDE 在部分 Windows 下有闪退的现象。 原因 是 Intel 的 IDE 版本采用的是未发布的 1.5.3, 它会检测系统的语言设置，当系统不是 En/US 时，就会退出。 解决方法 更改系统语言设置 或者 使用一款名为 Locale Emulator 的软件。 IDE 解压路径 Windows 下的解压路径 必须是顶层目录 ，比如 D:\\arduino-1.5.3 ，否则在 Verify 时会提示找不到特定的文件 / 目录。Linux 下无此问题。 Linux 连接板子和 PC 在 Windows 下第一次连接系统自动安装驱动肯定会失败的，需要我们手动指定驱动文件的路径。 在 Linux 终端下，必须以 sudo 权限运行 IDE，否则即使板子已经连接了 PC，在 IDE 下的 Tools\\Serial Port 是 disable 的，不能选择端口 1 $ sudo ./arduino & Linux 下 disable modem manager 前面的教程中提到，在大多数 Linux 发行版下，都需要 disable modem manager 才能 Upload 成功，不过我在 Ubuntu 下没有遇到这个问题 ... 然后 扯几句 硬件配置 从 Board Guide 中找到的截图如下 从它的配置中可以看到，Galileo 并不是一款简单的 Arduino 开发板，它的硬件系统其实是按照 PC 来设计的，如果我们只是简单的把它当作 Arduino 开发板来应用，有点大材小用了，这样子完全没有体现出 Galileo 的优势，只是一个速度更快的 Arduino 罢了。 事实上，如果功能上没有比传统的 Arduino 更强大的功能，估计 Intel 也不会推出这个产品了～Galileo 的真正强大的地方在于： 背后基于 UEFI/Linux 的软件平台以及 Galileo 自身的硬件配置。为此，Intel 提供了丰富的开发文档、软件代码支持，方便开发人员真正的发挥出 Galileo 的所有潜力。 软件构架 Galileo 不仅仅是硬件上按照 PC 设计的，事实上，它的软件构架也和 PC 一样。和普通的单片机不同，它并不是简单的运行用户开发的程序那么简单。它实际上运行着一个操作系统 —— 包含 UEFI(BIOS 的替代者 )、Grub、嵌入式 Linux 系统，用户编写的 Sketch 只是一个在 Linux 上面运行的应用而已。 Galileo 启动时可以从 ISP Flash 中启动一个微型的 Linux 系统，也可以从 MicroSD 卡中启动一个完整版的 Linux 系统。我们 Upload 时，Arduino IDE 将程序编译链接成一个标准的 Linux ELF 文件，并且下载到 Arduino 板子上运行，如图所示 开发嵌入式 Linux 设备 或许这才是 Galileo 的 \" 正经 \" 用途吧 ... 基于 Yocto Project，我们可以开发属于自己的 Linux 系统。 最后，送上一个别人的 Galileo 开箱视频","tags":"Embedded","loc":"https://qiangu.cool/posts/embedded/learn_arduino_series_2_intel_galileo_development_board.html","title":"学习 Arduino #2 初识 Intel Galileo 开发板"},{"url":"https://qiangu.cool/posts/embedded/learn_arduino_series_1_getting_started.html","text":"What is Arduino 版权所有：Arduino.cc Arduino 官网 首页的介绍： ARDUINO IS AN OPEN-SOURCE ELECTRONICS PROTOTYPING PLATFORM BASED ON FLEXIBLE, EASY-TO-USE HARDWARE AND SOFTWARE. IT'S INTENDED FOR ARTISTS, DESIGNERS, HOBBYISTS AND ANYONE INTERESTED IN CREATING INTERACTIVE OBJECTS OR ENVIRONMENTS. 官方网站最权威的答案： Arduino is a tool for making computers that can sense and control more of the physical world than your desktop computer. It's an open-source physical computing platform based on a simple microcontroller board, and a development environment for writing software for the board. Arduino can be used to develop interactive objects, taking inputs from a variety of switches or sensors, and controlling a variety of lights, motors, and other physical outputs. Arduino projects can be stand-alone, or they can communicate with software running on your computer (e.g. Flash, Processing, MaxMSP.) The boards can be assembled by hand or purchased preassembled; the open-source IDE can be downloaded for free. Development Language： Arduino programming language IDE： Arduino IDE 补充： Wikipedia 上的介绍 简单的说： Arduino 是一个开放源代码的单片机，它使用了 Atmel AVR 单片机，采用了基于开放源代码的软硬件平台，构建于开放源代码 simple I/O 接口板。开发语言为 Arduino programming language（基于 Wiring 语言），开发环境基于 Processing 。 Story of Arduino wikipedia 上的 小故事 ： Arduino 的核心开发团队成员包括：Massimo Banzi，David Cuartielles，Tom Igoe，Gianluca Martino，David Mellis 和 Nicholas Zambetti。 据说 Massimo Banzi 之前是意大利 Ivrea 一家高科技设计学校的老师。他的学生们经常抱怨找不到便宜好用的微控制器。2005 年冬天， Massimo Banzi 跟 David Cuartielles 讨论了这个问题。David Cuartielles 是一个西班牙籍芯片工程师，当时在这所学校做访问学者。两人决定设计自己的电路板，并引入了 Banzi 的学生 David Mellis 为电路板设计编程语言。两天以后，David Mellis 就写出了程式码。又过了三天，电路板就完工了。这块电路板被命名为 Arduino。几乎任何人，即使不懂电脑编程，也能用 Arduino 做出很酷的东西，比如对传感器作出回应，闪烁灯光，还能控制马达。随后 Banzi，Cuartielles，和 Mellis 把设计图放到了网上。保持设计的开放源码理念，因为版权法可以监管开源软件，却很难用在硬件上，他们决定采用共享创意许可。共享创意是为保护开放版权行为而出现的类似 GPL 的一种许可（license）。在共享创意许可下，任何人都被允许生产电路板的复制品，还能重新设计，甚至销售原设计的复制品。你不需要付版税，甚至不用取得 Arduino 团队的许可。然而，如果你重新发布了引用设计，你必须说明原始 Arduino 团队的贡献。如果你调整或改动了电路板，你的最新设计必须使用相同或类似的共享创意许可，以保证新版本的 Arduino 电路板也会一样的自由和开放。唯一被保留的只有 Arduino 这个名字。它被注册成了商标。如果有人想用这个名字卖电路板，那他们可能必须付一点商标费用给 Arduino 的核心开发团队成员。 Why is Arduino 官网介绍 ： There are many other microcontrollers and microcontroller platforms available for physical computing. Parallax Basic Stamp, Netmedia's BX-24, Phidgets, MIT's Handyboard, and many others offer similar functionality. All of these tools take the messy details of microcontroller programming and wrap it up in an easy-to-use package. Arduino also simplifies the process of working with microcontrollers, but it offers some advantage for teachers, students, and interested amateurs over other systems: Inexpensive Cross-platform (Windows, Linux, Macintosh OSX) Simple, clear programming environment Open source and extensible software Open source and extensible hardware How-to Develope IDE installation 官网上有 Windows, Linux, Mac 的详细安装步骤： for Windows for Linux Linux 安装过程 方法一： 解决包依赖关系：安装 openjdk-7-jre (openjdk-6-jre, sun's java 6 runtime, the sun-java6-jre package, the oracle JRE 7 应该也可以 ) 1 sudo apt-get install openjdk-7-jre 下载合适的 Arduino IDE 解压、切换到解压路径，运行目录下的 arduino 脚本 1 2 3 tar -zxvf arduino-1.0.5-linux32.tgz cd arduino-1.0.5 ./arduino 方法二 (for Ubuntu)： 下载 & 安装 1 sudo apt-get install arduino arduino-core 运行 1 $ arduino Dev IDE Arduino IDE 是用 Java 写的跨平台的程序，它源自 Processing programming language 和 Wiring 项目的 IDE 。它是为艺术家和其他不熟悉软件开发的新手而设计的。它包含一个有语法高亮、括号匹配、自动缩进功能的代码编辑器，还可以通过一个按键完成编译程序 (compile) 和烧录至电路板 (upload) 的功能。 Programming 一个 Arduino 程序 / 代码 称为 \" Sketch \"。Arduino 程序是用 C/C++ 写成的，Arduino IDE 含有一个名叫 \"Wiring\" 的代码库 ( 源自于 Wiring 项目 )，这样子可以大幅度简化常用 I/O 操作，用户只需要定义两个函数就可以写出一个可以运行的程序： setup() : 系统上电或者复位时启动，只运行一次，初始化配置 loop() : 一直循环被调用，直到断电 Arduino 的示例程序 \"Blink\"：( 等同于 C 的 hello world，对于硬件最简单就是控制一个 LED 的亮灭 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Blink Turns on an LED on for one second, then off for one second, repeatedly. This example code is in the public domain. */ // Pin 13 has an LED connected on most Arduino boards. // give it a name: int led = 13 ; // the setup routine runs once when you press reset: void setup () { // initialize the digital pin as an output. pinMode ( led , OUTPUT ); } // the loop routine runs over and over again forever: void loop () { digitalWrite ( led , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( led , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } 上面的这段代码对于一个标准 C++ 编译器来说是无效的，事实上当我们按下 IDE 界面上的 \"Upload to I/O board\" 按钮时，IDE 会拷贝一份代码，在开头加上 include 指示，在结尾加上一个很简单的 main() 函数，这样它就是一个有效的 C++ 程序了。 Arduino 使用 GNU toolchain 和 AVR Libc 来编译程序的，使用 AVRdude 把程序下载到板子上。因为 Arduino 平台采用的是 Atmel 的微控制器，所以 Atmel 的开发环境 AVR Studio 或者更新的 Atmel Studio 应该也可以作为 Arduino 的开发环境。 学习资源 Arduino 的联合创始人 Massimo Banzi 的 Tutorial Series Vedio 优酷视频地址 ，一共 11 课，涵盖最基本的面包板搭电路、I/O 接口控制、传感器控制、网络应用等方面，如果有编程基础，很快就可以上手制作自己的设备了～ Arduino 中文社区 论坛教程汇总帖 ，因为 Arduino 诞生的一个很大的目的就是为设计师、艺术家、业余爱好者提供更加方便的开发环境，所以，Arduino 的教程对于有编程基础的同学来说是很容易的 ：-P Arduino Language Reference en 官网上关于 Arduino 编程语言的介绍 Arduino Language Reference zh Arduino 中文社区翻译的 编程语言介绍 Arduino Core Functions, Libraries 官网上关于 IDE 中 File/Examples/ 下示例程序的说明 参考 Arduino official website Arduino on wiki Arduino 中文社区","tags":"Embedded","loc":"https://qiangu.cool/posts/embedded/learn_arduino_series_1_getting_started.html","title":"学习 Arduino #1 Arduino 入门"},{"url":"https://qiangu.cool/posts/ic/fpga_digital_processing_basic_1.html","text":"数字处理基础 数字处理基础 主要包括两个方面： 数的表示 常用算术运算的实现 下面分别讨论 数的表示 这部分讨论对于计算机 (PC)、数字信号处理器件 (DSP)、数字芯片 ( 包括 FPGA) 都是成立的。 人类如何计数 最早我们的祖先采用的是结绳计数，经过几千年的发展，现在我们使用的 10 进制位置计数法 。那么我们为什么偏偏选择 10 这个数字呢？ 大名鼎鼎的 Charles Petzold 在他的著作 code 中分析了我们的计数进制现象 。原因其实很简单，10 这个数字对于我们如此特别只是因为我们有 10 个手指 ( 脚趾 )，于是我们采用了 10 进制，并且逐渐习惯了它 。他在书中模拟了一下进制系统的演化过程，让我们逐渐从人类的 10 进制思维逐渐转化到计算机的 2 进制系统中： 假设我们是卡通动画中的人物，比如米老鼠 Mickey，仔细观察它就会发现，他的每个手只有 4 个手指，理所当然，他采用 8 进制来计数。如果更进一步，假设我们是龙虾，那么我们的每一只钳子上有两个 \" 手指 \"，一共有 4 个手指，所以，我们会采取 4 进制计数系统。最后，假设我们是海豚，那么我们只有两个鳍来计数了，这时候的计数系统就是 2 进制数字系统了。 r 进制 to 10 进制 只需要按权值展开就可以了，比如： 2 进制数 110101 对应的 10 进制数为 32 + 16 + 4 + 1 = 53 8 进制数 B65F 对应的 10 进制数为 11 × 16&#94;3 + 6 × 16&#94;2 + 5 × 16 + 15 × 1 = 46687 10 进制 to r 进制 整数部分：基数连除，逆序取余 小数部分：基数连乘，顺序取余 计算机如何计数 正数 & 负数 人类和计算机的计数原理是完全不同的，所以采用的方法也是完全不同的。对于人来说，区分正负数只需要在数字绝对值前添加一个符号 + 或者 - 即可，但是计算机只有 0 和 1 这两个符号可以使用；对于人来说，减法借位很容易，但是对于计算机硬件电路来说这是一件很麻烦的事。 常用的表示方法有 3 种： 原码 、 反码 、 补码 。对于计算机而言，硬件上最容易实现的是补码，这也是大多数计算机采用补码系统的原因 。 以前总结过一篇博客， 原码、反码、补码 整数 & 小数 整数 对于整数而言，不存在小数点的问题，所以自然地将我们人类所熟悉的 10 进制数转化为计算机熟悉的 2 进制数，分配足够的空间存储起来就 ok 。 小数 在计算机中，整数和小数之间并不是很容易转换的的，而且小数的存储和处理要比整数复杂。对于小数，可以有两种方法来表示： 定点数 & 浮点数 定点数的意思是小数点在数中的位置是固定不变的。整数可以看作是一种特殊的定点数，小数点在数的末尾。值得注意的是小数点的位置信息并没有和数字存储在一起，所以，使用定点数的程序必须知道小数点的位置。 浮点数的意思是小数点在数中的位置是变化的。当代大部分计算机处理浮点数的标准是 IEEE 在 1985 年制定的 ANSI/IEEE Std 754-1985 。 ============================== 跑题分割线 ======================== 在计算机出现不久的年代，计算机处理浮点数是一件很重要但也让人头疼的事。最早，还没有专门处理浮点数的硬件，所以程序猿必须编写软件来完成浮点数的计算。浮点数在科学运算和工程类程序中极为重要，因此常常被赋予很高的优先级，在计算机发展的早期，为新制造的计算机做的第一项工作就是为其编写浮点数运算程序。 如果可以直接利用计算机机器码指令来实现浮点数的计算，类似于 16 位处理器上进行乘法和除法运输，那么这台机器上所有的浮点数运算都会变得更快。IBM 公司在 1954 年发布了 IBM 704，它是第一台将浮点数运算硬件作为可选配件的商用计算机。该机器的浮点运算硬件可以直接进行加法、减法、乘法和除法，其他的浮点运算必须通过软件来实现。 从 1980 年开始，浮点运算硬件开始应用于桌面计算机，这起始于 Intel 当年发布的 8087 数字协同处理 (Numberic Data Coprocessor) 芯片，当时这种集成电路被称为 数学协同处理器 (math coprocessor) 或者 浮点运算单元 (floating-point,FPU) 。8087 不能独立工作，必须和 8086 或者 8088 一起工作，所以被称为 \" 协处理器 \"。 在最初版本的 IBM PC 主板上，位于 8080 芯片的右边有一个 40 个管脚的插槽供 8087 芯片接入，但是，这个插槽是空的，如果用户需要浮点运算则必须单独购买一块 8087 芯片。数字协处理器并不能加速所有的程序的运行速度，比如文字处理程序几乎用不到浮点运算，而电子表格处理程序对浮点数运算依赖程度很高。 安装了数学协处理器，程序员必须使用协处理器的机器码指令来编写特定的程序，因为数学协处理器不是标准硬件。最后就出现了这样的局面：如果机器上安装了数学协处理器，程序员就要学会编写相应的应用程序以支持它的运行；如果没有安装，程序员必须通过编程来模拟它进行浮点数的运算。 在 1989 年发布的 486DX 芯片中，FPU 已经内建在 CPU 的结构里，但是在 1991 年发布的 486SX 中，又没有内建 FPU，到了 1993 年发布的奔腾芯片中，CPU 内置 FPU 再次成为标准，并且是永远的标准。在 1990 年发布的 68040 芯片中，摩托罗拉首次将 FPU 集成到 CPU 中，在此之前是使用 68881 和 68882 数学协处理器来支持 68000 家族的微处理器。PowerPC 芯片同样使用了内置 FPU 的技术。 ============================== 跑题分割线结束 ======================== FPGA 不同于微处理器，它内部没有内置 FPU( 不包括硬核 )，对于 FPGA，浮点数可以克服定点数动态范围小的缺点，但是在运算时，实现浮点数的硬件实时成本高，处理速度慢，所以在非实时运算中有广泛的应用。对于通信系统中的信号，一般都是实时处理的，所以在 FPGA 开发中，一般只使用定点数 。 常用算术运算的 FPGA 实现 加法 在 Verilog HDL 中，直接使用运算符 + ，其本质上是一种并行加法器，应该保证两边的数位宽是一致的。举个栗子 1 2 3 4 5 6 7 8 9 10 module add_4 ( x , y , C ); input [ 3 : 0 ] x ; input [ 3 : 0 ] y ; output [ 3 : 0 ] sum ; output C ; assign { C , sum } = x + y ; endmodule 乘法 第一种方法，最简单，直接使用运算符 * ，如下所示 。但是这种方法写出来的代码效率很低，甚至有时候是不可综合的，实际应用中基本不会采用这种方法。 1 assign p = x * y ; 第二种方法是自己写代码实现乘法运算，或者是使用 IP COre。一般 FPGA 中都集成了硬核的乘法器，所以可以有两种方案来实现乘法器，DSP48 硬核 或者是 Slice 搭建 。 除法 除法是四则基本运算中最复杂的，也是最难实现的。除法可以看作是乘法的逆运算，但除法要复杂的多，最大的区别是乘法中的一些操作可以并行支持，通过流水线提高计算速度，但是除法必须顺序执行，运算最耗时间。 Verilog 提供了除法运算符 / ，如下所示。但是只有在除数为 2 或者 2 的整幂次时才是可综合的，其余情况都不可综合 。 1 q <= a / b ; 常用的方法是采用 IP Core，可以完成定点数和浮点数两类算法。 Cordic 算法 Cordic 算法 算法即坐标旋转数字计算方法，是 J.D.Volder1 于 1959 年首次提出，主要用于三角函数、双曲线、指数、对数的计算。该算法通过基本的加和移位运算代替乘法运算，使得矢量的旋转和定向的计算不再需要三角函数、乘法、开方、反三角、指数等函数。 它通常应用在没有硬件乘法器的应用中，比如微控制器、FPGA 中，进行的所有操作只有加法、移位和查表 。 Coridc 算法可以自己编写代码实现，也可以使用 IP Core 。( 事实上，所有的 IP 软核理论上都可以自己写，因为这些软核实际上就是别人写好的代码和文档，类似于 C 语言中的库函数 ) 参考 《无线通信的 Matlab 和 FPGA 实现》 code","tags":"IC","loc":"https://qiangu.cool/posts/ic/fpga_digital_processing_basic_1.html","title":"FPGA 数字处理基础 (1)"},{"url":"https://qiangu.cool/posts/book/the_catcher_in_the_rye_review.html","text":"如何认识这本书 以前就听说过这本书的名字，真正感兴趣是在《我爱摇滚乐》上看到的一篇文章，介绍了枪杀传奇乐队披头士 The Beatles 的主唱约翰 · 列侬 (John Winston Lennon) 的凶手马克 · 查普曼 (Mark David Chapman)，他被捕时身上就带着一本《麦田里的守望者》。当查普曼被捕时，警方从他的副本中发现了这样的话：\" 亲爱的霍尔顿 · 考尔菲德，自霍尔顿 · 考尔菲德，这是我的陈述。\" 后来才发现，其实这本书很有争议，它和几起枪击案与小说有关，这包括罗伯特 · 约翰 · 巴窦枪击丽贝卡 · 谢弗，约翰 · 欣克利刺杀罗纳德 · 里根未遂。马克 · 大卫 · 查普曼枪击了约翰 · 列侬。 这是一本怎样的书 麦田里的守望者 on wikipedia 该书于 1951 年出版之后，立刻引起巨大的轰动，受到读者 —— 特别是青年人 —— 的热烈的欢迎，被翻译为多国语版。小说每年大约有 250,000 本售出、总计为 6500 万本。时代杂志将《麦田里的守望者》列在 \"2005 年度百大英语小说（自 1923 年起）\" 榜上，现代图书馆及其读者也将其列在 20 世纪百大英文小说榜上。赞赏者认为本书用青少年的口吻平铺直叙，增加了作品的感染力，传神地描写主角的内心思维，并说出了青少年不满成年世界充满虚伪欺瞒的心声。批评者则认为书中主角离经叛道，逃学、吸烟、喝酒又满嘴粗话，会给年轻读者带来不良影响。当时许多图书馆及学校将之列为禁书，并被列在美国最具挑战性图书榜上。但现在这本书却是许多美国学校的指定读物。有的评论家说，它 \" 大大地影响了好几代美国青年 \"。而且有学者认为，霍尔顿是当代美国文学中最早出现的反英雄形象之一。 《麦田里的守望者》位列 20 世纪最佳小说之林。小说出版后不久，纳什 ·K· 伯格（Nash K. Burger）写给《纽约时报》称小说为 \" 少见的杰作 \"，詹姆斯 · 斯特恩（James Stern）则模仿霍尔顿的语气，为小说送上钦佩之词。. 美国前总统乔治 · 赫伯特 · 沃克 · 布什称小说为 \" 了不起的作品 \"，并称它启迪了自己。2009 年 6 月，BBC 的芬洛 · 卢勒（Finlo Rohrer）写道小说问世已有 58 年之久，但依然是 \" 青春期的定义之作 \"。霍尔顿常常愤世嫉俗、郁郁寡欢、离群索居、与世隔绝、迷失方向、玩世不恭 \"。亚当 · 戈普尼克认为小说与美国文学中的《了不起的盖茨比》、《哈克历险记》并列为 \" 三部完美之作 \"，称 \" 在对纽约 50 年代的捕捉上，没有哪一部作品可以与《麦田里的守望者》并驾齐驱。\" 并非所有评论都是积极的；与其他评论家一样，卢勒写道：\" 笼罩在神秘之中的小说并没有满足读者的期待，这让人感到失望。塞林格助长了这种神秘感，或者说，他什么都没做。\"。。论道小说风靡与争议的背后缘故时，称小说 \" 捕捉到了青春期存在的焦虑 \"、\" 中心人物复杂 \"、\" 对话风格平易近人 \"；与此同时，一些读者可能会对 \" 纽约 40 年代的俗语 \"、\" 人物的自恋 \"、\" 过多的牢骚 \" 表示反感。 每个人心中都有一个霍尔顿 花费了三天时间看完了全书，默默无语，不知道该说些什么 ... 这本书描写的对象是上世纪 50 年代，美国战后一代人的精神状态，他们酗酒、抽烟、吸毒，被称为 \" 垮掉的一代 \"，破破烂烂的 T 恤衫和牛仔裤，开着父母给的昂贵的跑车，抽一支接一支的大麻香烟，在公共场所旁若无人地亲吻，挑战社会传统和道德底线。因为时代背景、文化背景不同，很多中国小孩刚开始看前几章时，不是很有共鸣（比如我），甚至可能读到一半就想放弃。但是如果你坚持看完，相信我，你会不由自主的喜欢上这个满口脏话、叛逆、成绩不及格的问题少年 —— 霍尔顿。 每个人都有不同的成长经历，或顺利，或坎坷，但是没有人永远一帆风顺，每个人都有不开心、孤独、寂寞、迷茫的时候，如果你坚持看下去，你会从这个叛逆少年身上发现自己的影子，触动内心那温柔的一角。 青少年 & 成年人 这本书描写的对象是美国 \" 垮掉的一代 \"，和他们联系在一起的是酗酒、大麻、吸毒、叛逆等词，作为中国人，作为 90 后，我们似乎和他们没有任何交集和共同点 。但是仔细回顾历史，就会发现其实不光美国这一代人，在人类社会发展历史中，每一代人在前辈口中都是几乎一样的一无是处 。我们的父辈似乎总在对我们挑刺，认为我们叛逆、不听话，但是他们在批评我们时，却忘了他们当年也是这样过来的，就像 70 后看不顺眼 80 后，80 后看不顺眼 90 后，现在，我们 90 后也看不顺眼 00 后，认为这帮熊孩子屁事不懂，一天只知道火星文、非主流、45 度仰望天空 。 而这说白了就是青少年和成年人世界的代沟。 青少年的困境 美国硅谷创业之父 Paul Graham 的著作《黑客与画家》中第一篇文章：为什么书呆子不受欢迎，就讨论了青少年和成人世界的隔阂 。 关于校园暴力，成年人不是不知道孩子们内部发生的这些事，他们知道孩子的行为有时候是极端残酷的，正如我们知道贫穷国家的人们生活极端艰难，但是，像所有人一样，成年人不喜欢揪住不放这种令人不快的事实 。 学校就像是监狱一样，老师就像是狱卒。 这个比喻是作者形容美国公立学校的，或许在中国，即使一个学校再烂，大多数中国人都不会这么描述，中国的 \" 标准答案 \" 是学校是花园，老师辛勤的园丁。如今的成年人根本不接受青少年，他们在上班的路上顺便把孩子送到学校关着，就像周末出门时把狗送到寄养的地方。 而在工业社会以前，青少年的角色则更加积极，他们是学徒，不是在作坊里，就是在农庄里，或者是在某艘军舰上，他们是成年人社会的低级成员。青少年尊重成年人，成年人也接受青少年。而现在，青少年在生产活动中，根本毫无用处，只能在快餐店充当廉价劳动力。所以，成年人不得不把他们集中到一起，让几个成年人看守所有的孩子 —— 学校诞生了。 很新奇的看法，和中国传统意见完全不同，我们不妨保持 open mind，某种程度上这个分析是有道理的 :-P 隔阂 我们总是固执己见，尤其是青少年，谁没有从逃课准备去西部生活的霍尔顿身上看到自己的影子呢？但愿不要有一天，像 Eason 在 《shall we talk》 中唱的一样： 孩童只盼望歡樂 大人只知道寄望 為何都不大懂得努力體恤對方 ... 陪我講 陪我講出我們最後何以生疏 誰怕講 誰會可悲得過孤獨探戈 難得 可以同座 何以 要忌諱赤裸 如果心聲真有療效 誰怕暴露更多 你別怕我 ... 成人只寄望收穫 情人只聽見承諾 為何都不大懂得努力珍惜對方 ... 陪我講 陪我講出我們最後何以生疏 誰怕講 誰會可悲得過孤獨探戈 難得 可以同座 何以 要忌諱赤裸 如果心聲真有療效 誰怕暴露更多 Hold on 面对这个世界，你需要的是保持一个善良的心，并且坚持下去。每个人都有不开心、孤独、寂寞、迷茫的时候，保持一颗善良朴实的心灵，坚守住我们心中的那片麦田才是真正难能可贵的事。 有那么一群小孩子在一大块麦田里做游戏。几千几万个小孩子，附近没有一个人 —— 没有一个大人，我是说 —— 除了我。 我呢，就站在那混帐的悬崖边。我的职务是在那儿守望，要是有哪个孩子往悬崖边奔来，我就把他捉住 —— 我是说孩子们都在狂奔，也不知道自己是往哪儿跑，我得从什么地方出来，把他们捉住。 我整天就干这样的事。我只是想当个麦田里的守望者。 To-Do List 麦田里的守望者 (The Catcher in the Rye)、在路上 (On the Road)、了不起的盖茨比 (The Great Gatsby) 并称 \" 美国 xxx 小说 \"，盖茨比看过电影了，小说没有看过，以后有时间了再看～ On the Road The Great Gatsby 参考 麦田里的守望者 on wikipedia","tags":"Book","loc":"https://qiangu.cool/posts/book/the_catcher_in_the_rye_review.html","title":"麦田里的守望者 书评"},{"url":"https://qiangu.cool/posts/telecom/learning_ofdm_on_fpga_1_ofdm_basic.html","text":"Why OFDM Background 移动通信的信道模型一般建立为 时变多径信道模型 ，描述信道多径时延特性的一个重要统计参量是 均方根时延扩展 。 经过无线信道的时变多径传输，接收到的信号幅度会有起伏变化（瑞利分布 or 莱斯分布），这种现象称为 信号衰落 。按照已调信号的带宽可以将衰落分为两类： 窄带信号受到 平坦性衰落 宽带信号受到 频率选择性衰落 。 判断信号受到何种衰落： 定义信道的 相干带宽 。当数字信号的带宽越小于信道的相干带宽，则经过时变多经信道后，在信号带宽内的不同频率分量的幅度的相关性越大，不同的频率分量近似经历相同的衰落，即平坦性衰落，平坦性衰落对接收信号的波形无明显影响，码间干扰可以忽略，该系统称为 窄带系统 。当数字信号的带宽相对于信道的相干带宽越大时，信号带宽内的不同频率分量通过信道传输时会受到不同的衰落，即频率选择性衰落，频率选择性衰落使信号中的不同频率分量产生不同的幅度变化，造成接收信号的严重失真，引起吗见干扰，产生误码，该系统称为 宽带系统 。 Problem 需求 无线信道的频率资源是有限的，要求数字通信系统有效利用信道频带。希望数据传输速率越高越好。 瓶颈 在系统设计选择数字调制方式时，必须兼顾 频带利用率 和 误码性能 。在 AWGN 信道下，在满足误码性能的前提下，应该尽可能采用频带利用率高的数字调制方式。 然而，在以衰落为特征的移动通信系统中，影响误码性能的不仅仅是 加性噪声 ，还包括 衰落 和 码间干扰 。实现高速无线通信并非易事。 为避免码间干扰，数字调制信号的最大符号速率受到很大的限制 。 Solution 信道均衡 是一种经典的对抗码间干扰的技术，许多移动通信系统都采用信道均衡技术消除码间干扰。但是如果数据速率非常高，采用单载波传输数据，需要设计几十审计上百个抽头的均衡器，这简直是硬件设计的噩梦 。 既要对抗码间干扰，又要满足低复杂度且高效的手段传输高速数据业务，我们可以采用另外一种技术 —— OFDM 。 OFDM History 多载波调制技术早在 20 世纪 50 年代末至 60 年代初就已经应用于军事高频无线通信中，由于实现复杂，没有被广泛应用 。OFDM 就是一种多载波调制，其子载波间隔是子载波符号间隔的倒数，各子载波的频谱是重叠的，这种重叠可以使频谱效率显著提高 。 20 世纪 70 年代，Weinstein 和 Ebert 提出用 离傅里叶变换 (DFT) 及其 逆变换 (IDFT) 进行 OFDM 多载波调制方式的运算。 DFT 和 IDFT 的快速计算方法：FFT 和 IFFT 使 OFDM 能够以低成本的数字方式实现 。 在 20 世纪 80 年代，随着 OFDM 理论的不断完善、数字信号处理及微电子技术的不断快速发展，OFDM 技术也逐步走向实用化 。 大约从 20 世纪 90 年代起，OFDM 技术开始应用于各种有线及无线通信中，包括：DSL、DAB、DVB、WLAN 等。OFDM 已经成为下一代蜂窝移动通信空中接口的候选技术 。 OFDM Theory Orthogonal frequency-division multiplexing (OFDM) 的基本原理是将高速的数据流分解为多路并行的低速数据流，在多个载波上同时进行传输。 通过将高速数据分解为多个并行低速速率，克服了信道时延扩展对数据速率的限制，其中各个子载波之间是相互正交的关系，如图： OFDM 每个子载波的调制方式可以相互不同，比如 BPSK、QPSK、QAM 等方式 。 (OFDM 系统的内容可以写一本书了，简单写写 :-P ) OFDM 基带数字实现 发送端 Transmitter 基带系统发送端要实现的功能是将待发送序列 {A1,A2,A3...} 变换，得到复包络的采样值 {a1,a2,a3...} 。 为了实现 OFDM 调制的基带数字实现，首先要将 OFDM 信号的复包络进行采样，成为离散时间信号 。根据公式 (《通信原理》)，采样结果正好是对发送序列进行离散傅里叶反变换 (IDFT) 的结果，所以，我们可以 借助 IDFT 即可得到 OFDM 复包络的时间采样 。 发送端框图： 接收端 Receiver 基带系统接收端要实现的功能是对采样序列 {a1,a2,a3...} 进行变换，得到发送端发送过来的信息序列 {A1,A2,A3...} 。 接收端通过 I/Q 正交解调可以恢复 OFDM 信号的复包络，将其采样得到的时间序列 。因为发送端采用的 IDFT 是可逆变换，所以对采样结果进行 DFT 就可以得到发送序列 。 当序列的点数为 2 的整幂次时，DFT 和 IDFT 存在快速算法： FFT 和 IFFT 。 接收端框图： 循环前缀 cyclic prefix 为了有效对抗多径信道的时延扩展，OFDM 系统由多个子载波构成，只要子载波的取值可以满足符号周期远大于信道的时延扩展，就可以达到目标。在此基础上，还需要采取措施消除前后两个 OFDM 符号之间的 码间干扰 ISI 。 一种方法是在每个 OFDM 符号之间插入 保护间隔 Guard Interval 。为了对抗信号因信道延迟的影响，Gurad interval(Tg) 长度要大于最大的 Delay spread，即 Tg > delay spread time。 在保护区间未放信号的 OFDM 系统称 ZP-OFDM(zero padding)。ZP-OFDM 有比较低的传输功率，但在接收端接收于 zero padding 区域信号时，会破坏载波的正交性造成 \" 载波间的干扰（ICI） \"，所以复制 OFDM symbol 后半段信号并摆放于保护区间内，称之为 循环字首 (cyclic prefix) 。 加窗技术 前面介绍了 OFDM 符号的生成、循环前缀消除码间干扰，但是此时符号边界有尖锐的相位跳变，由此可知，OFDM 的带外衰减是比较慢的 。虽然随着载波数目的增大，OFDM 信号的带外衰减会增加，但是仍然不够快 。 为了使 OFDM 信号的带外衰减更快，可以采用对单个 OFDM 符号加窗的方法 。OFDM 的窗函数可以使信号的幅度在 u 符号边界更平滑地过渡到 0 。常用的窗函数是 升余弦滚降窗 。 增大滚降因子虽然能够使带外衰减更快，但降低了 OFDM 系统对多经实验的容忍能力，所以 在实际系统设计中，应当选择较小的滚降因子 。 OFDM 系统设计 OFDM 系统框图如下： 其中， 交织 是为了克服深衰落发生突发差错的影响，如果交织器的长度足够大，解交织后可将突发差错改造为独立差错，再通过纠错译码来纠正 。 在发送端： 二进制数据 通过纠错编码、交织后映射到 QAM 星座得到 一个 QAM 复数符号序列 ，再经过并串转换，得到 N 个并行 QAM 符号 ，每个符号进行 IFFT，将 OFDM 复包络的频域样值变换为 时域样值 ，进行并串转换，将时域样值变换为按时间顺序排列的 时域样值 ，然后在每个 OFDM 符号前插入前缀，通过 D/A，将离散的复包络变成 连续时间的复包络 。再将复包络的 I(t) 和 Q(t) 正交调制得到 OFDM 信号 ，将基带信号上变频到射频，经过功放，发送出去 。 在接收端： 接收端于发送端进行相反的变换，恢复出原数据 . 参考 《通信原理》 《移动通信原理》 OFDM wikipedia","tags":"Telecom","loc":"https://qiangu.cool/posts/telecom/learning_ofdm_on_fpga_1_ofdm_basic.html","title":"学习 OFDM 及其 FPGA 实现 1 —— OFDM Basic"},{"url":"https://qiangu.cool/posts/embedded/learning_yocto_from_zero_1_getting_started.html","text":"最近做嵌入式，开始学习 Yocto 项目相关的知识。网上关于 Yocto 的介绍、博客不少，但是大多数都是英文的。中文博客也有，不过都是一些大牛写的笔记，对于新手来说，并不是很容易懂 , 于是，就有了我的 \"Yocto 从零单排 \" &#94;_&#94; Yocto 从零单排第 1 期 —— 入门，了解什么是 Yocto 学习一个新事物，当然是官网的东西最权威最简洁明了，不易出错（避免二次理解），以下内容来自 Yocto 官网 和对其的翻译，本文只是我的学习笔记，详细内容见官网： Yocto Project 官网 What & Why Yocto What is Yocto 官网上的介绍： The Yocto Project is an open source collaboration project that provides templates, tools and methods to help you create custom Linux-based systems for embedded products regardless of the hardware architecture. 也就是说 \"Yocto 是一个开源协作项目，它通过提供模板、工具和方法来帮助开发者为嵌入式产品订制基于 LInux 的系统，而不用关注硬件结构。\" 这样，它就可以极大地简化开发过程，因为你不用再从头裁剪一个完整的 Linux 发布版本，后者通常包括许多你并不需要的软件。 它由许多硬件制造商、开源操作系统提供商和电子器件公司一起合作于 2010 年建立，目的是为了使混乱的嵌入式 Linux 开发更简单有序。 P.S. Yocto 项目有时也被称为 \"Umbrella\" 项目 P.P.S. yocto 的名字是委员会决定的，这个词本来是国际单位中的最小的单位，表示 10&#94;-24，也就是千万亿分之一，在此寓意 \" 基本的粒子 \" —— 贯穿嵌入式 Linux 开发过程的工具。 Why using Yocto 它是一个完整的嵌入式 Linux 开发环境，包含工具 (tools)、元数据 (metadata) 和文档 (documentation)—— 你需要的一切。这些免费工具 ( 包含仿真环境 emulation environments、调试器 debuggers、应用程序开发工具 Application Toolkit Generator) 很容易上手，功能强大，并且它们可以让系统开发以最优化的方式不断前进，而不用担心在系统原形阶段的投资损失。 Yocto Project Charter Yocto 作为一个开源项目，其本质就是欢迎大大小小的参与者。 Yocto 的目标： 为进一步的开发、定制 LInux 平台，基于 Linux 系统的开发提供一个写作平台 鼓励 Linux 平台开发的标准化和组建的重利用 专注于创造一个构建系统的基础设施和技术，能够满足所有用户的需求，并增加了缺失的功能 —— 来自于 OpenEmbedded 架构 文档化可以用到的工具和方法，使开发人员更容易使用它们 尽可能地保证这些开发工具和系统架构无关 ... Governance & Administration Yocto 是一个开源项目，它由维护者和 Yocto Project Advisory Board 领导。 Technical Leadership Yocto 项目的 technical leadership 和 Linux Kernel 的类似，是一个分级的、任人唯贤的，由一个 \" 仁慈的独裁者 \"(benevolent dictator) 领导的组织。组织的上层负责决策，同时也是下层子系统的领导者，下层维护者负责处理细节问题，比如 bug 和补丁。 Yocto 项目架构师：Richard Purdie 子系统 / BSP 层维护者：... The Yocto Project Community Yocto 是由社区的专家和志愿者共同协助设计、开发的，他们统称为贡献者 (contributors)，贡献者包括任何可能对 Yocto 有贡献的人，比如代码开发人员、文档编写者、兴趣小组、管理小组、维护者和技术领导小组等。 下图简明说明了 Yocto 项目社区的各个成员之间的相互影响的关系： Linux Foundation Linux Foundation 是一个致力于促进 Linux 发展的非盈利组织，关于它的主要事实： 赞助 Linux 的创造者 Linus Torvalds 的工作 持有 Linux 商标 经营着 Linux.com，每个月拥有活跃的 2000,000 的 Linux 开发人员和用户 主持着多个推进或标准化 Linux 的工作小组 举行世界上顶尖的 Linux 会议，包括 LinuxCon The Linux Foundation and the Yocto Project Linux Foundation 是业界最大的非盈利组织，作为 Linux 的维护者和 Linux 创造者 Linus Torvalds 的雇主，没有比它更适合 Yocto 项目生存的了。Linux Foundation 主持 Yocto 项目作为一个开源项目，它提供了一个厂商中立的协作环境。 Yocto Project 简介 Yocto 项目中有很多独立的子项目，这些子项目在嵌入式 Linux 开发中扮演着重要的角色，Yocto 项目则整合它们使它们可以相互协同工作。 Openembedded Core Metadata Set 元数据集 (Metadata Set) 按 \" 层 \" 进行排列，这样一来每一层都可以为下面的层提供单独的功能。基层是 OpenEmbedded-Core 或 oe-core，提供了所有构建项目所必需的常见配方 (recipes)、类和相关功能。 Openembedded Core 包含了 核心方法 (recipes) 的基础层、类 (classes) 和 相关文档，它们是各种嵌入式 Linux 系统 ( 包含 Yocto 在内 ) 的共同基础。Openembedded Core 由 Yocto Project 和 OpenEmbedded 项目共同维护，将 Yocto 和 Openembedded 分开的层是 meta-yocto 层，该层提供了 Pocky 发行版配置和一组核心的参考 BSP。 Openembedded 项目本身是一个 ie 独立的开源项目，具有可与 Yocto 项目交换的配方 (recipes)，但两者具有不同的治理和范围。 Swabber Swabber 可以提供一种检测主机系统的机制，一旦检测到问题，你就可以分析这是否真的是个问题。 Application Development Toolkit (ADT) Application Development Toolkit (ADT) 能够让系统开发人员为他们使用 Yocto Project 工具创建的发行版提供软件开发工具包 (SDK)，为应用程序开发人员提供了一种针对系统开发人员提供的软件栈进行开发的方法。ADT 包含一个交叉编译工具链、调试和分析工具，以及 QEMU 仿真和支持脚本。ADT 还为那些喜欢使用集成开发环境 (IDE) 的人提供了一个 Eclipse 插件。 AutoBuilder AutoBuilder 是一款能够不断自动构建 Yocto 的工具，它启用自动化的 Quality Assurance(QA) 活动。 BitBake BitBake 是一个构建引擎。它读取配方 (recipes) 并按照配方来获取、构建程序包，并将结果导入可启动的系统映像中。BitBake 是 Yocto 项目的核心组件。 Build Appliance Build Applicance 是一台运行 Hob 的虚拟机，它可以让你在非 Linux 环境下构建启动一个基于 Yocto 的嵌入式系统镜像。并不建议在日常开发中使用 Build Applicance，应该将其用在测试和体验 Yocto 项目上。 Cross-Prelink Cross-Prelink 为交叉编译开发环境提供预链接，这样可以在应用程序启动时提高其性能表现。 Eclipse IDE Plug-in Eclipse IDE Plug-in 把 Yocto ADT 和工具链集成到 Eclipse IDE 中。 EGLIBC Embedded GLIBC (EGLIBC) 是 GNU C Library (GLIBC) 的一个变体，旨在能够在嵌入式系统上运行。EGLIBC 的目标包括减少内存占用、让组件可配置、更好地支持交叉编译和交叉测试。EGLIBC 是 Yocto Project 的一部分，但在它自己的治理结构内加以维护。 Hob Hob 是 BitBake 的图形前端，它的主要目的是使常用命令更加方便使用。 Matchbox Matchbox 是 一个基于 X Window 系统的开源环境，主要用于非桌面系统、屏幕大小、输入方式或系统资源有限的嵌入式设备中，比如手持设备、机顶盒、电话亭等。 Poky Poky 是 Yocto Project 的一个参考构建系统。它包含 BitBake、OpenEmbedded-Core、一个板卡支持包 (BSP) 以及整合到构建过程中的其他任何程序包或层。Poky 这一名称也指使用参考构建系统得到的默认 Linux 发行版，它可能极其小 (core-image-minimal)，也可能是带有 GUI 的整个 Linux 系统 (core-image-sato)。 你可以将 Poky 构建系统看作是整个项目的一个参考系统，即运行中进程的一个工作示例。在下载 Yocto Project 时，实际上也下载了可用于构建默认系统的这些工具、实用程序、库、工具链和元数据的实例。这一参考系统以及它创建的参考发行版都被命名为 Poky。你还可以将此作为一个起点来创建您自己的发行版，当然，你可以对此发行版随意命名。 构建一个系统必须有工具链 (toolchain)：一个编译器 (compiler)、汇编器 (assembler)、链接器 (linker) 以及为给定架构创建二进制可执行文件所需的其他二进制实用程序 (other binary utilities)。Poky 使用了 GNU Compiler Collection (GCC)，不过你也可以指定其他工具链。Poky 使用了一种名为交叉编译 (cross-compilation) 的技术：在一个架构上使用工具链为另一个架构构建二进制可执行文件（例如，在基于 x86 的系统上构建 ARM 发行版）。开发人员常常在嵌入式系统开发中使用交叉编译来利用主机系统的高性能。 Pseudo 构建一个系统时，有时候有必要把自己模拟为系统管理员进行一些操作，比如定义某个文件的归属权和权限配置等。Pseudo 是一个可以模拟 root 的程序，使普通用户也可以具有 root 权限。 Toaster Toaster 是一个 API，它基于 web 界面来使用 BitBake，你可以通过浏览器来查阅 Toaster 收集到的你的系统的相关信息。 参考 Yocto Project 官网 Build custom embedded Linux distributions with the Yocto Projec","tags":"Embedded","loc":"https://qiangu.cool/posts/embedded/learning_yocto_from_zero_1_getting_started.html","title":"Yocto 从零单排 1 —— 入门"},{"url":"https://qiangu.cool/posts/misc/my_pkm.html","text":"PKM 什么是 PKM 个人知识管理 (Personal Knowledge Management) 是一种新的知识管理的理念和方法，能将个人拥有的各种资料、随手可得的信息变成更具价值的知识，最终利于自己的工作、生活。通过对个人知识的管理，人们可以养成良好的学习习惯 , 增强信息素养，完善自己的专业知识体系 , 提高自己的能力和竞争力，为实现个人价值和可持续发展打下坚实基础。 知乎上的 回答 ： 个人知识管理的概念最早是由 Paul Dorsey 教授提出的 , 原文为 \" Personal Knowledge Management should be viewed as a set a problem-solving skills that have both a logical or conceptual as well as physical or hands-on component. \", 中文意思就是 : 个人知识管理应该被看作既有逻辑概念层面又有实际操作层面的一套解决问题的技巧与方法。所以个人知识管理主要讲的是一种方法论。 Personal knowledge management on wikipedia 为什么写这篇 blog 从小到大，上了这么多年的学，每个人都有自己的学习习惯和知识管理方法。这篇 blog 是在我 Google、知乎问答、参考相关博客内容的基础上，总结出的学习习惯和使用各种工具的经验，写这篇博客的目的不是秀逼格有多高（估计很多人都看不上），也不是所谓的教程（根本不够资格），而是 为了分享和讨论 :-D 获取知识 总结我的知识来源，大致可以分为 3 类：纸质书籍、网络资源、其他 。分别总结如下 书籍 书籍上的知识占到了我总来源的 50% 。相比于电子读物，我更喜欢阅读纸质书籍。 纸质书籍更适合深度阅读 这就是为什么很多码农桌子上都有那么几本经典著作，虽然他们的电脑里面也保存着相应的电子版。 纸和笔是最原始的阅读工具，但是也是最有效，或者 最自由的 这是目前电子书籍 / 笔记最大的缺点，写一段标注文字，画一个草图，列一个表格，插入一个公式，不仅需要花费很多时间，而且操作很繁琐，结果也往往差强人意 。 阅读体验 毫无疑问纸质书籍的阅读体验更好一些，不然 Kindle 也就不会出现了 :-D 至于读书笔记，我的方法很原始 =.= 书边笔记，这样笔记和书是一体的，如果空白不够大，有便利贴 标记符号，简单的标记，比如 ？ 表示疑问、 ！ 表示注意、 || 表示分层、 * 表示重要内容、圈出关键名词 / 定义 etc 整理笔记，定期将书本上的笔记整理到 Blog / Evernote 中 网络 互联网时代，善于利用互联网上的资源，相当于守着一座 \" 知识金山 \" 每天面对海量的信息，如果不加以过滤，我们就会被淹没在信息的海洋之中，浪费了大量时间而毫无收益。我的信息来源： RSS 订阅 以前使用 Google Reader，自从 GR 死了之后，转到了 Feedly 。主要是搜集一些大牛的博客，订阅 真正 感兴趣的内容。 RSS 订阅是个时间黑洞，曾经我的 RSS 订阅长期 1000+，而且我从来没有看完过，作为处女座强迫症患者，有时候花费了很多时间，甚至占用上课学习时间。后来看到 刘未鹏 在 《暗时间》 中有一篇文章讲自己的学习习惯，才明白原来这是源自人不肯 \" 关上一扇门 \" 的心理。 事实上，真正宝贵的信息，在其他来源你也可以接触到。 于是，我退订了很多从来不看或者很少看的源，从此，告别阅读焦虑。:-D Google / Wiki 拒绝做伸手党，我们遇到的很多问题实际上别人都遇到过了，并且提供了解决方法。在网上发帖问别人的时候，很多问题都可以从 FAQ、官方文档中都能找到答案。 知乎 / Quora / Stack Overflow 这绝对是一个值得一生相伴的好东西 :-P 长期混迹于此，瞬间高大上的境界、令人仰视的逼格不再是梦想，相信我，你的人生因此而改变！（利益相关：非广告，深度沉迷者） 论坛 / 豆瓣小组 当然是讨论知识的论坛，而非八卦娱乐主题的论坛。长期泡论坛，不仅可以寻找答案，帮助别人，还可以扩展自己的见识，结识大牛，论坛里面的老油条个个都是大神。 用到的工具： feedly 是一款 RSS 阅读器 同类产品还有很多，比如国外的 Diggo、国内的鲜果、豆瓣九点等 。feedly 在国内访问并不是很稳定，即使这样，我仍然选择它是因为舒服的排版、另外功能上有些源 Diggo 无法抓取到 。 pocket 是一个用于管理互联网文章的应用程序 PC 上有 chrome 插件，手机上也有相应的客户端，这样我们就可以很方便地在各个平台上、把各个源的文章都收集到一起，稍后阅读（比如排队、休息时）。 我还它当作汇聚资料的容器使用，比如我写这篇博客，从网上搜集到很多相关内容，把我认为重要的保存在 pocket 当中，然后再做整理 。 P.S. 还有另外一个方法，feedly 上的文章可以直接保存到 Evernote 中，但是这是付费功能，虽然可以用 ifttt 解决，但是这种方法无法收集其他地方的文章，而且，不知道是不是因为天朝的原因，ifttt 收集的速度并不快，一般要 30 分钟左右才能在 Evernote 中看到收集的文章，最重要的一点，在 Evernote 中看文章，眼睛一直盯着屏幕的右下角，都快成斜眼了 T_T，so 还是 pocket 好！ 其他 所谓其他，就是在其它地方，看到的、想到的，使用手机肯定是最方便的。我只使用过两款应用 Google Keep 和 Evernote 。 Google Keep Google 发布的笔记软件，和其他各种笔记类软件相比，Keep 的功能实在是 \" 弱爆了 \"，或许称之为 便签 sticker 更合适 . Evernote 大名鼎鼎的笔记软件，功能非常强大。 有很多人把这两个软件做比较 Google Keep VS Evernote，你还会继续使用 Evernote 吗？为什么？ 刚宣布 Reader 关停，Google Keep 随即上线，这是用来跟 Evernote 竞争的产品吗？谷歌做这个有什么优势？谷歌如何让用户有安全感地放心使用旗下产品？ 事实上，这两个产品的定位根本就不一样，引用里面的某个答案 Google Keep 偏重于随时随地记录碎片知识 , 建立待办事项 , 是个效率工具 . 完成的事情就随手一滑存档掉 , 并没有提供更一步的存储整理的途径 . 所以 Google Keep 并不是知识的终点 , 它只是用来记录临时想法的 , 这恰恰和它的 logo 形象十分契合 ( 想想卡通里面人物突然奇思妙想了 ... 灯泡就亮了 - -). 它就是用来存储这些 \" 灯泡 \" 的 . 一般，我使用 Keep 来记录平时的想法，也把它当作便签来使用，记录杂事，有部分 to-do-list 的作用。毕竟，Evernote 缓慢的启动速度和不方便的操作实在是太影响心情了 。 还有一个答案，不能同意更多： 归根到底， keep 是一个轻量级 GTD 系统，它要解决的问题和 evernote 是不同的。那些认为 keep 可以取代 evernote 的用户，他们本身就不需要 evernote —— 对他们而言，evernote 的强大反而太过繁冗，已是多余。 整理知识 获取到知识，下一步就是整理和吸收它们了。 Evernote 说道 PKM，就不得不提 Evernote 。这么一款大名鼎鼎的笔记软件，有很多人在使用，分享使用技巧 。搜集到一个很全的资源帖： 印象笔记 Evernote 教程 (douban) 里面总结了官方的教程、民间高手的使用心得。基本上花费一下午的时间在豆瓣 & 知乎上逛一逛，就可以成为高手了 。 我不是 EN 的高级用户，也没有专门去探索进阶用法，我只是把它当作单纯的电子笔记本，不代替便签（Google Keep），也不代替知识管理软件（Wiz、OneNote），一般也就以下几个方面： 保存博客草稿，毕竟 Keep 这样的便签不适合于写大段文字 记录私人笔记 摘抄网络上的精彩内容（也是为写 blog 服务），EN 在 chrome 上的 web clipper 插件真心不错 忍不住跑题说一下我的使用感受： 优点 ：全平台、全功能、云同步。 缺点 ：大而无当，这是一款变形金刚一样的软件，功能强大到有人为此写出一本厚厚的 使用教程 。但是，强大的功能也就意味着软件的笨重和操作的繁琐。 和便签类应用相比 它太笨重了！ 与 Keep 简洁的操作（快速新建、左右滑动归档、撤销），这货简直慢的让人无法忍受。知乎上有个贴子专门讨论这个问题： 为什么有人对印象笔记没有任何兴趣呢？ 其中有个回答，也是我的感受： 你明知道它的功能正是你需要的，但打開它就是不想用，也不知道從何用起。 和知识管理类应用相比 仅个人意见，EN 并不适合作知识管理 。它只有 笔记本 和 笔记本组 这两个概念，也就是说，它最多支持 2 级目录，而实际上，我们的知识体系应该是和树一样，不断地分支增长的 。其他笔记类应用比如 Wiz 笔记就要比它好很多 。 P.S. 我曾经也为用 Keep 还是 EN 纠结过，最终我选择了 Keep，直到后来我看到这句话： 那些认为 keep 可以取代 evernote 的用户，他们本身就不需要 evernote 我才明白，我根本就不需要 EN！我曾经尝试过在 EN 中建立一个完备正交的目录，后来发现，其中最重要的部分和我的博客目录是一模一样的 。我已经有个博客了，为什么还要 EN 呢？（个人认为 blog 比 EN 更好，原因后文解释） 事实上很多人根本就没有管理知识的必要，因为他们没有那么多知识需要整理。使用 Evernote 的动机无非就是人类的天性 ——\" 收藏 \" 癖好，看到什么东西都想收藏，比如用过的袋子，小本子，现在轮到网页，图片，链接了。可是我们收藏了以后还会去看么？就像我们硬盘里面收集的 \" 世界一百部名著 \" 一样，它静静地躺在硬盘中，积累了厚厚的灰 。 EN 的 logo 是一只大象，寓意来自美国谚语 \"An elephant never forgets\"，大象的记忆力很强，这和它的宣传 \"Evernote 是你的第二个大脑 \" 是一致的，而且是一个永远不会忘记的大脑。 所以，为什么不就这么用呢？在 EN 中新建几个笔记本，把我们不需要记住但是以后可能会用到的 \" 知识 \" 丢进去，加上简单的标签，然后我们只需要记住在笔记里有这么个记录，然后其他的全都可以忘掉了，需要的时候去搜索一下就可以了。利用它强大的接口功能，记录杂事、美食、私人日记、生活小感悟、小常识，但是对于体系结构化的知识，个人认为写一个技术博客是更优的选择（理由在后文） :-P 漫长的跑题终于结束了，总之就是， 把 EN 当作收集小知识的笔记本即可，个人知识管理选择其他软件 / 写博客是更优的选择。给它做做减法，使用你需要的功能，不要成为工具的奴隶。 XMind 目前还处于用笔和纸的阶段，大概了解了一些 XMind 的用途，感觉很好很强大。尤其是用它建立的结构化的提纲，对于整理文章、知识体系结构有巨大的帮助。还在探索中，更加进阶的功能和使用心得以后再总结。 使用 / 分享知识 月光博客中的一段话： 知识共享和传播，是为了让别人知道你知道的知识，并得到信息的反馈，为什么要分享，不在于你认识什么人，而在于什么人认识你，不在于什么人影响了你，而在于你影响了什么人。 获取、整理知识，接下来就是使用 / 分享知识。只有把别人的东西转化为自己的，才算是掌握了。我觉得最好的方法就是写 Blog。 为什么要写 Blog 这个问题曾经我也问过自己，以前只是看到学长学姐们写的 Blog，感觉很厉害，认为自己也应该有这样一个。后来看到 暗时间 里面的两篇文章： 《书写是为了更好的思考》 《为什么你从现在开始就应该写博客》 认真总结了一下写博客的好处： 总结知识 这是我写 Blog 最直接的一个动机。只有把别人的东西转化为自己的，才算是真正掌握了。记录下自己某段时间的学习收获，思考感悟，不仅可以帮助自己回忆以前的知识，说不定还可以帮助到别人（我就是受益者，从别人的博客中学习到了很多知识） 帮助思考 这是写 Blog 最大的好处。这个好处不仅仅局限于写 Blog 这种形式，无论以什么方式，只要写下你的思考过程和内容，就可以帮助你思考问题，也就是 书写 的好处。 《暗时间》 里面有个很形象的比喻： 人的思考就像是在黑暗中打着手电筒前行。 因为人的脑力资源是有限的，所以我们经常遇到想问题想岔了，然后回不到原点的情况。书写不仅可以帮助我们缓存手电筒照到的区域，还可以帮助我们扩大手电筒的照亮直径。比如我写这篇博客，开始只是记录下别人的 PKM 的方法和工具的关键字，然后在大纲和简记的基础上，补充自己的心得完成的。 得到交流帮助 Blog 相比于 EN 的最大的优势。写 Blog 是开放的，别人可以随意看，而写 EN 我们只能自己看（EN 的共享笔记体验并不好）。每个人的思考都有盲点，你的盲点可以在别人那里得到补充，知识和思考在讨论得到提炼升华。 还有一个好处是，敦促你必须认真思考。想象你在给一个玩偶小熊讲一个原理、技术，那么你必须 \" 彻底反思整个知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的。设想自己在 11 层，给处于 1 层的小熊讲明白一件事。\" 现在你不需要小熊了，因为有更挑剔的的对手 —— 你的博客的读者。你偷懒不写 / 写出无意义的文章，他们不会像小熊一样包容你，只有写出高质量的博客才对得起观众，否则就是浪费他们的时间了。 锻炼心智 激励你去坚持学习和思考： 为了让你的博客有价值，你必须不断地总结自己学习的结果，比必须不断思考，给出比别人深刻、读到的见解。 让你学会持之以恒地做一件事： 理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。 上述体验在写代码时也能体会到。 锻炼文字功底 对于码农，这算是优点么？反正没有坏处 :-P 写在最后 总结一下总的流程就是： 获取知识 ：书籍 + feedly + pocket + Google Keep 整理知识 ：Evernote + XMind 使用 / 分享知识 ：Blog 总结出来并且在实际行动中加以利用才是王道。 参考 我，和我的知识工具们 (2011-02-15 更新 ) 我的知识管理工具列表 Evernote on zhihu PKM on zhihu","tags":"Misc","loc":"https://qiangu.cool/posts/misc/my_pkm.html","title":"我的 PKM"},{"url":"https://qiangu.cool/posts/book/make_friends_with_time_review.html","text":"如梦初醒 突然发现自己已然变成了学校里面的老人，还有不多时日，就要离开在这片我生活了 7 年的土地，还来不及伤感，更多的是惊慌和不安 。从来没有这么感觉时间不够用： 每天都在忙碌，但是不知道在忙碌什么； 论文貌似总在和我捉迷藏，连影子都不显露； 静心思考自己的 \" 核心战斗力 \"。才发现自己还是当年的那个 \" 战五渣 \"； 生活中有那么多美好的事物，等着我去发现、去体验，比如健身、阅读、骑行 ... 还有写不完的代码 归结起来就是一句话： 时间不够用 。 解决方法也很简单： 管理时间 。 \" 管理时间 \" 这个话题当初我是如此的不屑，因为我 自信 自己的自制力，现在看来，更确切的说法应该是我的 自负 。亡羊补牢，为时未晚！于是，从豆瓣、大神们的博客上搜集到了几本书，甚至还有平时买书是赠送的 \" 心灵鸡汤 \" ... 是时候认真规划一下了，学会管理时间 。 暂时手头有以下几本书，后续还有很多计划看的书单 :-D（关于时间管理，正在学习 ing，以后再总结） 把时间当作朋友 暗时间 How to Get Things Down 超级时间整理术 花费了将近两周的时间，在闲时看完了这本 《与时间做朋友》 。写写心得体会吧～ 把时间当作朋友 关于作者 李笑來 先来点正面的：（ 某度百科 ，没有搜到 wiki） 上大学学的是会计，出来做的却是销售。再后来加盟新东方，任教至今已有 N 年。其间学生数万。著有畅销 TOEFL 辅导书籍《TOEFL 核心词汇 21 天突破》、《TOEFL 高分作文》、《把时间当作朋友》、《SAT 官方指南全程导学》、《新托福 iBT 词汇分类突破》，常年位于同类图书销售排行榜首。授课风格以朴实、有效为长。格外注重培养学生的独立思考能力，凡事都从独特的视角出发，而不限于书本知识。 李笑来最大的贡献是《TOEFL 核心词汇 21 天突破》，这本词汇书里面的很多词汇出现的频率都很高，里面共有 2140 个单词，可以很快的背一遍然后重复很多遍，这样容你有时间把所有单词都记住；如果说背那种有 10000 多个单词的书恐怕难以坚持到最后。 因为这种优点，笑来成为托福考试旗帜性的人物。 于 2007 年 2 月前后开始动手写的大约八九十篇文章的集合。2009 年 6 月 出版《把时间当做朋友》，至次年 6 月已经重印 11 次，深受读者喜爱。这本书从心智成长的角度来谈时间管理，指出时间管理是成功的关键所在。作者引述自己从事的职业中所遇到的事例，告诉我们：如何打开心智，如何运用心智来和时间做朋友，如何理解时间管理的意义，在时间管理上取得突破，进而用心智开启自己的人生成功之旅。 再来点负面的～ 从买到书，然后知道了这个人，关注到了一些李笑來老师的言论（博客、twitter、微薄），再结合对这本书的感受，个人对李老师不是很感冒 =.= 李笑来有哪些明显错误的观点？ 臭不要脸的流氓都一个德行 对李笑来的有关知乎《臭不要脸的流氓都一个德行》一文有什么看法？ 李笑來老师在书中一直强调 \" 开启心智，获得解放 \"，但就我从网络上他的言论来看，他远远没有达到这个标准，我认为，任何一个达到开启心智的人，不会在网上撒破，写 blog 破口大骂，武断地下结论，在 twitter 上和网友通宵争论 。一个人连自己的嘴巴都管不好，竟然也写书教导别人 \" 开启心智 \". 我阴暗地猜测一下，或许是因为他在新东方当老师的经历的后遗症（是的，我对新东方老师存有偏见，结合身边的一些同学的感受，或许称新东方老师为推销员更合适 ...）；也许和他的学历有关，这里不是对学历的歧视，学历低的牛人多了去了，只是有时候学历会限制一个人的眼界和修养，这本书的第一版出版人 周筠 在知乎上评论李笑來时就如是说： 若李笑来当年的求学环境更好，可能思维会比现在灵活而视野宽广。基本上靠自学、野路子出身、容易剑走偏锋的他，最需要的还是对自己的反思。这种反思，还尤其包括对自己优势和短处的清晰判断。 还有一种可能，这是他的营销手段，毕竟他在创业，使自己时刻处于舆论之中，就是绝佳的免费广告 。 读书心得 首先，不得不承认，这本书的口碑相当不错，在豆瓣上评分为 8.8 分，在书的扉页介绍中也是特意提到了这一点 。而且被列为 \" 中国书刊发行协 2010 年度全行业优秀畅销品种 \"，但是于我而言，看这本书的过程是 \" 惊喜 —— 还可以 —— 一般 \" 。 管理自己 \" 要管理的不是时间，而是自己 。\" 可能这是我从本书中学习到的最有用的观点吧 。时间不会因为我们管理减缓流逝速度，我们能做的只有管理自己 。 事实上，这本书关于管理自己，争取时间的内容并不多，甚至没有占到总篇幅的一半 . 书名是 \" 把时间当作朋友 \"，开篇说 \" 你是不是很缺时间？你想不想和时间做朋友？相信我，你并不孤独，只要看下去就能找到和时间做朋友的方法！\"，然后在草草介绍了时间管理方面的内容之后，文章开始转向另外一个话题 —— 运用心智获得解放 ... 甚至类似跑题问在具体每一小节中都有不同程度的复现 。 关于管理自己、规划时间的内容，目前还在看 GTD 相关的书，看完再总结～ 成功学 这本书在序言中就在抨击 \" 成功学 \"，并且申明本书绝对不是一本成功学，也不是心灵鸡汤，也不是讲大道理的书，也不是一本随便翻翻就可以的书 。尽管作者尽量以朴素的方式总结自己的经验，并且以朴素的语言表达出来，但是正如自己所言， \" 不可避免地透漏出说教的神态 \" 。 Critical Thinking 在读这本书前，我对 critical thinking 只是有所了解，于是运用自己理解的方法，来审视这本书的内容，不失为一个绝佳的练习方法 :-D 然后我发现文章中很多地方的逻辑并不严密，甚至有些结论无中生有，或者过于武断，牵强附会 。 P.S. 关于 critical thinking ，阅读更多的书以后再总结 。 论点、论据、论证 这本书一开始描绘的问题让我仿佛找到知己，因为我就是这样一个时间不够用患者，顺带 拖延症晚期，看到李老师说可以 \" 开启心智，获得解放，和时间做朋友 \" 时，可以想想我是多么的激动，差点就泪流满面了 T_T 然后我就抱着 \" 开启心智 \" 的伟大目标开始了后面的阅读，但是让人失望的是，作者在后面的论述并没有表现出和前言相当的精彩内容。首先，他的某些结论或许是他长期思考总结出来的，适合于他，但是并不能作为普适的经验，甚至有些结论过于武断，只是他的生活经验，缺乏科学的支持；其次，作为一个典型的工科学生，对他的论点、论据、论证方法实在无法赞同，很多时候感觉是想到哪里写到哪里，到后面都忘了前文的目的，转而说下一个问题，就像是聊天一样，扯到十万八里之外了。完全没有达到 \"critical thinking\" 的标准 。 总之，抛开对作者的映像，就这本书而言，还是比较值得一读的（只是没有像宣传的那么唬），作为一本心理学、时间管理、自我实现方面的入门级书，看看总是没有错的 。 其他人的评价 豆瓣上有篇书评，个人感觉相当精髓，不能同意更多： 李氏 \" 中医 \"？ ，其中有一句 我相信这本书是有阶段性意义的，对我个人而言，甚至可以说相当大。 就是在这本书里，我看到一个勇于面对自己的缺点的人，一个认同个人奋斗改变人生的人，令人遗憾的是，我也看到一个仅仅是文笔简洁的人，一个至今仍局限于个人经验而不愿意走出来的人。 周筠 老师评价： 我是李笑来《把时间当作朋友》第一版的出版人，他的书中的好些观点对我都有触动，给我不少帮助，为此很感谢他。 至今，我还是认为《把时间当作朋友》对很多迷途中的年轻人会有较大帮助，不能因为其中有些观点经不起推敲，就否定这本书的价值。 对我来说，这本书是有营养的，所以我才会热心出版。","tags":"Book","loc":"https://qiangu.cool/posts/book/make_friends_with_time_review.html","title":"把时间当作朋友 书评"},{"url":"https://qiangu.cool/posts/cs/learning_linux_package_management.html","text":"Linux 软件包依赖问题 早期的 Linux 系统上的软件是通过源码方式发布的，大家下载下来，在自己的机器上编译，得到可执行程序 。 但是，任何程序员写程序都有可能会依赖一些别人已经写成的库，所以几乎一定规模的程序必然有依赖 。尤其是对于 Linux 系统，因为它是 free（自由，not 免费） ，开源软件的开发者不是在一个体系下，软件包的依赖关系就比较伤脑筋了， 尤其是当我们的系统里有成百上千的软件时，软件包管理的必要性就更明显了 。 比如我们需要安装 package_a，而 package_a 依赖于 package_b 才能运行，但是我们的系统没有安装 package_b，如果强制安装 package_a，软件很可能不能正常运行 。 P.S. 其实在 Windows 下也存在相似的问题，只是因为有微软统一的体系，很多 dll 被集成在系统中，所以这个问题不明显 。 不同的系统对于这个问题有不同的处理方法，这也体现出它们不同的处理问题的哲学： 知乎上的问题： Unix 的包依赖是如何形成的？ 有个回答： GNU/Linux：通常这个系统大多数软件是自由软件，换句话说，他们通常依赖的库也是自由的，所以软件开发者认为你可以自由的获取这些依赖库，自然就不需要自己再提供了。由系统 \" 发行版 \" 负责维护属于这个系统的所有依赖库，并且安装软件时确定依赖 这个体系的特点是： 1. 系统依赖通常是统一的，如果有多个程序依赖同一个库，在这个系统中通常是同一份 2. 具有庞大的资源。例如 Debian 系现成的可依赖软件多达 30G，所以通常不可能预先把所有依赖都安装全，但庞大的依赖库给编程人员提供了很多方便 3. 你安装的软件越多，共同依赖所体现出的价值越高，解决依赖问题就越简单（因为当你安装足够多软件时，主流的依赖已经全部在你系统了） 4. 由于巨大的共同依赖库存在，软件本身可以很小 Windows：通常而言，这个系统的软件是商业软件，因此，他们依赖的库也很有可能是商业软件，所以，不可能要求用户自行获取这些依赖，这些依赖通常在发布软件的时候提供。如果你安装的软件少，这个体系很方便 。 不过这造成了一些缺点： 1. 没有一个庞大的公共库，很多功能以及基础库都是每个公司自己实现一套，浪费很多劳动力，编程人员到每个公司得学习一套不同的库，给编程人员带来不便 2. 所有应用程序都自己带依赖，因此很可能有许多程序同时附带了相同的依赖，并且这些相同依赖还有可能是不同的版本，这会造成许多混乱 3. 由于所有应用程序都自己提供所有依赖，每个软件体积都很庞大 4. 系统中安装的软件越多，越容易出问题。 Linux 包管理系统 Package management system on wikipedia : A package management system , also called package manager , is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites. Package management systems are designed to save organizations time and money through remote administration and software distribution technology that eliminate the need for manual installs and updates. This can be particularly useful for large enterprises whose operating systems are based on Linux and other Unix-like systems, typically consisting of hundreds or even thousands of distinct software packages; in the former case, a package management system is a convenience, in the latter case it becomes essential. 在 Linux 发行版中，几乎每一个发行版都有自己的软件包管理系统 。 Dpkg Dpkg on wiki Dpkg 是基于 Debian 系统的包管理软件 。 dpg 可以用来安装、删除、提供 .deb 格式软件包相关信息的文件 。 dpkg 由 Matt Welsh、Carl Streeter、 Ian Murdock 用 Perl 语言编写，后来在 1994 年。 Ian Jackson 改用 C 重写了大部分内容 。 dpkg 是 \"Debian package\" 的缩写，它最初是为 Debian 系统编写的，也可以在使用 .deb 格式的 Ubuntu 系统上使用 。 常用语法 1 2 3 4 dpkg -i peackage.deb // install dpkg -r package.deb // remove dpkg -l [ optional pattern ] // list installed package dpkg --configure package // configure package 详细用法 1 2 dpkg --help man dpkg Apt Advanced Packaging Tool on wiki The Advanced Packaging Tool, or APT, is a free software user interface that works with core libraries to handle the installation and removal of software on the Debian GNU/Linux distribution and its variants. APT simplifies the process of managing software on Unix-like computer systems by automating the retrieval, configuration and installation of software packages, either from precompiled files or by compiling source code. apt 最初是设计为 dpkg 的前端，用来处理 .deb 格式的文件，后来它被 APT-RPM 组织改造可以支持 RPM 包管理系统 。 apt 由 apt-get 、 apt-cache 和 apt-config 等小工具组成 常用语法 1 2 3 4 5 apt-get install package // install apt-get remove package // remove apt-cache search package // search apt-get update // update source list apt-get upgrade // upgrade installed software 详细用法 1 2 3 4 man apt man apt-get man apt-update man apt-upgrade 彩蛋 在 terminal 中输入 apt-get -h help 内容结束的最后一样会有一句： This APT has Super Cow Powers. 在 terminal 中输入 apt-get moo 会显示一头牛 :-P ( __ ) ( oo ) / ------\\/ / | || * / \\ ---/\\ ~~ ~~ .... \"Have you mooed today?\" ... Aptitude aptitude on wiki aptitude is a front-end to the Advanced Packaging Tool (APT). It displays a list of software packages and allows the user to interactively pick packages to install or remove. It has an especially powerful search system utilizing flexible search patterns. It was initially created for Debian, but has appeared in RPM Package Manager (RPM) based distributions as well (such as Conectiva). aptitude 是 APT 的文本界面客户端，它的交互性比 apt 好，似乎在处理依赖问题上也更好一些（我遇到的问题，用 aptitude 可以很方便地解决而 apt 不行 ） 常用语法 1 2 3 4 5 6 7 aptitude install package aptitude remove package aptitude clean aptitude search package aptitude show string aptitude update aptitude dist-update 详细用法 1 2 man aptitude aptitude -h 彩蛋 YUM Yellowdog Updater, Modified on wiki The Yellowdog Updater, Modified (yum) is an open-source command-line package-management utility for Linux operating systems using the RPM Package Manager. Though yum has a command-line interface, several other tools provide graphical user interfaces to yum functionality. YUM 是一个基于 RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM 包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装 。被 Yellow Dog Linux 本身，以及 Fedora、Red Hat Enterprise Linux 采用 。 举个栗子 有些软件要求的库的版本高于 (>=)xx.xxx，有些软件要求库的版本必须是 (=)xx.xxx，如果我们的库不能满足要求则无法安装软件 。一般 apt-get 会处理比较简单的依赖关系，但是有些依赖关系 apt-get 并不能解决 。这时候可以试试 aptitude 。 问题 为新安装的 Ubuntu 安装开发环境时，遇到了库版本过高的问题，执行下面的命令 1 sudo apt-get install build-essential 结果 apt-get 提示有不满足依赖关系的包 Reading package lists... Done Building dependency tree Reading state information... Done Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: build-essential : Depends: dpkg-dev (>= 1.13.5) but it is not going to be installed E: Unable to correct problems, you have held broken packages. 于是我们手动安装特定的库 1 sudo apt-get install dpkg-dev 结果提示我们库版本过高 Reading package lists... Done Building dependency tree Reading state information... Done Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is to be installed Recommends: build-essential but it is not going to be installed Recommends: fakeroot but it is not going to be installed Recommends: libalgorithm-merge-perl but it is not going to be installed E: Unable to correct problems, you have held broken packages. 解决问题 —— 使用 aptitude 解决方法就是降级 。 方法有两个： apt-get 直接指定安装特定的版本 首先查询是否提供低版本的包 1 apt-cache showpkg package_name 若有则指定安装某个版本 1 sudo apt-get install package_name = version 使用 aptitude 自动处理 我采用的第二种方法： 1 sudo aptitude install build-essential 结果如下 The following NEW packages will be installed: build-essential dpkg-dev{ab} The following packages are RECOMMENDED but will NOT be installed: fakeroot libalgorithm-merge-perl 0 packages upgraded, 2 newly installed, 0 to remove and 18 not upgraded. Need to get 718 kB of archives. After unpacking 1,636 kB will be used. The following packages have unmet dependencies: dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is installed. The following actions will resolve these dependencies: Keep the following packages at their current version: 1) build-essential [Not Installed] 2) dpkg-dev [Not Installed] Accept this solution? [Y/n/q/?] 当然不是中止安装，选择 n ， aptitude 给出另外一个解决方案： The following actions will resolve these dependencies: Downgrade the following packages: 1) libdpkg-perl [1.16.12ubuntu1 (now) -> 1.16.10ubuntu1 (raring)] Accept this solution? [Y/n/q/?] 这正是我们需要解决的版本过高的问题，将库软件版本降级 The following packages will be DOWNGRADED: libdpkg-perl The following NEW packages will be installed: build-essential dpkg-dev{a} The following packages are RECOMMENDED but will NOT be installed: fakeroot libalgorithm-merge-perl 0 packages upgraded, 2 newly installed, 1 downgraded, 0 to remove and 18 not upgraded. Need to get 904 kB of archives. After unpacking 1,632 kB will be used. Do you want to continue? [Y/n/?] 选择 y 。然后 aptitude 会完成剩余的工作 。 问题解决啦！ 参考 Unix 的包依赖是如何形成的？ apt-get install 安装软件问题 ( 安装包的依赖库版本过高问题 )","tags":"CS","loc":"https://qiangu.cool/posts/cs/learning_linux_package_management.html","title":"学习 Linux 软件包依赖管理"},{"url":"https://qiangu.cool/posts/tools/learning_vim_save_project_configuration.html","text":"关于 Vim 和 IDE 的争论，这是程序猿的圣战，不再浪费时间 :-D 在参考了很多人分享的博客和教程之后，终于把 Vim 搭建成为一个自己定制的 IDE（这种说法严格意义上说，是不对的，应该是 \" 组合一组工具成为一个 IDE \"），总结一下～ 本系列的内容很多都是参考别人的博客写的，也包含部分自己摸索的结果 。虽然部分内容和参考文章相同，但是总结一下自己的学习过程还是一件有必要的事 :-P 很多编辑器都有一个功能是以前打开过的文档会有记忆，再次打开时会直接跳转到上次编辑的地方，比如 Sublime Text 2 ，强大的 Vim 当然也有这个功能， 我们的目标就是让 Vim 和其他 IDE 一样，可以记住上次的编辑状态 。 Vim 要实现这个功能，涉及到两个地方的配置： session & viminfo 。 Session Intro 在 Vim 中输入 1 :help session 就可以看到关于 session 的介绍： A Session keeps the Views for all windows, plus the global settings. You can save a Session and when you restore it later the window layout looks the same. You can use a Session to quickly switch between different projects, automatically loading the files you were last working on in that project. 在我使用的 Vim 7.3 中， help 中的 usr_21.txt 的主题是 Go away and come back ，其中 21.4 节保存的就是关于 session 的说明，在 Vim 中输入 1 :help 21 .4 就可以看到关于 session 的详细介绍 。 Config Session 保存的信息由 sessionoptions 确定，详细用法可以查看 help 1 :help 'sessionoption' 'sessionoptions' 'ssop' string (default: \"blank,buffers,curdir,folds,help,options,tabpages,winsize\" ) It is a comma separated list of words. Each word enables saving and restoring something 也就是说 session 保存的会话的属性默认的有 8 个 ： 当前编辑的空窗口、缓冲区、当前目录、折叠信息、帮助信息、选项、标签页、窗口大小信息 。 在上面的设置中，不要同时包含 curdir 和 sesdir 两个选项，若两个选项都不包含，则保存 session 时，会保存绝路径 。添加 sesdir 可以将当前目录设置为 session-file 所在的目录，这个设置有个很有用的地方就是，当我们通过网络访问我们的工程或者有很多个工程版本，这时候只需要每个工程下保存一个 session-file 即可 。 删除 / 加入 某个选项的方法 1 2 :set sessionoptions- = curdir :set sessionoptions += sesdir Save 详细的语法可以在 help 中查看 1 :help mksession 使用 mksession 命令保存会话 1 2 3 :set sessionoptopms- = curdir :set sessionoptions += sesdir :mksession project.vim 如果 session-file 已经存在，则使用 1 :mksession! project.vim Load 然后退出 Vim，在别的目录下打开，干点别的事，这时候我们想起刚才的工程里面有个小 bug，想恢复过去，这时候就是只需要使用 source 命令即可 。 使用 source 命令 1 source PATHto/project.vim 这时候可以看到，已经恢复了之前的状态 。 只使用 session 就可以恢复一些上次编辑的信息，但是这还不够，我们还可以配合使用 viminfo 来恢复更多的信息 。在 Vim 的 :help 21.4 中有介绍两者的关系 Sessions store many things, but not the position of marks, contents of registers and the command line history. You need to use the viminfo feature for these things. In most situations you will want to use sessions separately from viminfo. This can be used to switch to another session, but keep the command line history. And yank text into registers in one session, and paste it back in another session. You might prefer to keep the info with the session. You will have to do this yourself then. You could also use a Session file. The difference is that the viminfo file does not depend on what you are working on. There normally is only one viminfo file. Session files are used to save the state of a specific editing Session. You could have several Session files, one for each project you are working on. Viminfo and Session files together can be used to effectively enter Vim and directly start working in your desired setup. Viminfo Intro 在 Vim 中输入 1 :help viminfo 就可以看到关于 viminfo 的介绍： If you exit Vim and later start it again, you would normally lose a lot of information. The viminfo file can be used to remember that information, which enables you to continue where you left off. 在 Vim 7.3 中， help 中的 usr_21.txt 的主题是 Go away and come back ，其中 21.3 节保存的就是关于 viminfo 的说明，在 Vim 中输入 1 :help 21 .3 就可以看到关于 viminfo 的详细介绍 。 viminfo 文件可以保存的内容有： The command line history 命令行历史 The search string history 字符串搜寻历史 The input-line history 输入行历史 Contents of non-empty register 非空寄存器内容 Marks for serval files 文件位置标记 Last search/substitute pattern 最近模式匹配搜索历史 The buffer list 缓冲区列表 Global variables 全局变量 Save 其实 Vim 每次退出时都会在 ～/ 目录下保存一个 .viminfo 的文件，但是每次打开关闭一个文件都会覆盖上次的记录，所以我们需要为工程手动保存一个 viminfo 文件，并且保存在工程目录下，防止被覆盖 。 保存命令 :wviminfo 的帮助 1 :help :wviminfo 使用 wviminfo 保存 1 :wviminfo project.viminfo 载入 viminfo 文件 载入命令 rviminfo 帮助 1 :help :rviminfo 载入 viminfo 文件 1 :rviminfo path/to/project.viminfo 总结 为了节省每次都要手动输入一些设置命令，我们可以把部分相同的设置放在 .vimrc 文件中 1 2 set sessionoptions- = curdir set sessionoptions += sesdir 每次退出 Vim 时保存 1 2 :mksession project.vim :wviminfo project.viminfo 进入 Vim 想恢复项目设置时 1 2 :source projetc.vim :rviminfo projetc.viminfo 参考 vi/vim 使用进阶 : 使用会话和 viminfo vi/vim 使用进阶 : 保存项目相关配置","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_save_project_configuration.html","title":"学习 Vim 保存项目设置"},{"url":"https://qiangu.cool/posts/tools/learning_vim_vundle.html","text":"学习 Vim，使用 Vundle 管理插件 。 Vim 插件 Vim 的强大之处在于它的可扩展性，你可以把它当作一个简单的文本编辑器，也可以安装各种功能强大的插件，把它武装成一个 IDE 。 我们可以从以下几个地方找到 Vim 插件，一般比较常用的插件从官网上都可以找到，还有一些插件是大神们自己写的，托管在 GitHub 上 。 Vim 官网 GitHub 什么是 Vundle Vim 的插件虽然强大，但是因为 Vim 根本就没有插件管理这个概念，所有插件的文件都散布在 ~/.vim 下的几个文件夹中，配置 vim 的过程 , 就是在网上不停的搜插件，拷贝到 ~/.vim 下，发现更新，要重新下载重新拷贝，想要删除某个不需要插件，更是要小心翼翼的不要删错。配置出顺手的 Vim, 需要极大的耐心和运气，而且如果换一台电脑，就要重复一次这样的痛苦经历 。 自然地，因为管理插件的需求，最早出现了一些管理插件的脚本，但是写脚本需要一定的 shell 知识，直接 copy 别人的自己并不一定适用 。后来，出现了一些插件，比如 pathogen，muzuiget，vim-flavor，Vundle 等 。 目前比较流行的方式是采用 Vundle 来管理插件（别的我也没有试过 ...） Vundle on GitHub Vundle on vim.org Vundle 的介绍： Vundle is short for Vim bundle and is a Vim plugin manager. Vundle 可以在交互的方式下做到： 在 .vimrc 中管理和配置插件 安装插件 更新插件 按名字搜索插件 删除插件 如何使用 Vundle 管理插件 安装 Vundle Vundle 的安装需要 Git 。 从 GitHub 上 clone 下来就可以了 1 git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle 配置 Vundle 将下列内容加入到 .vimrc 文件中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 set nocompatible \" be iMproved, required filetype off \" required \" set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/vundle/ call vundle#rc() \" alternatively, pass a path where Vundle should install plugins \"let path = '~/some/path/here' \" call vundle#rc ( path ) \" let Vundle manage Vundle, required Plugin 'gmarik/vundle' \" The following are examples of different formats supported. \" Keep Plugin commands between here and filetype plugin indent on. \" scripts on GitHub repos Plugin 'tpope/vim-fugitive' Plugin 'Lokaltog/vim-easymotion' Plugin 'tpope/vim-rails.git' \" The sparkup vim script is in a subdirectory of this repo called vim. \" Pass the path to set the runtimepath properly. Plugin 'rstacruz/sparkup' , { 'rtp' : 'vim/' } \" scripts from http://vim-scripts.org/vim/scripts.html Plugin 'L9' Plugin 'FuzzyFinder' \" scripts not on GitHub Plugin 'git://git.wincent.com/command-t.git' \" git repos on your local machine (i.e. when working on your own plugin) Plugin 'file:///home/gmarik/path/to/plugin' \" ... filetype plugin indent on \" required \" To ignore plugin indent changes, instead use: \"filetype plugin on \" \" Brief help \" :PluginList - list configured plugins \" :PluginInstall(!) - install (update) plugins \" :PluginSearch ( ! ) foo - search ( or refresh cache first ) for foo \" :PluginClean(!) - confirm (or auto-approve) removal of unused plugins \" \" see :h vundle for more details or wiki for FAQ \" NOTE: comments after Plugin commands are not allowed. \" Put your stuff after this line 从上面的配置文件中可以看到，Vundle 把插件分为了 3 类： scripts on GitHub repos GitHub 上的脚本，需要按照 usrname/repos 的格式写出插件的名称 scripts from http://vim-scripts.org/vim/scripts.html Vim scripts 上的脚本，不用作者名，直接写插件名 scripts not on GitHub 不是 GitHub 上的脚本，需要写出插件的详细路径 运行 Vundle 修改好 .vimrc 文件后，打开 Vim，使用以下命令管理插件 列表 1 2 :Bundles // 列出所有插件（包括未安装的） :BundleList // 列出已安装的插件 安装 1 :BundleInstall 搜索 1 :BundleSearch // 后面不接插件名时，同 Bundles，列出了 4000 个插件 更新 1 :BundleInstall! 删除 在 .vimrc 文件中删除 / 注释掉相应的插件名，然后输入命令 1 :BundleClean P.S. 我安装的插件 列出一些我安装的插件，这些插件都是大家比较常用的，可以从相关的网站或者帮助文档中找到使用说明或者 README ，计划在后续中写一写使用心得～ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Bundle 'taglist.vim' Bundle 'The-NERD-tree' Bundle 'SuperTab' Bundle 'snipMate' Bundle 'L9' Bundle 'FuzzyFinder' Bundle 'bufexplorer.zip' Bundle 'winmanager' Bundle 'a.vim' Bundle 'c.vim' Bundle 'Markdown' Bundle 'Conque-Shell' Bundle 'vimwiki' Bundle 'genutils' Bundle 'lookupfile' Bundle 'DoxygenToolkit.vim' \"Bundle 'ManPageView' Bundle 'calendar.vim' Bundle 'AutoClose' \" scripts on GitHub repos Bundle 'suan/vim-instant-markdown' Bundle 'godlygeek/tabular' 参考 vim 中的杀手级插件 : vundle Vundle 管理 Vim 插件","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_vundle.html","title":"学习 Vim 使用 Vundle 管理插件"},{"url":"https://qiangu.cool/posts/tools/learning_vim_vimrc_preliminary.html","text":"总结初步配置 Vim，让 Vim 更顺手 。 在哪里配置 Vim 学习 Vi 和 Vim 编辑器 ： Vim 依照特定顺序寻找初始化的信号，它执行找到的第一组指令（可以是 环境变量 or 配置文件），然后开始编辑工作 。所以，Vim 在下列清单中遇到的第一个项目，就是清单中被执行的唯一项目 。书寻如下： VIMINIT 。它是环境变量，如果不为空，Vim 把它的内容当作 ex 命令执行 用户 vimrc 文件 。 exrc 选项 。如果设置了 Vim 的 exrc 选项，它会寻找三个额外的配置文件 。 vimrc （vim runtime configure）文件一般有 3 个： /etc/vim/vimrc 本配置文件影响所有的用户，一般不应该更改这个配置文件，因为谁也不能保证别人的喜好和自己一样 。 /usr/share/vim/vimrc 输入命令 1 ll /usr/share/vim/vimrc 就可以看到，本文件是 /etc/vim/vimrc 的软链接 。 ~/.vimrc 一般来说，配置 vim 就是在这个文件中配置，如果不存在的话 touch 一个新文件并命名 。vimrc 。我们在下面说的配置都是在本文件中配置 。 映射 esc 键 因为历史原因，Joy 设计 vi 时采用的键盘和我们现在用的标准键盘布局并不一样，当时他的键盘的 esc 键在现在我们的 Caps Lock 键的位置，所以才设计使用 esc 作为模式转换键 。为了更加方便顺手地使用 vim，当然要把这两个键相互调换一下 。 在 vim 的官网上就有介绍如何实现两个按键的调换 Map caps lock to escape in XWindows 具体方法，在 ～/ 目录下新建一个文件，加入一下内容 1 2 3 4 5 ! Swap caps lock and escape remove Lock = Caps_Lock keysym Escape = Caps_Lock keysym Caps_Lock = Escape add Lock = Caps_Lock 保存为 .speedswrapper 然后输入命令 1 xmodmap ~/.speedswrapper 这时，对于整个系统范围，这两个键已经调换了位置 。 设置颜色主题 colorscheme Vim 自带一些颜色主题，一般存放在 /usr/share/vim/vim7x 目录下（我的 Vim 版本为 7.3，所以路径为 /usr/share/vim/vim73 ）. 如果对系统自带的主题不满意，网上有很多不错的主题，个人最喜欢 molikai 主题，把下载下来的配色文件拷贝到 usr/share/vim/vim73 路径下，打开 vim 后 输入 1 :colorscheme molikai 就 ok 了～ 不过这个方法在关闭 vim 后就恢复了，要想省去每次都输命令的烦恼，只需要在下一步 .vimrc 文件中加入以下内容就可以了 1 colorscheme molikai 编写 .Vimrc vimrc 文件是配置 Vim 编辑特性比较好的地方，差不多任何 Vim 选项都能在次文件中被设置为打开或者关闭，而且它特别适合设置全局变量与定义函数、缩写、按键映射 。 注释以双引号 \" 开始，可位于一行的任何 2 位置，所有位于双引号后面的文本，包括双引号都会被视为注释而忽略 可以用冒号 : 表示 ex 命令 配置 Vim 特性 vimrc 配置很简单，网上有很多人都分享了自己的配置方案 。我找到一份注释良好的 配置范例 ，这篇博客的作者总结了自己 8 年的使用经验，给出了两份配置文件，基本版 Basic 和 终极版 Ultimate 。 作为码农，当然要选择终极版了～不过个人喜欢用 Vundle 管理我的 Vim 插件（计划下篇博客记录我的配置过程），不是很喜欢作者选择的所有插件，想自己定制插件组合，那么目前只需要看 基础版就足够了 。 copy 了一份基础版到自己的 github 中，有备无患 :-D Copy of basic vimrc configure file 我自己的配置文件： My .vimrc file 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" General \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" set nocompatible \" Set how many lines of history VIM has to rememer set history = 800 \" Enable filetype plugins filetype plugin on filetype indent on \" Set to auto read when a file is changed from the outside set autoread \" Set leader key let mapleader = \" , \" let g:mapleader = \" , \" \" fast saving nmap <leader>w :w!<cr> \" fast saving nmap <leader>q :q!<cr> \" fast editing nmap <leader>aq :qa<cr> \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Vim user interface \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Set 20 lines to the cursor set so = 20 \" Turn on the wild menu set wildmenu \" Ignore complited files set wildignore = *.o,*~,*.pyc \" Always show current postion set ruler \" Highlight current line set cursorline \" Height of command bar set cmdheight=2 \" A buffer becomes hidden when it is abandoned set hid \" Configure backsapce so it acts as it should act set backspace=eol,start,indent set whichwrap+=<,>,h,l \" Ignore case when searching set ignorecase \" When searching try to be smart about cases set smartcase \" Highlight search results set hlsearch \" Make search act like in morden browsers set incsearch \" Don ' t redraw while executing marcros set lazyredraw \" For regular expressions turn magic on set magic \" Show matching brackets when text indicator is over them set showmatch \" How many tenths of a second to blink when matching brackets set mat=2 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Colors and Fonts \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Enable syntax highlight syntax enable colorscheme molokai set background=dark :set t_Co=256 \" Set utf8 as standard encoding and en_US as the standard language set encoding = utf8 \" Use Unix as the standard file type set ffs=unix,dos,mac \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Files, backups and undo \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Turn backup off, since most stuff is in SVN. git et.c anyway set nobackup set nowb set noswapfile \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Text, tab and indent related \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Use sapce instead of tabs set expandtab \" Be smart when using tabs set smarttab \" 1 tab = 4 spaces set shiftwidth=4 set tabstop=4 \" Linebreak on 500 characters set lbr set tw = 500 set ai \"Auto indent set si \" Smart indent set wrap \"Wrap lines \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Moving around, tabs, windows and buffers \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Treat long lines as break lines map j gj map k gk \" Smart way to move between windows map <C-j> <C-w>j map <C-k> <C-w>k map <C-h> <C-w>h map <C-l> <C-w>l \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Status line \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Show line number set number \" Always show the status line set statusline=%F%m%r%h%w\\ [FORMAT=%{&ff}]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %{strftime(\\\"%d/%m/%y\\ -\\ %H:%M\\\")} \"\"set statusline=\\ %{HasPaste()}%F%m%r%h\\ %w\\ \\ CWD:\\ %r%{getcwd()}%h\\ \\ \\ Line:\\ %l \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Spell checking \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Pressing ,ss will toggle and untoggle spell checking map <leader>ss :setlocal spell!<cr> map <leader>sn ]s map <leader>sp [s map <leader>sa zg 参考 学习 vi 和 Vim 编辑器 The Ultimate vimrc","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_vimrc_preliminary.html","title":"学习 Vim 初步配置 Vim"},{"url":"https://qiangu.cool/posts/misc/how_to_use_gmail_elegantly.html","text":"Gmail 是 Google 提供的邮箱，细数使用 Gmail 已经快 5 年了，但是最近才发现自己的使用方法根本不对，摸索了 2 天，总结一下使用心得～ 为何使用 Gmail 关于 QQ mail 和 Gmail 谁好谁坏的问题，知乎上有一堆 为什么这么多人说 Gmail 好用？Gmail 和 QQmail 相比到底好在哪里？ 为什么现在这么多受过高等教育的人喜欢用 Gmail，国内的邮箱如何？ 不喜欢 Gmail 而喜欢 QQ 邮箱的人，为什么会产生这样的偏好？ 我选择 Gmail 的理由： Gmail 账户是 Google 所有服务的入口，除了可以使用 Gmail 外和其他所有 Google 产品都有无缝的整合 。 强大的功能，比如我最喜欢的 邮件对话功能 和 label 功能 ，还有 过滤器 ，Chrome + Gmail，给你最简洁强大的体验 。 安全，邮件不会受到某些机器 & 人工的监视，免受 GFW 的干扰 这恰恰是一些人不使用 Gmail 的原因，因为 Gmail 不稳定，但是关于这个问题，引用 和菜头 在知乎上的一句话 \" 因为 Gmail 总有访问正常的一天，只要 Google 不死。对未来没有信心做人和一条咸鱼又有什么区别？\" ，况且，在 Geek 面前这都不是问题 。） 关于 Google 和百度、天朝的恩怨，一个有独立判断能力的人都明白为什么 Google 退出中国 。 我是 G 粉，Gmail 代表了自由 :-D Gmail 可以代收发邮件，测试了一下 QQ mail 和 163 是可以用的，所以，只需要 一个 Gmail 就可以管理 3 个邮箱了。 对于中国人来说，邮箱貌似是一个很边缘化的东西，而对于西方国家来说，邮箱交流是一件再普通的事了。听说微软 和 Google 公司即使一个办公室内的同事，上下级都是用邮件交流的（国内互联网公司貌似也有，但是没有达到那么频繁的程度），全世界的邮件流量超过 80% 在欧美 。所以，QQ mail 上到处是贺卡、问候、漂流瓶，这也是为什么用 QQ mail 发一份简历时为什么显得不正式的原因 。 如何优雅地使用 Gmail 擅自使用知乎风格来命名这个子标题，其实只是我个人的一些使用心得 :-D 完整的攻略当然是官方的 帮助 代收其他邮箱 官方帮助文档，导入 邮箱账户 Gmail 最多可以导入 5 个邮箱账户的邮件，对于普通人来说，远远足够了 。 Inbox /Archive 这是我最喜欢 Gmail 的地方，也是我以前一直没有正确使用的功能 。以前，我的 inbox 里面有大概 800+ 份邮件，包括已读 / 未读，私人邮件、工作邮件、广告、各个网站注册激活链接、社交网络消息提醒等，全部混在一起 。 从知乎上找到一个改变我对邮箱 Inbox/Archive 的认识的回答，问题是 如何有效地使用 Gmail 的 Archive（归档）功能？ ，回答者是 钢盅郭子 。 精髓就是 Inbox = 待 / 未处理 Archive = 已 / 不处理 阅读完邮件（已读），却无法立刻做出响应（回复或开展相关工作）的可能性是很高的，此时可以将邮件留在收件箱内留待日后处理。 而将邮件存档，则说明已经不再对此邮件感兴趣了，即便它始终未读，我们也可以通过其他信息（标题、收件人不是自己）确定这是一封不需要关注的邮件。 有人认为 Inbox 可以覆盖 Archive 的功能。我觉得可以理解，毕竟，喜欢把所有工作都堆放在办公桌台面上的也是大有人在。但即使我们有许多的文件夹或标签可用来分类、标识，抽屉总还是办公桌的默认配置吧。 像我以前一样，读完的文件仍然保留在 Inbox 中，就像每次都在办公桌面上读完文件都不收拾，越摆越多，只是这个虚拟的办公桌不会堆不下文件 。 正确的使用方法应该是把 Inbox 视为一个 tmp，在阅读完邮件后，该删除的删除、该归档的归档、该打标签的打标签，就像保持桌面整洁一样 。 P.S. 事实上，Inbox 只是一个标签，所谓 归档（Archive） 就是删除这个标签，一份处理完的邮件不再应该打上 Inbox 的标签，所以我们要进行归档 。 标签 & 文件夹 Gmail 使用了标签代替文件夹，真是一个革命性的创举 。 帮助里面 [ 列举 ][lable] 了 标签 相比于 文件夹 的优势 一个会话可以拥有一个以上的标签，而一封邮件只能放在一个文件夹中 会话可以同时存在于多个位置（收件箱、所有邮件、已发邮件等等），便于日后查找 。而在文件夹中，您必须记住邮件的存档位置，才能找到它 。 您可以利用标签对会话进行搜索，而您不可能总是在文件夹内进行搜索 。 所以，我们需要做的就是阅读邮件，然后按照邮件的属性，给它打上标签（label），比如私人邮件、工作邮件、学习邮件、注册验证邮件、社交邮件等等 。每种表情可以自定义颜色，按照邮件在我们心目中的重要程度，给每种标签赋予不同的颜色，一眼看上去，简洁明了，而且很好看 。 了解如何创建、修改、删除和搜索标签 星标邮件 & 重要邮件 Gmail 提供了自动识别邮件重要性的功能，它可以根据算法，用户使用习惯等自动识别，标记一个邮件是否是 \" 重要的 \"，除此之外，我们可以自己给邮件打星标，来标记邮件的重要程度 。 根据我的使用习惯，感觉超过 5 个标签，就有点让人迷惑了，所以，我使用的星标一共有 4 个： 黄色星星 表示一般重要文件 红色叹号 表示非常重要邮件 紫色问号 表示未处理完，将来还需要处理 绿色对号 表示已经处理完，暂时一段时间都不需要处理的邮件，除非我手动搜索 has : green - check 过滤器 使用强大的过滤器，我们可以让 Gmail 实现自动对邮件进行分类 比如，邮件里包含 \" 注册 \"、\" 激活 \"、\"Active\"、\"Registration\"、\"Verify\" 等单词，就可以自动打上 \" 注册验证 \" 标签 。 再比如，为转发邮箱 QQ mail 或者 163 邮箱设置自动打标签，标记为已读，自动存档、转发、删除等 。 实验室功能 Gmail 实验室有一些很好玩的功能，比如在邮件中看 Google Map，查看 Google Calendar，取消发送等 。至于 Google 目前主推的 Google+ 和 Google Drive 已经整合进 Gmail 了 。 强大的 Gmail 真是让人越用越不释手 :-D 参考 收发 Gmail 必学 12 招，善用邮件分类、前端管理当 Gmail 达人 如何優雅地使用 Gmail & Mailing List 知乎 Gmail 精华问题","tags":"Misc","loc":"https://qiangu.cool/posts/misc/how_to_use_gmail_elegantly.html","title":"如何优雅地使用 Gmail"},{"url":"https://qiangu.cool/posts/misc/run_warcraft_on_ubuntu.html","text":"闲来无聊，在 Ubuntu 下 wine 了一个 WarCraft 3 玩 在实验室的 \" 老爷车 \" 电脑上运行。稍微有一点卡，在 5 年前买的笔记本（core 2 T6600, 4G RAM）上运行就感觉不到卡了 。 实验室电脑配置： Processor: Pentium(R) Dual-Core CPU E5200 @ 2.50GHz × 2 Graphics: Gallium 0.4 on NV86 Memory: 2.0 GiB OS type: 32-bit 安装 Wine Wine 是 wine is not an emulator 的缩写，它可以在 x86、x86-64 上容许类 Unix 操作系统在 X Window System 下运行 Microsoft Windows 程序的软件 . 它的官方网址：http://www.winehq.org/ 方法一： Ubuntu 软件仓里搜索 Wine，就可以找到 Wine Windows Program Loader ，直接安装即可 方法二： 使用 apt-get 1 2 apt-cache search wine suod apt-get install wine P.S. 若是其他系统，找不到对应的二进制包，可以直接从官网上下载源码，自己编译（官网上有详细的 FAQ ） 拷贝 WarCraft 如果是双系统，则不必拷贝 WarCraft 文件夹，因为我电脑上只有 Ubuntu，所以从同学那里拷贝了一个，放在了 ～/ 目录下 。 配置 Wine & WarCraft CD key 注册表问题 直接以 wine 运行 war3.exe 时提示没有 CD key，在 WarCraft 目录下找到了两个注册表文件， War3.reg 和 一键导入 .reg 。 在终端下导入注册表 1 wine regedit 然后导入这两个文件，再次尝试，还是不行 ... 不急，游戏目录下还有一个程序叫 War3RegFixer.exe ，看名字就知道是我们需要的 1 wine War3RegFixer.exe 因为我的 Ubuntu 是英文版的，打开后是乱码 ... 找了一台 Windows 电脑，运行了一下，按照向导就可以修复 CD key 的问题 。 分辨率问题 第一次运行的结果一般不会全屏，处女座的强迫症犯了，还好比较简单 ：D 1 wine regedit 找到 HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/Video ，里面有两个注册表值 resheight 和 reswidth ，将他们设为和当前分辨率相同的十进制数值就可以了。 画面卡 因为 Wine 对 DirectX 的支持还不够好，如果电脑配置比较低，运行的时候添加参数 -opengl 就可以了，为了避免每次运行都要输入参数，可以在注册表 HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/ 下新建整数（DWORD），名为 Gfx OpenGL ，值为 1 。 运行 终端下 现在就可以在终端下运行 war3.exe 了 1 wine war3.exe 熟悉的画面就出来了～ 这样子运行如果切出游戏，有时会导致 war3 崩溃或者切换不出去。一个解决方法是以窗口模式运行，只需要添加参数 -window 即可 1 wine war3.exe -window 效果如下 不过个人不是很喜欢，因为鼠标总是超出窗口，极其不方便，影响游戏操作和感受 ：D 桌面启动器 我们可以为 war3 添加一个桌面启动器，这样就不用进入终端启动了 新建文件 frozen-throne.desktop 文件，添加以下内容 1 2 3 4 5 6 7 [ Desktop Entry ] Version = 1 .0 Name = Frozen Throne Exec = /home/chien/WarCraft/war3.exe Terminal = false Icon = /home/chien/WarCraft/war3.jpg Type = Application 然后把这个文件移动到 /usr/share/applicants/ ，这时在 unity 中搜索 froz ，就能看到我们刚才新建的启动器了～ 至此，就可以在 Ubuntu 下享受 War3 了 gl hf！ 参考 用 Wine 运行魔兽争霸 III Wine 魔兽争霸 3 的一些设置 Wine 魔兽争霸 3，流畅运行 + 键盘操作 + 窗口化","tags":"Misc","loc":"https://qiangu.cool/posts/misc/run_warcraft_on_ubuntu.html","title":"在 Ubuntu 下运行 WarCraft"},{"url":"https://qiangu.cool/posts/book/steve_jobs_review.html","text":"一直想买本 《乔布斯传》 ，但是被 ￥68.00 的定价击败了，舍不得花钱买 :D 但是电子书的体验真的太差，看了一半就没有坚持下来。突然发现有个同学有本崭新的《乔布斯传》，于是借来用闲暇时间看了一个多月才看完 ... 作为一名资深 \" 挨踢 \" 菜鸟，乔布斯的名字可以说是如雷贯耳，他在普通人眼中，尤其是果粉眼中，基本上就是神一般的存在。以前我也一直这么认为，直到看完这本书，我才发现事实中的 \" 乔帮主 \" 完全是另外一个人，一个有爱有恨，爱哭，执着的同时执着到固执的地步，毫不做作的一个人。 写几点感触吧，以证明没有白看这本书，看书的价值就在与思考～ 爱哭的教主 这是我看书时，最惊奇的地方。有网友统计，传记里记载的乔布斯一共哭泣了 157 次，其中哭倒在地 25 次，大哭并尖叫 34 次，泪流满面 42 次。以前觉得神一样的 \" 乔帮主 \" 肯定是神挡杀神，佛挡杀佛，怎么会动不动就哭鼻子呢。联系他的人生经历，原来这样子更符合他的性格 。 在知乎上看到 一个回答 ： 乔布斯是一个多愁善感的人，他经常哭。他从小就发现这种方式能达到目的。我觉得实际上他是那种不去刻意控制自己情绪的人，想哭就哭，想骂就骂，想夸就夸，不受限制。我们所知道的他哭的例子，只不过是几个很有名的瞬间，被放大了。 我们从小就被 \" 男儿有泪不轻弹 \" 给害了，变成了貌似坚强，却浅了情感。 i hope i can cry when i want to. 或许，这样率性，真实的人生是另外一种更值得追求的选择，只是这种性格注定只有两种结局：1. 你很 nb，可以把内心的真实想法随意说出来，别人即使很不爽，但是也不能对你怎么样，甚至尊敬你，这种最典型的就是 yy 小说中的主人公，而现实生活中则没几个，乔布斯就是典型例子；2. 你自己没有什么本事，还有一身尖酸刻薄的臭脾气，最后只能是连一个朋友也没有，一事无成。而大多数人，都会选择作出 \" 正确 \" 的选择 —— 尽量修炼自己，积累知识，同时在这个人情冷漠的年代找到一两个好朋友和 \" 红颜／蓝颜知己 \" 。 不是任何一个人想哭就能哭的，这也是需要一定资本足够 nb 才行 ... 乔布斯为何而哭？ 嬉皮士＆禅宗＆迷幻药＆现实扭曲力场 乔布斯由于自己身世的原因，总是对这种追求人生真谛的事很感兴趣 。（前半句为个人猜测，后半句是事实）他经历了嬉皮士运动，去印度寻找过 \" 精神导师 \"，嗑过迷幻药，在遇到罗伯特 弗里德兰之前，他羞涩又谦逊，非常内敛，但是很快他就学会了弗里德兰的强大气场，并且发展成为自己著名的 \" 现实扭曲力场 \" 。 乔布斯从来都不是标准意义上的 \" 好学生 \"，相反，他叛逆，敏感，但是他也喜欢思考，在养父的影响下，他培养出了对细节要求到苛刻的 \" 工匠精神 \" 。他直接给惠普的创始人打电话要求一份临时工的工作，参见工程师的会议，探索自己感兴趣的电路，和沃兹一起做出 \" 能打电话的盒子 \"，大发一笔 。另一方面，他又直接逼自己的养父母同意退学，去了里德学院，结果还是不去上课，上了一半就退学了 。 这样的上学经历，在中国人看来，真的是无可就药，他能有后来的成就真的是不可思议。我好像为自己翘课，学习成绩不好找到了一个完美的借口 ... 关于为什么中国出不了乔布斯，中外教育制度差别等话题都被谈烂了，个人认为，外界的客观环境是一方面，自身的努力也很重要（不仅中国出不了乔布斯，事实上，全世界也就这么一位，在美国，乔布斯也不是普通人能效仿的，不然美国遍地都是乔布斯了 -.-）。 站在人文与科技的十字路口 乔布斯：初心与终点 乔布斯是令人倾慕的天才、艺术家、犀利的商业决策者，而他亦正亦邪的浪子一面，暴君般肆虐、魔鬼般欺骗、傀儡师般操控他人，则平添戏剧性和张力。 乔布斯与他的同行们不同。盖茨、Facebook 的扎克伯格和亚马逊的贝佐斯们所致力的，都是将技术融入生活：无论让每户人家的桌子上摆一台电脑、让每个人将自己的身份及社会关系映射到互联网上，还是通过互联网销售书籍、音乐和电影。他们像工业革命时代掌握蒸汽机的人一样，以更高级的技术破坏既有的世界规则，并以此打造庞大的商业帝国 。 而科技对于乔布斯，更像画笔之于梵高、刻刀之于米开朗基罗。他热爱美好的事物，也希望自己成为一名创作者。自 21 岁创立苹果电脑，到 56 岁宣布退休，35 年间他主导设计的软、硬件各超过百款，而在美国商标专利局备案的署有他的名字的专利就多达 300 余个 —— 相比之下，拥有更深厚技术背景的盖茨名下的专利不过九项、Google 的两名创始人拉里 · 佩奇和谢尔盖 · 布林拥有的专利总和也没超过 20 个 。 以前美国的专利申请很宽松，乔帮主的专利大多数应该是设计方面的吧，而佩奇的专利明显更有技术含量 。 乔帮主最看不上盖茨的就是 \" 糟糕的品味 \"，而盖茨也在访谈中承认自己最想拥有的就是一流的品味。两个人的人生轨迹完全不同，代表了完全相反的两条路，却最终成一生的对手和朋友，多么神奇 。 控制欲 乔帮主追求完美的欲望和控制欲强烈到一种不可思议的地步，他想控制产品的方方面面，不但是用户体验，甚至不想让用户拆开 Mac，iphone；里面的电路也和外面一样精致，即使用户永远都不会看到。用户买来直接用就行了，其他的全部由他，苹果公司负责，甚至他认为用户从来不知道自己需要什么样的产品，如汽车的发明人福特说的一样 ——\" 在我发明汽车以前，人们只会想买一辆什么样的马车 \" 。 他的这种控制欲望能成功，是建立在高雅的品味之上的。这种软件、硬件一体化，端到端的产品更本轮不到用户插手，这和 Geek 精神完全相悖，在 Apple I 时，他和沃兹的分歧就已经出现了，最终以教主的痛哭流涕收场。幸好这个世界上 Geek 只是少数，幸好他的艺术品味一流高雅，发明了改变 P C、手机、动画、音乐等行业的产品，让我们体验到什么是美好的产品 。 但是这种控制欲和他的 \" 现实扭曲力场 \" 也有副作用。在饮食上他是严格的素食主义者，面对他得癌症的现实，他也选择性的忽略，即使后来身体状况很糟糕了，他仍然只吃蔬菜和水果。如果他能及早面对癌症肿瘤，或许可以在扩散之前就控制住病情，但是他是乔布斯，所以他不会这样。 Jobs 像个任性的大孩子，尽情挥洒着自己的才能，永不停歇的迈向理想。留给中国人太多感动和反思 。 参考 乔布斯为何而哭？ 乔布斯：初心与终点","tags":"Book","loc":"https://qiangu.cool/posts/book/steve_jobs_review.html","title":"乔布斯传 书评"},{"url":"https://qiangu.cool/posts/cs/cosnt_qualifier.html","text":"为什么要使用 const 限定符 一个需要使用 const 的简单例子 C++ Primer 中的例子 1 2 3 for ( int index = 0 ; index != 512 ; ++ index ) { // ... } 这段代码语法上是没有问题的，但是事实上是有两个小问题的，而且两个小问题都和数字 512 有关 。 第一个问题是 程序的可读性 比较 index 与 512 有什么意思呢？也就是说 512 这个值作用何在？在程序中这种数字被称为 魔数（magic number） ，它的意义在上下文中没有体现出来，好像这个数是凭空魔术般变出来的 。 第二个问题是 程序的可维护性 如歌这个程序非常庞大，512 这个数字出现了 100 次，进一步假设这 100 次中，有 80 次是表示某个缓冲区的大小，剩余 20 次用于其他目的 。现在，我们需要把缓冲区的大小增大到 1024，要实现这个目标，必须检查每个 512 出现的位置，必须确定哪些是表示缓冲区大小，哪些不是 。 解决这两个问题的方法是定义一个变量，并且初始化为 512 1 2 3 4 int buf_size = 512 ; for ( int index = 0 ; index != buf_size ; ++ index ) { //... } 通过定义一个好记的变量，就可以增强程序的可读性，而且需要改变这个值时，只需要咋初始化的地方做修改 。这种方法不仅明显减小了工作量，而且大大减小了出错的可能性 。 看起来问题好像已经解决了，但是，事实上，我们可以进一步 在上面的代码中， buf_size 是可以被修改的，它有可能会被有意或者无意修改 。为了避免这种情况，就需要使用 const 限定符了 。 1 const buf_size = 512 ; 定义 buf_size 为 常量（constant） ，并且初始化为 512 . 变量（variable） buf_size 仍然是一个左值，但是这个左值现在是不能被修改的。（因为 const 把变量转化为常量，所以在定义的时候必须初始化！） 如何使用 const 限定符 C++ Primer 中有这么一句话 It (const) transforms an object into a constant. 但是在这句话之后有说 The variable bufSize is still an lvalue 这是矛盾的，因为常量是不能当左值的 。个人感觉严谨的说法应该是 \"cosnt 使变量具有了常量的属性 \" 文件的局部变量 const 限定符修同时也改变了变量的作用范围 。普通非 const 变量的默认是具有 外部连接（external linkage） 的，在全局作用域内定义非 const 变量时，它在整个程序中都可以被访问 。比如 1 2 3 4 5 6 // file1.cpp int counter ; //file2.cpp extern int counter ; ++ counter ; 但是，对于 全局作用域内的 const 类型的对象，其默认是 内部连接（internal linkage） ，仅在定义该对象的文件内可见，不能被其他文件访问 。要想在整个程序里面访问，就必须在定义的时候显式地声明为 extern 类型 。比如 1 2 3 4 5 6 7 //file1.cpp extern int buf_size = fcn (); //fiel2.cpp extern const int buf_size ; for ( int index = 0 ; index != buf_size ; ++ index ) //... 使用 const 的方法 定义在头文件中 inlcude 如果 const 变量是用常量表达式初始化的，那么就可以把它的定义放在头文件中，即使多次包含这个头文件也不会产生 \" 重定义 \" 的问题 。 1 2 3 4 5 6 // file1.h const int bufsize = 512 ; // file2.cpp include \"file1.h\" int size = bufsize 定义时声明为 extern 如果 const 变量不是用常量表达式初始化的，那么就不能把它当在头文件中 。只能在源文件中定义并初始化 。因为 const 变量是文件局部变量，所以要在其他文件中使用该变量，必须在定义时加上 extern 声明 。 比如 1 2 // file1.cpp extern const int bufsize = 512 ; 在头文件中声明为 extern 类型，以使其他文件共享。 1 2 3 4 5 6 // file1.h extern const int bufsize ; // fil2.cpp #include \"file1.h\" int size = bufsize ; 不需要在头文件中声明，在其他文件中使用前声明 1 2 3 // file2.cpp extern const int bufsize ; int size = bufsize ; P.S. 在 C 中 const 是默认为外部连接的，在 C++ 中是默认为内部连接的 。 至于为什么要这么规定， Thinking in C++ 中有说明 Constants were introduced in early versions of C++ while the Standard C specification was still being finished. It was then seen as a good idea and included in C. But somehow, const in C came to mean \"an ordinary variable that cannot be changed.\" In C, it always occupies storage and its name is global. The C compiler cannot treat a const as a compile-time constant. In C, if you say const bufsize = 100 ; char buf [ bufsize ] ; you will get an error, even though it seems like a rational thing to do. Because bufsize occupies storage somewhere, the C compiler cannot know the value at compile time. In C++, a const doesn't necessarily create storage. In C a const always creates storage. Whether or not storage is reserved for a const in C++ depends on how it is used. In general, if a const is used simply to replace a name with a value (just as you would use a #define), then storage doesn't have to be created for the const. If no storage is created (this depends on the complexity of the data type and the sophistication of the compiler), the values may be folded into the code for greater efficiency after type checking, not before, as with #define. If, however, you take an address of a const(even unknowingly, by passing it to a function that takes a reference argument) or you define it as extern, then storage is created for the const. Since a const in C++ defaults to internal linkage, you can't just define a const in one file and reference it as an extern in another file. To give a const external linkage so it can be referenced from another file, you must explicitly define it as extern, like this: extern const int x = 1 ; Notice that by giving it an initializer and saying it is extern, you force storage to be created for the const(although the compiler still has the option of doing constant folding here). The initialization establishes this as a definition, not a declaration. The declaration: extern const int x ; in C++ means that the definition exists elsewhere (again, this is not necessarily true in C). You can now see why C++ requires a constdefinition to have an initializer: the initializer distinguishes a declaration from a definition (in C it's always a definition, so no initializer is necessary). With an external constdeclaration, the compiler cannot do constant folding because it doesn't know the value. const 引用 & const 对象 在引用的定义中声明 const，此 const 约束的是引用，而不是引用的对象 。比如 1 const int & ref = ival 其中， const 修饰的是 int & ，规定了引用 ref 为 const 类型变量，而 ival 的类型则由其他语句定义说明 。 const 引用： 引用变量为 const 类型，引用对象的类型可以是 const、nonconst、r-value nonconst 引用： 引用变量为 nonconst 类型，引用对象只能是同类型的 nonconst 类型 因为引用只是对象的另外一个名字，它们指向的是统一块内存空间，所以通过修改引用的值就能达到修改对象的值的目的 。 当对象是 const 类型时，隐含的含义是该对象不能被修改，所以只能定义 const 类型的引用指向它；nonconst 类型的引用隐含的意思是可以通过引用修改对象值，这对于 const 类型的对象来说是不允许的 。 当对象是 nonconst 类型时，隐含的含义是该对象可以通过引用来修改，此时，const 引用和 nonconst 引用都可以指向该对象 。当使用 nonconst 引用时，可以通过引用修改对象的值；当使用 const 引用时，虽然对象的值是可以改变的，但是不能通过该引用修改，因为引用的类型是 const，定义以后，不能再修改 。 何时应该使用 const Scott Meyers 大神的经典著作 Effective C++ 里面提到的关于 const 的使用 。 Effective C++ 条款 02：尽量以 const、enum、inline 替换 #define（Prefer consts,enums,and inline to #define） 使用 const 代替 #define，事实上 const 的最初动机就是取代预处理器 #define 来进行值替代 。因为 #define 不被视为语言的一部分，这就是它的问题所在 。 1 #define ASPECT_RATIO 1.653; 记号名 ASPECT_RATIO 也许从未被编译器看见，也许在编译器开始处理代码前就被与处理器移走了，于是记号没有进入记号表，当出现编译错误时，也许会提示是 1.653 而不是 ASPECT_RATIO，这回带来很多困惑 。 解决之道就是以一个常量代替上述的宏 1 const double AspectRatio = 1.653 ; Effective C++ 条款 03：尽可能使用 const（Use const whenever possile） 参考 C++ Primer Thinking in C++ Effective C++","tags":"CS","loc":"https://qiangu.cool/posts/cs/cosnt_qualifier.html","title":"C++ const 限定符"},{"url":"https://qiangu.cool/posts/ic/pulse_edge_detection.html","text":"脉冲边沿检测是 FPGA 设计中经常用到的方法，本文总结一下其原理和实现代码，可以将其加入我们自己的代码库中，以备以后使用 。 脉冲边沿检测原理 如图，任何一个脉冲既有上升沿也有下降沿，系统的时钟周期一定要比脉冲宽度小，而且越小越好，即频率越高越好 。 脉冲边沿的特点就是：边沿两侧的电平发生了变化 。 利用这一点，我们就可以设计出检测边沿的方法 。 操作方法： 建立 2 个寄存器，形成二级寄存器，在时钟触发中，首先把数据送入第一个寄存器中，然后在下一个时钟上沿到来时，将第一个寄存器中的数据存入第二个寄存器，也就是说第二个寄存器中的数据始终比第一个寄存器晚一个周期，即晚一个数据 。根据系统时钟检测，如果前后进来的信号发生了变化，可以用异或运算，异或结果为 1，说明电平发生了变化，有边沿产生。 脉冲边沿检测方法 检测是否有边沿 程序： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 module DETECT_EDGE ( clk , rst_n , trig_in , trig_edge ); input clk ; input rst_n ; input trig_in ; output trigedge ; reg trig_r1 ; reg trig_r2 ; always @ ( posedge clk or negedge rst_n ) begin if ( ! rst_n ) begin trig_r1 <= 1 'b0 ; trig_r2 <= 1 'b0 ; end else begin trig_r1 <= trig_in ; trig_r2 <= trig_r1 ; end end assign trigEdge = trig_r1 &#94; trig_r2 ; endmodule 综合结果： 仿真结果： 检测 上 / 下 边沿 下降沿检测原理： 将第一个寄存器中的数据取反与第二个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 1 变为 0 时，就会在新的寄存器里产生一个高电平，并维持一个周期 。 上升沿检测原理： 将第二个寄存器中的数据取反与第一个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 0 变为 1 时（上升沿，此时 r1 变为 1，但 r2 仍保持前一周期的 0），就会在新的寄存器里产生一个高电平，并维持一个周期 。 程序： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 module DETECT_EDGE ( clk , rst_n , trig_in , trig_pos_edge , trig_neg_edge ); input clk ; input rst_n ; input trig_in ; output trig_pos_edge ; output trig_neg_edge ; reg trig_r0 ; reg trig_r1 ; reg trig_r2 ; always @ ( posedge clk or negedge rst_n ) begin if ( ! rst_n ) begin trig_r0 <= 1 'b0 ; trig_r1 <= 1 'b0 ; trig_r2 <= 1 'b0 ; end else begin trig_r0 <= trig_in ; trig_r1 <= trig_r0 ; trig_r2 <= trig_r1 ; end end assign trig_pos_edge = trig_r1 & ( ! trig_r2 ); // Detect posedge assign trig_neg_edge = ( ! trig_r1 ) & trig_r2 ; // Detect negedge endmodule 综合结果： 仿真结果： 另外一种写法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 module DETECT_EDGE ( clk , rst_n , trig_in , tirg_pos_edge , trig_neg_edge ); input clk ; input rst_n ; input trig_in ; output trig_pos_edge ; output trig_neg_edge ; reg [ 2 : 0 ] trig_r ; always @ ( posedge clk or negedge rst_n ) begin if ( ! rst_n ) trig_r <= 3 'b0 ; else trig_r <= { trig_r [ 1 : 0 ], trig_in }; end assign trig_pos_edge = ( trig_r [ 1 : 0 ] == 2 'b01 ); assign trig_neg_edge = ( trig_r [ 1 : 0 ] == 2 'b10 ); endmodule 综合结果： 仿真结果： 脉冲边沿检测应用 理想的键盘输入特性： 然而实际的键盘受制造工艺等影响，其输入特性不可能如上图完美 。当按键按下时，在触点即将接触到完全接触这段时间里，键盘的通断状态很可能已经改变了多次 。即在这段时间里，键盘输入了多次逻辑 0 和 1，也就是输入处于失控状态 。如果这些输入被系统响应，则系统暂时也将处于失控状态，这是我们要尽量避免的 。在触点即将分离到完全分离这段时间也是一样的 。 实际的键盘输入特性： 软件消抖 要占用系统资源，在系统资源充足的情况下使用软件消抖更加简单 。软件消抖的实质在于降低键盘输入端口的采样频率，将高频抖动略去 。实际应用中通常采用延时跳过高频抖动区间，然后再检测输入做出相应处理。一般程序代码如下： 1 2 3 4 5 6 7 8 if ( value == 0 ) // 一旦检测到键值 { Delay (); // 延时 20ms，有效滤除按键的抖动 if ( value == 0 ) // 再次确定键值是否有效 { do something // 执行相应处理 } } 这段软消抖程序从机理上看不会有什么问题，通常在软件程序不太 \" 繁忙 \" 的情况下也能够很好的消抖并做相应处理 。但是如果在延时期间产生了中断，则此中断可能无法得到响应 。 对于硬件资源丰富的 FPGA 系统，可以使用硬件来减轻软件工作量，通常称之为 \" 硬件加速 \" 。在按键信号输入到软件系统前用逻辑对其进行一下简单的处理即可实现所谓的 \" 硬件消抖 \"，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 对输入信号 inpio 硬件滤波，每 20ms 采样一次当前值 reg [ 18 : 0 ] cnt ; //20ms 计数器 always @ ( posedge clk_25m or negedge rst_n ) if ( ! rst_n ) cnt <= 19 'd0 ; else if ( cnt < 19 'd500000 ) cnt <= cnt + 1 'b1 ; else cnt <= 19 'd0 ; reg [ 1 : 0 ] inpior ; // 当前 inpio 信号锁存，每 20ms 锁存一拍 always @ ( posedge clk_25m or negedge rst_n ) if ( ! rst_n ) inpior <= 2 'b11 ; else if ( cnt == 19'h7ffff ) inpior <= { inpior [ 0 ], inpior }; else inpior <= inpior ; wire inpio_swin = inpior [ 0 ] | inpior [ 1 ]; // 前后 20ms 两次锁存值都为 0 时才为 0 该程序中设置了一个 20 ms 计数器，通过间隔 20 ms 对输入信号 inpio 采样两次，两次相同则认为键盘输入稳定，得到用硬件逻辑处理后的 inpio_swin 信号则是消抖处理过的信号 。程序不再需要 delay() 来滤波了，也不会出现使用纯软件处理出现的 \" 中断失去响应 \" 的情况了，这就是 \" 硬件加速 \" 的效果 。 我们可以看到，传统单片机等系统大多是串行处理，即顺序执行，只能并行处理一些中断程序 。对于这样的系统，只能采用单纯软件或硬件电路消抖，但都不那么完美 。而对于 FPGA 等并行处理的系统，其优势就很明显，只要片内逻辑资源够用，通过硬件加速软件消抖的处理，完全可以做到按键消抖并行化，不影响系统的实时性 。 参考 脉冲边沿检测（Verilog） 脉冲边沿检测原理 verilog 版本 脉冲边缘检测法 按键消抖","tags":"IC","loc":"https://qiangu.cool/posts/ic/pulse_edge_detection.html","title":"脉冲边沿检测"},{"url":"https://qiangu.cool/posts/ic/learning_fpga_how_to.html","text":"学习 FPGA 差不多一年多，长期混迹于各大论坛，让我学习到了很多知识，转载一篇文章。 当年在对于 FPGA 什么都不懂的情况下，觉得这篇文章相当高大上，现在看来，的确如此～和别的入门级别的文章书籍相比，这篇文章没有涉及 FPGA 设计的细节，而是很精炼地讲了 FPGA 设计中最基本的 \" 世界观 \" 。也就是说这篇没有一头扎进 \" 术 \" 的内容中让读者无从读起，而是从整体上给出 FPGA 设计的 \" 道 \" 。对于初学者 —— 尤其是我这样从软件思维过渡过来的人，的确是不错的入门指导 。 转载地址： 如何学习 FPGA？FPGA 学习必备的基础知识 FPGA 已成为现今的技术热点之一，无论学生还是工程师都希望跨进 FPGA 的大门。网络上各种开发板、培训班更是多如牛毛，仿佛在告诉你不懂 FPGA 你就 OUT 啦。那么我们要玩转 FPGA 必须具备哪些基础知识呢 ? 下面我们慢慢道来。 要了解什么是 FPGA 既然要玩转 FPGA，那我们首先最重要的当然是要了解什么 FPGA 。FPGA（Field-Programmable Gate Array），即现场可编程门阵列 。看到编程两个字码农就笑了，不就是编程嘛，那可是我们的强项 。且慢，此编程非彼编程 。一定要把 FPGA 的编程和软件编程区分开来 。软件的编程，处理器会逐条的把语言翻译成各种控制信号，去控制内部电路完成一个个运算或操作 。那么 FPGA 的编程是怎么实现的呢？无论 Altera 家还是 Xlinix 家的 FPGA，叫法有什么差异，基本单元都相似，都是由真值表和 D 触发器构成 。改变真值表的值就改变了逻辑功能，再通过和 D 触发器组合来实现任何时序逻辑 。所以我们对 FPGA 的编程，实际上就是去修改这些真值表和连接关系，使他们组成一张专门的真值表，去实现特定的功能 。这和软件编程一步步运行程序有本质的区别 。要想玩转 FPGA，就必须理解 FPGA 内部的工作原理，学习如何利用这些单元实现复杂的逻辑设计 。 正确理解 HDL 语言 HDL（Hardware Description Language），硬件描述语言 。通过名称我们能看出来，HDL 语言是一种 \" 描述 \" 语言，这一点和 C 语言是有本质区别的 。正确理解描述的含义，对学好 HDL 语言很有帮助 。HDL 语言只是用文本的方式把硬件电路描述出来 。我们在阅读 HDL 程序的时候，在脑子里应该能反映出一个完整的硬件电路结构 。从另一方面说，我们在编写 HDL 语言之前，就已经对要实现的电路有清晰的概念 。所以 HDL 语言只是一个描述我们头脑中具体电路的工具， 玩转 FPGA 的根本不是语言而是逻辑电路设计 。不要再纠结于我应该学习 VHDL 还是 Verilog，哪种语言更好学这些问题 。如果把学习 FPGA 的重点放在学习语言上，死记硬背一些语法，那自然是抓错了重点 。语言在日常使用中会越用越熟练，不需要花很长的专门时间去学习 。当然一本好的参考资料可以随时方便查询会是很有帮助的 。 数字电路基础 说到底，FPGA 就是一堆数字逻辑组合在一起实现特定功能而已 。所以数字电路基础知识是根本 。如果你连触发器，组合电路，时序电路，竞争，毛刺等等基本概念还莫能两可不清不楚的话，那玩转 FPGA 只能是痴人说梦的幻想了 。我们必须要好好的学好数字电路基础这门课，基本的数字电路烂熟于心 。把这些基础打牢固，再往更深的方向发展 。什么时候能够从抽象的算法中提炼算法的结构，再分解成具体的模块并通过硬件电路实现出来，这时候就算从菜鸟级别步入老鸟级别了 。 硬件设计思想 这一点应该说是重中之重 。学习 FPGA，一定要有硬件设计思想 。在软件编程的时候，比如 1 秒钟能实现 5 次乘法运算，那系统要求 1 秒钟实现 50 次乘法运算怎么办，我们会尽可能的优化代码，让代码更简洁更高效，或者提高系统主频，让系统跑的更快 。但是在 FPGA 里面我们不是这种思维方式。在 FPGA 里实现一个乘法器不够用，那我就实现两个实现三个去满足系统要求；我可以进行流水线设计；串行运行方式不够快了，我可以先串并转换，再并行的做处理 — — 只要 FPGA 的资源够用，我可以充分利用资源去满足系统要求 。因为在我手里的就是一堆硬件资源，我要做的是把他们组合成一个好用的电路 。评价硬件描述语言写的好坏的标准和其他软件编程语言的标准是完全不同的 。因此一定要摒弃软件编程的一些固有思路，学会用硬件的方式去解决问题 。时刻提醒自己正在设计的是一个电路，而不是一行行空洞的代码 。这是很多做软件编程的人很难跨过的坎 。FPGA 学了很久还在纠结到底是用 if-else 语句好呢还是用 case 语句好？而不能透过这些语句表面看到他们所具体代表的电路 。只有建立了硬件设计思想，才有更深入学习 FPGA 的可能 。 FPGA 入门简单精通难 。要想入门，买一块开发板跟着例程走一遍，很多人都能在很短的时间内熟悉开发软件的操作方法并且点亮开发板上的 LED 或者再实现个跑马灯什么的，但是再往后进步往往就进展很慢 。上面提到的这四条是玩转 FPGA 的基础，只有打好了坚实的基础后面才能一马平川 。希望每个学习 FPGA 的人最后都能成为大牛，设计出自己的完美电路 。","tags":"IC","loc":"https://qiangu.cool/posts/ic/learning_fpga_how_to.html","title":"(转载) 如何学习 FPGA"},{"url":"https://qiangu.cool/posts/tools/learning_linux_ssh.html","text":"实验室的师兄师姐毕业了，继承了他们的旧电脑 。宿舍的笔记本和实验室的电脑出现了相互之间传送同步文件的需求 。想到了两种方法： 云同步 SSH / SCP 解决方案 1 是最省事的，也是目前最流行的，目前各大互联网公司都提供各种云服务，比如国外的 Google Drive、Dropbox，国内的百度云、360 网盘什么的。这种方案最大的有点是跨平台，不过这个方案是借助了第三方的服务器，需要连接到互联网才行，而且对网速是有一定要求的。 解决方案 2 相比于方案 1 的优势是：不是必须要连接到互联网，在局域网内也可以同步文件 。一般局域网内传输文件的速度要比连外界的服务器快很多 。 考虑到校园网的环境，明显方案 2 更加好 。 什么是 SSH 最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑 。 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置 。 最初的 SSH 协议是由芬兰的一家公司的研究员 Tatu Ylönen 于 1995 年设计开发的，但是因为受版权和加密算法等等的限制，现在很多人都转而使用 OpenSSH 。OpenSSH 是 SSH 的替代软件包，而且是开放源代码和免费的 。—— Wikipedia 关于 SSH 的原理，找到了一系列 阮一峰 的文章，很简洁明了 : SSH SSH 原理与运用（一）：远程登录 SSH 原理与运用（二）：远程操作与端口转发 SSH 的用法 最简单明了的教程就是 man page 了 1 man ssh 内容为 1 2 3 4 5 6 7 8 9 10 NAME ssh — OpenSSH SSH client ( remote login program ) SYNOPSIS ssh [ -1246AaCfgKkMNnqsTtVvXxYy ] [ -b bind_address ] [ -c cipher_spec ] [ -D [ bind_address: ] port ] [ -e escape_char ] [ -F configfile ] [ -I pkcs11 ] [ -i identity_file ] [ -L [ bind_address: ] port:host:hostport ] [ -l login_name ] [ -m mac_spec ] [ -O ctl_cmd ] [ -o option ] [ -p port ] [ -R [ bind_address: ] port:host:hostport ] [ -S ctl_path ] [ -W host:port ] [ -w local_tun [ :remote_tun ]] [ user@ ] hostname [ command ] 进阶的书籍有： SSH, The Secure Shell: The Definitive Guide , O'reilly 目前已经有两台安装了 Ubuntu 的电脑，实验室的一台 name 是 lab ，宿舍的一台 name 是 dom ，两台电脑上都有一个用户名为 chien 。 我们的目的是使两台电脑可以相互之间通过 SSH 访问。 下面就是整个过程： 安装 SSH server SSH 只是一种协议，在 Ubuntu 下，具体实现使用的是 OpenSSH 。Ubuntu 默认是安装了 SSH 客户端 openssh-client ，而没有安装 SSH 服务程序 openssh-server 。 检测本机是否已经安装了 SSH server 1 ssh localhost 如果结果是 1 ssh: connect to host localhost port 22 : Connection refused 说明 SSH server 还没有安装 。 安装方法： 1 sudo apt-get install openssh-server 启动 SSH 服务 启动 SSH server 1 sudo /etc/init.d/ssh start 查询服务是否正确启动 1 ps -e | grep ssh 返回结果应该类似于 1 2 4156 ? 00 :00:00 ssh-agent 4606 ? 00 :00:00 sshd 则说明服务已经正确启动 。 因为两台电脑要相互访问，所以它们的角色即使 server，又是 client，所以需要在两台电脑上都执行上面两步 。 远程访问 首先，查询本机 IP 地址 1 ifconfig 比如 lab 的 IP 地址是 10.105.55.155 , dom 的 IP 地址是 10.210.111.116 。（因为是校园网，所以分配到的都是内网地址） 然后，在宿舍用 dom 访问 lab 这台机器 1 ssh chien@10.105.55.155 实际结果如下图 在执行命令前，提示符显示目前的用户是在 dom 这台机器上的用户 chien，本机 home 目录下有 dom 文件，但是没有 lab 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 lab 机器，远程机器 home 目录下有 lab 文件，但是没有 dom 文件 。 同理，在实验室用 lab 访问 dom 这台机器 1 ssh chien@10.210.111.116 实际结果如下图 在执行命令前，提示符显示目前的用户是在 lab 这台机器上的用户 chien，本机 home 目录下有 lab 文件，但是没有 dom 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 dom 机器，远程机器 home 目录下有有 dom 文件，但是没有 lab 文件 。 省去 IP 地址 每次登录都需要记忆、手动输入 IP 地址，其实只需要改 /etc/hosts 文件，就能省去手动输入 IP 地址的烦恼。 1 vim /etc/hosts 在 dom 的 hosts 文件后面添加 1 lab 10 .105.55.155 在 lab 的 hosts 文件后面添加 1 dom 10 .210.111.116 以后，登录时只需要输入 1 2 3 4 5 // from dom to lab ssh lab // from lab to domm ssh dom 就可以登录了。 公钥登录 上一步解决了 IP 地址的问题，但是还是需要手动输入密码 。我们可以用公钥登录的方法，免去输密码的烦恼。 首先，什么是数字签名 Digital Signature 数字签名是什么？ What is a Digital Signature? 其次，生成数字签名 Ubuntu 默认安装了 ssh-keygen ，可以生成公钥和私钥 1 ssh-keygen 命令执行过程中会询问保存密钥文件的路径，还可以为密钥文件设置口令（passphrase）。运行结束以后，在 $HOME/.ssh/ 目录下，会新生成两个文件： id_rsa.pub 和 id_rsa 。前者是你的公钥，后者是你的私钥。 然后，发布数字签名 使用 ssh-copy-id 命令可以把公钥复制到远程机器中 。 将 dom 的公钥发送到 lab 中 1 ssh-copy-di chien@lab 将 lab 的公钥发送到 dom 中 1 ssh-copy-di chien@dom 最后，使用公钥登录 此时，远程登录时就不再需要输入密码了 1 2 3 4 5 // from dom to lab ssh lab // from lab to dom ssh dom 使用 SCP 传输文件 SSH 提供了一些命令和 shell 用来登录远程服务器 。在默认情况下它不允许你拷贝文件 , 但是还是提供了一个 \"scp\" 命令 。scp 命令是 SSH 中最方便有用的命令了，试想，在两台服务器之间直接传送文件。仅仅用 scp 一个命令就完全解决了 。 man page 1 man scp 内容为 1 2 3 4 5 6 7 NAME scp — secure copy ( remote file copy program ) SYNOPSIS scp [ -12346BCpqrv ] [ -c cipher ] [ -F ssh_config ] [ -i identity_file ] [ -l limit ] [ -o ssh_option ] [ -P port ] [ -S program ] [[ user@ ] host1: ] file1 ... [[ user@ ] host2: ] file2 scp 可以实现把 [[user@]host1:]file1 复制到 [[user@]host2:]file2 的功能。所以 上传 dom 本地文件至服务器 lab 1 scp ~/dom chien@lab:~/ 下载 lab 服务器文件至本地 dom 1 scp chien@lab:lab ~/ 若发送文件夹则添加参数 -r 即可 1 scp -r ~/test chien@lab:~/ 至此，就实现了两台电脑的之间相互远程访问的功能 。 Reference 数字签名是什么？ What is a Digital Signature? SSH 原理与运用（一）：远程登录 SSH 原理与运用（二）：远程操作与端口转发","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_linux_ssh.html","title":"学习 Linux SSH"},{"url":"https://qiangu.cool/posts/ic/writing_synthesizable_code.html","text":"对电路建模方法有很多种，可以用绘制原理图，也可以用 硬件描述语言（Hardware Description Language） 建模 。硬件描述语言中最常用的就是 Verlilog 和 VHDL 。 Verilog HDL 和 VHDL 相比有很多优点，有 C 语言基础的话很容易上手。搜集了一些网上大神的经验总结和书上的例子，所以对于和我一样的初学者，这篇博客应该还是很有提高作用的，至于具体语法，任何一本书都讲的很详细。 HDL 从网上找到一篇文章，把 HDL 的历史说的非常清楚。 作者 董培良 题目： 浅谈 VHDL/Verilog 的可综合性以及对初学者的一些建议 首先要明确的是 VHDL 和 Verilog 并非是针对硬件设计而开发的语言，只不过目前被我们用来设计硬件。HDL 是 Hardware Description Language 的缩写，正式中文名称是 \" 硬件描述语言 \"。也就是说，HDL 并不是 \" 硬件设计语言（Hardware Design Language）\"。别看只差这一个单词，正是这一个单词才决定了绝大部分电路设计必须遵循 RTL 的模式来编写代码，而不能随心所欲得写仅仅符合语法的 HDL 代码。 VHDL 于 1980 年开始在美国国防部的指导下开发，完成于 1983 年，并于 1987 年成为 IEEE 的标准。当初开发这种语言，是出于美国国防部采购电子设备的需要。美军的装备采购自私人企业，时常要面对这样一种风险：如果某种武器大量装备部队，而其中某个零件的供应商却在几年后倒闭了，那这种武器的再生产、维修和保养都会出现大问题。而电子设备、尤其是集成电路的内部结构较为复杂，若出现前面所说的情况要找其他公司生产代用品非常困难。于是美国防部希望供应商能以某种形式留下其产品的信息，以保证一旦其破产后能由其他厂商迅速生产出代用品。 显然，当初的设计文档显然是不能交出来的，这在美国会涉及商业机密和知识产权问题。于是美国防部就想出了一种折衷的方法 —— 描述硬件的语言，也就是 VHDL 。通过 VHDL，供应商要把自己生产的集成电路芯片的行为描述出来：比如说，加了什么样的信号后过多少时间它能输出什么等等。这样，如果有必要让其他厂商生产代用品，他们只需照着 VHDL 文档，设计出行为与其相同的芯片即可。这样的代用品相当于是新厂商在不了解原产品结构的情况下独立设计的，所以不太会涉及知识侵权。 Verilog HDL 也形成于差不多的年代，是由 Gateway Design Automation 公司大约在 1983 年左右开发的。其架构同 VHDL 相似，但主要被用来进行硬件仿真。或许私人公司更注重实用，Verilog 要比 VHDL 简洁得多。 由此可见，这两种最流行的用于电路设计的语言，没有一种是为了设计硬件而开发的（更何况 80 年代还没有现在的那些功能强大的 EDA 软件呢）。因此，当初制订 HDL 语言标准的时候，并没有考虑这些代码如何用硬件来实现。换句话说，有些代码写起来简单，实现起来却可能非常复杂，或者几乎不可能实现。 可综合代码 任何符合 HDL 语法标准的代码都是对硬件行为的一种描述，但不一定是可直接对应成电路的设计信息。行为描述可以基于不同的层次，如系统级，算法级，寄存器传输级 (RTL)、门级等等。以目前大部分 EDA 软件的综合能力来说， 只有 RTL 或更低层次的行为描述才能保证是可综合的 。而众多初学者试图做的，却是想让软件去综合 算法级或者更加抽象的硬件行为描述 。 所有综合工具都支持的语法： always , assign , begin , end , wire , tri , inout , aupply0 , supply1 , input , reg , integer , default , and , nand , or , nor , xor , xnor , buf , not , bufif0 , bufif1 , notif0 , notif1 , if , case , for , function , instantitation , module , negedge , posedge , operators , output , parameter 有些工具支持，有些工具不支持的语法： asex , casez , wand , triand , wor , trior , real , disable , forever , arrays , memories , repreat , task , while 建立可综合模块的原则 不要用 initial （FPGA 上电时初始状态不定，一般需要上电复位信号，在复位信号有效的时候进行初始化，上电复位信号可以由外部手动输入，也可以系统自己产生 —— 写一个实现上电产生自动复位信号的模块）。P.S. 现在的综合软件功能已经足够强大，即使写了 initial 语句，在 ISE 13.3 中仍然是可综合的，而且没有 warning 和 info 的提示） 不使用 #10 （在仿真中有用，实际在硬件上不会实现） 不使用循环次数不定的循环语句，如 forever 、 while 等 不使用用户自定义原语（UDP 原件） 除非是关键路径设计，一般不采用调用门级原件描述的设计的方法，建议采用行为语句完成设计 尽量使用同步方式设计电路 用 always 语句描述组合逻辑时，在敏感信号列表中要列出所有输入信号 所有的内部寄存器都应该可以被复位，在 FPGA 设计时应尽量使用器件的全局复位端信号作为系统的总复位 时序逻辑使用非阻塞赋值，组合逻辑使用阻塞赋值，同一过程块中不要同时使用阻塞和非阻塞两种方式 不要在不同的 always 过程块中对同一变量赋值（否则综合时会提示有多驱动源错误， multiple source ），对同一赋值对象，不能既使用阻塞赋值，又使用非阻塞赋值 如果不打算把变量综合成锁存器，在 if 语句或 case 语句的所有分支中都要对变量明确赋值（不能省去 else 或 default ，原理：在省去的情况下，变量的值会保持原来的值不变，所以系统会综合出一个锁存器 Latch） 避免混合使用上升沿和下降沿触发器 同一变量的赋值不能受多个时钟控制，也不能受两种不同时钟条件（或不同时钟沿）控制 避免在 case 语句中使用 x 或 z 值 不可综合代码 不可综合语法： time , defparam , $finish , fork , join , initial , delays , UDP , wait initial 只能在 Testbench 中使用，不能综合 events 在 Testbench 中更有用，不能综合 不支持 real 类型的综合 不支持 time 类型的综合 force 和 release assign 和 deassign 不支持 reg 类型的综合，支持 wire 类型的综合 fork...join 不可综合，可以用非块语句达到同样的效果 primitives 支持门级原语综合，不支持非门级原语综合 不支持 table 和 UDP 的综合 同一个 reg 被多个 always 块驱动 延时，不可综合为硬件电路延时，综合工具会忽略延时，但是不会报错 与 x 、 z 比较，综合工具会忽略，所以要保证信号只有两个状态， 0 或 1 判断是否可综合 继续引用 董培良 的文章： 用一句简单的话概括：电脑永远没有你聪明 。具体来说，通常 EDA 软件对 HDL 代码的综合能力总是比人差 。对于一段代码，如果你不能想象出一个较直观的硬件实现方法，那 EDA 软件肯定也不行。比如说，加法器、多路选择器是大家都很熟悉的电路，所以类似 A + B - C ( A > B ) ? C: D 这样的运算一定可以综合。而除法、开根、对数等等较复杂的运算，必须通过一定的算法实现，没有直观简单的实现方法，则可以判断那些计算式是不能综合的，必须按它们的算法写出更具体的代码才能实现 。此外，硬件无法支持的行为描述，当然也不能被综合（比如想在 FPGA 上实现 DDR 内存那样的双延触发逻辑，代码很容易写，但却不能实现）。 不过，这样的判断标准非常主观模糊，遇到具体情况还得按设计人员自己的经验来判断 。如果要一个相对客观的标准，一般来说：在 RTL 级的描述中，所有逻辑运算和加减法运算、以及他们的有限次组合，基本上是可综合的，否则就有无法综合的可能性 。当然，这样的标准仍然有缺陷，更况且 EDA 的技术也在不断发展，过去无法综合的代码或许将来行，某些软件不支持的代码换个软件或许行 。比如固定次数的循环，含一个常数参数的乘法运算等等，有些 EDA 软件支持对它们的综合，而有些软件不行。 所以，正确的判断仍然要靠实践来积累经验。当你可以较准确判断代码的可综合性的时候，你对 HDL 的掌握就算完全入门了。 参考 浅谈 VHDL/Verilog 的可综合性以及对初学者的一些建议","tags":"IC","loc":"https://qiangu.cool/posts/ic/writing_synthesizable_code.html","title":"编写可综合的 Verilog HDL 代码"},{"url":"https://qiangu.cool/posts/ic/learning_fpga_getting_started.html","text":"FPGA 是什么 FPGA 是 PLD 家族中的一员，要说清楚什么是 FPGA，就不得不说一说 PLD 。（ 以下内容来自 wikipedia ） PLD & ASIC 早期的数字逻辑系统，是由中、小规模集成电路芯片搭建而成的。这种形式的电路在可靠性、工作速度、功耗和体积方面都难以满足大规模、高性能信息处理系统的要求 。后来，随着集成电路的发展，出现可专用集成电路 。 专用集成电路 （Application Specific Integrated Circuits, ASIC ）是指依产品需求不同而非通用目的，而自定义的特殊规格集成电路 。ASIC 可以将整个系统集成到一个芯片上。由于芯片内集成度高、连线短，所以它可以满足之前 \" 搭建系统 \" 难以满足的性能指标 。 随着芯片尺寸的减小和设计工具的发展，这些年来 ASIC 芯片最大的集成度从 5,000 增长到了 超过 100,000,000 门 。现代的 ASIC 通常都包含了微处理器、存储块（如 ROM 、RAM 、EEPROM 、Flash 等）。这种 ASIC 被称为 SoC （ system on chip ），ASIC 设计师采用硬件描述语言（Hardware Description Language，HDL），比如 Verilog、VHDL，描述 ASIC 的功能 。 但是 ASIC 的研制周期长，现代信息处理的快速发展要求集成电路的设计、测试和生产周期尽可能的段，这就促进了可编程逻辑器件的发展 。严格地说，有些可编程器件出现的时间比 ASIC 出现的早，这里说的可编程器件主要是指 CPLD/FPGA 。 可编程逻辑器件 （Programmable Logic Device, PLD ）是一种用来搭建可重配置数字电路的电子器件。和逻辑门（logic gate）不同，PLD 出厂时逻辑功能是没有被定义的，在使用之前，必须先重配置（reconfigure）。 历史 ROM as PLD 在 PLD 器件被发明之前，就已经有人 将 ROM 以 PLD 的概念来运用 ，用 ROM 芯片来充当一些输入性的组合逻辑（combinatorial logic）的函数发生器。ROM 有 m 个地址线，则有 n = 2&#94;m 个输出结果，这和布尔逻辑是一一对应的，所以如果把 ROM 的地址线当作相互之间没有关系的输入，则相应的输出就可以实现不同的函数。 早期的 Mask ROM 存储数据的方式是使用内部的硬件电路，所以只能在出厂时就写入数据，而且以后不能更改。这就导致了一系列缺点： 因为消费者必须联系制造商才能生产出自定义的芯片，所以只有买大量的 ROM 芯片时才经济划算 。 因为同样的原因，从设计到最终生产出产品，中间耗费的时间很长 。 Mask ROM 在研发中基本上不能使用，因为设计师在改进设计时需要经常改动 ROM 里面的值 。 如果一个设备中含有故障的 Mask ROM，那么修复这个设备的唯一方法就是召回设备并且更换其中的每一个 Mask ROM 。 PROM PROM （Programmable Read Only Memory）是周文俊于 1956 年发明的。他在纽约 Garden City 的 American Bosch Arma Corporation 工作，当时，美国空军为了提升空军用计算机以及 Atlas E/F 波段导弹的灵活性和保安性而提出要求，这项技术就是为了满足这一要求而产生的 。 PROM 是通过熔丝 / 反熔丝（fuse/antifuse）实现对每个 bit 的设置 。通过使用高电压脉冲改变内部的物理结构，这种方法通常是不可逆的，所以它只允许用户更改一次配置 。PROM 解决了上面提到的问题 1 和问题 2 ，因为公司可以买一大批没有配置过的 PROM，设计人员可以根据自己的需要随意配置 。 EPROM EPROM （Erasable Programmable Read Only Memory）是 intel 公司的 Dov Frohman 于 1971 年发明的 。与 PROM 不同的是，EPROM 可利用高电压将资料编程写入，通过紫外线照射的方式不断的重置为未配置状态。因此，在封装外壳上会预留一个石英玻璃所制的透明窗以便进行紫外线曝光。写入程序后通常会用贴纸遮盖透明窗，以防日久不慎曝光过量影响资料。 因为 EPROM 可以重复配置，所以它解决了上面的第 3 个问题 。 EEPROM EEPROM （Electrically Erasable Programmable Read-Only Memory）于 1983 年被发明出来。相比 EPROM，EEPROM 不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据 。 如果设备可以从外部接收数据（比如 PC 通过串口线），就可以在线配置 EEPROM，这样它解决了问题 4 。 虽然解决了上面的 4 个问题，但是把 ROM 当作 PLD 器件使用，还是有很多弊端： 与专用逻辑电路相比，ROM 的速度很慢 当输入不同步时（异步状态），ROM 的输出有毛刺 更加耗电 与可编程逻辑相比，价格更贵，尤其是高速应用中 而且，大部分 ROM 没有输出寄存器，所以它不能直接应用在时序电路中，所以在状态机的设计中，通常还需要一个外部的 TTL 寄存器 。对电路设计的业余爱好者来说，有时也仍然用 \"2716\" 之类的普遍型 EPROM 芯片来充当 PLD，这种用法有时也称为 \" 穷人的 PAL\"。（PAL 也是 PLD 的一种，以下将再进一步说明） 于是，就出现了 PLD 器件。 早期可编程逻辑 1969 年，Motorola 生产出 XC157，它是一个有 12 个逻辑门和 30 个独立输入 / 输出管脚的可编程逻辑正列。 1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（PLA）。 1971 年，通用电器公司（GE）在新的 PROM 技术的基础上发明了一种可编程逻辑器件。这个实验性质的设备通过使用多层逻辑来提高 IBM 的 ROAM 性能 。GE 的这个设备是最早的 PLD 设备，比 Altera 的 EPLD 早了十几年 。 1974 年，GE 和 Monolithic Memories 达成协议，开发一种可编程逻辑器件。这个设备被称为 \"Programmable Associative Logic Array\" 或者是 PALA 。最终于 1976 年完成 MMI 5760 ，它可以实现超过 100 门的时序电路。GE 的开发环境支持这一器件，它可以直接将布尔表达式转化为配置器件的代码，然而最终这个器件却没有上市。 PLA 1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（ PLA ）。 PLA 具有一组可编程的 AND 阵列，AND 阵列之后连接一组可编程的 OR 阵列 ，这样就可以只在合乎设定条件时才允许产生逻辑信号输出 。 虽然名字中含有可编程 3 个字，但是并不是所有的 PLA 都可以现场编程，事实上许多都属遮罩性的可编程化，性质与 ROM 相同，必须在芯片制造厂内就执行与完成程序化设定，尤其是内嵌于电路较复杂的芯片（例如：微处理器）的 PLA 多属此种程序化方式。 PAL PAL （Programmable Array Logic）是 Monolithic Memories 公司在 1978 年 3 月提出的，在数字电路中用来搭建逻辑功能的可编程器件的总称 。PAL 内部含有固定的或门阵列，可编程的与门阵列，从而实现所要求的逻辑函数。 PAL 内部有个 PROM 的核，外部附加的输出逻辑电路，这样就可以实现所需要的逻辑功能 。因为 PAL 是基于 PROM 的，所以要使用特殊的设备，PAL 才具有可编程性，而且是 \" 一次编程 \" 。 GAL GAL （Generic array logic）是 PAL 的发展，是 Lattice Semiconductor 于 1985 年发明 。这个设备具有和 PAL 同样的功能，但是可以重配置多次，所以 GAL 在设计中很有用，一旦有错误，只需要擦除后重新配置即可 。 后来，International CMOS Technology (ICT) 公司发明了 类似的设备，称为 PEEL（programmable electrically erasable logic）。 CPLD CPLD （Complex programmable logic device）适合用来实现各种运算和组合逻辑（combinational logic）。PAL、GAL 仅适合用在约数百个逻辑门所构成的小型电路，若要实现更大的电路则适合用 CPLD，一颗 CPLD 内等于包含了数颗的 PAL，各 PAL（逻辑区块）间的互接连线也可以进行程序性的规划、烧录，CPLD 运用这种多合一（All-In-One）的整合作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。 CPLD 与 PAL 的共同点： 非易失性配置存储器。与 FPGA 不同，CPLD v 不需要外部的 ROM，只要系统上电，就可以正常工作。 对于许多旧的 CPLD 来说，布线约束要求大部分逻辑块要和输入输出相连接，以减少内部状态记录，对于新的 CPLD 系列来说，已经不需要这样了。 CPLD 与 FPGA 的共同点： 可以利用大量的逻辑资源，CPLD 等价有有数百万的逻辑门资源可以用来实现比较复杂的设计，而 PAL 最多等价有几千个逻辑门，FPGA 有几万到几百万的逻辑门。 提供一些更加灵活的资源，比如宏模块之间复杂的反馈连接和整数运算。 大的 CPLD 和小 FPGA 之间最显著的差别就是 CPLD 含有片内非易失性存储器 。因为非易失性存储器的特点，CPLD 在数字电路设计中被当作 \"boot loader\" 来使用，之后它再把系统的控制权转交给没有这种特性的设备，最好的例子就是使一块 CPLD 从非易失性存储器中装载配置 FPGA 所需要的数据 。 FPGA FPGA （Field Programmable Gate Array，FPGA）是在 PAL、GAL、CPLD 等可编程逻辑器件的基础上进一步发展的产物。它是作为专用集成电路领域中的一种半定制电路而出现的，既解决了全定制电路的不足，又克服了原有可编程逻辑器件门电路数有限的缺点。 当 PAL 忙于进展成 GAL、CPLD 时，另一种 \" 可编程化 \" 的流派也逐渐成形，此称之为现场可编程闸阵列（Field Programmable Gate Array，FPGA）。FPGA 是以阵列（Gate Array）技术为基础所发展成的一种 PLD 。所谓 \"Field Programmable\" 就是说芯片是出厂以后由客户或者设计师配置而工作的 。 1980 年代后期，Naval Surface Warfare Department 在 Steve Casselman 的提议下成立了实验项目，目的是为了研制一台由 600,000 个逻辑门组成的计算机。Casselman 最后成功了并且在 1992 年获得了专利 。 Xilinx 公司的共同创世人 Ross Freeman 和 Bernard Vonderschmitt 在 1985 年发明出第一款商业 FPGA —— XC2064 。XC2064 芯片有可以编程的逻辑门和可以编程的内部连接线，这开辟了一项新的技术和市场 。XC2064 有 64 个可配置逻辑块（configurable logic blocks，CLBs），和 3 输入查找表（lookup tables，LUTs）。 从 1985 开始到 90 年代中期，Xilinx 一直处于高速发展阶段，之后竞争对手出现了，截至 1993 年，Actel 占据了 18% 的市场 。 90 年代是 FPGA 爆炸式发展的年代，这一期间出现了大量高端技术和产品。在 90 年代初期，FPGA 主要应用于通信领域，在 90 年代后期，FPGA 已经广泛应用于消费品、汽车和工业应用 。 为什么选择 FPGA FPGA vs ASIC ASIC 的优点： ASIC 在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低 。 ASIC 的缺点： 设计周期最长，设计成本贵，设计费用最高，适合于批量很大或者对产品成本不计较的场合。 至于 FPGA 的优点和缺点完全就是 ASIC 的取反 。FPGA 一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA 具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用 FPGA 进行除错的成本较低 。在一些技术更新比较快的行业，FPGA 几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时 FPGA 方便灵活的优势就显得很重要。这也是 FPGA 能够发展起来的原因，市场是不会允许一个毫无优势的技术发展到今天这种地步的 。 个人认为两者不是对立的，由于各自的特点，它们有各自适用的环境，不能一棒子打死，否定其中一个 。事实上更多的情况是：设计的开发是在普通的 FPGA 上完成的，然后将设计转移到一个类似于专用集成电路的芯片上 。 FPGA vs CPLD 为了达到上述目的，还有一种方法是使用 CPLD 。 CPLD 和 FPGA 都包括了一些相对大数量的可以编辑逻辑单元。CPLD 逻辑门的密度在几千到几万个逻辑单元之间，而 FPGA 通常是在几万到几百万。 FPGA 与 CLPD 最大的区别就是：FPGA 是基于查找表（look up table，LUT），而 CPLD 是基于海门架构（sea-of-gates），也就是它们的系统结构 。CPLD 的结构具有一定的局限性 。这个结构由一个或者多个可编辑的结果之和的逻辑组列和一些相对少量的锁定的寄存器组成 。这样的结果是缺乏编辑灵活性，但是它的优点是，其延迟时间易于预计，逻辑单元对连接单元比率较高 。而 FPGA 具有的连接单元数量很大，这样虽然让它可以更加灵活的编辑，但是结构却复杂的多 。 CPLD 和 FPGA 另外一个区别是大多数的 FPGA 含有高层次的内置模块（比如加法器和乘法器）和内置的存储器 。一个由此带来的重要区别是，很多新的 FPGA 支持完全的或者部分的系统内重新配置 。允许他们的设计随着系统升级或者动态重新配置而改变 。一些 FPGA 可以让设备的一部分重新编辑，而其他部分继续正常运行 。 CPLD 与 FPGA 之间结构、原理上的差别导致两者应用上的差别 。考虑成本、性能要求等因素，应该根据实际情况选择 。 Xilinx & Altera FPGA 的制造商主要是 Xilinx 和 Altera 两家，他们合起来市场占有率达到了 80% 之多 。两家是 FPGA 技术的领导者也是长期竞争对手 。 Xilinx 于 1984 年创建于美国加利福尼亚州的硅谷，总部位于硅谷核心的圣何塞。它是一家主要提供 FPGA 的科技公司 。并且就是它的创始人是发明了 FPGA 。 Altera 是一家位于美国硅谷的可编程逻辑器件和 CPLD 的制造商 。该公司于 1984 年推出了其首款可编程逻辑设备。 两家一直是互为竞争对手，一般来说，大学里面都 Altera 的器件和 VHDL 上课，所以在学校里面用 Xilinx 的人比较少 。 因为原理是一样的，所以只要学会一种，另一种就很容易上手。学校实验室里面用的是 Xilinx 。 Xilinx FPGA Architecture（架构） FPGA 需要反复烧写，所以不能像 ASIC 一样通过固定的与非门来完成，只能采用一种易于反复配置的结构，查找表就可以很好的满足这一要求。目前主流 FPGA 都是采用了基于 SRAM 工艺的查找表结构（军品和宇航级 FPGA 采用 Flash 或者熔丝 / 反熔丝工艺），通过烧写文件改变查找表内容的方法来实现对 FPGA 的重复配置。 查找表（look-up table，LUT）本质上就是一个 RAM 。当用户通过原理图或 HDL 语言描述了一个电路以后，FPGA 开发软件会计算逻辑电路的所有可能结果，并把真值表事先写入 RAM，这样，每输入一个信号进行逻辑运算就相当于输入一个地址进行查找，这样 LUT 就具有了和逻辑电路相同的功能 。实际上，LUT 具有更快的执行速度和更大的规模 。 上电时，FPGA 将外部存储器中的数据读入片内 RAM，完成配置后，进入工作状态；掉电后 FPGA 恢复为白片，内部逻辑消失。这样 FPGA 不仅能够反复使用，还无须专门的 FPGA 编程器，只需通用的 EPROM、PROM 编程器即可。 目前，Xilinx FPGA 仍然是基于查找表技术，但是其概念已经远远超出查找表技术的限制，并且整合了常用功能的硬核模块（如块 RAM，时钟管理和 DSP）。Xilinx FPGA 内部大致可以分为 6 部分： IOB 可编程输入 / 输出单元简称 I/O 单元，是芯片与外界电路的接口部分，完成不同电气特性下输入 / 输出信号的驱动和匹配 。 CLB CLB（Configurable Logic Block）是 FPGA 内的基本逻辑单元，Xilinx FPGA 的 CLB 由多个相同的 Slice 和附加逻辑组成 。 DCM 业内大多数 FPGA 都提供数字时钟管理（Digital Clock Manager）。Xilinx FPGA 提供 DCM 和 PLL 。 BRAM 大多数 FPGA 都具有内嵌的块 RAM，这大大扩展了 FPGA 的应用范围和灵活度 。块 RAM 可以被配置为单口 RAM、双端口 RAM、内容地址存储器（CAM）和 FIFO 等常用存储结构 。 Routing Resource 布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度 。Xilinx FPGA 的布线资源可以分为 4 类：全局布线资源、长线资源、短线资源、分布式资源 。 Embedded Module 内嵌功能模块只要是指 DLL、PLL、DSP 和 CPU 等 软核 ，还有底层的 硬核 资源，比如内嵌的 Power PC、ARM9、DSP 芯片等 。 Xilinx 主流 FPGA Xilinx 主流的 FPGA 主要有 A 系列、K 系列、V 系列、Spartan 系列，如今还有最新的 Zynq 系列，官网上有详细介绍 。 开发流程 FPGA 的开发流程如下图所示： 整个开发过程就是使用开发工具 ISE Design Suite，按照流程图进行 。图示是标准流程，但是实际上并不是严格按照每一个步骤进行 。 一般简化过的流程是 设计可综合的代码 综合 Systhesis 前两步主要是确保写的代码是开发工具可以转化为实际电路。 综合后仿真 这一步保证模块的逻辑功能是正确的，即检验模块的结果是否和预期一致 时序约束 为设计添加时序约束和管脚约束 实现 Implement 按照约束条件将综合结果映射到实际器件中 时序分析 实际上，一次就能达到时序要求且布线成功的情况并不多，尤其是对于高速设计，所以需要根据上一步的时序结果对设计进行修改，以满足时序要求，类似于写软件的 Debug 。 下载，在线调试 将设计下载到芯片中调试。 参考 PLD wikipedia FPGA wikipedia","tags":"IC","loc":"https://qiangu.cool/posts/ic/learning_fpga_getting_started.html","title":"学习 FPGA 入门"},{"url":"https://qiangu.cool/posts/cs/built_in_types.html","text":"类型是程序设计的基础。一些程序设计语言，比如 Smalltalk 和 Python，在运行的时候才检查预计中的对象的类型，想反，C++ 是静态类型（statically typed）语言，在编译时执行类型检查。导致的结果是： 变量和函数在使用前必须先声明 。 每种类型都定义了其存储空间要求和可以在该类型的所有对象上执行的操作。C++ 是 在 C 的基础上扩充得到的，为了和 C 兼容， C++ 在必要时必须能够直接处理硬件，所以 C++ 提供的一组基本内置类型，如 int、char 等，这些类型与它们在机器硬件上的标示方式紧密相关。（所以，C++ 可以称为 \" 具有高级语言库的低级语言 \"） 本文只限于总结 C++ 的内置类型（Built-in Types），不讨论自定义类型 。 基本内置类型 算术类型 C++ 语言自身定义了一组基本类型来表示不同的数据，如整数、浮点数、字母、bool 类型等，这些类型统称为 算术类型（Arithmetic type） 。 size 算术类型的存储空间依机器而定，即用多少二进制位 bit 来表示一个数 。C++ 标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间 。事实上，对于 int 类型，几乎所有的编译器使用的存储空间都比所要求的大 。 使用 sizeof() 操作符可以查询对象或类型的大小（以字节为单位），包含头文件 1 #include <limits> 就可以使用 STL 库中的 numeric_limits<T>::max 和 numeric_limits<T>::min 查询各个内置内类类型的最大值和最小值。 下面是 Ubuntu amd64 版本上的结果： 算术类型可以分为两类：表示整数的 整型 和表示浮点数的 浮点型 。 Integral Types 表示整数、字符、布尔值的算术类型合称为 整型（integral types）。 整数的基本表示类型是 int 。int 类型前面可以加两类修饰说明，表示数据位数长短的 short 和 long ；表示有无符号的 signed 和 unsigned 。组合出来的结果就有 4 种： 1 2 3 4 signed short int unsigned short int signed long int unsigned long int 每一种的数据长短和可以表示的范围都不相同。 字符类型有两种： char 和 wchar_t 。char 用来表示 基本字符集 中的字符，wchar_t 用于 扩展字符集 ，比如汉字和日语 。修饰 int 类型有无符号的 signed 和 unsigned 也可以修饰 char 类型 。 C++ Primer (chapter 2) 中写到： Unlike the other integral types, there are three distinct types for char: plain char, signed char, and unsigned char. Although there are three distinct types, there are only two ways a char can be represented. The char type is respresented using either the signed char or unsigned char version. Which representation is used for char varies by compiler. 为什么会有这么奇怪的事呢？上网搜索了一下，按照自己的理解总结了一下： signed/unsigned 可以描述的类型有 int 和 char 两种，在 C 的标准里面规定：对于 int 类型，如果没有在类型前显式地声明，默认 int 是 signed 类型，而对于 char 类型，则是 Implementation Defined 。也就是说由编译器在编译的时候决定具体使用哪一种 。而为什么要作出这么奇怪的规定呢？是因为 char 类型本来就是用来表示字符而非数字的， ASCII 码字只使用 7 bit，所以使用 signed/unsigned 对其没有影响，但是如果使用 char 类型来表示一个 8 bit 的数字（有时候空间不够用时不得不这样做，比如嵌入式系统中），为了可移植性，必须写明 signed/unsigned 。所以，如果用来表示字符，则直接使用 char 就行，如果用来表示整数，则声明是 signed/unsigned 。 Linux C 编程一站式学习：整型 中进一步解释： 编译器可以定义 char 型是无符号的，也可以定义 char 型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种，x86 平台的 gcc 定义 char 型是有符号的。这也是 C 标准的 Rationale 之一： 优先考虑效率，而可移植性尚在其次。 这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用。另一方面，写不可移植的代码有时候也是必要的，比如 Linux 内核代码使用了很多只有 gcc 支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写。如果不是为了效率，一般来说就没有理由故意编写不可移植的代码。 网上有 博客 说： VC 编译器、x86 上的 GCC 都把 char 定义为 signed char，而 arm-linux-gcc 却把 char 定义为 unsigned char 。 于是，编写一个测试小程序就可以知道我们使用的编译器是如何处理的。 源代码： 1 2 char ch1 = - 1 ; printf ( \"ch1 = %d \\n \" , ch1 ); 运行结果： 结果说明，gcc 把 char 默认为 signed char 处理。 布尔类型表示 true 和 false 。可以将任何算术类型的值赋给 bool 对象， 0 表示 false ，任何非 0 值都表示 true 。 Floating-Point Types 类型 float 表示 单精度浮点数 类型 double 表示 双精度浮点数 类型 long double 表示 扩展精度浮点数 从前面的运行结果可以看出在我的电脑上 float 使用 1 个字（32 bit） 表示，double 使用 2 个字（64 bit） 表示，long double 使用 4 个字（128 bit） 表示 。 C++ Primer (chapter 2)： The float type is usually not precise enough for real programsfloat is guaranteed to offer only 6 significant digits. The double type guarantees at least 10 significant digits, which is sufficient for most calculations. Determining which floating-point type to use is easier: It is almost always right to use double. The loss of precision implicit in float is significant, whereas the cost of double precision calculations versus single precision is negligible. In fact, on some machines, double precision is faster than single. The precision offered by long double usually is unnecessary and often entails considerable extra run-time cost. void void 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。 初始化 Initialize 初始化 & 赋值 首先是初始化的必要性： 在 C++ 中，初始化是一个非常重要的概念，给变量一个初始值几乎总是正确的，但不要求必须这么做。定义变量时，应该给变量赋初始值，除非确定将变量用于其他意图之前会覆盖这个初值。如果不能保证读取变量前重置变量，就应该初始化变量。变量没有初始化是很常见的导致程序崩溃 / 结果错误的原因，而且有时候很难像 Debug 一样找到这个错误（bug 导致程序一定不对，但是没有初始化的变量的结果是随机的）。所以，良好的习惯是对每个变量都进行初始化 。 其次是初始化和赋值的区别： 初始化 Initialization ：创建变量并且给它赋初始值 赋值 Assigment ：擦除变量的当前值并用新值代替 C++ 提供两种初始化变量的方法：复制初始化（ copy-initialization ）和直接初始化（ direct-initialization ）。复制初始化使用 = ，直接初始化使用 () 。 1 2 int ival = 1024 ; // copy-initialization int ival ( 1024 ); // direct-initialization 使用 = 很容易让人把初始化和赋值混淆在一起，但是在 C++ 中这是两种不同的操作，当涉及到类对象时，两种不同的初始化方式的区别是很微妙的。目前先不考虑这点，只需要知道直接初始化语法更灵活而且效率高。 内置类型初始化 当我们定义一个变量却没有初始化时，系统 有可能 会为我们进行隐式的初始化。至于系统是否帮我们隐式初始化变量，以及为变量赋予一个怎样的初始值，这要取决于 该变量的类型 以及我们 在何处定义的该变量 。 这里我们只考虑内置类型的初始化： 内置类型的变量是否自动初始化取决于变量定义的位置。在函数体外（全局范围）定义的变量都初始化为 0，函数体内定义的变量不进行自动初始化 。 算术类型转换 隐式类型转换 当两个操作数类型不同时，C++ 并不是直接把两个数加在一起，而是提供了一组转换规则，以便在执行算术操作之前，将两个数转换为同一数据类型。这些转换规则由编译器自动执行，不需要程序眼介入，有时甚至不需要程序员了解。因此，它们被称为 隐式类型转换 ( implicit type conversion ) 。 在以下情况会发生隐式类型转换： 混合类型表达式，操作数被转换为相同类型 1 2 3 int ival ; double dval ; ival >= dval ; // ival converted to double 用作条件表达式被转化为 bool 型 1 2 3 int ival ; if ( ival ) // ival converted to bool while ( cin ) // cin converted to bool 用表达式初始化（赋值）某一变量，表达式被转化为该变量类型 1 2 3 int ival = 3.14 ; // 3.14 converted to int int * ip ; ip = 0 ; // the int 0 converted to a null pointer of type int * 另外，函数调用时也可能发生隐式类型转化。 算术类型转换 C++ 语言为内置类型提供了一组转化规则，其中最常用的就是算术转化（arithmetic conversion）。算术转化规则定义了一个 类型转换层次 ，该层次规定了操作数应该按照什么次序转换为表达式中最宽的数据类型。 有两条通用规则： 为了保留精度，如果有必要，数据总是被提升为较宽的类型 所有含有小于整形的有序类型的算术表达式在计算之前其类型都会被转换成整型（整型提升 integral promotion） 关于有符号数和无符号数，原则是： 不同级数据转换，若较宽的类型可以表示所有较窄的类型的数，则直接将较窄的类型提升为较宽的类型，否则，把两个数都转换为无符号的较宽的类型 。 同级数据转换，unsigned int 和 int ，signed 类型会转换为 unsigned 类型 。 unsigned 操作数的转换依赖于机器中整型的相对大小，所以，这类转换依赖于机器。 举个栗子： short 类型 与 int 类型 。在我的机器上，short 类型所占用的宽度为半字（2 Byte），int 类型占用的宽度为 1 个字（4 Byte）。所有的 unsigned short 的值都包含在 int 之中，所以，unsigned short 转换为 int 。 下面程序 1 2 3 4 unsigned a = 4 ; signed b = - 20 ; int c = ( a + b > 4 ) ? 1 : 0 ; cout << \"unsigned int b' = \" << unsigned ( b ) << endl ; 运行结果为 1 2 unsigned int b ' = 4294967276 c = 1 因为 b = -2 被转化为一个很大的正数 b' = 4294967276 references c++ Primer C++ 之 char , signed char , unsigned char，以及 Integral Promotion Linux C 编程一站式学习：整型","tags":"CS","loc":"https://qiangu.cool/posts/cs/built_in_types.html","title":"C/C++ 内置数据类型"},{"url":"https://qiangu.cool/posts/tools/install_ise_modelsim_on_ubuntu.html","text":"从 Windows 平台转移到 Linux，于是把 FPGA 的开发平台也搬过来。 软件版本： Ubuntu 13.10 Desktop amd64 ISE 14.7 for Linux ModelSim 6.5b for Linux 下载 ISE Design Suit for Linux Xilinx 官方网站上有 下载链接 ，但是在校园网内下载速度实在是蛋疼，还好有校内 bt 资源。 我下载下来的 ISE 版本为 14.7 ，tar 包大小为 6.5 G 。 ModelSim for Linux 网上的教程（2011 年前）都说是 ModelSim 官方网站 上提供 ftp 下载链接，但是好像现在官网上不再提供下载链接了，我只找到 ModelSim PE Student Edition，而且还是 Windows 平台的 ... 花费了一下午的时间，不停地在各个论坛注册下载附件，终于把 ModelSim_6.5b for Linux 下载下来了 , 结果安装时提示找不到 libxp.so.6 库，于是 apt-get 到一些 libxp 的库，安装后仍然提示找不到，无奈放弃了，准备老老实实用 ism 了（以后有时间了再慢慢折腾 T_T） 安装 ISE DS 14.7 首先解压 1 tar -xvf Xilinx_ISE_DS_Lin_14.7_1015_1.tar 接着进入解压出来的目录并给安装文件赋予执行的权限 1 2 cd Xilinx_ISE_DS_Lin_14.7_1015_1/ sudo chmod +x xsetup 然后执行 xsetup 1 sudo ./xsetup 然后熟悉的图形界面就出来，和 Windows 下一样，同意安装许可协议，不停地下一步就可以安装成功。 安装完成以后，运行 1 2 cd /opt/Xilinx/14.7/ISE_DS source settings64.sh 此时，已经可以从终端运行 ISE 了 1 nohup ise & 熟悉的图形界面出来了： P.S. 选择安装版本时，选择 System Edition ，因为这个版本功能最全 选择安装组件时，不要勾选 Install Cable Drivers ，我们自己编译安装另外一个驱动（因为此驱动只能在 Linux 内核 < 2.6 的版本中使用，所以即使勾选了最后安装完成时会提示 Driver installation failed ） Crack 又到了该和谐的地方了 =.= 第一次打开 ISE 时，会自动弹出 License Management Tools 提示我们添加 License 。网上有一大堆破解包，我使用以前在 Windows 中生成的 Lincese，直接就可以使用了～ 再次声明：仅供技术交流，请支持正版软件 installing Cable Drivers 正如前面所说，因为 ISE 自带的驱动程序依赖于一个叫 windrvr 的文件。 而该文件目前只有 Linux 内核 2.4 的二进制版本，因此遇到高于 2.4 内核的 Linux 发布版，如我使用的 Ubuntu 13.10（Linux version 3.11.0-12-generic ） 就不工作了。 好在一个叫 Michael Gernoth 的德国人，大公无私地写了一个 windrvr 的替代版本，并且开放源码，这样，无论碰到什么版本的内核，现场编译一个驱动并安装， 就能解决 Linux 内核版本匹配的问题。 XILINX JTAG tools on Linux without proprietary kernel modules 所以按照说明 首先安装 usb 驱动开发包，在 64 位系统下 1 sudo apt-get install libusb-dev libc6-dev-i386 fxload 接着下载驱动程序的源代码 1 2 cd /opt/Xilinx sudo git clone git://git.zerfleddert.de/usb-driver 然后编译驱动程序 1 2 cd usb-driver/ sudo make 下载下来的源代码中有个脚本可以设置好一切，我们只需要运行脚本就 ok 1 ./setup_pcusb /opt/Xilinx/14.7/ISE_DS/ISE/ 把 Xilinx 路径添加到系统 PATH 中 1 2 echo \"PATH=\\$PATH:/opt/Xilinx/13.2/ISE_DS/ISE/bin/lin64/\" >> ~/.bashrc echo \"export PATH\" >> ~/.bashrc 这时候，写个小测试的程序， Systhesize -> Implement -> Generate Programming File ，打开 iMPACT , 如图所示，可以看到已经识别出 JTAG 链上的芯片 ModelSim 待续 ... 配置 ISE & ModelSim ISE 其实也没有特殊配置的地方，主要是自定义代码编辑器，目前我的主要使用的是 sublime text 2 ，正在向 vim 过度 ing 具体步骤 Edit -> Preferences -> Editors，选择 custom ，在右侧的 \"Command line syntax\" 中写自定义编辑器的执行路径 配置自定义编辑器为 vim 1 gnome-terminal --maximize -x vim $1 ModelSim ModelSim 编译 Xilinx 库，ISE 关联 ModelSim 待续 ... 参考 XILINX JTAG tools on Linux without proprietary kernel modules Xilinx JTAG Linux 【Linux 软件安装】Ubuntu12.04: Xilinx ISE 14.6","tags":"Tools","loc":"https://qiangu.cool/posts/tools/install_ise_modelsim_on_ubuntu.html","title":"Ubuntu 下安装 ISE & Modelsim"},{"url":"https://qiangu.cool/posts/tools/learning_vim_survival.html","text":"这个系列的博客是我学习 Vim 过程中的记录和总结，内容基本上来自网络上前辈们的博客，还有部分内容是我自己学习的心得。真心感谢前辈们的分享，我会尽量在后面的文章中标明内容出处，比如我学习 Vim 的路线就是按照这个博客 vi/vim 使用进阶 : 目录 来学习的。希望我的学习历程可以帮助到和我一样的菜鸟，能更好地使用这款神器～ 第一篇：入门 / 存活 Survival Vim 是什么 简单的说， Vim 就是广大的编辑器中的一员，但是对程序猿来说，她并不是一款简单的编辑器。她强大的编辑能力、苗条的身材（软件体积小、启动速度快）和 Linux 系统的血缘关系（几乎是 Linux 系统的标配），使其在全世界有成千上万的粉丝，以至于掌握 Vim 成为每个码农必备技能。 Wikipedia 上 Vim 的介绍： Vim (an acronym for Vi IMproved) is a text editor written by Bram Moolenaar and first released publicly in 1991. Based on the vi editor common to Unix-like systems, Vim is designed for use both from a command line interface and as a standalone application in a graphical user interface. Vim is free and open source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The license is compatible with the GNU General Public License. 历史 摘抄（翻译）自 Wikipedia 关于 vi/Vim 的发展，还是从头说起： ed 是 UNIX 界最古老最基本的编辑器，它由 Ken Thompson (UNIX 之父 ) 于 1971 年在 PDP-11 /20 上用汇编写成 。ed 的许多特性来自于 Thompson 在加州伯克利大学上学时受到的 qed 编辑器的影响 。Thompson 对 qed 非常熟悉，他在 CTSS 和 Multics 操作系统上重新实现了一边 qed ，并且在他的版本中，第一次实现了正则表达式（ regular expressions ）。虽然正则表达式也是 ed 的一部分，但是一般认为在 qed 中正则表达式的实现更多一些 。 ed 是为电传机（ teletype ）而不是终端显示器（ display terminals ）设计的行编辑器，它是一个行编辑器。在它的起源地 —— AT&T 实验室，人们似乎很满意把 ed 设置为默认的编辑器，即使它的功能很基本而且很不友好。 George Coulouris 回忆说： [...] for many years, they had no suitable terminals. They carried on with TTYs and other printing terminals for a long time, and when they did buy screens for everyone, they got Tektronix 4014s. These were large storage tube displays. You can't run a screen editor on a storage-tube display as the picture can't be updated. Thus it had to fall to someone else to pioneer screen editing for Unix, and that was us initially, and we continued to do so for many years. Coulouris 认为 ed 的隐藏的命令只适合于 \" 神人 \"（immortals），所以在 Queen Mary College 当讲师的期间，他在 Thompson 的代码的基础上加强了 ed，并且命名为 em （the \"editor for mortals\"）。 em 是为终端显示器设计（display terminals）的，一次只显示一行的可视化编辑器，它是 UNIX 中第一个大量使用 \"raw terminal input mode\" 的程序，这种模式下，由应用程序而不是终端的驱动处理键盘的输入。1976 年夏天，Coulouris 参观 UC Berkeley 时，他带着一卷录有 em 的 DEC 磁带，他给很多人演示了 em ，有的人认为 em 只是有潜力，但是有的人却对此留下了深刻影响，其中就包括 Bill Joy 。 受到 em 的鼓舞，加上他们自己使用 ed 时的技巧，Bill Joy 和 Chuck Haley 这两个刚从 UC Berkeley 的毕业的研究生使用 em 的代码，设计了一个叫 en 的编辑器，然后把 en 扩展为 ex v0.1 。 ex 仍然只显示一行而非一屏的内容。后来，Chuck Haley 退出了开发，Bruce Englar 鼓励 Bill Joy 重新设计了 ex，在 1977 年 6 月到 10 月期间，他为 ex 添加了全屏可视化模式 ，ex 的 visual mode 也就是 vi 的命名原因 。 vi Wikipedia : vi /ˈviːˈaɪ/ is a screen-oriented text editor originally created for the Unix operating system. The portable subset of the behavior of vi and programs based on it, and the ex editor language supported within these programs, is described by (and thus standardized by) the Single Unix Specification and POSIX. 据 Bill Joy 讲，很多 vi 的可视化灵感来自于另外一个叫做 Bravo 的编辑器，在一次关于 vi 的起源的访谈中，他说： A lot of the ideas for the screen editing mode were stolen from a Bravo manual I surreptitiously looked at and copied. Dot is really the double-escape from Bravo, the redo command. Most of the stuff was stolen. There were some things stolen from ed—we got a manual page for the Toronto version of ed, which I think Rob Pike had something to do with. We took some of the regular expression extensions out of that. 至于为什么 vi 要设计成这么不友好，其实是有历史原因的： Joy 使用的是 Lear Siegler ADM3A 终端，如下图所示 在这个终端上， ESC 键的位置是现在 IBM PC keyboard 键盘的 Tab 键的位置，所以，选择 ESC 作为模式切换键是很方便的设计 。同时， h 、 j 、 k 和 l 键也起方向键的作用，所以，vi 也采用相同的设计 。Joy 解释说，因为他开发软件时使用的 Modem 的速率只有 300 波特，显示器上的刷新速度还没有他的思考速度快，所以他设计了单字符这样的简洁风格的命令。 1978 年 3 月，Joy 负责的 BSD Unix 发布了，系统自带了 ex 1.1，这为他的编辑器在 UC Berkeley 积攒了大量人气。从那时起，Unix 系统自带的编辑器只有 ed 和 ex 。在 1984 年的一次采访中，Joy 把 vi 的成功归功于免费，当时的其他编辑器，比如 Emacs 要花费数百美金 。 观察显示基本上，所有的 ex 用户都是在 visual mode 下工作，所以在 ex 2.0（作为 1979 年 5 月的 BSD Unix 的一部分）中，Joy 把 vi 作为 ex 的硬链接，这样用户一打开 ex，就默认进入 visual mode ，所以说，vi 并不是 ex 的进化，vi 就是 ex 。 虽然在今天看来，vi 是一个很小的，轻量级的程序，但是 Joy 把 ex 2.0(vi) 描述为一个非常大的程序，因为它几乎占据了 PDP-11/70 的所有内存。在 1979 年第 3 版 BSD 中，PDP-11 已经无法存储 v3.1 的 vi 。 Joy 一直领导着 vi 的开发，一直到 1979 年 6 月的 vi 2.7，到 1980 年 8 月的 v3.5 版本中，还作出偶尔的贡献。在谈及 vi 的起源和他为何退出开发时，他说， I wish we hadn't used all the keys on the keyboard. I think one of the interesting things is that vi is really a mode-based editor. I think as mode-based editors go, it's pretty good. One of the good things about EMACS, though, is its programmability and the modelessness. Those are two ideas which never occurred to me. I also wasn't very good at optimizing code when I wrote vi. I think the redisplay module of the editor is almost intractable. It does a really good job for what it does, but when you're writing programs as you're learning... That's why I stopped working on it. What actually happened was that I was in the process of adding multiwindows to vi when we installed our VAX, which would have been in December of '78. We didn't have any backups and the tape drive broke. I continued to work even without being able to do backups. And then the source code got scrunched and I didn't have a complete listing. I had almost rewritten all of the display code for windows, and that was when I gave up. After that, I went back to the previous version and just documented the code, finished the manual and closed it off. If that scrunch had not happened, vi would have multiple windows, and I might have put in some programmability—but I don't know. The fundamental problem with vi is that it doesn't have a mouse and therefore you've got all these commands. In some sense, its backwards from the kind of thing you'd get from a mouse-oriented thing. I think multiple levels of undo would be wonderful, too. But fundamentally, vi is still ed inside. You can't really fool it. It's like one of those pinatas—things that have candy inside but has layer after layer of paper mache on top. It doesn't really have a unified concept. I think if I were going to go back—I wouldn't go back, but start over again. 在 1979 年， Mark Horton 接管了 vi 的开发，他添加了对方向键和功能键的支持，用 terminfo 代替了 termcap，提高了 vi 的性能 。 到 1981 年的 8 月，v3.7 版的 vi 以前，UC Berkeley 是 vi 开发的中心，但是随着 1982 年初 Joy 的离开去创办 Sun Microsystems ，AT&T 的 UNIX System V (1983 年 1 月 ) 采用 vi，vi 代码库的变化开始变得缓慢混乱，而且变得相互不兼容。在 UC Berkeley，虽然有修改代码，但是版本号一直没有超过 3.7 。商业的 Unix 制造商，比如 Sun, HP , DEC , 和 IBM ，他们的系统 Solaris , HP-UX , Tru64 UNIX , 和 AIX ，今天仍然在使用从 3.7 release 中衍生出来的代码，但是加入了新的特性，比如可以调整的按键映射、加密等 。 虽然商业的制造商可以使用 Joy 的代码库（直至今天），但是有许多人却不能使用。因为 Joy 是在 Thompson 的 ed 的基础上开发的，所以 ex 和 vi 是派生出来的产品，不能发布给没有 AT&T 的许可证的人使用。想在类 Unix 系统上找到一个编辑器的话必须在别的地方寻找。1985 年，一个 Emacs 的版本（ MicroEmacs ）在很多平台上可以使用，但是直到 1987 年 6 月才出现一个 vi 的克隆版本 —— Steive 。在 1990 年 1 月初，Steve Kirkendall 为发布了一个新的 vi 克隆版本 Elvis ，它比 Stive 更加完整更加忠实于 vi 。它很快就吸引了社区用户的热情， Andrew Tanenbaum 马上在社区讨论在 Minix 中使用哪一个当中 vi 的克隆，结果 Elvis 胜利了，直到今天仍然在 Minix 中当作 vi 的克隆体使用 。 在 1989 年， Lynne Jolitz 和 William Jolitz 开始着手把 BSD Unix 移植到 386 系列的处理器上，为了发布一个免费版本，他们必须绕过 AT&T 含有的代码，其中就包括 Joy 的 vi 。为了填补 vi 的空白，他们在 1992 年的 386BSD 发布版中采用了 Elvis 作为 vi 的替代品，386BSD 后来的分支 FreeBSD 和 NetBSD 也延续了这一决定。但是在 UC Berkely，Keith Bostic 使用 Kirkendall 的 Elvis（v1.8）代码，编写了 nvi ，并于 1994 年春发布。当 FreeBSD 和 NetBSD 在 4.4-Lite2 代码库的基础上重新同步以后，他们也采用了 nvi，并且一直延续到今天。 虽然有很多 vi 的克隆体，而且它们都有很多加强的特性，但是在 2000 年前左右，Gunnar Ritter 使用了 2.11BSD 中的 Joy 的代码，并把 vi 移植到了类 Unix 系统中，比如 Linux 和 FreeBSD 。从技术上讲，他没有许可证而发布 vi 的做法是非法的，但是，到了 2002 年 1 月，AT&T 的许可证被取消了，vi 可以作为开源项目在其他发布版中使用。Ritter 继续在 Joy 的代码的基础上加强 vi 的特性，就像那些商业版一样。他的成果 Traditional Vi 在很多系统上运行。 虽然 Joy 的 vi 现在又可以在 BSD Unix 上使用，但是 很多 BSD 的粉丝都转移到 更加强大、但仍然保留着 vi 的某些特性的 nvi 的阵地。从某种意义上说，这是一个奇怪的反常现象，在 Joy 的 vi 的发源地 BSD 中不再使用 vi，但是缺少它的 AT&T 的发行版却仍然保留了它并使用至今。 在 1984 年 Emacs 发布以前，vi 几乎是所有 Hacker 使用的 Unix 标准编辑器，从 2006 年开始，作为 \" 单一 Unix 标准 \"（Single UNIX Specification） 的一部分，vi 和 vi 的变形体一定可以在今天的系统中找到。 Bram Moolenaar 于 1988 年买了一台 [Amiga][Amiga] 计算机，Amiga 上没有他常用的 vi，于是他在开源的 Stevie 的基础上，于 1991 年发布了 Vim v1.14 。 起初 Vim 是 \"Vi IMitation\" 的缩写，但是后来 1993 年 12 发布的 Vim 2.0 版本中改名为 \"Vi IMproved\" 。 vim 现在是 GNU General Public （GPL） 下的自由软件，几乎在所有的 Linux 系统和 苹果 OS X 系统中都可以找到她的身影。 为什么选择 Vim 程序猿界的 圣战： Windows vs Linux Vim/Emacs vs IDE ( Vim vs Emacs ) C++ vs JAVA vs Python vs ... 首先是在 Vim 和 IDE 之间的争论。 Vim & IDE \" 到底是该选择 vim 还是 IDE ？\" 在 Stackoverflow 和 知乎 上有非常多的这样的帖子。 比如这篇： What is your most productive shortcut with Vim? 再比如这篇： 为什么不少程序员极度推崇 Vim 和 Emacs，却对 IDE 嗤之以鼻？?? 总之，萝卜芹菜各有所爱，有 Geek 精神、喜欢折腾的人不用你去说服，他自然会去学习 Vim，没有心情、懒得折腾的人，你再怎么说 Vim 好，他也不会去尝试 。（是的，我就是喜欢折腾的人 &#94;_&#94;） 个人选择 Vim 的原因： Vim 是 Linux 的 \" 标配 \" 编辑器，在 Linux 下开发，不会 Vim 的程序猿不是好程序猿 还是因为 Linux 的原因。大多数 Linux 下的程序都是不需要界面的，终端才是 Linux 的精华，千万不要成迷于界面。在终端下，除了选择 Vim 你说还能选谁呢？ 因为 Vim 和 Linux 的 \" 血缘 \" 关系，终端 & Vim 给你纯正的 Linux 哲学体验（再说当你远程 ssh 登录时，总不能还用 IDE 吧？） Vim 下有着高度的编码一致性体验。学会了 Vim，写不同语言不同代码的体验是一样的，妈妈再也不用担心我要花时间学习不同的 IDE 了 ~ 我写的代码基本只限定在底层开发，主要代码是 C/C++、Shell 脚本、Python 脚本，不会涉及到 JAVA，更不会涉及前端开发；而且都是我的 \" 玩具小程序 \"，几乎不涉及好几百个源文件的项目，所以我不需要 IDE 的强大的管理能力，写一个 makefile 就 OK 了。 学习过 CPU 知识的人都知道，频繁打断流水线才是最影响效率的东西。在调试代码的时候，显然纯键盘流要比不停的 \" 鼠标 -> 键盘 -> 鼠标 -> ...\" 有效率的多，而且省事。 崇尚 Geek 文化，喜欢 \" 折腾 \"，Linux 哲学教导我要学习轻量级的 Vim，而不是笨重的 IDE 。 vim & emacs 来自 wiki 百科： Editor war 是指两类文本编辑器 Vi（以及衍生版本） 和 Emacs 之间的争论，这已经成为 hacker 文化和自由软件社区文化的一部分 。 因为他们都认为自己的选择是完美的，所以相互蔑视，相互之间争论（点燃战火）。相比其他的 IT 领域战争（如浏览器大战、操作系统之争、编程语言之争、代码缩进风格之战 )，编辑器的选择其实通常只是个人问题。 vim 的优点： 遵循 \" 简单工具，多样组合 \" 的理念。 小，符合 Unix 哲学中的 \" 只做一件事，并做好它 \"，避免了功能蔓延。 比 Emacs 快（至少历史上是这样的）。 可运行于任何实现了 C 标准库的系统之上，包括 UNIX、Linux、AmigaOS、DOS、Windows、Mac、BeOS 和 POSIX 兼容系统等等。 让 \"QWERTY\" 键盘用户将手指保持在默认键位上，使编辑时手指移动更少。 更普及。基本上所有 Unix 和类 Unix 系统都默认提供了 vi 或其变体。 Emacs 的优点： 符合 \" 厨房水槽 \" 理念，提供了比 vi 更多的功能。 移植最广泛的非试用计算机程序之一。它能在各种操作系统上运行，包括大多数类 Unix 系统（GNU/Linux、各种 BSD、Solaris、AIX、IRIX、AmigaOS、Mac OS X 等）、MS-DOS、Microsoft Windows 和 OpenVMS。Unix 系统，无论自由版本或商业版本，均随系统提供 Emacs 。 可扩展和可定制（Lisp 的变体 - Emacs Lisp） 幽默 Richard Stallman 组建了 The Church of Emacs，它称 vi 为 \" 魔鬼的编辑器 \"（vi-vi-vi 在罗马数字中表示兽名数目）。然而它并不反对 vi；相反，它视私有软件为诅咒。（\" 使用自由版本的 vi 不是罪恶，而是赎罪。\"）它还有专门的新闻组，alt.religion.emacs，发布主题宣扬这个滑稽的宗教。 Stallman 曾称自己是 St IGNU−cius，Emacs 教会的圣人。 vi 支持者也成立了对立的 Cult of vi，较强硬的 Emacs 的用户攻击这是 \" 抄袭他们的创意 \"。 关于 vi 的模式，一些 Emacs 用户说 vi 有两个模式 – \" 不停地哔哔叫 \" 和 \" 搞砸一切 \"。vi 用户则指责 Emacs 的快捷键会引发 \" 腕管综合症 \"，或者拿 EMACS 这个缩写词作文章，比如 \"Escape Meta Alt Control Shift\"（攻击 Emacs 太依赖修改键）。一些人断定是代表 \"Eight Megabytes And Constantly Swapping\"（8 MB，还不断进行内存交换，过去这已经是很多内存了），或者 \"EMACS Makes Any Computer Slow\"（EMACS 使一切计算机跑得慢，这是斯托曼惯用的递归缩写），讽刺 Emacs 对系统资源的高需求。 针对 Emacs 的 \" 功能蔓延 \"，vi 支持者认为 Emacs 是 \" 一个伟大的操作系统，只缺个体面的编辑器 \"。 UNIX 用户中流行一个游戏，考验一个 Emacs 用户对这个编辑器的理解深度，或者是拿 Emacs 的复杂性开玩笑，内容是：预测一下，如果一个用户按住修改键（比如 Control 或 Alt），然后键入自己的名字，会发生什么事。 开始学习 Vim 闲扯了这么多，终于开始学习 vim 了 ... 结合我的痛苦的学习过程，至今还在痛苦 ing，我觉得以下的学习顺序比较适合我这样的新手： 入门： 首先，在终端下输入 vimtutor 就能进入一个 vim 自带的教程，大概花半个小时的时间就能做完。完成以后基本上就可以说是可以使用这款 大 (chou) 名 (ming) 鼎 (zhao) 鼎 (zhu) 的 \" 反人类 \" 的编辑器～ 学习 陈皓 大神在 coolshell 的博客 vim 练级攻略 同样， coolshell 上介绍的一个关于 Vim 的游戏 —— vim adventrue 去图书馆借本书 Learning the vi and Vim Editors 进阶： 阅读 Vim manpage 和 安装 vim docs 中文版插件 一本书 Pratical Vim Vim 作者 Bram Moolenaar 的文档 seven habits for effective text editing 和 演讲视频 vi/vim 使用进阶 参考 vi wikipedia Vim wikipedia","tags":"Tools","loc":"https://qiangu.cool/posts/tools/learning_vim_survival.html","title":"学习 Vim 存活"},{"url":"https://qiangu.cool/posts/book/code_review.html","text":"最近花了一个星期的时间，终于把 Code 看完了，看完全书，观后感总结出来就一个字 —— 爽～ 书名： Code: The Hidden Language of Computer Hardware and Software 作者： Charles Petzold 这本书的作者 Charles Petzold 是 Windows 编程界一位大师，世界顶级技术作家。1994 年 5 月，Petzold 作为仅有的七个人之一（并且是唯一的作家）被《Window Magazine》和 Microsoft 公司授予 \"Windows Pioneer\" 奖，以表彰他对 Microsoft Windows 的成功做出的贡献 。 关于这本书的 \" 江湖地位 \" ，只需要来看看 stackoverflow 上的这个帖子就明白了： What is the single most influential book every programmer should read? 本书排名在 第 15 ，当然绝对排名没有很大的意义，但是也能说明本书的影响力 。另外本书号称 \" 完全不懂计算机的人也能看懂 \"... 如果这都不读，我不知道还有什么样的书值得我们去花费时间 : D 打通任督二脉 纵观程序员的 \" 武功秘籍 \"，不外乎两种：一种是讲 道 ，另外一种是讲 术 。 道 即 \" 道理 \"（真理），是脱离了具体事物，抽象出来的事物的本质 。比如平时学习的 数学 、 物理 、 化学 知识，再比程序中的 算法 、分析解决问题的 思维方式 等，都不会因时间和环境变化而不适用。 术 即 \" 技术 \"（技巧），是人们在具体工程实践中总结出来的一些技巧。比如 \"The art of XXX\" ，\"The principle of XXX\" 等 。 是的，这本书既不是单独讲 道 ，也不是单独讲 术 ，而是将两者结合起来，让你不仅明白 道 的深奥，也明白 术 的精妙；让你体会到 道 是如何在 术 中实现，也体会到 术 是如何在 道 的约束下追求极限的 。更加关键的是全书都是用很平白的语言讲述，平白到 \" 即使完全不懂计算机的人也能读懂 \" 的地步，这就是其厉害之处了。 就好像你学习了五花八门的心法秘籍和各式武功，每一门都厉害无比，可偏偏无法把这些武功融会贯通，修至大成 。这时候，你需要的不是一本《葵花宝典》，而是《论天下武功之间的关系及其融会贯通方法》，打通自己的任督二脉，也就是这本 Code 。 读这本书时，让我想起了在大学 4 年间读的各种课程： 读到 第 6 章 \" 电报机与继电器 \" 让我想起 大学物理 ，虽然翘了很多课，但是电磁感应什么的有中学基础，还好没有忘记 。 读到 第 7～9 章，书中对计数的方法和进制的讨论，让我想起 大学计算机基础 ，然后花了一天时间去把以前一知半解的 \" 原码、反码、补码 \" 仔细推敲总结一遍，收获颇大 。 读到 第 10 章，布尔代数 让我想起 离散数学 ，尤其发人深醒的是布尔发明了 布尔逻辑 100 多年后， 才有人（香农）将其和电路联系起来 。 读到 第 11～13 章，跟随作者的思路，我才明白当年令人痛不欲生的 模拟电路 、 数字电路 到底是来干什么的，数字电路是如何从最基本的门搭建出来更强的功能的元器件的，联系前面学习的 编码的知识，明白这样做的道理 。 读到 第 16～22 章，让我想起 微机原理 ，对微处理器的工作方式不再模糊不清，跟随着作者的思路搭建一台 \" 计算机 \"（当然和现在的计算机完全不同，但是原理是一模一样的），为自己搭建的处理器设计一套可以实现自动功能的编程语言，然后写一段程序，甚至一窥操作系统 。 还有等等 ... 胡扯了这么多，书固然是好书，但是更让人深思的是 国内外教育的差异 。吐槽我们的教育体制毫无意义，吐槽的人都当不上教育部长，没有能力去改变现状，有能力的 guan 猿却根本没有动力去改变。作为普通人，我们能做到的就是自己努力，找真正的好书、向真正的大师学习，比如上面提到过的 What is the single most influential book every programmer should read? 除了技术、还有很多程序员需要看的书。找到一本好书，然后 Let's start it !","tags":"Book","loc":"https://qiangu.cool/posts/book/code_review.html","title":"Code 书评"},{"url":"https://qiangu.cool/posts/cs/signed_number_representations.html","text":"最近找到一本好书 —— 《编码 : 隐匿在计算机软硬件背后的语言》 。作者是大名鼎鼎的 Charles Petzold ( 个人网站 )。书的介绍也很有意思，据说完全不懂计算机的人也能看懂 ... 于是买了本来拜读一下（这种文章当然是英文版最好了，只是学生党没银子，只好买翻译版了） 看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 Google 、 Wiki ，于是总结出下文。 基本概念 机器数 顾名思义，一个数字在机器中的存储方式，\" 数 \" 是指 有符号数（ signed number ），即包含了正负号的数，\" 机器 \" 当然是指计算机（ Computer ）了。 从小学毕业，刚进入初中，我们就知道数字是有符号的： 正数 & 负数 。但是在计算机的哲学体系中，整个世界只有两个元素：0 & 1 ，没有额外的专门表示正负号的符号。怎么办呢？解决方法就是添加一位来表示符号。于是，人们约定把符号位放在一个数字的 最高有效位 （Most significant bit, MSB ），在 大端序 中， MSB 指的是一个二进制数的最左边的一位。一般， MSB 等于 0 表示正数，1 表示负数。 真值 因为机器数中有一位表示符号，所以机器数的形式值不等于真正的数值，机器数对应的数值称为机器数的 真值 。 举个栗子： 用 8 bit 表示一个数字，因为有符号位的存在，可以表示的范围为 (-127, -0, +0, +127) 。 1 2 3 +5 的 机器数 = 0000_0101 ；真值 = + 000_0101 -5 的 机器数 = 1000_0101 ；真值 = - 000_0101 这种机器数的编码方式称为 原码 ( signed-magnitude ) ，是机器数编码方式中的一种。 The four best-known methods of extending the binary numeral system to represent signed numbers are: sign-and-magnitude, Ones' complement, two's complement, and excess-K. There is no definitive criterion by which any of the representations is universally superior. The representation used in most current computing devices is two's complement, although the Unisys ClearPath Dorado series mainframes use Ones' complement. （ Wikipeida ） 下面分别讨论： 机器数表示法 原码（sign and magnitude） 编码规则 1 2 3 正数： 0_xxxxxxx 负数： 1_xxxxxxx 8 bit 的原码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数 计算法则 1 2 3 # 两数符号相同： 低位相加，最高位的符号位不变（当低位相加产生进位时，溢出 Overflow） # 两数符号不同： 比较绝对值的大小，差的绝对值 = 大数 - 小数 ，符号位和大数的符号位相同 缺点 电路复杂 从前面的计算方法中可以看到，原码中的符号位不能直接参与运算，必须要单独的线路来确定符号位 原码的计算不能避免减法运算，加法运算是产生 进位 ，减法运算需要 借位 ，这是两种不同的运算过程，需要额外的电路把 加法器 改造为 减法器 （ 《编码》 这本书里面有详细介绍 如何使用继电器搭建 加法器 和 减法器） 0 的表示不唯一 0 可以编码为两种方式： 0000_0000 和 1000_0000 ，进一步增加了逻辑的复杂性 总结 This approach is directly comparable to the common way of showing a sign (placing a \"+\" or \"−\" next to the number's magnitude). Some early binary computers (e.g., IBM 7090 ) used this representation, perhaps because of its natural relation to common usage. Signed magnitude is the most common way of representing the significand in floating point values.（ Wiki ） 虽然 原码 的编码方式最接近人类的习惯，但是，并不适合在计算机中使用，为了解决原码计算中的一些问题，于是 反码 就出现了 反码（Ones' complement） 首先，来看看 Code 中介绍了基于 10 进制的补码： 实现一个减法 253 - 176 =？ 按照我们从数学课上学习到知识，这个计算需要进行 借位 操作，为了避免这个在计算机中很难实现的操作，可以稍微变化一下计算过程 253 + (999-176) + 1 - 1000 = ? 在这个过程中，用两个减法代替了原来的一个减法，避免了烦琐的 借位 操作。在这个运算中，负数 -176 转化为另外一个数 999 - 176 ，这个数称为它的 9 的补数 (nine's complement) 。 这个运算的关键在于： 把负数用 9 的补数表示，减法转化为加法 。同理，我们推广到 2 进制，就得到了 1 的补数 (Ones' complement) 。 把减数从一串 1 当中减去，结果就称为这个数的 \"1 的补数 \"，在求 1 的补数的时候，其实并不需要做减法，因为求 1 的补数，只需要将原来的 1 变为 0 ，0 变为 1 即可，也就是取反，在电路中只需要一个反向器就可以实现，所以 1 的补数 也称为 反码 。 从上面的描述就可以很容易写出反码的编码规则 编码规则 1 2 3 正数 反码 = 原码 负数 反码 = 符号位不变，其他位取反 8 bit 的反码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数 计算法则 反码的计算不用区分符号和绝对值，直接进行计算，计算结果若有溢出，需要将溢出加到最低位，这种操作称为 \" 循环进位 \"（end-around carry） 优缺点 优点，电路简单 因为不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，所以反码计算不需要单独的判断符号的电路，也不需要判断两个数绝对值相对大小的电路 节省了减法器，只需要一组额外的反向器就能把加法器改进为可以计算 加 / 减法 缺点 计算机中仍然需要进行 \" 循环进位 \" 的硬件电路，但是这种复杂度的电路是可以接受的 0 的表示不唯一，0 的编码仍然有两种方式： 0000_0000 和 1111_1111 总结 The PDP-1 , CDC 160 series , CDC 6000 series , UNIVAC 1100 series , and the LINC computer used Ones' complement representation.（ Wiki ） 反码 中仍然没有避免 0 有两种编码方式的问题，虽然对于人来说，+0 和 -0 没有区别，但是对于计算机来说，判断一个数是否为 0，要进行两次判断。为了解决 0 的表示问题和硬件上的 \" 循环进位 \"，于是人们又发明了 补码 补码（Two's complement） 前面介绍的 253 - 176 =？ 按照反码的方法可以转换为 253 + (999-176) + 1 - 1000 = ? 如果我们稍微再变形一下，就有 253 + (1000 - 176) - 1000 = ? 在这个运算中 -176 转化为 1000 - 176 ，这个数称为它的 10 的补数 (ten's complement) 。 这个运算的关键在于： 把负数用 10 的补数表示，减法转化为加法 。同理，我们推广到 2 进制，就得到了 2 的补数 (two's complement) 。 因为对一位二进制数 b 取补码就是 1 - b + 1 = 10 - b ，相当于从 2 里面减去 b , 所以，这种方法称为 2 的补数 ，这种编码方式简称 补码 。 举例说明，要表示 -4 ，需要对 0000_0100 取补码， 1111_1111 - 0000_0100 + 1 = 1_0000_0000 - 0000_0100 ，相当于从 2&#94;8 里面减去 4 。 从上面的计算过程可以很容易写出补码的编码规则 编码规则 1 2 3 正数 补码 = 原码 负数 补码 = 反码 + 1 8 bit 补码可以表示的范围是 [ -128, -1, +0, +127 ]，共 256 个数 。 目前大多数计算机内部使用的都是补码，所以对于编程中的 32 位 int 型变量，它可以表示的范围就是 [ -2&#94;32, +2&#94;32 - 1] 。 P.S. -128 没有对应的 原码 和反码，它的补码为 1000_0000 。 计算法则 采用补码的系统，减法转换成加法（减法等同于加上一个负数，所以不再有减法），忽略计算结果最高位的进位，不必加回到最低位上去。 优点 电路简单，从计算法则中可以看到，不用考虑 \" 循环进位 \" 的问题，所以，补码系统的电路是最简单的，这也是补码系统应用最广泛的原因 0 的表示是唯一的， 0000_0000 ，不再有 -0 的困扰 补码中的数学原理 补码能将减法转化为加法，其数学原理就是 模 。 举个栗子： 1 2 3 4 5 6 如果有个手表的时间为 6 点，实际时间为 4 点，那么如何校准呢？ 答案有两种方法： 1. 逆时针转动 2，也就是做 减法 6 - 2 = 4 2. 顺时针转动 10, 也就是做 加法 (6 + 10) mod 12 = 4 从这个例子中就可以很明白的看到 减法 是如何转化为 加法 的，也就是如何将一个 负数 转化为 正数 的 。 即有公式： A - B = A + (-B + M) 这个式子中的 -B + M 即为 B 的 补数 （类似于几何中的 补角 ） 。 溢出问题（摘自 百度百科 ） 无论采用何种机器数，只要运算的结果大于数值设备所能表示数的范围，就会产生溢出。 溢出现象应当作一种故障来处理，因为它使结果数发生错误。异号两数相加时，实际是两数的绝对值相减，不可能产生溢出，但有可能出现正常进位；同号两数相加时，实际上是两数的绝对值相加，既可能产生溢出，也可能出现正常进位。 由于补码运算存在符号位进位自然丢失而运算结果正确的问题，因此，应区分补码的溢出与正常进位。 详细论证过程不再复制粘贴了 ... 直接给出结论 结论：在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。 总结 由 \" 减去一个数 = 加上一个负数 \" ，计算机系统内部就不再有减法操作 由 \" 负数的表示由取模运算转变为补码表示 \" ，计算机系统就可以用一个正数来表示负数 所以，计算机内部只需要加法器就可以完成 加减法 和 正负数 的表示 。 Two's complement is the easiest to implement in hardware, which may be the ultimate reason for its widespread popularity. Processors on the early mainframes often consisted of thousands of transistors – eliminating a significant number of transistors was a significant cost savings. Mainframes such as the IBM System/360, the GE-600 series, and the PDP-6 and PDP-10 used two's complement, as did minicomputers such as the PDP-5 and PDP-8 and the PDP-11 and VAX. The architects of the early integrated circuit-based CPUs (Intel 8080, etc.) chose to use two's complement math. As IC technology advanced, virtually all adopted two's complement technology. x86, m68k, Power Architecture, MIPS, SPARC, ARM, Itanium, PA-RISC, and DEC Alpha processors are all two's complement. ( Wiki ) 有符号数和无符号数（摘自 整数的加减运算 ） 如果把所有的位数都用来表示数值的大小，那么 8 bit 二进制数可以表示的范围是 [0, 255] ，这种称为无符号数 。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样 。 举个栗子： 1 2 3 4 5 6 1000_0010 130 -126 + 1111_1000 => + 256 => + - 8 -------------- --------------- ----------- 1_0111_1010 122 + 256 122 无符号数（ok） 有符号数（error） 计算机的加法器在做完计算之后，根据最高位产生的进位设置 进位标志 ，同时根据最高位和次高位产生的进位的异或设置 溢出标志 。 如果看作无符号数 130 和 248 相加，计算结果是 122 进 1，也就是 122+256，这个结果是对的 ; 如果把这两个操作数看作有符号数 -126 和 -8 相加，计算结果是错的，因为产生了溢出 。 至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。 通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有 bit 都是零则设置零标志，如果计算结果的最高位是 1 则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。 从 原码 到 反码 ，再到 补码 ，可以清楚看到为了解决问题而改进的技术路线，虽然这些是非常基础知识，可能对我们对写程序没有很大的帮助，但是搞清楚这些不仅让你对计算机底层更加了解，更加关键的是 这个学习过程 和 解决编码问题的思路 。 参考文献 Signed number representations——Wiki Ones' complement Two's complement 整数的加减运算 机器数 —— 百度百科","tags":"CS","loc":"https://qiangu.cool/posts/cs/signed_number_representations.html","title":"原码、反码、补码"},{"url":"https://qiangu.cool/posts/misc/first_blood.html","text":"update 换电脑更新整个博客，折腾了一天记录一下： 将源文件和 pelican 设置挪到新的 repo: blog_generator 下 制定生成的网页目录为兄弟目录 blog repo: guqian110.github.io 每次更新，首先在 blog_generator 下 make clean ， make html ，然后 cd 到 guqian110.github.io 下 commit, push 为什么要搭建自己的博客 首先，来看看各类门户博客的优缺点。 国内大多数人的朋友圈都聚集在 QQ、微博、人人等社交平台上。但是这些社区并不适合写博客，面对满屏幕毫无营养的转载文章和五颜六色的广告，谁还有兴趣把自己的生活感悟写下来？其实，我们需要的仅仅是一方可以写字的净土。至于各大技术博客平台，它们明显不适合用来记录生活中的点滴琐事。CSDN 的博客系统一直是人们的吐槽对象，况且，CSDN 已经沦为学生求作业的地方，很多大神都转移阵地，去搭建自己的博客了。 既然这些平台都不能满足我们的需求，为什么我们不搭建一个属于自己的博客呢？ 我们写博客是为了记录自己的学习、生活和成长，寻找志同道合的知己。个人博客也是一种身份，代表了博主的兴趣爱好和品味。我们自己是博客的主人，可以自己定制主题和内容，而无需经受别人的审核和莫名删除的烦恼。 为什么选择 Markdown + Pelican + GitHub 不同于面向 发布 的 Html 语言， Markdown 是一种面向 书写 的语言，其目的就是让文档更容易写和读，让人们不再为 Html 繁琐的标签烦恼。 搭建个人博客最方便也最简易的方式就是采用 WordPress 平台。但是，简易也意味着无脑、不能随行所欲地定制。我们只是需要一个写字的地方，显然 WordPress 太臃肿，用来生成静态博客的 Pelican 才是我们的最佳选择。 Github 是一个共享虚拟主机服务，用于存放使用 Git 版本控制的软件代码和内容项目。——by Wikipedia 所以我们只要采用 Markdown 写下我们的博客内容，用 Pelican 生成静态网页，然后将其托管到 GitHub 上，就大功告成了！ 折腾了几天，终于在 Google 和以下几篇博客的帮助下，初步搭建好了个人的小窝。 一步一步打造 Geek 风格的技术博客 使用 Pelican 和 GitHub Pages 搭建个人博客 —— 基础篇 用 Pelican 和 GitHub Pages 搭建免费的个人博客 博客诞生记 : 基于 GitHub+Pelican 创建博客的整个过程 如何搭建 本博客就是在参考以上 4 篇博客的教程 + Google ，在 Ubuntu 13.10 下完成的，十分感谢各位博主的分享。在搭建过程中遇到了不少问题，但是在万能的 Google 面前，都一切都不是问题，同时我也学习到了不少知识。 详细的搭建过程参考以上 4 篇博客，不再赘述，下面总结一下自己安装过程中遇到的问题吧。 学习流程 学习 Git Git Refence Pro Git GitHub help 安装、学习使用 Pelican 搭建博客骨架 Pelican Source Code Pelican Doc 学习 Markdown 语法，写博客内容 Markdown 语法 Markdown 编辑器 Retext Pelican theme 修改 Pelican theme setting 问题总结 一种安装方式不成功时，可以试试其他方法。使用命令行安装 Pelican 时，由于学校的渣网速，我安装了好几遍都 time_out 认真读 doc，很多问题的答案都在 doc 里面，磨刀不误砍柴功。 由于薄弱的 Html 知识， Pelican theme 的修改花费了很多时间 (Orz...) 总之，既然搭建好了博客，就要坚持认真写下去，记录下生活中的每一点一滴。","tags":"Misc","loc":"https://qiangu.cool/posts/misc/first_blood.html","title":"First Blood"}]};