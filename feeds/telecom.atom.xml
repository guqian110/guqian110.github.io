<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Qian's Blog - Telecom</title><link href="http://guqian110.github.io/" rel="alternate"></link><link href="http://guqian110.github.io/feeds/telecom.atom.xml" rel="self"></link><id>http://guqian110.github.io/</id><updated>2015-08-27T22:06:00+08:00</updated><subtitle>Stay hungry. Stay foolish.</subtitle><entry><title>数字信号处理中的各种频率</title><link href="http://guqian110.github.io/posts/telecom/summary_of_frequency_in_digital_signal_processing.html" rel="alternate"></link><published>2015-08-27T22:06:00+08:00</published><updated>2015-08-27T22:06:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-08-27:/posts/telecom/summary_of_frequency_in_digital_signal_processing.html</id><summary type="html">&lt;p&gt;总结信号处理中的各种角频率&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近实习的时候，发现自己的 DSP 基本功还是不够扎实，关于模拟/数字角频率，频率，采样速率等一些概念理解的都不太深刻，愧对老师和这么多年的学习，Google 到一些讲解的比较清楚的 blog，备忘（抄袭）过来，温故而知新。&lt;/p&gt;
&lt;h2 id="1. unit circle &amp;amp; sin(cos)"&gt;1. unit circle &amp;amp; sin(cos)&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;首先从最基本的三角函数的定义开始：&lt;/p&gt;
&lt;p&gt;三角函数的定义方式有很多种，我觉得基于单位圆的定义是最形象，对之后理解各种角频率的物理/数学含义最有帮助。&lt;/p&gt;
&lt;p&gt;我们应该是在初中的时候第一次接触到三角函数，那时候三角函数的定义是直接给个三角形，然后直接定义 sin(cos) 为哪条边比哪条边的值，然后给出 sin(cos)  的波形如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sine &amp;amp; cosine" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Sine_cosine_one_period.svg/600px-Sine_cosine_one_period.svg.png"/&gt;
"Sine cosine one period" by Geek3 - Own work. Licensed under CC BY 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Sine_cosine_one_period.svg#/media/File:Sine_cosine_one_period.svg&lt;/p&gt;
&lt;p&gt;当我们将这个三角形和单位圆联系在一起的时候，sin(cos) 的几何意义就很明显了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="enter image description here" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Circle-trig6.svg/338px-Circle-trig6.svg.png"/&gt;&lt;/p&gt;
&lt;p&gt;"Circle-trig6" by This is a vector graphic version of Image:Circle-trig6.png by user:Tttrung which was licensed under the GFDL. Based on en:Image:Circle-trig6.png, which was donated to Wikipedia under GFDL by Steven G. Johnson. - This is a vector graphic version of Image:Circle-trig6.png by user:Tttrung which was licensed under the GFDL. ; Based on en:Image:Circle-trig6.png, which was donated to Wikipedia under GFDL by Steven G. Johnson.. Licensed under CC BY-SA 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Circle-trig6.svg#/media/File:Circle-trig6.svg&lt;/p&gt;
&lt;p&gt;图中红色的线段长度就是 sin 的值，蓝色的线段长度就是 cos 的值，如果我们假设坐标系的原点和单位圆重合，脑补一下下面的场景：有个小球（只能）沿着单位圆的圆周做运动。这时候，我们就会发现一个事实：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sin(t) 是小球 t 时刻在 y 轴上的投影，cos(t) 是小球 t 时刻在 x 轴上的投影。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进一步，当小球的运动速率是匀速率的时候，就有了上面提到的波形，更加形象的图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="enter image description here" src="https://upload.wikimedia.org/wikipedia/commons/3/3b/Circle_cos_sin.gif"/&gt;&lt;/p&gt;
&lt;p&gt;"Circle cos sin" by LucasVB - Own work. Licensed under Public Domain via Commons - https://commons.wikimedia.org/wiki/File:Circle_cos_sin.gif#/media/File:Circle_cos_sin.gif&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 关于投影，wiki 上有个解释欧拉公式的图特别好：&lt;/p&gt;
&lt;p&gt;"Sine and Cosine fundamental relationship to Circle (and Helix)" by Tdadamemd - Own work by uploader (.gif frames created in Powerpoint). Licensed under CC BY-SA 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Sine_and_Cosine_fundamental_relationship_to_Circle_(and_Helix).gif#/media/File:Sine_and_Cosine_fundamental_relationship_to_Circle_(and_Helix).gif&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有了上面简单的背景，就可以开始逐个讨论信号处理中的概念了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. o"&gt;2. &amp;Omega;&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;我们已经知道小球在圆周上做匀速率的圆周运动时，它在两个坐标轴上的投影就分别是 sin(cos)，如果我们想进一步描述小球的运动速率的快慢呢？&lt;/p&gt;
&lt;p&gt;假设小球完整转一圈所花费的时间为 T，转动的角度为 2&amp;pi;，则我们可以定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟角频率&lt;/strong&gt; &lt;code&gt;&amp;Omega; = 2&amp;pi;/T&lt;/code&gt;，单位是 rad / s&lt;/p&gt;
&lt;p&gt;来描述小球的转动速率的快慢。&lt;/p&gt;
&lt;p&gt;当 t = 2&amp;pi; 时，y = sin(&amp;Omega;*2&amp;pi;)，这时候可以看出 &amp;Omega; 的物理含义：&lt;strong&gt;在 2&amp;pi; 的时间内，小球所完成的圈数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的 Matlab 小程序演示了 2&amp;pi; 时间内 &amp;Omega; 和周期的对应关系：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;OMEGA&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;(:,&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'OMEGA='&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num2str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'t / s'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'amp'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'y = sin(OMEGA*t)'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="OMEGA" src="/images/summary-of-frequency-in-digital-signal-processing/OMEGA.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. f"&gt;3. f&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;小球在二维平面上的圆周运动投影到一维的坐标轴 x(y) 轴上看，则是左右（上下）振动。和 &amp;Omega; 类似，我们也可以定义一个物理量来描述这种振动的快慢：&lt;/p&gt;
&lt;p&gt;小球完成一次完整的圆周运动所花费的时间为 T，也就是完成一次振动花费了 T 时间，我们定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;频率&lt;/strong&gt; &lt;code&gt;f = 1 / T&lt;/code&gt;，单位是 Hz&lt;/p&gt;
&lt;p&gt;来描述振动的快慢。由前面 &amp;Omega; 的定义式可知，&lt;code&gt;&amp;Omega; = 2&amp;pi; * f&lt;/code&gt;，有 y = sin(2&amp;pi; * f * t)。&lt;/p&gt;
&lt;p&gt;当 t = 1s 时，y = sin(2&amp;pi; * f)，这时候可以看出 f 的物理意义：&lt;strong&gt;在 1s 的时间内，小球所完成的振动次数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的 Matlab 小程序演示了 1s 时间内 f 和振动周期的对应关系：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;(:,&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;'f='&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num2str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'t / s'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'amp'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'y = sin(2*pi*f*t)'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="f" src="/images/summary-of-frequency-in-digital-signal-processing/f.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. w"&gt;4. w&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;计算机的世界是离散的，所以当连续信号经过采样、量化得到离散信号后：&lt;/p&gt;
&lt;p&gt;y = sin(&amp;Omega;&lt;em&gt;t) = sin(&amp;Omega;&lt;/em&gt;n&lt;em&gt;Ts) = sin(&amp;Omega;&lt;/em&gt;Ts&lt;em&gt;n) = sin(w&lt;/em&gt;n)&lt;/p&gt;
&lt;p&gt;从数学上我们就可以得到：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字角频率&lt;/strong&gt; &lt;code&gt;w = &amp;Omega;*Ts = &amp;Omega; / Fs&lt;/code&gt;，单位是 rad&lt;/p&gt;
&lt;p&gt;可以看到，w 是用采样频率 Fs 对 &amp;Omega; 进行归一化得到的，所以 w 准确地应该叫做归一化数字角频率。&lt;/p&gt;
&lt;p&gt;连接模拟和数字的桥梁就是采样频率 Fs，由计算过程可以知道，w 相同的两个信号，它们的 &amp;Omega; 不一定相同。因为丢失了 Fs 信息，所以单独讨论 w 是没有意义的。&lt;/p&gt;
&lt;p&gt;虽然单独讨论 w 是没有意义的，但是这不代表 w 没有物理意义，当小球的振动频率为 f 时，每秒在圆周上转过的角度为 &amp;Omega; = 2&amp;pi; * f，而采样频率为 Fs 就是说每秒钟对小球进行 Fs 次采样（拍照），显然有 Fs 个样值（照片）。这些样值（照片）是均匀分布的，所以每两个样值点之间的弧度为 2&amp;pi; * f / Fs = w，这也就是 w 的物理含义：&lt;strong&gt;相邻两个样值点之间的弧度数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;================================== summary ====================================&lt;/p&gt;
&lt;p&gt;这几个频率之间是线性关系，可以得到下面的对应关系：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Item&lt;/th&gt;
&lt;th align="center"&gt;Min&lt;/th&gt;
&lt;th align="center"&gt;Mid&lt;/th&gt;
&lt;th align="center"&gt;Max&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;n&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;(N-1)/2&lt;/td&gt;
&lt;td align="center"&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&amp;Omega;&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;&amp;Omega;s/2&lt;/td&gt;
&lt;td align="center"&gt;&amp;Omega;s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;f&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;Fs/2&lt;/td&gt;
&lt;td align="center"&gt;Fs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;w&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;&amp;pi;&lt;/td&gt;
&lt;td align="center"&gt;2*&amp;pi;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由频谱的搬移过程可以知道，w 从 &amp;pi; 到 2&amp;pi; 是负频率搬移的结果，所以通常分析的时候 w 的范围为 [-&amp;pi;, &amp;pi;)，如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Item&lt;/th&gt;
&lt;th align="center"&gt;Min&lt;/th&gt;
&lt;th align="center"&gt;Mid&lt;/th&gt;
&lt;th align="center"&gt;Max&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&amp;Omega;&lt;/td&gt;
&lt;td align="center"&gt;-&amp;Omega;s/2&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;&amp;Omega;s/2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;f&lt;/td&gt;
&lt;td align="center"&gt;-Fs/2&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;Fs/2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;w&lt;/td&gt;
&lt;td align="center"&gt;-&amp;pi;&lt;/td&gt;
&lt;td align="center"&gt;0&lt;/td&gt;
&lt;td align="center"&gt;&amp;pi;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. ref"&gt;5. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Trigonometric_functions"&gt;Trigonometric functions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://anony3721.blog.163.com/blog/static/51197420111129503233/"&gt;阿英讲频率f，角频率&amp;Omega;和数字频率w的物理含义--附MATLAB仿真&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zhuanlan.zhihu.com/wille/19763358"&gt;傅里叶分析之掐死教程（完整版）更新于2014.06.06&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="digital procesing"></category><category term="frequency"></category></entry><entry><title>相关系数及Matlab函数</title><link href="http://guqian110.github.io/posts/telecom/correlation_coefficient_and_matlab_function.html" rel="alternate"></link><published>2015-03-16T00:00:00+08:00</published><updated>2015-03-16T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-16:/posts/telecom/correlation_coefficient_and_matlab_function.html</id><summary type="html">&lt;p&gt;总结相关系数的知识及其 Matlab 实现&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. correlation"&gt;1. Correlation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;首先总结一下基础背景知识：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Correlation_and_dependence"&gt;相关 &lt;code&gt;Correlation&lt;/code&gt;&lt;/a&gt; 是概率论与统计学中用来刻画两个随机变量之间统计关系的强弱和方向的量。在广义的定义下，有很多种类的相关系数（&lt;code&gt;correlation coefficient&lt;/code&gt;），它们通常用字母 &lt;code&gt;&amp;rho;&lt;/code&gt; 或者 &lt;code&gt;r&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;p&gt;我们通常说的相关系数的学名是：&lt;a href="http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient"&gt;皮尔逊积差系数（Pearson's product moment coefficient）&lt;/a&gt;，这种相关系数只对两个变量的线性关系敏感。&lt;/p&gt;
&lt;h3 id="1.1. pearson's product moment coefficient"&gt;1.1. Pearson's product moment coefficient&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在统计学中，基于总体的定义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pearson 相关系数使用两个变量的协方差（&lt;code&gt;covariance&lt;/code&gt;）和标准差（&lt;code&gt;standard deviations&lt;/code&gt;）来定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq1" src="http://upload.wikimedia.org/math/5/c/f/5cfbb6f9088ef5fbc8a84f59da872984.png"/&gt;&lt;/p&gt;
&lt;p&gt;其中，cov 是协方差，sigma 是标准差。因为 cov 可以写作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq2" src="http://upload.wikimedia.org/math/8/8/a/88a377faf813d502d6ab1f8193481223.png"/&gt;&lt;/p&gt;
&lt;p&gt;所以 Person 相关系数的定义式可以写作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq3" src="http://upload.wikimedia.org/math/e/2/6/e26e29b58777e55d79883c77edca4428.png"/&gt;&lt;/p&gt;
&lt;p&gt;根据概率论知识可以得到如下的变形形式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq4" src="http://upload.wikimedia.org/math/0/9/d/09d413641c8ba8f54b6113e5857c69f8.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于样本来估计协方差和标准差，可以得到定义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq5" src="http://upload.wikimedia.org/math/e/3/c/e3c7ff025788887bba2f3dfca7df94b9.png"/&gt;&lt;/p&gt;
&lt;p&gt;通过变形，可以得到下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq6" src="http://upload.wikimedia.org/math/8/0/5/8059a4dddb8b6c2c5e1eeefcb9630d93.png"/&gt;&lt;/p&gt;
&lt;h3 id="1.2. properties"&gt;1.2. Properties&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E7%9B%B8%E5%85%B3"&gt;wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当两个变量的标准差都不为零，相关系数才有定义。从柯西-施瓦茨不等式可知，相关系数的绝对值不超过1。当两个变量的线性关系增强时，相关系数趋于1或-1。当一个变量增加而另一变量也增加时，相关系数大于0。当一个变量的增加而另一变量减少时，相关系数小于0。当两个变量独立时，相关系数为0.但反之并不成立。这是因为相关系数仅仅反映了两个变量之间是否线性相关。比如说，X是区间［－1，1］上的一个均匀分布的随机变量。Y = X2.那么Y是完全由X确定。因此Y和X是不独立的。但是相关系数为0。或者说他们是不相关的。当Y和X服从联合正态分布时，其相互独立和不相关是等价的。&lt;/p&gt;
&lt;p&gt;当一个或两个变量带有测量误差时，他们的相关性就受到削弱，这时，&amp;ldquo;反衰减&amp;rdquo;性（disattenuation）是一个更准确的系数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6ce23c390101c6zc.html"&gt;【总结】matlab求两个序列的相关性&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关系数只是一个比率，不是等单位量度，无什么单位名称，也不是相关的百分数，一般取小数点后两位来表示。相关系数的正负号只表示相关的方向，绝对值表示相关的程度。因为不是等单位的度量，因而不能说相关系数0.7是0.35两倍，只能说相关系数为0.7的二列变量相关程度比相关系数为0.35的二列变量相关程度更为密切和更高。也不能说相关系数从0.70到0.80与相关系数从0.30到0.40增加的程度一样大。&lt;/p&gt;
&lt;p&gt;对于相关系数的大小所表示的意义目前在统计学界尚不一致，但通常按下是这样认为的：&lt;/p&gt;
&lt;p&gt;相关系数      相关程度&lt;/p&gt;
&lt;p&gt;0.00-&amp;plusmn;0.30    微相关&lt;/p&gt;
&lt;p&gt;&amp;plusmn;0.30-&amp;plusmn;0.50   实相关&lt;/p&gt;
&lt;p&gt;&amp;plusmn;0.50-&amp;plusmn;0.80   显著相关&lt;/p&gt;
&lt;p&gt;&amp;plusmn;0.80-&amp;plusmn;1.00   高度相关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复习了基础知识，另外还有两个概念：&lt;/p&gt;
&lt;h3 id="1.3. cross-correlation"&gt;1.3. Cross-correlation&lt;/h3&gt;
&lt;p&gt;对于连续函数，有下面的定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq7" src="http://upload.wikimedia.org/math/3/a/a/3aa0f20ebd9e984d8a17642c11d43de2.png"/&gt;&lt;/p&gt;
&lt;p&gt;对于离散函数，有下面的定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq8" src="http://upload.wikimedia.org/math/d/f/6/df665b17d676571c9dc7a1800e1b186a.png"/&gt;&lt;/p&gt;
&lt;p&gt;在信号处理中，用 互相关 &lt;a href="http://en.wikipedia.org/wiki/Cross-correlation"&gt;Cross-correlation&lt;/a&gt; 来&lt;strong&gt;衡量两个序列之间的相似程度&lt;/strong&gt;，通常可以用于在长序列中寻找一个特定的短序列（也就是通信系统的同步中）。&lt;/p&gt;
&lt;p&gt;在数理统计中，互相关用来两个随机序列的相关性。&lt;/p&gt;
&lt;p&gt;从定义式中可以看到，互相关函数和卷积运算类似，也是两个序列滑动相乘，但是区别在于：&lt;/p&gt;
&lt;p&gt;互相关的两个序列都不翻转，直接滑动相乘，求和；卷积的其中一个序列需要先翻转，然后滑动相乘，求和。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;f(t) 和 g(t) 做相关 = f*(-t) 与 g(t) 做卷积&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="1.4. autocorrelation"&gt;1.4. Autocorrelation&lt;/h3&gt;
&lt;p&gt;自相关 &lt;a href="http://en.wikipedia.org/wiki/Autocorrelation"&gt;Autocorrelation&lt;/a&gt; 是互相关的一种特殊情况，就是一个序列和它本身做相关，而不是两个序列，它&lt;strong&gt;主要用来衡量一个序列在不同时刻取值的相似程度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在数理统计中，自相关的定义式如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq9" src="http://upload.wikimedia.org/math/3/7/c/37c9812eaf2deca258f5526ac9067aa2.png"/&gt;&lt;/p&gt;
&lt;p&gt;如果随机过程是一个宽平稳过程，那么均值和方差都不是时间的函数，所以，自相关定义式变为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq10" src="http://upload.wikimedia.org/math/1/c/c/1cc9b1b80ab17d64568bca15bc7a5a9d.png"/&gt;&lt;/p&gt;
&lt;p&gt;在某些学科中，会去掉归一化因子 &amp;sigma;2，使用 自协方差 来代替 自相关。但是归一化因子可以让自相关的取值在 [-1, +1] 之间，不会随着序列的绝对大小而变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在信号处理中，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自相关的定义会去掉归一化，即不用减去均值，也不用除以方差。当除以方差时，一般叫做另外一个名字：自相关系数 &lt;code&gt;autocorrelation coefficient&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于连续函数，自相关的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq11" src="http://upload.wikimedia.org/math/9/8/c/98cd888f0d13972a937f5d37d9f24623.png"/&gt;&lt;/p&gt;
&lt;p&gt;对于离散函数，自相关的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq12" src="http://upload.wikimedia.org/math/4/c/2/4c23ef05df69ee440a2bda5a0b1d83bc.png"/&gt;&lt;/p&gt;
&lt;p&gt;自相关有很多性质，比如对称性、&lt;a href="http://en.wikipedia.org/wiki/Wiener%E2%80%93Khinchin_theorem"&gt;维纳-辛钦定理（Wiener&amp;ndash;Khinchin theorem）&lt;/a&gt; 等，就不再重复了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. matlab function_1"&gt;2. Matlab function&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="2.1. xcorr"&gt;2.1. xcorr&lt;/h3&gt;
&lt;p&gt;在 Matlab 中，计算自相关和互相关，可以使用同一个函数：&lt;code&gt;xcorr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;自相关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;互相关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为两个长度为 N 的序列进行相关，可以知道最多有 2N - 1 个非 0 的移位相乘结果，所以 xcorr 的返回结果就是长度为 2N - 1 的向量。（如果其中一个序列的长度小于 N，则会先补零再计算相关）&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;help xcorr&lt;/code&gt; 来查看详细的函数说明。&lt;/p&gt;
&lt;p&gt;下面举个使用例子：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c"&gt;%correlation&lt;/span&gt;
&lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c3&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;对于序列 x = [1, 2, 3]，移位相乘、求和，可以得到结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于序列 y 类似。&lt;/p&gt;
&lt;p&gt;对于 x、y 的互相关，当两个序列对齐的时候，相关性最高（归一化后为 1，意味着两个序列线性相关）&lt;/p&gt;
&lt;p&gt;xcorr 默认的返回结果是没有经过归一化的，而通常的应用中都要求归一化以得到精确的估计。解决这一问题的方法就是使用 xcorr 函数提供的 &lt;code&gt;option&lt;/code&gt; 选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;'biased' 有偏估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'unbiased' 无偏估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'coeff' 归一化，返回到最大值（对齐时）为理想的 1.0（= xcorr(x)./max(xcorr(x)) ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'none' 未经归一化的原始数据，默认的返回结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2.2. corrcoef"&gt;2.2. corrcoef&lt;/h3&gt;
&lt;p&gt;可以用 &lt;code&gt;corrcoef&lt;/code&gt; 函数来求两个序列的相关系数，函数的返回值为一个 2&amp;times;2 的矩阵，对角线上的值为两个序列的自相关系数，非对角线上的值为两个序列的互相关系数。&lt;/p&gt;
&lt;p&gt;在上面的例子中加入下面两句：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;c4&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;corrcoef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;返回结果为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 z 是 x 的线性函数，且系数为 -1，所以非对角线上的值为 -1。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. ref_1"&gt;3. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Correlation_and_dependence"&gt;correlation wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient"&gt;pearson wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cross-correlation"&gt;Cross-correlation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Autocorrelation"&gt;Autocorrelation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6ce23c390101c6zc.html"&gt;【总结】matlab求两个序列的相关性&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="correlation coefficient"></category><category term="matlab"></category></entry><entry><title>OFDM 中的 IFFT/FFT 注意事项</title><link href="http://guqian110.github.io/posts/telecom/ifft_and_fft_in_ofdm.html" rel="alternate"></link><published>2015-03-10T19:40:00+08:00</published><updated>2015-03-10T19:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-10:/posts/telecom/ifft_and_fft_in_ofdm.html</id><summary type="html">&lt;p&gt;OFDM 中做 IFFT/FFT 时需要注意的一点细节&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. intro"&gt;1. Intro&lt;/h2&gt;
&lt;p&gt;在做 OFDM 项目时，发现一个容易犯错的地方：&lt;code&gt;IFFT&lt;/code&gt;/&lt;code&gt;FFT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在很多介绍 OFDM 的书中，给出结论：在发射机，基带信号的复包络采用值正好是待发射序列的 IDFT，所以在 N 是 2 的指数时，可以采用 IFFT 来快速计算；在接收机，将接收的频带信号解调到基带，采样得到基带复包络，然后做 DFT (FFT) 即可得到原始的发射序列。&lt;/p&gt;
&lt;p&gt;这个结论是正确的，但是需要注意的一点是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调制/解调所做的运算的形式和 IFFT/FFT 是相同的，但是有一个功率归一化的系数的差别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多书（&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;）都给出了公式推导，然而这些公式并不严谨，这些公式只是为了说明做的变换形式是 IFFT/FFT。&lt;/p&gt;
&lt;p&gt;有的书（&lt;a href="http://book.douban.com/subject/1140934/"&gt;宽带无线通信OFDM技术&lt;/a&gt;）则给出了更加详细，严谨的公式推导。&lt;/p&gt;
&lt;h2 id="2. ifft / fft"&gt;2. IFFT / FFT&lt;/h2&gt;
&lt;p&gt;&lt;img alt="fft/ifft" src="http://guqian110.github.io/images/xilinx_fft_core_notes/theory.png"/&gt;&lt;/p&gt;
&lt;h2 id="3. ifft /fft in ofdm"&gt;3. IFFT /FFT in OFDM&lt;/h2&gt;
&lt;p&gt;OFDM 中 &lt;strong&gt;功率归一化因子&lt;/strong&gt; 为 1/sqr(N)，而标准的 IFFT 中的系数为 1/N，所以在调用标准 IFFT 函数之后，需要额外乘以一个 sqr(N) ：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/N &amp;times; sqr(N) = 1/sqr(N)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而在接收端，也要先除以一个 sqr(N)，然后再进行 FFT 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. ref"&gt;4. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1140934/"&gt;宽带无线通信OFDM技术&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="IFFT"></category><category term="FFT"></category><category term="OFDM"></category></entry><entry><title>信噪比小结</title><link href="http://guqian110.github.io/posts/telecom/summary_of_snr_and_noise.html" rel="alternate"></link><published>2015-03-10T19:31:00+08:00</published><updated>2015-03-10T19:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-03-10:/posts/telecom/summary_of_snr_and_noise.html</id><summary type="html">&lt;p&gt;学而时习之，总结一下信噪比相关的小知识&lt;/p&gt;</summary><content type="html">&lt;p&gt;所谓 &lt;code&gt;信噪比（SNR, Signal-to-noise ratio）&lt;/code&gt; 就是指 信号的功率 和噪声的功率 的比值。我们可以用它来比较信号的和背景噪声的相对大小，如果比值大于 1（0 dB），说明信号功率比噪声功率强。&lt;/p&gt;
&lt;h2 id="1. snr def"&gt;1. SNR Def&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;信噪比的定义式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="def" src="http://upload.wikimedia.org/math/f/0/e/f0e032777062c3f945554f1c63d9c864.png"/&gt;&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;P&lt;/code&gt; 表示信号/噪声的平均功率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果信号和噪声的方差已知，且两者的均值都为0，则信噪比可以写为下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq1" src="http://upload.wikimedia.org/math/9/0/9/9098fa286b51274407110dd98832b8b7.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果信号和噪声是使用相同的阻抗来测量的（功率这个词本来就源于物理，在电子系统中，功率 &lt;code&gt;P = UI = V^2/R&lt;/code&gt;），那么信噪比公式可以用幅度的平方比值来计算：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq2" src="http://upload.wikimedia.org/math/6/9/d/69d4d7d398cf17a0184463ae42b4b18b.png"/&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;A&lt;/code&gt; 为信号/噪声的 &lt;code&gt;均方根（ root mean square, RMS）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般信号的动态范围都很大，所以通常采用分贝的方式来表示信噪比&lt;/p&gt;
&lt;p&gt;&lt;img alt="ep3" src="http://upload.wikimedia.org/math/8/e/7/8e7f17468834710c835579e252528515.png"/&gt;&lt;/p&gt;
&lt;p&gt;把 均方根 带入，就可以得到下面的公式&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq4" src="http://upload.wikimedia.org/math/6/f/7/6f7dd3340b9b31a3d3afa11532c5480e.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般 SNR 指的是 &lt;strong&gt;平均&lt;/strong&gt; 信噪比，因为通常 SNR  的瞬时值是不同的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信噪比的概念也可以这么理解：将噪声的功率归一化为 1（0 dB），看信号的功率可以达到多大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. snr in telecom"&gt;2. SNR in telecom&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在物理学中，交流电信号的 平均功率 = (电压&amp;times;电流) 的均值，如下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq5" src="http://upload.wikimedia.org/math/b/a/1/ba1615e4d1dc51196247c5a912227dba.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq6" src="http://upload.wikimedia.org/math/c/6/9/c69fbca997fb4cc8a82823fe47c2e47d.png"/&gt;&lt;/p&gt;
&lt;p&gt;但是在信号处理和通信中，一般假设电阻的阻值为 1 欧姆，所以在计算能量、功率时，电阻因子会被忽略。这可能会引起一些困扰。&lt;/p&gt;
&lt;p&gt;所以信号的功率表示式简化为下面的公式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq7" src="http://upload.wikimedia.org/math/a/e/7/ae780e83e953d7329de754a42fcddb63.png"/&gt;&lt;/p&gt;
&lt;p&gt;（其中，&lt;code&gt;A&lt;/code&gt; 是交流信号的幅度）&lt;/p&gt;
&lt;h3 id="2.1. eb/n0"&gt;2.1. Eb/N0&lt;/h3&gt;
&lt;p&gt;在数字系统中可以使用 SNR 表示噪声的等级，但是更常用的是 &lt;code&gt;Eb/N0 (energy per bit to noise power spectral density ratio)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Eb/N0 是一种归一化的 SNR，称为 &amp;ldquo; SNR 每 bit &amp;rdquo;，在比较不同的调制方案的 &lt;code&gt;误比特率（BER, bit error rate）&lt;/code&gt; 性能时，因为这种方法不考虑带宽的因素，所以很有效。&lt;/p&gt;
&lt;p&gt;其中 Eb 是平均比特能量，它表示平均每个 bit 包含的能量。&lt;/p&gt;
&lt;p&gt;信号的功率就等于符号中每个比特的功率 Eb &amp;times; 每个符号所包含的比特数 fb（也就是比特速率）；噪声的能量可以用功率谱密度来计算，N0&amp;times;B，代入信噪比的定义式，就有下面的换算公式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq9" src="http://upload.wikimedia.org/math/3/5/3/353410b95506c2f45e069c58ff3d121b.png"/&gt;&lt;/p&gt;
&lt;p&gt;P.S. 上面的公式左边使用的是载噪比 CNR，在抑制载波的调制方式中，等于信噪比 SNR。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. awgn_1"&gt;3. AWGN&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;高斯分布（&lt;code&gt;Gaussian distribution&lt;/code&gt;）可以使用 &lt;code&gt;N(&amp;mu;,&amp;sigma;2 )&lt;/code&gt; 来表示，其中 &amp;mu; 是均值，&amp;sigma; 是标准差。&lt;/p&gt;
&lt;p&gt;对噪声进行建模，最简单的就是 &lt;strong&gt;加性高斯白噪声 (AWGN, Additive White Gaussian Noise)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加性：叠加在信号之上，而且无论有无信号，噪声都是始终存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高斯：噪声幅度的取值是随机过程，它的概率密度函数服从高斯分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;白噪声：噪声的功率谱密度函数取值是常数，在坐标系中表现为一条直线，在每个频率点的谱密度都一样，就像白光包含各种频率的光一样，所以叫做白噪声。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时满足这三个的条件的噪声就叫做 加性高斯白噪声。&lt;/p&gt;
&lt;p&gt;高斯白噪声的功率谱函数：&lt;code&gt;P(f) = N0/2&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;N0&lt;/code&gt; 是 &lt;strong&gt;单边噪声功率谱密度&lt;/strong&gt;，&lt;code&gt;N0/2&lt;/code&gt; 是 &lt;strong&gt;双边噪声功率谱密度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为功率谱密度函数的定义域是无穷大的，所以高斯噪声的功率也是无穷大的，它的功率只有在带限时才有意义。&lt;/p&gt;
&lt;p&gt;在计算前面 SNR 时，我们可以使用下面两种方法来得到 Pn：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果均值为 0，&lt;code&gt;Pn = 方差 &amp;sigma;2 = R(0)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果已知功率谱密度函数 P(f)，那么直接对其定积分&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. ref"&gt;4. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signal-to-noise_ratio"&gt;Signal-to-noise ratio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Eb/N0"&gt;Eb/N0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Gaussian_noise"&gt;Gaussian noise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.c114.net/thread-663445-1-1.html"&gt;关于白噪声功率谱密度和方差的关系 &lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="SNR"></category></entry><entry><title>LTE 咬尾卷积编码器的 Matlab 、C 语言及 FPGA 实现</title><link href="http://guqian110.github.io/posts/telecom/tail_bitting_convolutional_code_implementation_in_matlab_and_c_and_fpga.html" rel="alternate"></link><published>2015-01-07T00:00:00+08:00</published><updated>2015-01-07T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2015-01-07:/posts/telecom/tail_bitting_convolutional_code_implementation_in_matlab_and_c_and_fpga.html</id><summary type="html">&lt;p&gt;总结咬尾卷积编码的 Matlab 及 FPGA 实现方法。&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. tail bitting"&gt;1. Tail Bitting&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;咬尾卷积编码是一种特殊的卷积编码，它通过将编码器的移位寄存器的初始值设置为输入流的尾比特值，使得移位寄存器的初始和最终状态相同。和普通的卷积编码相比，咬尾的方案最大的优点是克服了编码时的码率损失，并且适合迭代译码，不过付出的代价是译码复杂度的增加。在 LTE 的标准中，咬尾卷积编码是一种备选的信道编码方案。&lt;/p&gt;
&lt;p&gt;通常以 (n, k, K) 来描述卷积编码，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 表示编码器的 &lt;em&gt;输入码元数&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 表示编码器的 &lt;em&gt;输出码元数&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt; 表示编码器的 &lt;em&gt;约束长度&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由输入的 k 个信息比特，得到 n 个编码结果，所以 &lt;em&gt;编码效率&lt;/em&gt; = k/n&lt;/p&gt;
&lt;p&gt;约束长度 &lt;code&gt;K&lt;/code&gt; 的意思是，编码结果不仅取决于当前输入的 k 比特信息，还取决于前 (K-1) 段时间内的信息位。在 k = 1 的条件下，编码器需要的 &lt;em&gt;移位寄存器级数&lt;/em&gt; m = K - 1。&lt;/p&gt;
&lt;p&gt;LTE 标准中编码器的结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="coder" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/coder.jpg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设输入的比特流为 c1, c2, c3, ... 得到的编码结果为 d1, d2, d3, ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中移位寄存器 D 从左到右一次是 S0, S1, ... S5。对其初始化时，S0 = Ck-1, S1 = Ck-2, ... S5 = Ck-6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行编码时，有抽头的寄存器之间进行模 2 加法（即异或）运算。每次对一个输入信息完成编码之后，移位寄存器右移一位，抛弃最右端的移位结果，采用前一个输入作为最左端的信息位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当最后的比特进行编码完之后，寄存器又回到了设定的初始状态，就像一条蛇咬住了自己的尾巴，所以称为 咬尾 Tail Bitting。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图中的 G1，G2, G3 是 &lt;em&gt;生成式&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的内容已经提供了足够的信息供我们实现，关于更多的卷积编码、LTE 标准等请查阅 wiki 和专业书籍。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. matlab implementation"&gt;2. Matlab Implementation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Matlab 的 &lt;code&gt;Communications System Toolbox&lt;/code&gt; 中提供了大量的常用函数，其中就有卷积编码函数 &lt;code&gt;convenc&lt;/code&gt;。我们就是基于这个函数实现LTE中的咬尾卷积编码。&lt;/p&gt;
&lt;p&gt;通过&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和 hlep browser，可以查到这个函数的用法，简单解释如下:&lt;/p&gt;
&lt;p&gt;convenc 函数有几种方式来调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;CODE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MSG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRELLIS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;CODE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MSG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRELLIS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PUNCPAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;CODE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(...,&lt;/span&gt; &lt;span class="n"&gt;INIT_STATE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个参数 &lt;code&gt;MSG&lt;/code&gt; 是待编码的信息比特&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数 &lt;code&gt;TRELLIS&lt;/code&gt; 是编码器的栅格描述&lt;/p&gt;
&lt;p&gt;TRELLIS 是 Matlab 内部定义的一种数据结构，它的值可以按照语法定义，更方便的方法是通过 &lt;code&gt;poly2trellis&lt;/code&gt; 这个函数，由多项式描述方式转化得到。&lt;/p&gt;
&lt;p&gt;查阅 poly2trellis 的 help 就可以看到它的用法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;trellis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;poly2trellis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ConstraintLength&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CodeGenerator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;ConstraintLength&lt;/code&gt; 是个 1&amp;times;k 维的向量，表示编码器的约束长度；&lt;code&gt;CodeGenerator&lt;/code&gt; 是个 k&amp;times;n 维的向量，表示编码器中各个寄存器的抽头。&lt;/p&gt;
&lt;p&gt;help 中以一个 2/3 码率的编码器为例，其结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="exmaple" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/example.png"/&gt;&lt;/p&gt;
&lt;p&gt;两组寄存器的长度分别为 4 和 3，所以 constraintlength 的取值为 [5, 4]；将每路输出的抽头用 8 进制来表示，即可得到 codegenerator 的取值 [27, 33, 0; 0, 5, 13]，表示第一路输出由第一组寄存器的 27 组合方式 + 第二组寄存器的 0 组合方式得到，第二路输出由第一组寄存器的 33 组合方式 + 第二组寄存器的 5 组合方式得到，第三路同理。&lt;/p&gt;
&lt;p&gt;应用到我们的编码器中，很容易写出其栅格描述&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;poly2trellis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;133&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;171&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;165&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数 INIT_STATE 是移位寄存器的初始值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INIT_STATE&lt;/code&gt; 用来设定寄存器的初始状态，其取值就是寄存器的值。&lt;/p&gt;
&lt;p&gt;在下面的程序中，我们的测试向量的最后 6 bit 为 010110，所以对应的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，可以写出 matlab 程序来实现咬尾卷积编码，如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c"&gt;% using a to test coder&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c"&gt;% describe the coder&lt;/span&gt;
&lt;span class="n"&gt;tre&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;poly2trellis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;133&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;171&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;165&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="c"&gt;% init state is depend on a&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;% encode&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tre&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;得到的编码结果是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据的格式是将 3 位并行结果串行输出： d00, d01, d02, d10, d11, d12, ...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. c implementation"&gt;3. C Implementation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;C 的实现很简单:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;encode_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;origin_bits_len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// initialize the LSR&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;origin_bits_len&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;origin_bits_len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;coded_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="c1"&gt;// shift the regs&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;origin_bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h2 id="4. verlog implementation"&gt;4. Verlog Implementation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;用 verilog 来实现编码器就相对简单直观的多，毕竟只有一组移位寄存器和一些抽头的异或运算。&lt;/p&gt;
&lt;h3 id="4.1. module &amp;amp; testbench"&gt;4.1. module &amp;amp; testbench&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tbce.v"&gt;module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tb_tbce.v"&gt;testbench&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="4.2. simulation"&gt;4.2. simulation&lt;/h3&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/sim1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/sim2.png"/&gt;&lt;/p&gt;
&lt;p&gt;和 matlab 中结果对比，结果是一致的。&lt;/p&gt;
&lt;h2 id="5. summary_1"&gt;5. Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;一个简单的咬尾卷积编码花费了一上午的时间才搞定，最大的收获就是：心态很重要，欲速则不达。没有认真看 help 就写程序，本来想节省时间，结果却相反 =.=&lt;/p&gt;
&lt;p&gt;戒骄戒躁！！！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="6. reference"&gt;6. Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/24784764/"&gt;无线通信新协议与新算法&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="tail bitting convolution"></category></entry><entry><title>数字信号处理和相关matlab函数总结</title><link href="http://guqian110.github.io/posts/telecom/digital_signal_processing_and_matlab.html" rel="alternate"></link><published>2014-09-03T23:16:00+08:00</published><updated>2014-09-03T23:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-09-03:/posts/telecom/digital_signal_processing_and_matlab.html</id><summary type="html">&lt;p&gt;总结信号处理和matlab相关应用&lt;/p&gt;</summary><content type="html">&lt;p&gt;学了这么多年的通信，却还是对信号处理的知识一知半解，应付考试还可以，但在实际应用中还是感到力不从心，很多知识都忘了。翻了一下午的 《信号与系统》、《数字信号处理》，简单总结一下。&lt;/p&gt;
&lt;p&gt;《信号与系统》算是通信专业最基础的专业课了。&lt;/p&gt;
&lt;p&gt;信号部分主要介绍信号的相关定义、分类、常用信号和三大变换：傅立叶变换、拉普拉斯变换和z 变换。&lt;/p&gt;
&lt;p&gt;系统部分主要从时域和频域使用不同的方法分析线性时不变系统（LTI）的性质。&lt;/p&gt;
&lt;p&gt;《数字信号处理》算是前一门课的深入，现在利用计算机处理信号，首先就是要将模拟信号数字化，然后进行处理。这门课也就是讲相关的知识。&lt;/p&gt;
&lt;p&gt;一般教材就讲两大部分：第一部分首先承接《信号与系统》，时域的连续信号要在计算机中处理就必须采样，变为时域离散信号，这部分就讲离散时间信号的处理，比如 z 变换 和离散傅立叶变换。第二部分讲数字滤波器的设计，包括 FIR 和 IIR 两种。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. signal processing"&gt;1. Signal Processing&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;em&gt;这部分是我串联的这两本书中很小的一部分知识，算是一个备忘的笔记吧，作为一名学渣，一个月不看也会忘记不少 =.=&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从 《信号与系统》 中我们可以知道：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周期信号 （连续）傅立叶级数 （CFS）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，由高数知识可以知道：只要满足 Dirichlet 条件，周期信号就可以进行傅立叶级数分解，可以得到幅度频谱和相位频谱。&lt;/p&gt;
&lt;p&gt;时域信号是周期的、连续的，频域信号是离散的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非周期信号 （连续）傅立叶变换 （CFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;周期信号的周期无限增大，就可以将周期信号转化为非周期信号，从而得到非周期信号的傅立叶变换。&lt;/p&gt;
&lt;p&gt;得到的频率域的结果为连续信号，计算结果为时域信号的频谱密度函数，简称频谱函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周期信号 （连续）傅立叶变换 （CFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于周期信号，因为它不满足绝对可积的条件，所以从非周期信号无法直接推广。但是借助 &lt;em&gt;奇异函数&lt;/em&gt;（如冲激函数）的概念，可以使许多不满足绝对可积的信号（如周期信号）存在傅立叶变换。&lt;/p&gt;
&lt;p&gt;周期信号的傅立叶变换结果由一些冲激函数组成，冲激函数的强度是对应的傅立叶级数的 2pi 倍，频谱是离散的。&lt;/p&gt;
&lt;p&gt;这样，周期信号和非周期信号的傅立叶分析得到了统一。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;接下来，就要进入《数字信号处理》部分了：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散时间信号傅立叶变换 （DTFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时域连续信号经过采样，得到离散时间信号，对于离散时间信号，可以从 z 变换中引出 DTFT 的定义。&lt;/p&gt;
&lt;p&gt;DTFT 是一种特殊的傅立叶变换（FT），它满足所有的傅立叶变换的性质。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散傅立叶变换 （DFT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然 DTFT 解决了信号在时域的连续问题，但是变换结果仍然是连续信号，也就是说在频域仍然是连续的，这样计算机仍然是无法处理的。所以，就引出了离散傅立叶级数（DFS)和离散傅立叶变换（DFT）。&lt;/p&gt;
&lt;p&gt;时域信号的周期性对应着频域的离散化，而且时域信号的离散化对应着频域的周期性。由这两点，可以知道周期的离散信号具有离散的、周期的频谱，也就是离散傅立叶级数（DFS）。&lt;/p&gt;
&lt;p&gt;把时域和频域的数据长度都限定在主周期，那么就得到了标准的离散傅立叶变换（DFT）。&lt;/p&gt;
&lt;p&gt;经过分析，可以知道，DFT 是 z 变换的取样，也是 DTFT 的取样结果。&lt;/p&gt;
&lt;p&gt;DFT 因为是离散的，长度有限，所以很适合计算机计算，而且人们发明了高效地计算 DFT 的方法 &amp;mdash;&amp;mdash; FFT 。&lt;/p&gt;
&lt;p&gt;知乎上还有一篇专栏的文章，得到了非常多人的赞同，可以进一步参考。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zhuanlan.zhihu.com/wille/19763358"&gt;傅里叶分析之掐死教程（完整版）更新于2014.06.06&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. matlab"&gt;2. Matlab&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="2.1. basic"&gt;2.1. basic&lt;/h3&gt;
&lt;p&gt;分析各种变化，可以得到以下的关系：&lt;/p&gt;
&lt;p&gt;N 点的 DFT（FFT），其结果对应的&lt;/p&gt;
&lt;p&gt;数字角频率 w 为 [0, 2pi)&lt;/p&gt;
&lt;p&gt;模拟角频率 &amp;Omega; 为 [0, &amp;Omega;s)&lt;/p&gt;
&lt;p&gt;模拟频率 f 为 [0, fs)&lt;/p&gt;
&lt;p&gt;所以对于 N 点 FFT 的结果，对应的横坐标频率的范围为 [0, fs)。&lt;/p&gt;
&lt;p&gt;matlab 提供了函数 fft 和 fftshift 直接完成变换。&lt;/p&gt;
&lt;h3 id="2.2. adv"&gt;2.2. adv&lt;/h3&gt;
&lt;p&gt;我们在对一个信号进行采样分析时，首先需要确定两个参数：参数有采样频率 &lt;code&gt;Fs&lt;/code&gt;，采样点数 &lt;code&gt;N&lt;/code&gt;，这两个因素决定了之后可以得到的时频域效果。&lt;/p&gt;
&lt;p&gt;假设我们的采样频率为 Fs （采样周期为 T = 1/Fs），一共采了 N 个点，那么相当于对信号进行了截断，截断长度为 L = N * T 秒。这 3 个参数就决定了我们的最终结果。&lt;/p&gt;
&lt;p&gt;在信号处理中存在下面的 3 个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;频谱混叠。如果信号不是带限的，那么为了减小频谱混叠的影响，我们应该&lt;strong&gt;尽可能提高采样频率 Fs&lt;/strong&gt;，而且 Fs 越大，时频域分辨率也越高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;频率分辨率和栅栏效应。因为 DFT 是 DTFT 的等间隔采样，那么 N 越大，采样点数越多，栅栏就越小。为了提高频率分辨率 &lt;code&gt;f0 = Fs/N&lt;/code&gt;，我们应该&lt;strong&gt;尽可能增大 N&lt;/strong&gt;，而且为了提高计算效率，N 等于 2 的 M 次方）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;截断效应和频谱泄漏。如果信号是无限长的，那么必须把它截断到长度 &lt;code&gt;L = N*T = N/Fs&lt;/code&gt;。截断会带来吉布斯效应，并且引入窗函数的频谱，造成频谱泄漏。应该&lt;strong&gt;使得 L 包含信号的绝大部分&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举例说明非周期信号和周期信号的分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;非周期信号&lt;/p&gt;
&lt;p&gt;假设我们要分析 tau = 1 的矩形窗函数，我们知道它的频谱，且取第一零点 1/tau = 1 为最高频，假设 8 倍采样，即 Fs = 8 Hz，假设频谱分辨率小于 0.1 Hz 即达到需求，则可以得到 N = 128，此时验证 L = 16 满足条件。由 tau 和 Fs 得到采样点包含 8 个 1 和 120 个0，所以：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;zeors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'f / Hz'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'Amplitude Response'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'tau = 1 rectangle window'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rect" src="/images/digital_signal_processing_and_matlab/rect_window.jpg"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周期信号&lt;/p&gt;
&lt;p&gt;假设信号为 x = 1 + 1/2&lt;em&gt;cos(2&lt;/em&gt;pi&lt;em&gt;15&lt;/em&gt;t) + 2&lt;em&gt;sin(2&lt;/em&gt;pi&lt;em&gt;40&lt;/em&gt;t)，包含一个直流分量和 f1 = 15, f2 = 40 Hz 的分量，fm = f2 = 40 Hz，若 8 倍采样，有 Fs = fm*8，若 fdelta &amp;lt; 0.1 hz，有 N = 4096，所以：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;f2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Fs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;w1&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;w2&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;grid&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'f / Hz'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'Amplitude Response'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'x = 1 + 1/2*cos(w1*n) + 2*sin(w2*n)'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital_signal_processing_and_matlab/period.jpg"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;综上，我们就有分析一个信号的&lt;strong&gt;通用步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首先确定Fs&lt;/strong&gt;：信号的频率信息对于我们是未知的，我们最多只知道信号的带宽，根据信号带宽，我们就可以确定一个采样率 Fs，比如 8 倍采样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定了 Fs，实际上的 w 就已经确定了，只是我们是不知道它的具体值（因为不知道fm）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;下一步应该确定 N&lt;/strong&gt;：由公式1和公式2可以推出 &lt;code&gt;N = Fs/fm*k&lt;/code&gt;。当Fs最小为奈奎斯特采样速率，k = 1 时，N 取到最小值 2，这种情况下虽然没有混叠，但是 fdelta 太大了，不利于观察频谱，应该由 &lt;code&gt;fdelta = Fs/N&lt;/code&gt; 决定 N 的最小值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;====================================== 补充一下 FFT 补零 ========================================&lt;/p&gt;
&lt;p&gt;验证程序：假设一个 sin 信号，f = 125， 8 倍采样有 Fs = 1000，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;N = 8，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital_signal_processing_and_matlab/N_8.jpg"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N = 8，补零到 64 点，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital_signal_processing_and_matlab/padding.jpg"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N = 64，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital_signal_processing_and_matlab/N_64.jpg"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直接给结论（上面的图也证明了这些结论）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在时域的采样序列后面添加后缀 0 ，等效在频域内插。频域内插只能从已有的样点推算，因为采样点数不够丢失的原始信号的信息无法通过内插来补偿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时域补零实际上改变了采样序列的，所以频域结果和原始信号不同，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补零无法提高频率分辨率，内插出的新分量不是真正物理意义上的频率，是 &amp;ldquo;假频&amp;rdquo;，真正的频率分辨率并没有提高。频率分辨率只能由提高采样点数来提高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. reference_1"&gt;3. Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3712794/"&gt;信号与系统引论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4025528/"&gt;数字信号处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/24868505/"&gt;数字信号处理教程&amp;mdash;&amp;mdash;MATLAB释义与实现&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="digital procesing"></category><category term="matlab"></category></entry><entry><title>学习 OFDM 及其 FPGA 实现 1 —— OFDM Basic</title><link href="http://guqian110.github.io/posts/telecom/learning_ofdm_on_fpga_1_ofdm_basic.html" rel="alternate"></link><published>2014-05-13T23:16:00+08:00</published><updated>2014-05-13T23:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-05-13:/posts/telecom/learning_ofdm_on_fpga_1_ofdm_basic.html</id><summary type="html">&lt;p&gt;基于 FPGA 实现 OFDM 系统。第一篇，OFDM 基础。&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. why ofdm"&gt;1. Why OFDM&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="1.1. background"&gt;1.1. Background&lt;/h3&gt;
&lt;p&gt;移动通信的信道模型一般建立为 &lt;strong&gt;时变多径信道模型&lt;/strong&gt;，描述信道多径时延特性的一个重要统计参量是 &lt;strong&gt;均方根时延扩展&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;经过无线信道的时变多径传输，接收到的信号幅度会有起伏变化（瑞利分布 or 莱斯分布），这种现象称为 &lt;strong&gt;信号衰落&lt;/strong&gt; 。按照已调信号的带宽可以将衰落分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窄带信号受到 &lt;strong&gt;平坦性衰落&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;宽带信号受到 &lt;strong&gt;频率选择性衰落&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判断信号受到何种衰落：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义信道的 &lt;strong&gt;相干带宽&lt;/strong&gt; 。当数字信号的带宽越小于信道的相干带宽，则经过时变多经信道后，在信号带宽内的不同频率分量的幅度的相关性越大，不同的频率分量近似经历相同的衰落，即平坦性衰落，平坦性衰落对接收信号的波形无明显影响，码间干扰可以忽略，该系统称为 &lt;strong&gt;窄带系统&lt;/strong&gt; 。当数字信号的带宽相对于信道的相干带宽越大时，信号带宽内的不同频率分量通过信道传输时会受到不同的衰落，即频率选择性衰落，频率选择性衰落使信号中的不同频率分量产生不同的幅度变化，造成接收信号的严重失真，引起吗见干扰，产生误码，该系统称为 &lt;strong&gt;宽带系统&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id="1.2. problem"&gt;1.2. Problem&lt;/h3&gt;
&lt;h4 id="1.2.1. xu qiu"&gt;1.2.1. 需求&lt;/h4&gt;
&lt;p&gt;无线信道的频率资源是有限的，要求数字通信系统有效利用信道频带。希望数据传输速率越高越好。&lt;/p&gt;
&lt;h4 id="1.2.2. ping jing"&gt;1.2.2. 瓶颈&lt;/h4&gt;
&lt;p&gt;在系统设计选择数字调制方式时，必须兼顾 &lt;strong&gt;频带利用率&lt;/strong&gt; 和 &lt;strong&gt;误码性能&lt;/strong&gt; 。在 AWGN 信道下，在满足误码性能的前提下，应该尽可能采用频带利用率高的数字调制方式。&lt;/p&gt;
&lt;p&gt;然而，在以衰落为特征的移动通信系统中，影响误码性能的不仅仅是 &lt;strong&gt;加性噪声&lt;/strong&gt;，还包括 &lt;strong&gt;衰落&lt;/strong&gt; 和 &lt;strong&gt;码间干扰&lt;/strong&gt; 。实现高速无线通信并非易事。&lt;/p&gt;
&lt;p&gt;为避免码间干扰，数字调制信号的最大符号速率受到很大的限制 。&lt;/p&gt;
&lt;h3 id="1.3. solution_1"&gt;1.3. Solution&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;信道均衡&lt;/strong&gt; 是一种经典的对抗码间干扰的技术，许多移动通信系统都采用信道均衡技术消除码间干扰。但是如果数据速率非常高，采用单载波传输数据，需要设计几十审计上百个抽头的均衡器，这简直是硬件设计的噩梦 。&lt;/p&gt;
&lt;p&gt;既要对抗码间干扰，又要满足低复杂度且高效的手段传输高速数据业务，我们可以采用另外一种技术 &amp;mdash;&amp;mdash; &lt;strong&gt;OFDM&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. ofdm history_1"&gt;2. OFDM History&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;多载波调制技术早在 20 世纪 50年代末至 60 年代初就已经应用于军事高频无线通信中，由于实现复杂，没有被广泛应用 。OFDM 就是一种多载波调制，其子载波间隔是子载波符号间隔的倒数，各子载波的频谱是重叠的，这种重叠可以使频谱效率显著提高 。&lt;/p&gt;
&lt;p&gt;20 世纪 70 年代，Weinstein 和 Ebert 提出用 &lt;strong&gt;离傅里叶变换(DFT)&lt;/strong&gt; 及其 &lt;strong&gt;逆变换(IDFT)&lt;/strong&gt; 进行 OFDM 多载波调制方式的运算。&lt;/p&gt;
&lt;p&gt;DFT 和 IDFT 的快速计算方法：FFT 和 IFFT 使 OFDM 能够以低成本的数字方式实现 。&lt;/p&gt;
&lt;p&gt;在 20 世纪 80 年代，随着 OFDM 理论的不断完善、数字信号处理及微电子技术的不断快速发展，OFDM 技术也逐步走向实用化 。&lt;/p&gt;
&lt;p&gt;大约从 20 世纪 90 年代起，OFDM 技术开始应用于各种有线及无线通信中，包括：DSL、DAB、DVB、WLAN等。OFDM 已经成为下一代蜂窝移动通信空中接口的候选技术 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. ofdm theory"&gt;3. OFDM Theory&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Orthogonal frequency-division multiplexing (OFDM) 的基本原理是将高速的数据流分解为多路并行的低速数据流，在多个载波上同时进行传输。&lt;/p&gt;
&lt;p&gt;通过将高速数据分解为多个并行低速速率，克服了信道时延扩展对数据速率的限制，其中各个子载波之间是相互正交的关系，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="carrier wave" src="/images/learning-ofdm-basic/carriers.png"/&gt;&lt;/p&gt;
&lt;p&gt;OFDM 每个子载波的调制方式可以相互不同，比如 BPSK、QPSK、QAM 等方式 。&lt;/p&gt;
&lt;p&gt;(OFDM 系统的内容可以写一本书了，简单写写 :-P )&lt;/p&gt;
&lt;h3 id="3.1. ofdm ji dai shu zi shi xian"&gt;3.1. OFDM 基带数字实现&lt;/h3&gt;
&lt;h4 id="3.1.1. fa song duan  transmitter"&gt;3.1.1. 发送端 Transmitter&lt;/h4&gt;
&lt;p&gt;基带系统发送端要实现的功能是将待发送序列 {A1,A2,A3...} 变换，得到复包络的采样值 {a1,a2,a3...} 。&lt;/p&gt;
&lt;p&gt;为了实现 OFDM 调制的基带数字实现，首先要将 OFDM 信号的复包络进行采样，成为离散时间信号 。根据公式(《通信原理》)，采样结果正好是对发送序列进行离散傅里叶反变换(IDFT)的结果，所以，我们可以 &lt;em&gt;借助 IDFT 即可得到 OFDM 复包络的时间采样 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;发送端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="transmitter" src="/images/learning-ofdm-basic/transmitter.png"/&gt;&lt;/p&gt;
&lt;h4 id="3.1.2. jie shou duan  receiver"&gt;3.1.2. 接收端 Receiver&lt;/h4&gt;
&lt;p&gt;基带系统接收端要实现的功能是对采样序列 {a1,a2,a3...} 进行变换，得到发送端发送过来的信息序列 {A1,A2,A3...} 。&lt;/p&gt;
&lt;p&gt;接收端通过 I/Q 正交解调可以恢复 OFDM 信号的复包络，将其采样得到的时间序列 。因为发送端采用的 IDFT 是可逆变换，所以对采样结果进行 DFT 就可以得到发送序列 。&lt;/p&gt;
&lt;p&gt;当序列的点数为 2 的整幂次时，DFT 和 IDFT 存在快速算法： FFT 和 IFFT 。&lt;/p&gt;
&lt;p&gt;接收端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="receiver" src="/images/learning-ofdm-basic/receiver.png"/&gt;&lt;/p&gt;
&lt;h3 id="3.2. xun huan qian zhui  cyclic prefix_1"&gt;3.2. 循环前缀 cyclic prefix&lt;/h3&gt;
&lt;p&gt;为了有效对抗多径信道的时延扩展，OFDM 系统由多个子载波构成，只要子载波的取值可以满足符号周期远大于信道的时延扩展，就可以达到目标。在此基础上，还需要采取措施消除前后两个 OFDM 符号之间的 &lt;strong&gt;码间干扰 ISI&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;一种方法是在每个 OFDM 符号之间插入 &lt;strong&gt;保护间隔 Guard Interval&lt;/strong&gt; 。为了对抗信号因信道延迟的影响，Gurad interval(Tg) 长度要大于最大的 Delay spread，即 Tg &amp;gt; delay spread time。&lt;/p&gt;
&lt;p&gt;在保护区间未放信号的 OFDM 系统称 ZP-OFDM(zero padding)。ZP-OFDM 有比较低的传输功率，但在接收端接收于 zero padding 区域信号时，会破坏载波的正交性造成 &amp;ldquo;&lt;strong&gt;载波间的干扰（ICI）&lt;/strong&gt;&amp;rdquo;，所以复制 OFDM symbol 后半段信号并摆放于保护区间内，称之为 &lt;strong&gt;循环字首(cyclic prefix)&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id="3.3. jia chuang ji zhu"&gt;3.3. 加窗技术&lt;/h3&gt;
&lt;p&gt;前面介绍了 OFDM 符号的生成、循环前缀消除码间干扰，但是此时符号边界有尖锐的相位跳变，由此可知，OFDM 的带外衰减是比较慢的 。虽然随着载波数目的增大，OFDM 信号的带外衰减会增加，但是仍然不够快 。&lt;/p&gt;
&lt;p&gt;为了使 OFDM 信号的带外衰减更快，可以采用对单个 OFDM 符号加窗的方法 。OFDM 的窗函数可以使信号的幅度在u符号边界更平滑地过渡到 0 。常用的窗函数是 &lt;strong&gt;升余弦滚降窗&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;增大滚降因子虽然能够使带外衰减更快，但降低了 OFDM 系统对多经实验的容忍能力，所以 &lt;em&gt;在实际系统设计中，应当选择较小的滚降因子 。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="3.4. ofdm xi tong she ji"&gt;3.4. OFDM 系统设计&lt;/h3&gt;
&lt;p&gt;OFDM 系统框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ofdm-system" src="/images/learning-ofdm-basic/ofdm_system.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;交织&lt;/strong&gt; 是为了克服深衰落发生突发差错的影响，如果交织器的长度足够大，解交织后可将突发差错改造为独立差错，再通过纠错译码来纠正 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在发送端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二进制数据&lt;/em&gt; 通过纠错编码、交织后映射到 QAM 星座得到 &lt;em&gt;一个 QAM 复数符号序列&lt;/em&gt;，再经过并串转换，得到 &lt;em&gt;N个并行 QAM 符号&lt;/em&gt;，每个符号进行 IFFT，将 OFDM 复包络的频域样值变换为 &lt;em&gt;时域样值&lt;/em&gt;，进行并串转换，将时域样值变换为按时间顺序排列的 &lt;em&gt;时域样值&lt;/em&gt;，然后在每个 OFDM 符号前插入前缀，通过 D/A，将离散的复包络变成 &lt;em&gt;连续时间的复包络&lt;/em&gt; 。再将复包络的 I(t) 和 Q(t) 正交调制得到 &lt;em&gt;OFDM信号&lt;/em&gt;，将基带信号上变频到射频，经过功放，发送出去 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端于发送端进行相反的变换，恢复出原数据 .&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. can kao_1"&gt;4. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;《通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4130536/"&gt;《移动通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Orthogonal_frequency-division_multiplexing"&gt;OFDM wikipedia&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="OFDM"></category></entry><entry><title>原码、反码、补码</title><link href="http://guqian110.github.io/posts/telecom/signed_number_representations.html" rel="alternate"></link><published>2014-03-19T14:31:00+08:00</published><updated>2014-03-19T14:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:guqian110.github.io,2014-03-19:/posts/telecom/signed_number_representations.html</id><summary type="html">&lt;p&gt;最近找到一本好书——《编码: 隐匿在计算机软硬件背后的语言》 。作者是大名鼎鼎的 Charles Petzold 。看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 Google、Wiki，于是总结出下文 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近找到一本好书&amp;mdash;&amp;mdash;&lt;a href="http://book.douban.com/subject/4822685/"&gt;《编码: 隐匿在计算机软硬件背后的语言》&lt;/a&gt;。作者是大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; (&lt;a href="http://charlespetzold.com/"&gt;个人网站&lt;/a&gt;)。书的介绍也很有意思，据说完全不懂计算机的人也能看懂...于是买了本来拜读一下（这种文章当然是英文版最好了，只是学生党没银子，只好买翻译版了）&lt;/p&gt;
&lt;p&gt;看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 &lt;a href="https://www.google.com.hk/"&gt;Google&lt;/a&gt;、&lt;a href="http://en.wikipedia.org/wiki/Main_Page"&gt;Wiki&lt;/a&gt;，于是总结出下文。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. ji ben gai nian"&gt;1. 基本概念&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="1.1. ji qi shu"&gt;1.1. 机器数&lt;/h3&gt;
&lt;p&gt;顾名思义，一个数字在机器中的存储方式，&amp;ldquo;&lt;em&gt;数&lt;/em&gt; &amp;rdquo; 是指 有符号数（&lt;code&gt;signed number&lt;/code&gt;），即包含了正负号的数，&amp;ldquo;&lt;em&gt;机器&lt;/em&gt; &amp;rdquo; 当然是指计算机（&lt;code&gt;Computer&lt;/code&gt;）了。&lt;/p&gt;
&lt;p&gt;从小学毕业，刚进入初中，我们就知道数字是有符号的：&lt;em&gt;正数&lt;/em&gt; &amp;amp; &lt;em&gt;负数&lt;/em&gt;。但是在计算机的哲学体系中，整个世界只有两个元素：0 &amp;amp; 1 ，没有额外的专门表示正负号的符号。怎么办呢？解决方法就是添加一位来表示符号。于是，人们约定把符号位放在一个数字的 &lt;em&gt;最高有效位&lt;/em&gt;（Most significant bit, &lt;code&gt;MSB&lt;/code&gt;），在&lt;a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F"&gt;大端序&lt;/a&gt;中，&lt;code&gt;MSB&lt;/code&gt; 指的是一个二进制数的最左边的一位。一般，&lt;code&gt;MSB&lt;/code&gt; 等于 0  表示正数，1 表示负数。&lt;/p&gt;
&lt;h3 id="1.2. zhen zhi"&gt;1.2. 真值&lt;/h3&gt;
&lt;p&gt;因为机器数中有一位表示符号，所以机器数的形式值不等于真正的数值，机器数对应的数值称为机器数的 &lt;em&gt;真值&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;
举个栗子：&lt;/p&gt;
&lt;p&gt;用 8 bit 表示一个数字，因为有符号位的存在，可以表示的范围为 (-127, -0, +0, +127) 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="err"&gt;的&lt;/span&gt; &lt;span class="err"&gt;机器数&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0000&lt;/span&gt;&lt;span class="n"&gt;_0101&lt;/span&gt; &lt;span class="err"&gt;；真值&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;000&lt;/span&gt;&lt;span class="n"&gt;_0101&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="err"&gt;的&lt;/span&gt; &lt;span class="err"&gt;机器数&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="n"&gt;_0101&lt;/span&gt; &lt;span class="err"&gt;；真值&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;000&lt;/span&gt;&lt;span class="n"&gt;_0101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种机器数的编码方式称为 &lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;&lt;em&gt;原码&lt;/em&gt;&lt;/a&gt; (&lt;code&gt;signed-magnitude&lt;/code&gt;) ，是机器数编码方式中的一种。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The four best-known methods of extending the binary numeral system to represent signed numbers are: sign-and-magnitude, Ones' complement, two's complement, and excess-K.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There is no definitive criterion by which any of the representations is universally superior. The representation used in most current computing devices is two's complement, although the Unisys ClearPath Dorado series mainframes use Ones' complement.&lt;/em&gt;
（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Wikipeida&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. ji qi shu biao shi fa_1"&gt;2. 机器数表示法&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="2.1. yuan ma (sign and magnitude)"&gt;2.1. 原码（sign and magnitude）&lt;/h3&gt;
&lt;h4 id="2.1.1. bian ma gui ze"&gt;2.1.1. 编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;正数：&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;_xxxxxxx&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;负数：&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;_xxxxxxx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8 bit 的原码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4 id="2.1.2. ji suan fa ze"&gt;2.1.2. 计算法则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;两数符号相同：&lt;/span&gt;  &lt;span class="err"&gt;低位相加，最高位的符号位不变（当低位相加产生进位时，溢出&lt;/span&gt; &lt;span class="n"&gt;Overflow&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;两数符号不同：&lt;/span&gt;  &lt;span class="err"&gt;比较绝对值的大小，差的绝对值&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;大数&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="err"&gt;小数&lt;/span&gt; &lt;span class="err"&gt;，符号位和大数的符号位相同&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="2.1.3. que dian"&gt;2.1.3. 缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电路复杂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从前面的计算方法中可以看到，原码中的符号位不能直接参与运算，必须要单独的线路来确定符号位&lt;/li&gt;
&lt;li&gt;原码的计算不能避免减法运算，加法运算是产生 &lt;em&gt;进位&lt;/em&gt;，减法运算需要 &lt;em&gt;借位&lt;/em&gt;，这是两种不同的运算过程，需要额外的电路把 &lt;code&gt;加法器&lt;/code&gt; 改造为 &lt;code&gt;减法器&lt;/code&gt;（&lt;a href="http://www.charlespetzold.com/code/"&gt;《编码》&lt;/a&gt;这本书里面有详细介绍 如何使用继电器搭建 加法器 和 减法器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0的表示不唯一&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0可以编码为两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1000_0000&lt;/code&gt;，进一步增加了逻辑的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="2.1.4. zong jie"&gt;2.1.4. 总结&lt;/h4&gt;
&lt;p&gt;This approach is directly comparable to the common way of showing a sign (placing a "+" or "&amp;minus;" next to the number's magnitude). Some early binary computers (e.g., &lt;a href="http://en.wikipedia.org/wiki/IBM_7090"&gt;IBM 7090&lt;/a&gt;) used this representation, perhaps because of its natural relation to common usage. Signed magnitude is the most common way of representing the significand in floating point values.
（&lt;a href="http://en.wikipedia.org/wiki/Signed_magnitude#Signed_magnitude_representation"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;虽然 &lt;code&gt;原码&lt;/code&gt; 的编码方式最接近人类的习惯，但是，并不适合在计算机中使用，为了解决原码计算中的一些问题，于是 &lt;code&gt;反码&lt;/code&gt; 就出现了&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="2.2. fan ma (ones' complement)_1"&gt;2.2. 反码（Ones' complement）&lt;/h3&gt;
&lt;p&gt;首先，来看看 &lt;a href="http://www.charlespetzold.com/code/"&gt;Code&lt;/a&gt; 中介绍了基于10进制的补码：&lt;/p&gt;
&lt;p&gt;实现一个减法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照我们从数学课上学习到知识，这个计算需要进行 &lt;em&gt;借位&lt;/em&gt; 操作，为了避免这个在计算机中很难实现的操作，可以稍微变化一下计算过程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个过程中，用两个减法代替了原来的一个减法，避免了烦琐的 &lt;em&gt;借位&lt;/em&gt; 操作。在这个运算中，负数 &lt;code&gt;-176&lt;/code&gt; 转化为另外一个数 &lt;code&gt;999 - 176&lt;/code&gt; ，这个数称为它的 &lt;code&gt;9 的补数(nine's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 9 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;1 的补数(Ones' complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;把减数从一串 1 当中减去，结果就称为这个数的 &amp;ldquo;1 的补数&amp;rdquo;，在求 1 的补数的时候，其实并不需要做减法，因为求 1 的补数，只需要将原来的 1 变为 0 ，0 变为 1 即可，也就是取反，在电路中只需要一个反向器就可以实现，所以 &lt;code&gt;1 的补数&lt;/code&gt; 也称为 &lt;code&gt;反码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;从上面的描述就可以很容易写出反码的编码规则&lt;/p&gt;
&lt;h4 id="2.2.1. bian ma gui ze"&gt;2.2.1. 编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;正数&lt;/span&gt;    &lt;span class="err"&gt;反码&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;原码&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;负数&lt;/span&gt;    &lt;span class="err"&gt;反码&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;符号位不变，其他位取反&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8 bit 的反码可以表示的范围是 [ -127, -0, +0, +127 ]，共 255 个数&lt;/p&gt;
&lt;h4 id="2.2.2. ji suan fa ze"&gt;2.2.2. 计算法则&lt;/h4&gt;
&lt;p&gt;反码的计算不用区分符号和绝对值，直接进行计算，计算结果若有溢出，需要将溢出加到最低位，这种操作称为 &amp;ldquo;循环进位&amp;rdquo;（end-around carry）&lt;/p&gt;
&lt;h4 id="2.2.3. you que dian"&gt;2.2.3. 优缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;优点，电路简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，所以反码计算不需要单独的判断符号的电路，也不需要判断两个数绝对值相对大小的电路&lt;/li&gt;
&lt;li&gt;节省了减法器，只需要一组额外的反向器就能把加法器改进为可以计算 加 / 减法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机中仍然需要进行 &amp;ldquo;循环进位&amp;rdquo; 的硬件电路，但是这种复杂度的电路是可以接受的&lt;/li&gt;
&lt;li&gt;0的表示不唯一，0的编码仍然有两种方式： &lt;code&gt;0000_0000&lt;/code&gt; 和 &lt;code&gt;1111_1111&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h4 id="2.2.4. zong jie"&gt;2.2.4. 总结&lt;/h4&gt;
&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/PDP-1"&gt;PDP-1&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_160_series"&gt;CDC 160 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC_6000_series"&gt;CDC 6000 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/UNIVAC_1100"&gt;UNIVAC 1100 series&lt;/a&gt;, and the &lt;a href="http://en.wikipedia.org/wiki/LINC"&gt;LINC&lt;/a&gt; computer used Ones' complement representation.（&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;反码&lt;/code&gt; 中仍然没有避免 0 有两种编码方式的问题，虽然对于人来说，+0 和 -0 没有区别，但是对于计算机来说，判断一个数是否为0，要进行两次判断。为了解决 0 的表示问题和硬件上的 &amp;ldquo;循环进位&amp;rdquo;，于是人们又发明了 &lt;code&gt;补码&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="2.3. bu ma (two's complement)_1"&gt;2.3. 补码（Two's complement）&lt;/h3&gt;
&lt;p&gt;前面介绍的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照反码的方法可以转换为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果我们稍微再变形一下，就有&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (1000 - 176) - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个运算中 &lt;code&gt;-176&lt;/code&gt; 转化为 &lt;code&gt;1000 - 176&lt;/code&gt;，这个数称为它的 &lt;code&gt;10 的补数(ten's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 10 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;2 的补数(two's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;因为对一位二进制数 b 取补码就是 &lt;code&gt;1 - b + 1 = 10 - b&lt;/code&gt;，相当于从 2 里面减去 b ,所以，这种方法称为 &lt;code&gt;2 的补数&lt;/code&gt;，这种编码方式简称 &lt;code&gt;补码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;举例说明，要表示 -4 ，需要对 &lt;code&gt;0000_0100&lt;/code&gt;取补码，&lt;code&gt;1111_1111 - 0000_0100 + 1 = 1_0000_0000 - 0000_0100&lt;/code&gt;，相当于从2^8里面减去 4 。&lt;/p&gt;
&lt;p&gt;从上面的计算过程可以很容易写出补码的编码规则&lt;/p&gt;
&lt;h4 id="2.3.1. bian ma gui ze"&gt;2.3.1. 编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;正数&lt;/span&gt;    &lt;span class="err"&gt;补码&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;原码&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;负数&lt;/span&gt;    &lt;span class="err"&gt;补码&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;反码&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8 bit补码可以表示的范围是 [ -128, -1, +0, +127 ]，共 256 个数 。&lt;/p&gt;
&lt;p&gt;目前大多数计算机内部使用的都是补码，所以对于编程中的 32 位 &lt;code&gt;int&lt;/code&gt; 型变量，它可以表示的范围就是 [ -2^32, +2^32 - 1] 。&lt;/p&gt;
&lt;p&gt;P.S. -128 没有对应的 原码 和反码，它的补码为 &lt;code&gt;1000_0000&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id="2.3.2. ji suan fa ze"&gt;2.3.2. 计算法则&lt;/h4&gt;
&lt;p&gt;采用补码的系统，减法转换成加法（减法等同于加上一个负数，所以不再有减法），忽略计算结果最高位的进位，不必加回到最低位上去。&lt;/p&gt;
&lt;h4 id="2.3.3. you dian"&gt;2.3.3. 优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;电路简单，从计算法则中可以看到，不用考虑 &amp;ldquo;循环进位&amp;rdquo; 的问题，所以，补码系统的电路是最简单的，这也是补码系统应用最广泛的原因&lt;/li&gt;
&lt;li&gt;0 的表示是唯一的，&lt;code&gt;0000_0000&lt;/code&gt;，不再有 -0 的困扰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2.3.4. bu ma zhong de shu xue yuan li"&gt;2.3.4. 补码中的数学原理&lt;/h4&gt;
&lt;p&gt;补码能将减法转化为加法，其数学原理就是 &lt;em&gt;模&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;如果有个手表的时间为&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="err"&gt;点，实际时间为&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;点，那么如何校准呢？&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="err"&gt;答案有两种方法：&lt;/span&gt;

&lt;span class="o"&gt;#&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;逆时针转动&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;，也就是做&lt;/span&gt; &lt;span class="err"&gt;减法&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="o"&gt;#&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="err"&gt;顺时针转动&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;也就是做&lt;/span&gt; &lt;span class="err"&gt;加法&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;mod&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从这个例子中就可以很明白的看到 &lt;em&gt;减法&lt;/em&gt; 是如何转化为 &lt;em&gt;加法&lt;/em&gt; 的，也就是如何将一个 &lt;em&gt;负数&lt;/em&gt; 转化为 &lt;em&gt;正数&lt;/em&gt;的 。&lt;/p&gt;
&lt;p&gt;即有公式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A - B = A + (-B + M)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个式子中的 &lt;code&gt;-B + M&lt;/code&gt; 即为 &lt;code&gt;B&lt;/code&gt; 的 &lt;em&gt;补数&lt;/em&gt; （类似于几何中的&lt;em&gt;补角&lt;/em&gt;） 。&lt;/p&gt;
&lt;h4 id="2.3.5. yi chu wen ti (zhai zi  bai du bai ke )"&gt;2.3.5. 溢出问题（摘自 &lt;a href="http://baike.baidu.com/view/60437.htm"&gt;百度百科&lt;/a&gt;）&lt;/h4&gt;
&lt;p&gt;无论采用何种机器数，只要运算的结果大于数值设备所能表示数的范围，就会产生溢出。 溢出现象应当作一种故障来处理，因为它使结果数发生错误。异号两数相加时，实际是两数的绝对值相减，不可能产生溢出，但有可能出现正常进位；同号两数相加时，实际上是两数的绝对值相加，既可能产生溢出，也可能出现正常进位。&lt;/p&gt;
&lt;p&gt;由于补码运算存在符号位进位自然丢失而运算结果正确的问题，因此，应区分补码的溢出与正常进位。&lt;/p&gt;
&lt;p&gt;详细论证过程不再复制粘贴了...直接给出结论&lt;/p&gt;
&lt;p&gt;结论：在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。&lt;/p&gt;
&lt;h4 id="2.3.6. zong jie"&gt;2.3.6. 总结&lt;/h4&gt;
&lt;p&gt;由 &lt;em&gt;&amp;ldquo;减去一个数 = 加上一个负数&amp;rdquo;&lt;/em&gt;，计算机系统内部就不再有减法操作&lt;/p&gt;
&lt;p&gt;由 &lt;em&gt;&amp;ldquo;负数的表示由取模运算转变为补码表示&amp;rdquo;&lt;/em&gt;，计算机系统就可以用一个正数来表示负数&lt;/p&gt;
&lt;p&gt;所以，计算机内部只需要加法器就可以完成 加减法 和 正负数 的表示 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Two's complement is the easiest to implement in hardware, which may be the ultimate reason for its widespread popularity. Processors on the early mainframes often consisted of thousands of transistors &amp;ndash; eliminating a significant number of transistors was a significant cost savings. Mainframes such as the IBM System/360, the GE-600 series, and the PDP-6 and PDP-10 used two's complement, as did minicomputers such as the PDP-5 and PDP-8 and the PDP-11 and VAX. The architects of the early integrated circuit-based CPUs (Intel 8080, etc.) chose to use two's complement math. As IC technology advanced, virtually all adopted two's complement technology. x86, m68k, Power Architecture, MIPS, SPARC, ARM, Itanium, PA-RISC, and DEC Alpha processors are all two's complement.&lt;/em&gt;(&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations#Two.27s_complement"&gt;Wiki&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. you fu hao shu he wu fu hao shu (zhai zi  zheng shu de jia jian yun suan )_2"&gt;3. 有符号数和无符号数（摘自 &lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;）&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;如果把所有的位数都用来表示数值的大小，那么8 bit 二进制数可以表示的范围是 [0, 255] ，这种称为无符号数 。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="o"&gt;#&lt;/span&gt;   &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="n"&gt;_0010&lt;/span&gt;              &lt;span class="mi"&gt;130&lt;/span&gt;                  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;126&lt;/span&gt;
    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1111&lt;/span&gt;&lt;span class="n"&gt;_1000&lt;/span&gt;     &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;   &lt;span class="o"&gt;+&lt;/span&gt;   &lt;span class="mi"&gt;256&lt;/span&gt;          &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="c1"&gt;--------------      ---------------      -----------&lt;/span&gt;
    &lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;_0111_1010&lt;/span&gt;              &lt;span class="mi"&gt;122&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;             &lt;span class="mi"&gt;122&lt;/span&gt;

    &lt;span class="o"&gt;#&lt;/span&gt;                        &lt;span class="err"&gt;无符号数（&lt;/span&gt;&lt;span class="n"&gt;ok&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;        &lt;span class="err"&gt;有符号数（&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算机的加法器在做完计算之后，根据最高位产生的进位设置 &lt;em&gt;进位标志&lt;/em&gt; ，同时根据最高位和次高位产生的进位的异或设置 &lt;em&gt;溢出标志&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;如果看作无符号数130和248相加，计算结果是122进1，也就是122+256，这个结果是对的; 如果把这两个操作数看作有符号数-126和-8相加，计算结果是错的，因为产生了溢出 。&lt;/p&gt;
&lt;p&gt;至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。&lt;/p&gt;
&lt;p&gt;通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有bit都是零则设置零标志，如果计算结果的最高位是1则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;从 &lt;code&gt;原码&lt;/code&gt; 到 &lt;code&gt;反码&lt;/code&gt;，再到 &lt;code&gt;补码&lt;/code&gt;，可以清楚看到为了解决问题而改进的技术路线，虽然这些是非常基础知识，可能对我们对写程序没有很大的帮助，但是搞清楚这些不仅让你对计算机底层更加了解，更加关键的是 &lt;em&gt;这个学习过程&lt;/em&gt; 和 &lt;em&gt;解决编码问题的思路&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. can kao wen xian"&gt;4. 参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signed_number_representations"&gt;Signed number representations&amp;mdash;&amp;mdash;Wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ones'_complement"&gt;Ones' complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Two's_complement"&gt;Two's complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://baike.baidu.com/view/60437.htm"&gt;机器数&amp;mdash;&amp;mdash;百度百科&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="Code"></category></entry></feed>