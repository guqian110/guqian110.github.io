<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Qian's Blog - Linux</title><link href="https://qiangu.cool/" rel="alternate"></link><link href="https://qiangu.cool/feeds/linux.atom.xml" rel="self"></link><id>https://qiangu.cool/</id><updated>2015-05-06T10:37:00+08:00</updated><subtitle>Stay hungry. Stay foolish.</subtitle><entry><title>学习 Vim 之 vim_signature 插件</title><link href="https://qiangu.cool/posts/linux/learning_vim_signature_plugin.html" rel="alternate"></link><published>2015-05-06T10:37:00+08:00</published><updated>2015-05-06T10:37:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-05-06:/posts/linux/learning_vim_signature_plugin.html</id><summary type="html">&lt;p&gt;学习 vim 书签的基本知识和 vim_signature 插件的使用方法&lt;/p&gt;</summary><content type="html">&lt;p&gt;在追踪代码时，经常跳转到很多新文件中，想回到原点时就比较麻烦了，这时候就需要 &amp;ldquo;书签&amp;rdquo; 了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. bookmarks"&gt;1. Bookmarks&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;用 &lt;code&gt;:help marks&lt;/code&gt; 来查看关于书签的说明：&lt;/p&gt;
&lt;p&gt;书签可以分为 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;lowercase marks&lt;/p&gt;
&lt;p&gt;书签名只能为 'a - 'z，只在所在文件内有效，不能在文件之间跳转，不同书签名不能包含有相同字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uppercase  marks&lt;/p&gt;
&lt;p&gt;书签名只能为 'A - 'Z，也叫文件书签，可以在文件之间跳转，不同书签名不能包含有相同字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;numbered marks&lt;/p&gt;
&lt;p&gt;书签名只能为 '0 - '9，用 &lt;code&gt;.viminfor&lt;/code&gt; 文件来设置&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用字母 a-zA-Z 建立的书签能被保存下来，再次打开时仍然存在，而用数字 0-9 建立的书签在关闭文件后就被删除了，不能恢复，所以 一般使用 a-zA-Z 更多一点吧。&lt;/p&gt;
&lt;p&gt;知道这些最基本的东西就可以顺利使用书签了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;help 文档中说 numbered marks 不能手动设置，实际上是可以的，不知道是不是我理解错了，不过这个应该不影响平常的使用。&lt;/p&gt;
&lt;h3 id="1.1. usage"&gt;1.1. Usage&lt;/h3&gt;
&lt;p&gt;常用的几个 Vim 内置的书签命令如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置书签 &lt;code&gt;m{a-zA-Z}&lt;/code&gt;，如 ma&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除书签 &lt;code&gt;delm {marks}&lt;/code&gt;，如 delm a&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转书签&lt;/p&gt;
&lt;p&gt;跳转有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 backtick 键（数字 1 键左边），跳转到设置书签时光标所在的行和列，如 `a&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用单引号 &lt;code&gt;'&lt;/code&gt;，跳转到书签所在行的第一个非空字符处（不包含列信息），如 'a&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;`` 回到到上次修改的位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出所有书签 &lt;code&gt;:marks&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. vim-signature_1"&gt;2. Vim-signature&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;使用 Vim 书签时，最大的不方便之处是：书签是不可见的，也就是说我们输入命令之后，是无法看到书签是否建立成功了，外观上是看不出书签行和普通行的区别的。还好有个很不错的插件 &lt;a href="https://github.com/kshenoy/vim-signature"&gt;vim-signature&lt;/a&gt; 可以帮助我们实现可视化的书签。&lt;/p&gt;
&lt;p&gt;在 github 项目上有这个插件的简单介绍，另外在 Vim 中也可以看 help 文档查阅详细帮助，这里只记录我用到简单配置。&lt;/p&gt;
&lt;h3 id="2.1. install"&gt;2.1. Install&lt;/h3&gt;
&lt;p&gt;使用这个插件需要 vim 支持 sign 特性，使用命令 &lt;code&gt;:echo has('signs')&lt;/code&gt; 来查看 vim 是否支持这个特性，如果结果是 1，则支持，如果结果是 0，需要重新编译 vim。&lt;/p&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'vim-signature'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="2.2. usage"&gt;2.2. Usage&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;:help signature&lt;/code&gt; 可以查看帮助文档。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;mx&lt;/span&gt;           &lt;span class="nv"&gt;Toggle&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;x&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;display&lt;/span&gt; &lt;span class="nv"&gt;it&lt;/span&gt; &lt;span class="nv"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;leftmost&lt;/span&gt; &lt;span class="nv"&gt;column&lt;/span&gt;
&lt;span class="nv"&gt;dmx&lt;/span&gt;          &lt;span class="nv"&gt;Remove&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;x&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt; &lt;span class="nv"&gt;where&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;zA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Z&lt;/span&gt;

&lt;span class="nv"&gt;m&lt;/span&gt;,           &lt;span class="nv"&gt;Place&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;available&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt;
&lt;span class="nv"&gt;m&lt;/span&gt;.           &lt;span class="k"&gt;If&lt;/span&gt; &lt;span class="nv"&gt;no&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt; &lt;span class="nv"&gt;on&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;, &lt;span class="nv"&gt;place&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;available&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt;. &lt;span class="nv"&gt;Otherwise&lt;/span&gt;, &lt;span class="nv"&gt;remove&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;first&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;     &lt;span class="nv"&gt;existing&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt;.
&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;           &lt;span class="nv"&gt;Delete&lt;/span&gt; &lt;span class="nv"&gt;all&lt;/span&gt; &lt;span class="nv"&gt;marks&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt;
&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;     &lt;span class="nv"&gt;Delete&lt;/span&gt; &lt;span class="nv"&gt;all&lt;/span&gt; &lt;span class="nv"&gt;marks&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;
]`           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt;
[`           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;prev&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt;
]&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;           Jump to start of next line containing a mark&lt;/span&gt;
[&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;           Jump to start of prev line containing a mark&lt;/span&gt;
`]           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;by&lt;/span&gt; &lt;span class="nv"&gt;alphabetical&lt;/span&gt; &lt;span class="nv"&gt;order&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt;
`[           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;by&lt;/span&gt; &lt;span class="nv"&gt;alphabetical&lt;/span&gt; &lt;span class="nv"&gt;order&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;prev&lt;/span&gt; &lt;span class="nv"&gt;mark&lt;/span&gt;
&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;]           Jump by alphabetical order to start of next line having a mark&lt;/span&gt;
&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;[           Jump by alphabetical order to start of prev line having a mark&lt;/span&gt;
&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;           &lt;span class="nv"&gt;Open&lt;/span&gt; &lt;span class="nv"&gt;location&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;display&lt;/span&gt; &lt;span class="nv"&gt;marks&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;

&lt;span class="nv"&gt;m&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;]       &lt;span class="nv"&gt;Toggle&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;corresponding&lt;/span&gt; &lt;span class="nv"&gt;marker&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;@#$&lt;span class="o"&gt;%^&amp;amp;*&lt;/span&gt;&lt;span class="ss"&gt;()&lt;/span&gt;
&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;S&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;]&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;   &lt;span class="nv"&gt;Remove&lt;/span&gt; &lt;span class="nv"&gt;all&lt;/span&gt; &lt;span class="nv"&gt;markers&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;same&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt;
]&lt;span class="o"&gt;-&lt;/span&gt;           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;having&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;marker&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;same&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt;
[&lt;span class="o"&gt;-&lt;/span&gt;           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;prev&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;having&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;marker&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;same&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt;
]&lt;span class="o"&gt;=&lt;/span&gt;           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="k"&gt;next&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;having&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;marker&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;any&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt;
[&lt;span class="o"&gt;=&lt;/span&gt;           &lt;span class="nv"&gt;Jump&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;prev&lt;/span&gt; &lt;span class="nv"&gt;line&lt;/span&gt; &lt;span class="nv"&gt;having&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;marker&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;any&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt;
&lt;span class="nv"&gt;m&lt;/span&gt;?           &lt;span class="nv"&gt;Open&lt;/span&gt; &lt;span class="nv"&gt;location&lt;/span&gt; &lt;span class="nv"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;display&lt;/span&gt; &lt;span class="nv"&gt;markers&lt;/span&gt; &lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;current&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;
&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;BS&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;        &lt;span class="nv"&gt;Remove&lt;/span&gt; &lt;span class="nv"&gt;all&lt;/span&gt; &lt;span class="nv"&gt;markers&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且 help 中列出了具体配置，我们可以对其修改，自定义快捷键。总结一下我常用的操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置书签 &lt;code&gt;mx&lt;/code&gt;，比如 ma&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除书签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接在目标行重新输入 &lt;code&gt;mx&lt;/code&gt;，旧书签就会被删除，并且设定到光标所在行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将光标移动到旧书签行，重新输入 &lt;code&gt;mx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有 lowercase + uppercase marks，&lt;code&gt;m&amp;lt;Space&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有 numbered marks，&lt;code&gt;m&amp;lt;BS&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转书签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;]`，跳转到前一个书签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[`，跳转到后一个书签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;]-，跳转到之前同一类型的 numbered marks 书签行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[-，跳转到之后同一类型的 numbered marks 书签行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. ref_1"&gt;3. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/kshenoy/vim-signature"&gt;vim-signature&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.tuicool.com/articles/f6feae"&gt;像 IDE 一样使用 Vim&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Vim"></category><category term="vim_signature"></category></entry><entry><title>学习 Vim 之 lookupfile 插件</title><link href="https://qiangu.cool/posts/linux/learning_vim_lookupfile_plugin.html" rel="alternate"></link><published>2015-05-03T00:00:00+08:00</published><updated>2015-05-03T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-05-03:/posts/linux/learning_vim_lookupfile_plugin.html</id><summary type="html">&lt;p&gt;学习使用 lookupfile 插件。&lt;/p&gt;</summary><content type="html">&lt;p&gt;系统内置的 &lt;code&gt;:find&lt;/code&gt; 命令不够好：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;项目比较大，文件比较多时，查找速度慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须输入文件全名，而且不能使用正则表达式查找&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而使用 NERDTree 的话，在一个小窗口内，按照目录浏览查找的效率也很低。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lookupfile&lt;/code&gt; 这个插件可以实现类似 Sublime Text 中 Ctrl + P 的效果，只需要输入文件的部分名字即可匹配查找到文件。&lt;/p&gt;
&lt;h2 id="1. install"&gt;1. Install&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;lookupfile 需要 &lt;code&gt;genutils&lt;/code&gt; 插件的支持，使用 Vundle 安装两个插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'genutils'&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'lookupfile'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. config"&gt;2. Config&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;关于 lookupfile 的详细配置，查看 help 文档，下面是几个常用的配置选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;LookupFile_MinPatLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;LookupFile_PreserveLastPattern&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;LookupFile_PreservePatternHistory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;LookupFile_AlwaysAcceptFirst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;LookupFile_AllowNewFiles&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="2.1. tags"&gt;2.1. tags&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-lookupfile-plugin/"&gt;vi/vim使用进阶: lookupfile插件&lt;/a&gt; 中介绍到 lookupfile 可以使用 ctags 生成的 tags 文件来查找，不过其查找效率比较低，所以作者写了一个 shell 脚本来生成专用的 tags 文件：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c1"&gt;# generate tag file for lookupfile plugin&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="s2"&gt;"!_TAG_FILE_SORTED\t2\t/2=foldcase/"&lt;/span&gt; &amp;gt; filenametags
find . -not -regex &lt;span class="s1"&gt;'.*\.\(png\|gif\)'&lt;/span&gt; -type f -printf &lt;span class="s2"&gt;"%f\t%p\t1\n"&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    sort -f &amp;gt;&amp;gt; filenametags
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;为了方便起见，把这个脚本保存为 &lt;code&gt;genfiletags&lt;/code&gt; 文件，然后将其移动到专门存放常用 shell 脚本的目录下，将这个目录添加到系统变量 &lt;code&gt;$PATH&lt;/code&gt; 中，这样在 vim 中直接运行 &lt;code&gt;:!genfiletags&lt;/code&gt; 就可以生成 tags 文件了。&lt;/p&gt;
&lt;p&gt;生成好 tags 文件后，还要配置 vim，告诉它使用这个文件来查找：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;filereadable&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;./filenametags&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_TagExpr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;"./filenametags"&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;
&lt;span class="k"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="2.2. case sensitive"&gt;2.2. case sensitive&lt;/h3&gt;
&lt;p&gt;lookupfile 插件是大小写敏感的，可以在查找到时候加上 &lt;code&gt;\c&lt;/code&gt; 就能忽略大小写，不过这样很麻烦，下面是更加简单的方法，在 .vimrc 中添加下面这段代码即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;function&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="nv"&gt;LookupFile_IgnoreCaseFunc&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pattern&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;_tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt;
    &lt;span class="nv"&gt;try&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;eval&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_TagExpr&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;newpattern&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;\c&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt; . &lt;span class="nv"&gt;a&lt;/span&gt;:&lt;span class="nv"&gt;pattern&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;taglist&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;newpattern&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;catch&lt;/span&gt;
        &lt;span class="nv"&gt;echohl&lt;/span&gt; &lt;span class="nv"&gt;ErrorMsg&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;Exception: &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; . &lt;span class="nv"&gt;v&lt;/span&gt;:&lt;span class="nv"&gt;exception&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;echohl&lt;/span&gt; &lt;span class="nv"&gt;NONE&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
    &lt;span class="nv"&gt;finally&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;_tags&lt;/span&gt;
    &lt;span class="nv"&gt;endtry&lt;/span&gt;

    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Show the matches for what is typed so far.&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;map&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt;, &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;v:val["filename"]&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;files&lt;/span&gt;
&lt;span class="nv"&gt;endfunction&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_LookupFunc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;LookupFile_IgnoreCaseFunc&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="2.3. summary"&gt;2.3. Summary&lt;/h3&gt;
&lt;p&gt;综上，.vimrc 中的配置内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Config lookupfile&lt;/span&gt;
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_MinPatLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_PreserveLastPattern&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_PreservePatternHistory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_AlwaysAcceptFirst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_AllowNewFiles&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;filereadable&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;./filenametags&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_TagExpr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;"./filenametags"&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;
&lt;span class="k"&gt;endif&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;silent&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;lk&lt;/span&gt; :&lt;span class="nv"&gt;LUTags&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;silent&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;ll&lt;/span&gt; :&lt;span class="nv"&gt;LUBufs&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;silent&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;lw&lt;/span&gt; :&lt;span class="nv"&gt;LUWalk&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; lookup file with ignore case&lt;/span&gt;
&lt;span class="nv"&gt;function&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="nv"&gt;LookupFile_IgnoreCaseFunc&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pattern&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;_tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt;
    &lt;span class="nv"&gt;try&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;eval&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_TagExpr&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;newpattern&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;\c&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt; . &lt;span class="nv"&gt;a&lt;/span&gt;:&lt;span class="nv"&gt;pattern&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;taglist&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;newpattern&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;catch&lt;/span&gt;
        &lt;span class="nv"&gt;echohl&lt;/span&gt; &lt;span class="nv"&gt;ErrorMsg&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;Exception: &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; . &lt;span class="nv"&gt;v&lt;/span&gt;:&lt;span class="nv"&gt;exception&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;echohl&lt;/span&gt; &lt;span class="nv"&gt;NONE&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
    &lt;span class="nv"&gt;finally&lt;/span&gt;
        &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;_tags&lt;/span&gt;
    &lt;span class="nv"&gt;endtry&lt;/span&gt;

    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Show the matches for what is typed so far.&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;map&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tags&lt;/span&gt;, &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;v:val["filename"]&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;files&lt;/span&gt;
&lt;span class="nv"&gt;endfunction&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;LookupFile_LookupFunc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;LookupFile_IgnoreCaseFunc&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. usage_1"&gt;3. Usage&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;lookupfile 可以查找文件夹、缓冲区、按照目录查找三种方法：&lt;/p&gt;
&lt;h3 id="3.1. :lookupfile"&gt;3.1. &lt;code&gt;:LookupFile&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;按 F5 或者输入命令 &lt;code&gt;:LookupFile&lt;/code&gt; 来打开上部的 lookupfile 小窗口，输入文件名即可查找，可以使用 vim 的正则表达式查找，使用 Ctrl-N 和 Ctrl-P 来上下选择查找结果。&lt;/p&gt;
&lt;h3 id="3.2. :lubufs"&gt;3.2. &lt;code&gt;:LUBufs&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;虽然有 &lt;code&gt;BufExplorer&lt;/code&gt; 可以查看 buffers，但是当 buffer 很多时，使用 lookupfile 更加方便一点。&lt;/p&gt;
&lt;p&gt;输入命令 &lt;code&gt;:LUBufs&lt;/code&gt; 查找缓冲区的文件。&lt;/p&gt;
&lt;h3 id="3.3. :luwalk"&gt;3.3. &lt;code&gt;:LUWalk&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;:LUWalk&lt;/code&gt; 来浏览目录。这个功能和 NERDTree 重复了，个人感觉 NERDTree 浏览目录更加方便一点，毕竟不用输入文件目录名，可以少翘几个字符...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. ref_1"&gt;4. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-lookupfile-plugin/"&gt;vi/vim使用进阶: lookupfile插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.163.com/lgh_2002/blog/static/44017526201061313442254/"&gt;lookupfile.vim插件详解【OK】&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Vim"></category><category term="lookupfile"></category></entry><entry><title>Regular Expression 小结</title><link href="https://qiangu.cool/posts/linux/summary_of_regular_expression.html" rel="alternate"></link><published>2015-04-27T00:00:00+08:00</published><updated>2015-04-27T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-04-27:/posts/linux/summary_of_regular_expression.html</id><summary type="html">&lt;p&gt;regular expression 学习笔记&lt;/p&gt;</summary><content type="html">&lt;p&gt;看完了 &lt;a href="http://book.douban.com/subject/6959486/"&gt;Introducing Regular Expressions&lt;/a&gt;，记录一下学习笔记。这本书是非常简单的入门书，一天时间就能看完。作者还推荐了基本进阶书：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1872091/"&gt;Mastering Regular Expressions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3443904/"&gt;Regular Expressions Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2363803/"&gt;Regular Expression Pocket Reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;看完这本书，基本上已经满足项目中简单的 RE 需求，以后需要深入的话，再补这几本书。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. what is a re?"&gt;1. What Is a RE?&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;引用 Ken Thompson 的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A regular expression is a pattern which specifies a set of strings of characters; it is said
to match certain strings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. basic"&gt;2. Basic&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;metacharacters&lt;/p&gt;
&lt;p&gt;元字符，在表达式中有特殊的含义，也是保留字。一共有 14 个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配任意字符&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;对字符转义&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;选择操作（或）&lt;/span&gt;
&lt;span class="o"&gt;^&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;行起始&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;行结束&lt;/span&gt;
&lt;span class="o"&gt;?&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="err"&gt;或&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;次&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="err"&gt;或&lt;/span&gt; &lt;span class="err"&gt;多次&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;或&lt;/span&gt; &lt;span class="err"&gt;多次&lt;/span&gt;
&lt;span class="p"&gt;[]&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;字符组符号&lt;/span&gt;
&lt;span class="err"&gt;{}&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;量词或代码块符号&lt;/span&gt;
&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;分组符号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;character shorthand&lt;/p&gt;
&lt;p&gt;也叫做 character escape，中文翻译成：&amp;ldquo;字符组简写&amp;rdquo; / &amp;ldquo;转义字符&amp;rdquo;，常用简写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;数字字符，&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;非数字字符，&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;单词字符&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;非单词字符&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;空格&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;换行&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;回车&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;单词边界&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;报警符&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;cx&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;控制字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="3. simple match patterns"&gt;3. Simple Match Patterns&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;几个常见的模式匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;string literals&lt;/p&gt;
&lt;p&gt;使用普通字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;digits&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;简写形式&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="err"&gt;任意一个数字&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1278&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;限定备选集合为&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;non-digits&lt;/p&gt;
&lt;p&gt;&lt;em&gt;大写的简写形式&lt;/em&gt; 或者 &lt;em&gt;取反&lt;/em&gt; 即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;word characters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;              &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;简写形式&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Z0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="err"&gt;任意一个字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;non-word characters&lt;/p&gt;
&lt;p&gt;&lt;em&gt;大写的简写形式&lt;/em&gt; 或者 &lt;em&gt;取反&lt;/em&gt; 即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zA&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Z0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;whitespace&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;any characters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. boundaries"&gt;4. Boundaries&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行首、行尾&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;行首&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;行尾&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单词边界&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;单词边界&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;单词开头&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;单词结尾&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非单词边界&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. alternation, groups, and backreferences"&gt;5. Alternation, Groups, and Backreferences&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Alternation&lt;/p&gt;
&lt;p&gt;比如要匹配 THE 或者 The 或者 the，使用如下的语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;THE&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Subpatterns&lt;/p&gt;
&lt;p&gt;THE、The、the 是 3 个子模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;THE&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号对于子模式不是必须的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;tT&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ceinry&lt;/span&gt;&lt;span class="o"&gt;]*&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以匹配 the、The、their 等单词，严格意义上中括号内的叫做 字符组 &lt;code&gt;character classes&lt;/code&gt;，不过因为两者有近似的功能，所以也可以将其做一类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Capturing Groups and Backreferences&lt;/p&gt;
&lt;p&gt;对于括号()内的模式进行捕获，将其存储在临时内存中，然后可以通过后向引用重用已捕获的内容。&lt;/p&gt;
&lt;p&gt;重引用时 &lt;code&gt;\1&lt;/code&gt;、&lt;code&gt;$1&lt;/code&gt; 表示对第一个分组的引用；&lt;code&gt;\2&lt;/code&gt;、&lt;code&gt;$2&lt;/code&gt; 表示对第二个分组的引用；依次类推。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-Capturing Groups&lt;/p&gt;
&lt;p&gt;对于之后不会进行引用的分组，可以使用非捕获分组，因为不会对其分配内存所以可以提高性能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;THE&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;The&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="6. character classes"&gt;6. Character Classes&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Character Classes&lt;/p&gt;
&lt;p&gt;也叫做 方括号表达式，字符组可以帮助我们匹配特定字符或者特定的字符序列：&lt;/p&gt;
&lt;p&gt;匹配特定字符&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;aeiou&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;匹配元音字符&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;匹配特定字符序列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;24680&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;～&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt; &lt;span class="err"&gt;之间的偶数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Negated Character Classes&lt;/p&gt;
&lt;p&gt;匹配与字符组不匹配的字符，方法就是在开头加上 脱字符 &lt;code&gt;^&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;aeiou&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;    &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;不想匹配元音字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Union and Difference&lt;/p&gt;
&lt;p&gt;字符组可以像集合一样操作（如求并集、求差集），实际上字符组还有一个名字就叫做 字符集 &lt;code&gt;character set&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并集：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="err"&gt;或者&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="err"&gt;之间的数字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;差集：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="err"&gt;之间，但是排除&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="err"&gt;之间的字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POSIX Character Classes&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POSIX&lt;/code&gt; (Portable Operating System Interface ) 是 IEEE 维护的一系列标准，格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[[: xxxx:]]&lt;/span&gt;
&lt;span class="na"&gt;[[:^ xxxx:]]        // 取反匹配&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 xxxx 取值为 digit、word 等，举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[[:&lt;/span&gt;&lt;span class="n"&gt;alnum&lt;/span&gt;&lt;span class="p"&gt;:]]&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配字母和数字&lt;/span&gt;
&lt;span class="p"&gt;[[:&lt;/span&gt;&lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="p"&gt;:]]&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配大写或小写字母&lt;/span&gt;
&lt;span class="p"&gt;[[:&lt;/span&gt;&lt;span class="n"&gt;ascii&lt;/span&gt;&lt;span class="p"&gt;:]]&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;匹配&lt;/span&gt; &lt;span class="n"&gt;ASCII&lt;/span&gt; &lt;span class="err"&gt;范围内的字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般不常用 POSIX 格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="7. matching unicode and other characters"&gt;7. Matching Unicode and Other Characters&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Matching a Unicode Character&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uxxxx&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;syntax&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;u00e9&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;character&lt;/span&gt; &lt;span class="err"&gt;&amp;eacute;&lt;/span&gt; 
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;u6c60&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;character&lt;/span&gt; &lt;span class="err"&gt;池&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Matching Characters with Octal Numbers&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;      &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;xxx&lt;/span&gt; &lt;span class="err"&gt;是&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="err"&gt;位&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="err"&gt;进制数字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如 &amp;eacute; 也可以用 &lt;code&gt;\351&lt;/code&gt; 来匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Matching Control Characters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;cx&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="err"&gt;是想匹配的控制字符&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;空字符&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;NUll&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;cG&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;报警字符&lt;/span&gt; &lt;span class="n"&gt;BEL&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;cH&lt;/span&gt;         &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="err"&gt;退格符&lt;/span&gt; &lt;span class="n"&gt;Backspcace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="8. quantifiers"&gt;8. Quantifiers&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="8.1. greedy, lazy, and possessive"&gt;8.1. Greedy, Lazy, and Possessive&lt;/h3&gt;
&lt;p&gt;量词的属性有 贪婪，懒惰，占有。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Greedy&lt;/p&gt;
&lt;p&gt;所谓 &amp;ldquo;贪婪&amp;rdquo; 就是说 在匹配前会选定尽可能多的内容，也就是整个输入。然后开始匹配时，会首先匹配整个字符串，如果失败，则回退一个字符，重新匹配（这个过程叫做回溯 backtracking），直到找到匹配的内容或者没有字符可以尝试为止。&lt;/p&gt;
&lt;p&gt;量词的默认属性是贪婪的。&lt;/p&gt;
&lt;p&gt;形象的描述是：它先 &amp;ldquo;吃&amp;rdquo; 进所有的字符，然后每次 &amp;ldquo;吐&amp;rdquo; 出一点，慢慢咀嚼消化...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It takes a mouthful, then spits back a little at a time, chewing on what it just ate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lazy&lt;/p&gt;
&lt;p&gt;量词的另外一种策略。从待匹配的内容起始位置开始尝试匹配，每次检查字符串的一个字符，寻找匹配内容，最后会尝试匹配整个字符串。&lt;/p&gt;
&lt;p&gt;形象的描述是：它每次只吃一点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It chews one nibble at a time&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Possessive&lt;/p&gt;
&lt;p&gt;占有量词会抓取整个目标，然后尝试寻找匹配。不过它只尝试一次，不会回溯。&lt;/p&gt;
&lt;p&gt;形象的描述是：它不 &amp;ldquo;咀嚼&amp;rdquo; 而是直接 &amp;ldquo;吞咽&amp;rdquo;，然后才想知道 &amp;ldquo;吃&amp;rdquo; 的是什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It doesn&amp;rsquo;t chew; it just swallows, then wonders what it just ate. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="8.2. basic quantifiers"&gt;8.2. Basic Quantifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt;    匹配 0 或 1 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;    匹配 1 或 多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;    匹配 0 或 多次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些量词默认是贪心的，也就是说第一次尝试时会尽可能多地匹配字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.*&lt;/code&gt; 叫做 &lt;code&gt;Kleene star&lt;/code&gt;，以纪念 RE 的发明人Stephen Kleene。&lt;/p&gt;
&lt;h3 id="8.3. range syntax"&gt;8.3. Range Syntax&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt;   精确匹配 n 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}&lt;/code&gt;  匹配 n 次 或 多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{m,n}&lt;/code&gt; 匹配 m 至 n 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{0,1}&lt;/code&gt; 与 &lt;code&gt;?&lt;/code&gt; 相同（0 或 1 次）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{1,0}&lt;/code&gt; 与 &lt;code&gt;+&lt;/code&gt; 相同（1 或 多次）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{0,}&lt;/code&gt;  与 &lt;code&gt;*&lt;/code&gt; 相同（0 或 多次）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="8.4. lazy quantifiers"&gt;8.4. Lazy Quantifiers&lt;/h3&gt;
&lt;p&gt;懒惰的意思就是匹配尽可能少的字符，它就是个懒虫！它总会找到匹配下限。比如 5*?，它不会匹配任何内容，因为 * 的下限是 0 次；再比如 5+?，它只会匹配 1 个5，因为 + 的下限是 1 次；再比如 5{2,5}?，它只会匹配 2 个 5，因为下限是 2。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;?? &lt;/li&gt;
&lt;li&gt;+?&lt;/li&gt;
&lt;li&gt;*?&lt;/li&gt;
&lt;li&gt;{n}?&lt;/li&gt;
&lt;li&gt;{n,}?&lt;/li&gt;
&lt;li&gt;{m,n}?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些加了 ? 的 RE 表示懒惰匹配，也就是 &lt;em&gt;找下限&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id="8.5. possessive quantifiers"&gt;8.5. Possessive Quantifiers&lt;/h3&gt;
&lt;p&gt;占有式量词就是贪婪式量词的弱化版，只在第一次进行匹配，如果失败就停止，而不是继续回溯下去。它会将自己的输入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;?+&lt;/li&gt;
&lt;li&gt;++&lt;/li&gt;
&lt;li&gt;*+&lt;/li&gt;
&lt;li&gt;{n}+&lt;/li&gt;
&lt;li&gt;{n,}+&lt;/li&gt;
&lt;li&gt;{m,n}+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些量词后面加了 + 的 RE 表示占有匹配，也就是只检查第一次尝试。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="9. lookarounds_1"&gt;9. Lookarounds&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;环视 是一种非捕获分组，它的作用是检查模式的前/后的内容来匹配，也成为 零宽度断言 &lt;code&gt;zero-width
assertions&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Positive Lookaheads&lt;/p&gt;
&lt;p&gt;正前瞻。 pattern 之后必须紧随着 lookaround 的才会被匹配。&lt;/p&gt;
&lt;p&gt;比如想找到所有之后紧随着一个 marinere 的 ancyent ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ancyent&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;?=&lt;/span&gt;&lt;span class="n"&gt;marinere&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Negative Lookaheads&lt;/p&gt;
&lt;p&gt;反前瞻。对正前瞻的取反，也就是 pattern 之后必须没有 lookarounds 的才会被匹配。&lt;/p&gt;
&lt;p&gt;比如想找到所有后面没有 marinere 的 ancyent：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ancyent&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;?!&lt;/span&gt;&lt;span class="n"&gt;marinere&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Positive Lookbehinds&lt;/p&gt;
&lt;p&gt;正后顾。后顾和前瞻的方向相反，检查 pattern 之前的内容，之前有 lookarounds 的 pattern 才会被匹配到。&lt;/p&gt;
&lt;p&gt;比如想找到所有之前有 ancyent 的 marinere：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;?&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;ancyent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;marinere&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Negative Lookbehinds&lt;/p&gt;
&lt;p&gt;反后顾。对正后顾的取反，也就是 pattern 之前必须没有 lookarounds，才会被匹配。&lt;/p&gt;
&lt;p&gt;比如想找到所有之前不存在 ancyent 的 marinere：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;?&amp;lt;!&lt;/span&gt;&lt;span class="n"&gt;ancyent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;marinere&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于正、反；前瞻、后顾可以用下面的规律记：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前瞻/后顾：&lt;/strong&gt;以 lookarounds 为原点，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pattern 在 lookarounds 之前就是 前瞻&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pattern 在 lookarounds 之后就是 后顾&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;正/反：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果条件是 lookarounds   存在，就是 正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果条件是 lookarounds 不存在，就是 负&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;了解了这些基础知识，基本上就可以读懂、书写 RE 了，还需要的就是平时多加思考练习，然后看更加高阶的书了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="10. ref"&gt;10. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6959486/"&gt;Introducing Regular Expressions&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="regular expression"></category></entry><entry><title>学习 Vim 之 BufExplorer、NERDTree、WinManager、Powerline 插件</title><link href="https://qiangu.cool/posts/linux/learning_vim_bufexplorer_nerdtree_winmanager_powerline.html" rel="alternate"></link><published>2015-03-04T22:40:00+08:00</published><updated>2015-03-04T22:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-03-04:/posts/linux/learning_vim_bufexplorer_nerdtree_winmanager_powerline.html</id><summary type="html">&lt;p&gt;学习 BufExplorer、NERDTree、WinManager、Powerline 插件&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. bufexplorer"&gt;1. BufExplorer&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;:ls&lt;/code&gt; 命令可以查看打开的 buffer，然后在不同的 buffer 之间切换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;bn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;n&lt;/code&gt; 是 buffer 的标号。&lt;/p&gt;
&lt;p&gt;这种内置的方法效率比较低，尤其是当我们打开很多个 Buffer 之后，问题更加明显。所以就有了各种 buf 类的插件，最有名的就是：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=42"&gt;BufExplorer&lt;/a&gt; 和 &lt;a href="http://www.vim.org/scripts/script.php?script_id=159"&gt;MiniBufferExplorer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不同的人使用习惯不同，在 stackoverflow 上有专门讨论两者的优劣的问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1649187/vim-minibufexpl-versus-bufexplorer-plugins"&gt;ViM: minibufexpl versus bufexplorer plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我个人觉得 BufExplorer 更好一些，主要原因在于 Mini 在打开很多 buffer时（&amp;gt;8个），切换 buffer 效率很低，而且 Mini 会占用几行宝贵的屏幕资源。&lt;/p&gt;
&lt;p&gt;下面就主要说 BufExlplorer。&lt;/p&gt;
&lt;h3 id="1.1. install"&gt;1.1. Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'bufexplorer.zip'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="1.2. config"&gt;1.2. Config&lt;/h3&gt;
&lt;p&gt;查看 help 文档，自定义配置，我的简单配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Config BufExplorer&lt;/span&gt;
&lt;span class="s2"&gt;""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;bufExplorerDefaultHelp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;       &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Do not show default help.&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;bufExplorerShowRelativePath&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Show relative paths.&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;bufExplorerSortBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;mru&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;        &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Sort by most recently used.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. nerdtree_1"&gt;2. NERDTree&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;NERDTree 是一款可以提供树形目录的 vim 插件，使用它我们可以在 vim 内以树形结构浏览文件目录。&lt;/p&gt;
&lt;h3 id="2.1. install"&gt;2.1. Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'The-NERD-tree'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="2.2. usage"&gt;2.2. Usage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入 &lt;code&gt;:NERDTree&lt;/code&gt; 打开 NERDTree 窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用快捷键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;o 打开/关闭光标所在目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;t 在新 tab 中打开文件，并跳转到该 tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;T 在新 tab 中打开文件，并不跳转到该 tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p 跳转到父节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P 跳转到根节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;q 关闭 NERDTree 窗口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. powerline_1"&gt;3. Powerline&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;状态栏也是一个非常重要的窗口，可以为我们提供一些文档的基本信息，我们可以自己 DIY，在 .vimrc 文件中添加相关的设置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;statusline&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FORMAT&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;POS&lt;/span&gt;&lt;span class="o"&gt;=%&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;%%&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="n"&gt;strftime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="ss"&gt;"%d/%m/%y\ -\ %H:%M\"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用 &lt;a href="https://github.com/Lokaltog/vim-powerline"&gt;Powerline&lt;/a&gt; 插件，一款可以提供非常漂亮的状态栏的插件。它会覆盖掉 .vimrc 中对状态的配置，删除插件后配置信息可以重新起作用。&lt;/p&gt;
&lt;h3 id="3.1. install"&gt;3.1. Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'Lokaltog/vim-powerline'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="3.2. config"&gt;3.2. Config&lt;/h3&gt;
&lt;p&gt;为了保证状态栏始终显示，在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;laststatus&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置之后，应该就可以看到漂亮的状态栏了。&lt;/p&gt;
&lt;p&gt;查看 help：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;powerline&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还可以自定义一些选项，比如颜色主题等。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. winmanager_1"&gt;4. WinManager&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;我们已经安装很多插件，比如 Taglist，BufExlporer、NERDTree 等，这时候我们就需要一个窗口管理插件来将它们组合起来 &amp;mdash;&amp;mdash; &lt;a href="http://www.vim.org/scripts/script.php?script_id=95"&gt;WinManager&lt;/a&gt; &lt;/p&gt;
&lt;h3 id="4.1. install"&gt;4.1. Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'winmanager'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 vim，输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="4.2. config"&gt;4.2. Config&lt;/h3&gt;
&lt;p&gt;查看 help 文档，我们可以进行简单的设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Config Winmanager&lt;/span&gt;
&lt;span class="s2"&gt;""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;winManagerWindowLayout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;NERDTree|TagList&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;NERDTree_title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;[NERDTree]&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;

&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;m&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; :&lt;span class="nv"&gt;WMToggle&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="nv"&gt;function&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="nv"&gt;NERDTree_Start&lt;/span&gt;&lt;span class="ss"&gt;()&lt;/span&gt;  
    &lt;span class="k"&gt;exec&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;NERDTree&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;  
&lt;span class="nv"&gt;endfunction&lt;/span&gt;

&lt;span class="nv"&gt;function&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="nv"&gt;NERDTree_IsValid&lt;/span&gt;&lt;span class="ss"&gt;()&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  
&lt;span class="nv"&gt;endfunction&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候我们按下组合键 Ctrl-m 即可切换是否显示 winmanager 窗口布局。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;最后附上效果图一张：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/learning-vim-bufexplorer-nerdtree-winmanager-powerline/screenshot.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. ref_1"&gt;5. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-netrw-bufexplorer-winmanager-plugin/"&gt;vi/vim使用进阶: 文件浏览和缓冲区浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/bokee/article/details/6633193"&gt; 将Vim改造为强大的IDE&amp;mdash;Vim集成Ctags/Taglist/Cscope/Winmanager/NERDTree/OmniCppComplete（有图有真相）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/chijianqiang/archive/2012/11/06/vim-3.html"&gt;谁说Vim不是IDE？（三）&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="vim"></category><category term="BufExplorer"></category><category term="NERDTree"></category><category term="WinManager"></category><category term="Powerline"></category></entry><entry><title>在 Vim 中写 Markdown 文件</title><link href="https://qiangu.cool/posts/linux/learning_vim_markdown.html" rel="alternate"></link><published>2015-02-01T13:46:00+08:00</published><updated>2015-02-01T13:46:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-02-01:/posts/linux/learning_vim_markdown.html</id><summary type="html">&lt;p&gt;在 Vim 中使用 Markdown 语法写文本。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;code&gt;Vim&lt;/code&gt; 和 &lt;code&gt;Markdown&lt;/code&gt; 就不多罗嗦了，记录一下最近在 Vim 中摸索使用 Markdown 的经历。&lt;/p&gt;
&lt;h2 id="1. syntax hightlight"&gt;1. Syntax Hightlight&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Vim 可以通过插件来提供对 Markdown 语法的支持，网上找到很多这类插件：&lt;/p&gt;
&lt;p&gt;官网上的插件：&lt;a href="http://www.vim.org/scripts/script.php?script_id=2882"&gt;Markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我找到的是下面这个：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/plasticboy/vim-markdown"&gt;plasticboy/vim-markdown&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="1.1. install"&gt;1.1. Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 管理插件，只需要在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'godlygeek/tabular'&lt;/span&gt;
&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'plasticboy/vim-markdown'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开 Vim，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;h3 id="1.2. file extension"&gt;1.2. File extension&lt;/h3&gt;
&lt;p&gt;Markdown 文件的后缀名可以是 &lt;code&gt;.markdown&lt;/code&gt;，&lt;code&gt;mkd&lt;/code&gt;，&lt;code&gt;mkdn&lt;/code&gt;，&lt;code&gt;md&lt;/code&gt; 等，但是 plasticboy 的插件只识别 &lt;code&gt;mkd&lt;/code&gt; 和 &lt;code&gt;markdown&lt;/code&gt; 两种：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/10964681/enabling-markdown-highlighting-in-vim"&gt;Enabling markdown highlighting in Vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为我们已经按照 .md 格式写了很多文本了，这时候更好选择当然是修改设置，让 vim 可以识别这种类型的文件，而不是修改文件后缀名。所以我们需要在 vimrc 中设置一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;au&lt;/span&gt; &lt;span class="n"&gt;BufRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;BufNewFile&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;md&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;filetype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，.md 文件就可以被识别了。&lt;/p&gt;
&lt;p&gt;经过上面两步，此时再打开 markdown 文件就可以看到语法高亮了，plasticboy/vim-markdown 还支持一些高级的主题：比如支持 LaTeX 数学公式的高亮，ToC 等，从 github 上可以看到相关设置的介绍说明。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. preview_1"&gt;2. Preview&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;一些专门的 Markdown 软件、网页编辑器都是提供实时预览，Vim 虽然不提供预览窗口，但是配合浏览器，我们也可以实现实时预览的功能，当然还是依靠万能的插件。&lt;/p&gt;
&lt;p&gt;我使用的是：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/suan/vim-instant-markdown"&gt;suan/vim-instant-markdown&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="2.1. install"&gt;2.1. Install&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先要保证已经安装了 node.js&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;npm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有，安装 npm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;npm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装 &lt;code&gt;instant-markdown-d&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;npm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;g&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;instant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;markdown&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确保系统安装了 &lt;code&gt;xdg-utils&lt;/code&gt;，否则 apt-get 安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 Vundle 管理插件&lt;/p&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'suan/vim-instant-markdown'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开 vim，输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="2.2. config &amp;amp; use"&gt;2.2. Config &amp;amp; Use&lt;/h3&gt;
&lt;p&gt;如果机器比较老，插件占用的资源过多的话，可以设置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;instant_markdown_slow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来降低资源利用。&lt;/p&gt;
&lt;p&gt;默认情况下，当我们打开 markdown 文件时，插件会自动打开一个预览的浏览器标签页，如果不想，可以关闭自动打开功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;instant_markdown_autostart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在需要时手动输入命令 &lt;code&gt;:InstantMarkdownPreview&lt;/code&gt; 来预览。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Vim 窗口重叠在浏览器窗口之上时，会遮住部分内容；当两个窗口并排时，浏览器窗口无法完全显示全部内容，这在小尺寸屏幕上尤其明显。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开的预览网页无法实时跟随内容滚动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后放一张截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/learning-vim-markdown/screenshot.png"/&gt;&lt;/p&gt;
&lt;h2 id="3. ref_1"&gt;3. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/plasticboy/vim-markdown"&gt;plasticboy/vim-markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/10964681/enabling-markdown-highlighting-in-vim"&gt;Enabling markdown highlighting in Vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/suan/vim-instant-markdown"&gt;suan/vim-instant-markdown&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="vim"></category><category term="markdown"></category></entry><entry><title>学习 Vim 之 Ctags/Cscope/Taglist</title><link href="https://qiangu.cool/posts/linux/learning_vim_ctags_cscope_taglist.html" rel="alternate"></link><published>2015-01-25T21:32:00+08:00</published><updated>2015-01-25T21:32:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-01-25:/posts/linux/learning_vim_ctags_cscope_taglist.html</id><summary type="html">&lt;p&gt;总结使用 Ctags/Cscope/Taglist 的使用方法。&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. background"&gt;1. Background&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;tags 文件是一种非常有用的文件，本文的内容都是基于 &lt;code&gt;tag&lt;/code&gt; 的，所以首先得了解什么是 tag？&lt;/p&gt;
&lt;p&gt;Vim Manual 里面的简单介绍就足够我们进行下面的内容了。查看 Manual：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;tagsrch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 tags 文件的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先使用 tag 工具（ctags、cscope等）生成 tags 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，将 tags 文件路径导入到 Vim 中，让 Vim 知道从哪个 tags 文件中查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，使用 Vim 的命令查找 tag。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. ctags"&gt;2. Ctags&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="2.1. intro"&gt;2.1. Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="ctags.sourceforge.net/"&gt;Ctags 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ctags"&gt;wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ctags&lt;/strong&gt; is a programming tool that generates an index (or tag) file of names found in source and header files of various programming languages. Depending on the language, functions, variables, class members, macros and so on may be indexed. These tags allow definitions to be quickly and easily located by a text editor or other utility. Alternatively, there is also an output mode that generates a cross reference file, listing information about various names found in a set of language files in human-readable form.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;manpage: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;ctags&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vim Manual：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;ctags&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简而言之，Ctags 是一个可以自动提取源文件和头文件中函数、变量、类成员、宏定义等元素的工具，然后它会建立一个 tags 文件，其他编辑器（比如我们使用的 Vim）可以读取这个 tags 文件，从而快速定位代码的位置。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ctags --list-language&lt;/code&gt; 可以查看 ctags 支持的语言，使用 &lt;code&gt;ctags --list-maps&lt;/code&gt; 可以查看哪些后缀名对应对应的语言。&lt;/p&gt;
&lt;h3 id="2.2. install"&gt;2.2. Install&lt;/h3&gt;
&lt;p&gt;ctags 是 Unix 系统自带的一个工具，但是功能比较少，所以一般使用 Exuberant Ctags。在 Linux 上，Exuberant Ctags 是默认的 Ctags 程序。如果系统中没有安装的话，我们可以从官网上下载源码编译安装，或者直接 apt-get 安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;exuberant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ctags&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="2.3. config"&gt;2.3. Config&lt;/h3&gt;
&lt;p&gt;我们要使用 tags，第一步就是生成 tags 文件。生成 tags 文件时，ex-ctags 提供了很多参数供我们控制生成结果，详细内容可以查看其 manpage，这里有 easwy 大神翻译的中文版：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/exuberant-ctags-chinese-manual/"&gt;Exuberant Ctags中文手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以将配置写在 .vimrc 中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;tags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="k"&gt;map&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F12&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ctags&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="c1"&gt;--c++-kinds=+p --fields=+iaS --extra=+q .&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们只需要按 Ctrl-F12 即可自动生成 C++ 项目的 tags 文件。&lt;/p&gt;
&lt;h3 id="2.4. usage"&gt;2.4. Usage&lt;/h3&gt;
&lt;p&gt;Vim 提供了接口可以调用 tags 文件，它使用一个栈来记录我们在文件中跳转的位置。ctags 其 manual page 中有说明如何在 Vi 中使用 ctags：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vi -t tags&lt;/code&gt; 打开 vi，并且将光标停留在 &lt;code&gt;tag&lt;/code&gt; 定义的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ta tag&lt;/code&gt; 寻找 &lt;code&gt;tag&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl-]&lt;/code&gt; 寻找光标处 tag 的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl-T&lt;/code&gt; 返回到 tag 的前一个位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tnext&lt;/code&gt; 如果某个 tag（比如函数）有多次定义，会匹配到多个结果，本命令跳到下一个结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tprevious&lt;/code&gt; 同上，跳转到前一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tfirst&lt;/code&gt; 跳转到第一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tlast&lt;/code&gt; 跳转到最后一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ts tag&lt;/code&gt; 同上，列出所有匹配到 tag 的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:tags&lt;/code&gt; 显示 tagstack 中的内容，即我们的跳转记录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. cscope_1"&gt;3. Cscope&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="3.1. intro"&gt;3.1. Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://cscope.sourceforge.net/"&gt;Cscope 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cscope"&gt;cscope wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cscope is a console mode or text-based graphical interface that allows computer programmers or software developers to search C source code (there is limited support for other languages). It is often used on very large projects to find source code, functions, declarations, definitions and regular expressions given a text string. cscope is free and available under a BSD License. The original developer of cscope is Joe Steffen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;man page:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;man&lt;/span&gt; &lt;span class="n"&gt;cscope&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vim help:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt; &lt;span class="n"&gt;if_cscop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The following text is taken from a version of the cscope man page:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cscope is an interactive screen-oriented tool that helps you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Learn how a C program works without endless flipping through a thick listing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Locate the section of code to change to fix a bug without having to learn the entire program.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examine the effect of a proposed change such as adding a value to an enum variable.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verify that a change has been made in all source files such as adding an argument to an existing function.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rename a global variable in all source files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change a constant to a preprocessor symbol in selected lines of files.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is designed to answer questions like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Where is this symbol used?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is it defined?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where did this variable get its value?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What is this global symbol's definition?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is this function in the source files?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What functions call this function?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What functions are called by this function?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where does the message "out of space" come from?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is this source file in the directory structure?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What files include this header file?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cscope answers these questions from a symbol database that it builds the
 first time it is used on the source files.  On a subsequent call, cscope
 rebuilds the database only if a source file has changed or the list of
 source files is different.  When the database is rebuilt the data for the
 unchanged files is copied from the old database, which makes rebuilding
 much faster than the initial build.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，就是 ctags 的加强版，ctags 只能让我们跳转到某个 tag 的定义之处，但是无法让我们知道这个 tag 还在哪里出现过，或者被哪个函数调用过，这时候就需要 cscope 来大显身手了～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cscope 对 C/C++ 支持比较好，当然我们也可以自己定制来支持其他语言，比如 Java，Python 等。&lt;/p&gt;
&lt;h3 id="3.2. install"&gt;3.2. Install&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;cscope&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="3.3. usage"&gt;3.3. Usage&lt;/h3&gt;
&lt;p&gt;联合使用 Cscope + Vim 的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 cscope 生成数据库文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;cscope&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Rbkq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中参数的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-R 递归，对子目录也建立数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-b 只生成数据库，不进入 scope 界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-k 生成数据库时，不搜索 &lt;code&gt;/usr/include&lt;/code&gt; 目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-q 生成 &lt;code&gt;cscope.in.out&lt;/code&gt; 和 &lt;code&gt;cscope.po.out&lt;/code&gt; 文件，加快查找速度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更详细的参数见 man page。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数据库导入 Vim 中&lt;/p&gt;
&lt;p&gt;cd 到源文件目录下，执行上一步操作，然后打开 vim 输入下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt; &lt;span class="k"&gt;add&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cscope&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Vim 中查找&lt;/p&gt;
&lt;p&gt;通用格式为 &lt;code&gt;:cs find -option label&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;option 可以有很多种模式，在 Vim 中使用 &lt;code&gt;:help cscope-find&lt;/code&gt; 来查看 option：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;C&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;definition&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="k"&gt;called&lt;/span&gt; &lt;span class="k"&gt;by&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="n"&gt;calling&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;
&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;egrep&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;
&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Find&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="k"&gt;including&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="3.4. config"&gt;3.4. Config&lt;/h3&gt;
&lt;p&gt;Vim 的 cscope 接口提供了一些参数，可以让我们更加灵活地使用 cscope，可以用 &lt;code&gt;help if_cscop&lt;/code&gt; 来查看完整的说明，这里有一份前辈翻译的中文版&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/dengxiayehu/article/details/6330200"&gt;Cscope的使用（领略Vim + Cscope的强大魅力）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我找了几个常用的选项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;cscopequickfix&lt;/p&gt;
&lt;p&gt;vim 提供了 &lt;code&gt;cscopequickfix&lt;/code&gt; 选项，让查找结果在 quickfix 的窗口显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时使用 cscope ctags &lt;/p&gt;
&lt;p&gt;设置 &lt;code&gt;cst&lt;/code&gt; 选项，可以同时查找 cscope 和 ctags，查找顺序有 &lt;code&gt;csto&lt;/code&gt; 选项来决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ctags&lt;/code&gt; 等同于 &lt;code&gt;:cs find g&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了省事，我们可以将一些参数设置写在 .vimrc 文件中，Vim help 中有推荐设置，下面是我修改过的配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;has&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;cscope&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;csprg&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="nv"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;cscope&lt;/span&gt;
    &lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;cscopequickfix&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;,&lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;,&lt;span class="nv"&gt;d&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;,&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;,&lt;span class="nv"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;,&lt;span class="nv"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;
    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;set cst &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;keep&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;regular&lt;/span&gt; &lt;span class="nv"&gt;tag&lt;/span&gt; &lt;span class="nv"&gt;behavior&lt;/span&gt;
    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;set csto=0 &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;keep&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;regular&lt;/span&gt; &lt;span class="nv"&gt;tag&lt;/span&gt; &lt;span class="nv"&gt;behavior&lt;/span&gt;
    &lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;nocsverb&lt;/span&gt;
    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; add any database in current directory&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;filereadable&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;cscope.out&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;add&lt;/span&gt; &lt;span class="nv"&gt;cscope&lt;/span&gt;.&lt;span class="nv"&gt;out&lt;/span&gt;
    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; else add database pointed to by environment&lt;/span&gt;
    &lt;span class="k"&gt;elseif&lt;/span&gt; &lt;span class="mh"&gt;$C&lt;/span&gt;&lt;span class="nv"&gt;SCOPE_DB&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;add&lt;/span&gt; &lt;span class="mh"&gt;$C&lt;/span&gt;&lt;span class="nv"&gt;SCOPE_DB&lt;/span&gt;
    &lt;span class="k"&gt;endif&lt;/span&gt;
    &lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;csverb&lt;/span&gt;
&lt;span class="k"&gt;endif&lt;/span&gt;

&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;g&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cfile&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="o"&gt;^&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cfile&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;$&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;d&lt;/span&gt; :&lt;span class="nv"&gt;cs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Using 'CTRL-spacebar' then a search type makes the vim window&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; split horizontally, with search result displayed in&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; the new window.&lt;/span&gt;

&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;g&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cfile&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="o"&gt;^&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cfile&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;$&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;d&lt;/span&gt; :&lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; Hitting CTRL-space *twice* before the search type does a vertical&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; split instead of a horizontal one&lt;/span&gt;

&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt;
    \:&lt;span class="nv"&gt;vert&lt;/span&gt; &lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;g&lt;/span&gt;
    \:&lt;span class="nv"&gt;vert&lt;/span&gt; &lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt;
    \:&lt;span class="nv"&gt;vert&lt;/span&gt; &lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;t&lt;/span&gt;
    \:&lt;span class="nv"&gt;vert&lt;/span&gt; &lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;t&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;e&lt;/span&gt;
    \:&lt;span class="nv"&gt;vert&lt;/span&gt; &lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;e&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;
    \:&lt;span class="nv"&gt;vert&lt;/span&gt; &lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="o"&gt;^&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cfile&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;$&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nv"&gt;nmap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;d&lt;/span&gt;
    \:&lt;span class="nv"&gt;vert&lt;/span&gt; &lt;span class="nv"&gt;scs&lt;/span&gt; &lt;span class="nv"&gt;find&lt;/span&gt; &lt;span class="nv"&gt;d&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;R&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="nv"&gt;expand&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;cword&amp;gt;&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. taglist_1"&gt;4. Taglist&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="4.1. intro"&gt;4.1. Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=273"&gt;Taglist 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用过 VS 的人都知道，在左侧有一个窗口专门显示当前代码文件中的宏、函数、变量定义，并且随着文件切换自动更新。我们这里介绍的 Taglist 完成的就是类似的功能，让我们可以高效地浏览代码。不过要使用 Taglist，首先要安装前面介绍的 Ctags。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The "Tag List" plugin is a source code browser plugin for Vim and provides an overview of the structure of source code files and allows 
you to efficiently browse through source code files for different programming languages. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="4.2. install"&gt;4.2. Install&lt;/h3&gt;
&lt;p&gt;与前面的 ctags、cscope 不同的是，taglist 是一款 Vim 插件。如果使用 Vundle 来管理、安装插件，在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'taglist.vim'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开 vi，然后输入命令 &lt;code&gt;:BundleInstall&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3 id="4.3. config"&gt;4.3. Config&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;:help taglist&lt;/code&gt; 查看帮助。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;:TlistToggle&lt;/code&gt; 切换是否显示 Taglist 窗口。&lt;/p&gt;
&lt;p&gt;我们可以直接在 .vimrc 中添加以下设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_Show_One_File&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_Exit_OnlyWindow&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_SHow_Menu&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;Tlist_File_Fold_Auto_Close&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="4.4. usage"&gt;4.4. Usage&lt;/h3&gt;
&lt;p&gt;在 taglist 窗口，我们可以使用下面的一些快捷键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt; 折叠所有 tag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-&lt;/code&gt; 折叠单个 tag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 打开一个折叠&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; taglist 窗口放大/缩小，方便查看 tag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; 更新 taglist&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sapce&lt;/code&gt; 显示光标处 tag 的原型定义&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配合另外一个窗口管理插件 winmanager，我们可以将我们的 Vim 打造成一个伪 IDE :D&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. ref_1"&gt;5. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/alexdboy/article/details/3871707"&gt;ctags的使用及相关参数介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/exuberant-ctags-chinese-manual/"&gt;Exuberant Ctags中文手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-use-ctags-tag-file/"&gt;vi/vim使用进阶: 使用标签(tag)文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cscope.sourceforge.net/"&gt;cscope 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cscope"&gt;cscope wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/dengxiayehu/article/details/6330200"&gt;Cscope的使用（领略Vim + Cscope的强大魅力）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=273"&gt;Taglist 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-taglist-plugin/"&gt;vi/vim使用进阶: 使用taglist插件&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="vim"></category><category term="ctags"></category><category term="cscope"></category><category term="taglist"></category></entry><entry><title>基于 Doxygen 的 C++ 注释风格</title><link href="https://qiangu.cool/posts/linux/doxygen_cpp_comment_style.html" rel="alternate"></link><published>2015-01-13T18:00:00+08:00</published><updated>2015-01-13T18:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-01-13:/posts/linux/doxygen_cpp_comment_style.html</id><summary type="html">&lt;p&gt;总结基于 Doxygen 的 C++ 注释规则&lt;/p&gt;</summary><content type="html">&lt;p&gt;本文内容参考自网上博客内容&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;C++标准注释原则 - 基于doxygen的C++注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6294abe701012pee.html"&gt;Doxygen C++注释规范及生成帮助文档配置步骤&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ticktick.blog.51cto.com/823160/188674"&gt;Doxygen详细介绍（三）（Doxygen注释风格）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重新整理排版了一下。写本文的主要目的是备忘，当作快速参考来查。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. doxygen"&gt;1. Doxygen&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;若想用 Doxygen 生成漂亮的文档，我们必须在以下几个地方添加 Doxygen 风格的注释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件头（包括 头文件 .h 和 源文件 .cpp）&lt;/p&gt;
&lt;p&gt;主要用于版权声明，描述本文件的功能，以及作者、版本信息等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的定义&lt;/p&gt;
&lt;p&gt;主要用于描述类的功能，同时也可以包含使用方法、注意事项的 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的成员变量定义&lt;/p&gt;
&lt;p&gt;对该成员变量进行 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的成员函数定义&lt;/p&gt;
&lt;p&gt;对该成员函数的功能进行 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数实现&lt;/p&gt;
&lt;p&gt;对函数的功能、参数、返回值、需要注意的问题、相关说明等进行 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. c++ comment style"&gt;2. C++ Comment Style&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Doxygen 支持多种注释风格，比如 JavaDoc-like 风格，Qt 风格等。在写 C++ 代码时，我们应该遵守 C++ 的行注释风格，所谓行注释风格，是指一般 C++ 程序员避免使用 C 风格的注释符号 &lt;code&gt;/* */&lt;/code&gt;，而是使用 3 个连续的 &lt;code&gt;/&lt;/code&gt; 作为注释的开头。除了这个区别之外，其他部分和 JavaDoc 风格类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个对象的 brief description 用单行的 &lt;code&gt;///&lt;/code&gt; 开始，并且写在代码前面。一般 brief 写在头文件中，对象的声明之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个对象的 detailed description 用多于两行的 &lt;code&gt;///&lt;/code&gt; 开始，并且写在代码前面。如果注释长度不足两行，第二行的开头仍要写出。一般 detailed 写在源文件中，对象的定义之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一段代码既是声明也是定义，则 brief 和 detailed 写在一起。使用 &lt;code&gt;\brief&lt;/code&gt; 命令，并且使用空行将两者分开。一般 brief 写在头文件中，对象的声明之前。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 line at least.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是代码模板：&lt;/p&gt;
&lt;h3 id="2.1. license"&gt;2.1. License&lt;/h3&gt;
&lt;p&gt;使用 DoxygenToolKit 自动生成的 Lisence 即可。&lt;/p&gt;
&lt;h2 id="3. file header_1"&gt;3. File header&lt;/h2&gt;
&lt;hr/&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \file file_name.h&lt;/span&gt;
&lt;span class="c1"&gt;/// \brief Head file for class Ctest.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed file description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \author author_name&lt;/span&gt;
&lt;span class="c1"&gt;/// \version version_number&lt;/span&gt;
&lt;span class="c1"&gt;/// \date xxxx-xx-xx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="3.1. namespace"&gt;3.1. Namespace&lt;/h3&gt;
&lt;p&gt;namespace 的注释方式：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \brief A brief namespace description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed namespace description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="3.2. class"&gt;3.2. Class&lt;/h3&gt;
&lt;p&gt;class 的定义和声明都在头文件中，所以使用下面这种 brief 和 detailed 结合的方式：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \brief A brief class description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed calss description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h4 id="3.2.1. member function"&gt;3.2.1. member function&lt;/h4&gt;
&lt;p&gt;对于成员函数，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若是在头文件的声明处，使用 brief&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是在源文件的定义处，使用 detailed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是在头文件处，声明和定义重合，使用 brief + detailed&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="3.2.2. member variable"&gt;3.2.2. member variable&lt;/h4&gt;
&lt;p&gt;对于成员变量，在行末使用 &lt;code&gt;///&amp;lt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="3.3. function_1"&gt;3.3. Function&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;brief:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单行的 &lt;code&gt;///&lt;/code&gt; 注释：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// A brief function description.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;detailed:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至少两行 &lt;code&gt;///&lt;/code&gt; 的注释：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// This is the detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在 detailed description 中还可以添加一些 &lt;code&gt;structural command&lt;/code&gt;，常用的有 &lt;code&gt;\param&lt;/code&gt;、&lt;code&gt;\return&lt;/code&gt;、&lt;code&gt;\see&lt;/code&gt;、&lt;code&gt;\note&lt;/code&gt;、&lt;code&gt;\warning&lt;/code&gt; 等：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// This is the detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p1 Brief description for p1&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p2 Brief description for p2&lt;/span&gt;
&lt;span class="c1"&gt;/// \return Brief description for return value&lt;/span&gt;
&lt;span class="c1"&gt;/// \note something to note.&lt;/span&gt;
&lt;span class="c1"&gt;/// \warning Warning.&lt;/span&gt;
&lt;span class="c1"&gt;/// \see See-also&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;brief + detailed:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果函数声明和定义重合，则 brief 和 detailed 合在一起，并且使用 &lt;code&gt;\brief&lt;/code&gt; 命令，格式如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \brief A brief function description.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p1 Description for p1.&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p2 Description for p2.&lt;/span&gt;
&lt;span class="c1"&gt;/// \return Description for return value.&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在 Doxgyen 的 manual 里面有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike most other documentation systems, doxygen also allows you to put the documentation of members (including global functions) in front of the definition. This way the documentation can be placed in the source file instead of the header file. This keeps the header file compact, and allows the implementer of the members more direct access to the documentation. As a compromise the brief description could be placed before the declaration and the detailed description before the member definition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Doxygen 允许注释出现在对象的定义之前，所以我们可以将注释写在源文件中，而不是头文件中。这样做的好处是使头文件更加紧凑、代码的实现者阅读起来也更加直观。所以我们采用的方案是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在函数声明前写 brief，在函数定义前写 detailed。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 inline 函数，使用 brief，尽量保持简洁，不要多于一行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3.4. variable"&gt;3.4. Variable&lt;/h3&gt;
&lt;p&gt;变量一般使用 &lt;code&gt;///&amp;lt;&lt;/code&gt; 方式即可：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; brief description for variable m_a&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;m_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;///&amp;lt; brief description for variable m_b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;如果需要进行详细描述，则采用类似函数注释的方法（brief + detailed）：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;m_c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="3.5. enum &amp;amp; struct"&gt;3.5. Enum &amp;amp; Struct&lt;/h3&gt;
&lt;p&gt;类似于 Variable 的注释方式：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Tenum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;em_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum value em_1&lt;/span&gt;
    &lt;span class="n"&gt;em_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum value em_2&lt;/span&gt;
    &lt;span class="n"&gt;em_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum value em_3&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;emVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;///&amp;lt; enum variable.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="3.6. others"&gt;3.6. Others&lt;/h3&gt;
&lt;p&gt;TODO 命令：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \todo Task1 to do&lt;/span&gt;
&lt;span class="c1"&gt;/// \todo Task2 to do&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;BUG 命令：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;/// \bug Bug1 to be fixed&lt;/span&gt;
&lt;span class="c1"&gt;/// \bug Bug2 to be fixed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从网上找到一个Doxygen for C 的示例：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://fnch.users.sourceforge.net/doxygen_c.html"&gt;Doxygen usage example (for C)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有一些注释方法很有借鉴意义，可以当作模板来用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.P.S&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又找到一份注释规范的文档，写的挺好，值得一看。&lt;/p&gt;
&lt;p&gt;&lt;a href="/file/cpp_comment_standard.doc"&gt;C++注释规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. ref_1"&gt;4. Ref&lt;/h2&gt;</content><category term="Linux"></category><category term="C++"></category><category term="comment style"></category></entry><entry><title>学习 Vim 插件 DoxygenToolKit.vim</title><link href="https://qiangu.cool/posts/linux/learning_vim_doxygentoolkit.html" rel="alternate"></link><published>2015-01-12T15:21:00+08:00</published><updated>2015-01-12T15:21:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-01-12:/posts/linux/learning_vim_doxygentoolkit.html</id><summary type="html">&lt;p&gt;学习 Vim 插件 DoxygenToolKit&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://guqian110.github.io/pages/2015/01/11/how_to_analysize_code_elegantly.html"&gt;前面一篇博客&lt;/a&gt;已经介绍过 Doxygen 了，Doxygen 的确是一个非常给力的工具，但是为了生成文档，我们必须在注释上花费很大的时间和精力。&lt;/p&gt;
&lt;p&gt;那么问题又来了：&lt;strong&gt;如何才能既享受 Doxygen 的强大功能，同时又避免大量的重复性的注释内容？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决思路： 让编辑器来替我们写那些格式和内容固定的部分，我们只负责写真正的有效内容。&lt;/p&gt;
&lt;p&gt;所以，答案就是：&lt;strong&gt;Vim + DoxygenToolKit.vim 插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. doxygentoolkit"&gt;1. DoxygenToolKit&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;DoxygenToolKit 是 Vim 的一款插件，用它可以很方便地添加 Doxygen 风格的注释，可以节省大量时间和精力，提高写代码的效率。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=987"&gt;DoxygenToolKit Official Website&lt;/a&gt; 官网上介绍，目前定义了 5 个功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen license comment.  The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen author skeleton.  The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen comment skeleton for a C, C++ or Python function or class, including @brief, @param (for each named argument), and @return. The tag  text as well as a comment block header and footer are configurable. (Consequently, you can have \brief, etc. if you wish, with little effort.) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore code fragment placed in a block defined by #ifdef ... #endif (C/C++).  The  block name must be given to the function. All of the corresponding blocks 
in all the file will be treated and placed in a new block DOX_SKIP_BLOCK (or any other name that you have configured).  Then you have to update PREDEFINED value in your doxygen configuration file with correct block name. You also have to set ENABLE_PREPROCESSING to YES. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate a doxygen group (begining and ending). The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id="1.1. installation"&gt;1.1. Installation&lt;/h3&gt;
&lt;p&gt;如果我们使用 Vundle 管理插件，安装步骤就非常简单了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 Vundle 中加入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bundle&lt;/span&gt; &lt;span class="s1"&gt;'DoxygenToolkit.vim'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 Vim，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;BundleInstall&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vundle 会自动完成安装 :-D&lt;/p&gt;
&lt;h3 id="1.2. configuration for c++"&gt;1.2. Configuration for c++&lt;/h3&gt;
&lt;p&gt;我们有两种方法可以修改设置，方法一是直接在 DoxygenToolKit.vim 脚本文件中修改相关变量；方法二是在 ~/.vimrc 里面修改。显然方法二更加好一点，因为如果用方法一直接改原脚本，可能还得保存备份才能恢复默认值。&lt;/p&gt;
&lt;p&gt;因为平时写的 C++ 程序比较多，所以针对&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;基于 Doxygen 的 C++ 注释风格&lt;/a&gt;，我们需要进行以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中我特别配置了以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_briefTag_funcName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;yes&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;

    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; for C++ style, change the '@' to '\'&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_commentType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;C++&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_briefTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;brief &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_templateParamTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;tparam &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_paramTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;param &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_returnTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;return &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_throwTag_pre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;throw &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt; @exception is also valid&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_fileTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;file &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_dateTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;date &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_authorTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;author &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_versionTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;version &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_blockTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;name &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_classTag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;class &lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;DoxygenToolkit_authorName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;Qian Gu, guqian110@gmail.com&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
    &lt;span class="nv"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;g&lt;/span&gt;:&lt;span class="nv"&gt;doxygen_enhanced_color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;let g:load_doxygen_syntax = 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使前一步中设置了 C++ 风格，但是生成的 Lisence 仍然是 &lt;code&gt;//&lt;/code&gt;，而不是我们想要的 &lt;code&gt;///&lt;/code&gt;，所以我们还需要修改原脚本（line 362~363）为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolKit_startCommentBlock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"/// "&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolKit_interCommentBlock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"/// "&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="1.3. usage"&gt;1.3. Usage&lt;/h3&gt;
&lt;p&gt;官网上也给出了使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;License&lt;/p&gt;
&lt;p&gt;将光标放在需要生成 License 的地方，然后输入命令 &lt;code&gt;:DoxLic&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Author&lt;/p&gt;
&lt;p&gt;将光标放在合适的地方，然后输入命令 &lt;code&gt;:DoxAuthor&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function / Class&lt;/p&gt;
&lt;p&gt;将光标放在 function 或者 class 的名字所在的一行，然后输入命令 &lt;code&gt;:Dox&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore code fragment (C/C++ Only)&lt;/p&gt;
&lt;p&gt;如果想忽略调试部分的代码，那么只需要执行命令 &lt;code&gt;:DoxUndoc(DEBUG)&lt;/code&gt; 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Group&lt;/p&gt;
&lt;p&gt;输入命令 &lt;code&gt;DoxBlock&lt;/code&gt; 来插入一个注释块&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了方便使用，我们可以自定义一些 map，省去输入命令的繁琐。&lt;/p&gt;
&lt;h3 id="1.4. example"&gt;1.4. Example&lt;/h3&gt;
&lt;p&gt;同样是官网上的例子：&lt;/p&gt;
&lt;p&gt;假设有个函数如下&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; 
&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;mychar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;myint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;myarray&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DEFAULT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//... &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;那么执行 &lt;code&gt;:Dox&lt;/code&gt; 命令之后会生成以下内容&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;* @brief &lt;/span&gt;
&lt;span class="cm"&gt;* &lt;/span&gt;
&lt;span class="cm"&gt;* @param mychar &lt;/span&gt;
&lt;span class="cm"&gt;* @param myint &lt;/span&gt;
&lt;span class="cm"&gt;* @param myarray &lt;/span&gt;
&lt;span class="cm"&gt;* @param mask &lt;/span&gt;
&lt;span class="cm"&gt;* &lt;/span&gt;
&lt;span class="cm"&gt;* @return &lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. ref_1"&gt;2. Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=987"&gt;DoxygenToolKit.vim&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Linux"></category><category term="Vim"></category><category term="DoxygenToolKit"></category></entry><entry><title>如何优雅的分析代码</title><link href="https://qiangu.cool/posts/linux/how_to_analyse_code_elegantly.html" rel="alternate"></link><published>2015-01-11T18:49:00+08:00</published><updated>2015-01-11T18:49:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-01-11:/posts/linux/how_to_analyse_code_elegantly.html</id><summary type="html">&lt;p&gt;学习 Doxygen + Graphviz 的使用方法&lt;/p&gt;</summary><content type="html">&lt;p&gt;当我们来接手一个别人的工程时，阅读别人的代码是一件很痛苦的事。成千上百的函数，糟糕的代码风格，不知所云的注释，这些都是让人抓狂。那么，问题就来了：&lt;strong&gt;如何优雅地分析别人的代码？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案就是：&lt;strong&gt;Doxygen + Graphviz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个工作流程很简单，我们在写程序时按照 Doxygen 约定的格式注释代码（不注释也可以），Doxygen 会对代码进行分析，然后列出程序中的变量、类定义、数据结构、函数表用关系等，然后调用 Graphviz 将结果用图形化的形式表现出来。&lt;/p&gt;
&lt;p&gt;这个功能在自动生成文档、代码分析时非常强大，下面分别简单介绍一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Linux 环境下，Vim 有插件 &lt;strong&gt;DoxygenToolKIt.vim&lt;/strong&gt; 可以帮助我们很方便地写出 Doxygen 风格的代码。这里只介绍 Doxygen + Graphviz，DoxygenToolKit.vim 在另外一篇中介绍。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. graphviz"&gt;1. Graphviz&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="1.1. what is graphviz?"&gt;1.1. What is Graphviz?&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.graphviz.org/"&gt;Graphviz official website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Graphviz is open source graph visualization software. Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. It has important applications in networking, bioinformatics,  software engineering, database and web design, machine learning, and in visual interfaces for other technical domains. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="1.2. installation"&gt;1.2. Installation&lt;/h3&gt;
&lt;p&gt;官方网站上有各个平台（Windows/Unix/Linnux/Mac）的安装文件和源码，在 Ubuntu 13.10 saucy 下，直接使用 apt-get 安装即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;graphviz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="1.3. more"&gt;1.3. More&lt;/h3&gt;
&lt;p&gt;更多详细的介绍见官网的 About、Documentation、Wiki、FAQ。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. doxygen_1"&gt;2. Doxygen&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="2.1. what is doxygen"&gt;2.1. What is Doxygen&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen Official website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxygen is the de facto standard tool for generating documentation from annotated C++ sources, but it also supports other popular programming languages such as C, Objective-C, C#, PHP, Java, Python, IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL, Tcl, and to some extent D.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。只要我们在写注释的时候按照它制定的规则写，那么它就可以为我们生成漂亮的文档。&lt;/p&gt;
&lt;h3 id="2.2. installation"&gt;2.2. Installation&lt;/h3&gt;
&lt;p&gt;官网上的 Manual 中有详细的介绍，对于不同平台，采用不同的安装方式（从源码编译安装、二进制文件安装），下面仅记录我在 Ubuntu 下使用源码编码的方式安装过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载源代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;doxygen&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;doxygen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;doxygen&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装成功之后，在 &lt;code&gt;/usr/bin/&lt;/code&gt; 或者 &lt;code&gt;/usr/local/bin&lt;/code&gt; 目录下可以查看到二进制 &lt;code&gt;doxygen&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若 configure 出错，检查依赖关系，安装需要系统中有 GNU 工具（flex, bison, libiconv and GNU make, and strip）和 Perl 支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 Doxygen 要调用 Graphviz，所以先安装 Graphviz，然后编译安装 Doxygen&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="2.3. getting started"&gt;2.3. Getting Started&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/starting.html"&gt;Getting Started&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查 Doxygen 是否支持你项目所使用的语言&lt;/p&gt;
&lt;p&gt;Doxygen 支持  C, C++, C#, Objective-C, IDL, Java, VHDL, PHP, Python, Tcl, Fortran, D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个配置文件&lt;/p&gt;
&lt;p&gt;Doxygen 使用一个配置文件来工作，，每个项目都应该有一个自己对应的配置文件。我们可以使用 &lt;code&gt;doxygen -g&lt;/code&gt; 来让 Doxygen 自动生成一个参考配置文件，然后修改其中个别配置即可.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;doxygen&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;g&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;常用配置：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PROJECT_NAME = "Test Project"&lt;/code&gt; 配置项目名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PROJECT_NUMBER = 1.0&lt;/code&gt; 配置项目版本号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUTPUT_DIRECTORY = ./doxygen-output&lt;/code&gt; 配置输出结果目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OPTIMIZE_OUTPUT_FOR_C = YES&lt;/code&gt; 设置针对哪种语言进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;EXTRACT_ALL = YES&lt;/code&gt; 默认是 &lt;code&gt;NO&lt;/code&gt;，即默认只对有标准注释的文件进行分析。如果我们希望对一个没有按照标准格式注释的项目进行分析，那么就要改为 &lt;code&gt;YES&lt;/code&gt;，这在接手一个旧项目，分析代码时尤其有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HAVE_DOT = YES&lt;/code&gt; 设置 Doxygen 调用 dot 工具（graphviz 的一部分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DOT_PATH = /usr/local/graphviz&lt;/code&gt; 指定 graphviz 的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 Doxygen&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;doxygen&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果前一步没有指定配置文件的名字的话，直接运行 &lt;code&gt;doxygen&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;运行完之后，就可以在指定的输出目录中看到结果，用浏览器可以看到 HTML 版本的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照 Doxygen 格式注释代码&lt;/p&gt;
&lt;p&gt;这一步应该在最前面，即先按照 Doxygen 风格格式注释好代码，然后再进行分析。官网上针对不同的编程语言，有详细的举例说明：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#specialblock"&gt;Documenting the code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="2.4. documenting the code"&gt;2.4. Documenting the code&lt;/h3&gt;
&lt;p&gt;这部分虽然在最后，事实上应该是第一步，也就是说我们先按照规定添加 Doxygen 风格的注释，然后再配置、调用 Doxygen 来生成文档。&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen 官网&lt;/a&gt;上有详细的注释&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html"&gt;格式说明&lt;/a&gt;，下面是我搬运来学习，自己翻译的。&lt;/p&gt;
&lt;p&gt;我们在 C/C++ 风格注释块中加入一些特殊符号，这样 Doxygen 就知道需要把这段注释分析生成在文档中，这样的注释在官网中叫做 &lt;code&gt;Special comment blocks&lt;/code&gt;。下面详细介绍类 C/C++ 语言（C/C++/C#/Objective-C/PHP/Java）的注释，其他语言（Python, VHDL, Fortran, Tcl）见官网。&lt;/p&gt;
&lt;p&gt;对于代码中的任何实体（&lt;code&gt;entity&lt;/code&gt;），都有两种注释，它们一起工作，完成注释功能，但至少得有一个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a brief description&lt;/code&gt;：单行的简短注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a detailed description&lt;/code&gt;：多行的详细注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 方法 &lt;code&gt;methods&lt;/code&gt; 和 函数 &lt;code&gt;functions&lt;/code&gt;，还有额外的第三种注释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in body description&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于详细注释（detailed description），可以用以下的几种风格来进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JavaDoc Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即在 C 风格注释块开始使用两个星号 &lt;code&gt;*&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* ... text ...&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Qt Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即在 C 风格注释块开始处添加一个叹号 &lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;* ... text ...&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C++ Comment Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用连续两个以上的 C++ 注释行组成注释块，并且每行要多写一个 &lt;code&gt;/&lt;/code&gt; 或者 &lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;///&lt;/span&gt;
&lt;span class="o"&gt;///&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;///&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//!&lt;/span&gt;
&lt;span class="o"&gt;//!&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;//!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四种格式，有的人喜欢让自己的注释更加醒目一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;/////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="o"&gt;///&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;/////////////////////////////////////////////////&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于简单注释（brief description），也有以下的几种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以选用以上其中一种风格，然后加入 &lt;code&gt;\brief&lt;/code&gt; 命令来标明 brief 的开始。这种方式以段落的结尾作为结束。所以在 brief 后要写 detailed 的话，需要空一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* \brief Brief description.&lt;/span&gt;
&lt;span class="cm"&gt;*         Brief description continued.&lt;/span&gt;
&lt;span class="cm"&gt;*&lt;/span&gt;
&lt;span class="cm"&gt;*  Detailed description starts here.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果选择 JavaDoc 的风格，并且在配置文件中设置 &lt;code&gt;JAVADOC_AUTOBRIEF = YES&lt;/code&gt; 的话，Doxygen 会自动将第一句话作为 brief description，这个句子以 &lt;code&gt;. + 空格/空行&lt;/code&gt; 结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/** Brief description which ends at this dot. Details follow&lt;/span&gt;
&lt;span class="cm"&gt;*   here.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式对多行的 C++ 特殊注释风格也有效：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;///&lt;/span&gt; &lt;span class="n"&gt;Brief&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;ends&lt;/span&gt; &lt;span class="k"&gt;at&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Details&lt;/span&gt; &lt;span class="n"&gt;follow&lt;/span&gt;
&lt;span class="o"&gt;///&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三种方法是使用不多于一行的特殊 C++ 风格注释，下面是两个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;///&lt;/span&gt; &lt;span class="n"&gt;Brief&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="cm"&gt;/** Detailed description. */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：（这种情况下，必须用空行把 brief 和 detailed 分开，同时 &lt;code&gt;JAVADOC_AUTOBRIEF = NO&lt;/code&gt;）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//!&lt;/span&gt; &lt;span class="n"&gt;Brief&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="o"&gt;//!&lt;/span&gt; &lt;span class="n"&gt;Detailed&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; 
&lt;span class="o"&gt;//!&lt;/span&gt; &lt;span class="n"&gt;starts&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Doxygen 和其他的文档系统的一个不同之处就是它允许把注释写在实体的定义（包括全局函数）之前。这样，就可以把注释直接写在源文件里面而不是头文件中，从而使头文件更加紧凑，而且功能的实现人员也更容易阅读注释。&lt;strong&gt;所以，一个折衷方案就是在声明前写 brief description，在定义前写 detailed description。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="2.4.1. putting documentation after members"&gt;2.4.1. Putting documentation after members&lt;/h4&gt;
&lt;p&gt;在注释结构体、类、枚举类型等时，有时习惯将注释写在代码的后面，而不是前面。因为 Doxygen 默认注释是解释后面的代码，所以这时候就需要在注释中添加一个额外的 &lt;code&gt;&amp;lt;&lt;/code&gt; 来标明是注释前面的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Qt 风格的注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/*!&amp;lt; Detailed description after the member */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; Detailed description after the member */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;//!&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Detailed&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="k"&gt;after&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;
         &lt;span class="o"&gt;//!&amp;lt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般来说，我们通常在后面添加的注释都是 brief description 而不是 detailed description，所以更常见的格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;//!&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Brief&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="k"&gt;after&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;///&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Brief&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt; &lt;span class="k"&gt;after&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种添加 &lt;code&gt;&amp;lt;&lt;/code&gt; 的方法只能用在 成员（&lt;code&gt;member&lt;/code&gt;）和 参数（&lt;code&gt;parameter&lt;/code&gt;）中，不能用在描述文件、类、联合体、名字空间和枚举本身。此外, 在后面提到的结构化命令（如&lt;code&gt;\class&lt;/code&gt;）在这种注释段中是无效的。&lt;/p&gt;
&lt;h4 id="2.4.2. examples"&gt;2.4.2. Examples&lt;/h4&gt;
&lt;p&gt;官网上提供了一个例子，分别用 Qt 和 JavaDoc 的风格注释一段相同的 C++ 代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Qt style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//!  A test class. &lt;/span&gt;
&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;  A more elaborate class description.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//! An enum.&lt;/span&gt;
    &lt;span class="cm"&gt;/*! More detailed enum description. */&lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;TEnum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
                 &lt;span class="n"&gt;TVal1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal1. */&lt;/span&gt;  
                 &lt;span class="n"&gt;TVal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal2. */&lt;/span&gt;  
                 &lt;span class="n"&gt;TVal3&lt;/span&gt;  &lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal3. */&lt;/span&gt;  
               &lt;span class="p"&gt;}&lt;/span&gt; 
         &lt;span class="c1"&gt;//! Enum pointer.&lt;/span&gt;
         &lt;span class="cm"&gt;/*! Details. */&lt;/span&gt;
         &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;enumPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
         &lt;span class="c1"&gt;//! Enum variable.&lt;/span&gt;
         &lt;span class="cm"&gt;/*! Details. */&lt;/span&gt;
         &lt;span class="n"&gt;enumVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//! A constructor.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      A more elaborate description of the constructor.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//! A destructor.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      A more elaborate description of the destructor.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
   &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//! A normal member taking two arguments and returning an integer value.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      \param a an integer argument.&lt;/span&gt;
&lt;span class="cm"&gt;      \param s a constant character pointer.&lt;/span&gt;
&lt;span class="cm"&gt;      \return The test results&lt;/span&gt;
&lt;span class="cm"&gt;      \sa Test(), ~Test(), testMeToo() and publicVar()&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;testMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;//! A pure virtual member.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      \sa testMe()&lt;/span&gt;
&lt;span class="cm"&gt;      \param c1 the first argument.&lt;/span&gt;
&lt;span class="cm"&gt;      \param c2 the second argument.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testMeToo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//! A public variable.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      Details.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;publicVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//! A function variable.&lt;/span&gt;
    &lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      Details.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/qtstyle/html/class_test.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaDoc style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  A test class. A more elaborate class description.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;     * An enum.&lt;/span&gt;
&lt;span class="cm"&gt;     * More detailed enum description.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;TEnum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
          &lt;span class="n"&gt;TVal1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; enum value TVal1. */&lt;/span&gt;  
          &lt;span class="n"&gt;TVal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; enum value TVal2. */&lt;/span&gt;  
          &lt;span class="n"&gt;TVal3&lt;/span&gt;  &lt;span class="cm"&gt;/**&amp;lt; enum value TVal3. */&lt;/span&gt;  
         &lt;span class="p"&gt;}&lt;/span&gt; 
       &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;enumPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/**&amp;lt; enum pointer. Details. */&lt;/span&gt;
       &lt;span class="n"&gt;enumVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/**&amp;lt; enum variable. Details. */&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A constructor.&lt;/span&gt;
&lt;span class="cm"&gt;       * A more elaborate description of the constructor.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
      &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A destructor.&lt;/span&gt;
&lt;span class="cm"&gt;       * A more elaborate description of the destructor.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
     &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * a normal member taking two arguments and returning an integer value.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param a an integer argument.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param s a constant character pointer.&lt;/span&gt;
&lt;span class="cm"&gt;       * @see Test()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see ~Test()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see testMeToo()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see publicVar()&lt;/span&gt;
&lt;span class="cm"&gt;       * @return The test results&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;testMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A pure virtual member.&lt;/span&gt;
&lt;span class="cm"&gt;       * @see testMe()&lt;/span&gt;
&lt;span class="cm"&gt;       * @param c1 the first argument.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param c2 the second argument.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;testMeToo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;       * a public variable.&lt;/span&gt;
&lt;span class="cm"&gt;       * Details.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;publicVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * a function variable.&lt;/span&gt;
&lt;span class="cm"&gt;       * Details.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
       &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/jdstyle/html/class_test.html&lt;/p&gt;
&lt;h4 id="2.4.3. documentation at other places"&gt;2.4.3. Documentation at other places&lt;/h4&gt;
&lt;p&gt;我们之前的例子中注释都是在文件、命名空间、类的声明或者定义之前，或者在它们的成员的前/后。虽然一般来说这是很正常的，但是有时候我们需要把代码写在在文档的其他地方。对于文件的注释更是如此，因为对于文件来说，根本就不存在在它之前的地方（"in front of a file"）。&lt;/p&gt;
&lt;p&gt;Doxygen 允许你把注释写在任何地方（例外情况是在函数体内 or 在 C 风格注释块内）。你需要付出的代价就是要在注释块内部多写一些结构化命令（&lt;code&gt;structural command&lt;/code&gt;）来标明。所以，&lt;strong&gt;一般来说，我们应该尽量避免使用结构化命令，除非是有其他的特殊要求这样做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构化命令以一个 &lt;code&gt;\&lt;/code&gt; 或者 &lt;code&gt;@&lt;/code&gt;（JavaDoc 风格）开始，后面接一个命令名字 + 一个（多个）参数。举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*! \class Test&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A test class.&lt;/span&gt;

&lt;span class="cm"&gt;    A more detailed class description.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中的 &lt;code&gt;\class&lt;/code&gt; 指示这个注释块中包含一个 Test 类的文档。其他常用的命名如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\structure&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\union&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;emun&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\typedef&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\file&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\namespace&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\package&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\interface&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的命令和说明在这里：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html"&gt;special commands&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对 C++ 类成员进行注释的时候，必须先注释这个类，对于命名空间来说也是如此。对 C 的全局函数、 typedef、enum、 preprocessor definition 进行注释，必须先注释包含它们的文件（通常是头文件）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Attention:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在重复一下容易出错的地方：&lt;strong&gt;在注释全局对象时，必须先注释它们所在的文件。&lt;/strong&gt;也就是说，必须包含以下两者之一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* \file */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* @file */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是官网上的一个 C 头文件的例子：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*! \file structcmd.h&lt;/span&gt;
&lt;span class="cm"&gt;\brief A Documented file.&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \def MAX(a,b)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A macro that returns the maximum of \a a and \a b.&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \var typedef unsigned int UINT32&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A type definition for a .&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \var int errno&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Contains the last error code.&lt;/span&gt;
&lt;span class="cm"&gt;    \warning Not thread safe!&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int open(const char *pathname,int flags)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Opens a file descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param pathname The name of the descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param flags Opening flags.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int close(int fd)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Closes the file descriptor \a fd.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to close.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn size_t write(int fd,const char *buf, size_t count)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Writes \a count bytes from \a buf to the filedescriptor \a fd.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to write to.&lt;/span&gt;
&lt;span class="cm"&gt;    \param buf The data buffer to write.&lt;/span&gt;
&lt;span class="cm"&gt;    \param count The number of bytes to write.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int read(int fd,char *buf,size_t count)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Read bytes from a file descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to read from.&lt;/span&gt;
&lt;span class="cm"&gt;    \param buf The buffer to read into.&lt;/span&gt;
&lt;span class="cm"&gt;    \param count The number of bytes to read.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#define MAX(a,b) (((a)&amp;gt;(b))?(a):(b))&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;UINT32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;上面这个例子中的每个注释块都包含了一条结构化命令，所以这些注释可以放在文件的其他位置或者放在其他文件中，不会影响到最终生成的文档。这种方法的坏处在于我们实际上写了两遍原型，当做修改时我们必须同时修改代码和注释。因此，我们在使用前应该仔细考虑是否真的需要结构化命令，并且尽可能避免使用它。一个常见的现象就是在函数前的注释块中包含了 &lt;code&gt;\fn&lt;/code&gt; 命令，显然这是冗余的，除了导致错误，这个命令毫无作用。&lt;/p&gt;
&lt;p&gt;如果我们对以 .dox, .txt, .doc 结尾的文件注释，那么 Doxygen 会自动忽略这些文件。&lt;/p&gt;
&lt;p&gt;如果我们有一个 Doxygen 无法解析的文件，但是仍然像注释它，那么就使用 &lt;code&gt;\verbinclude&lt;/code&gt; 这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*! \file myscript.sh&lt;/span&gt;
&lt;span class="cm"&gt;*   Look at this nice srcipt.&lt;/span&gt;
&lt;span class="cm"&gt;*  \verbinlcude mycript.sh&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还要确定在配置文件中 &lt;code&gt;INPUT&lt;/code&gt; 变量显式地说明这个脚本文件，或者 &lt;code&gt;FILE_PATTERNS&lt;/code&gt; 变量必须包含&lt;code&gt;.sh&lt;/code&gt; 文件扩展名并且可以通过 &lt;code&gt;EXAMPLE_PATH&lt;/code&gt; 变量寻找到这个文件。&lt;/p&gt;
&lt;h4 id="2.4.4. anatomy of a comment block"&gt;2.4.4. Anatomy of a comment block&lt;/h4&gt;
&lt;p&gt;前面介绍了如何对代码进行注释，并且讨论了两种不同的注释：brief 和 detailed，还讨论了如何使用结构化命令。&lt;/p&gt;
&lt;p&gt;下面我们分析注释块本身。&lt;/p&gt;
&lt;p&gt;Doxygen 支持很多种格式的注释，最简单的就是文本文件，适用于比较短的注释。对于比较长的注释，我们需要清单、表格等更加结构化的元素，对于这种情况，Doxygen 支持 Markdown 语法，可以直接读取 Markdown 文件，详细内容看这里：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/markdown.html"&gt;Markdown Support&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;(Markdown 源自邮件的文本格式，语法非常简洁，并且功能很强大，这篇文章本书就是用 Markdown 语法写的，语法细节见官网，这里不再赘述。)&lt;/p&gt;
&lt;p&gt;P.S.&lt;/p&gt;
&lt;p&gt;找到一篇博客，详细介绍了基于 Doxygen 的 C++ 注释风格：&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;C++标准注释原则 - 基于doxygen的C++注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;最后展示一张我的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/how-to-analyse-code-elegantly/result.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. ref._2"&gt;3. Ref.&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/blood008/article/details/6567169"&gt;linux doxygen 的安装和使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/wishma/archive/2008/07/24/1250339.html"&gt;doxygen 使用简介（C,C++为代码作注释）&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="doxygen"></category><category term="code"></category></entry><entry><title>学习 Arduino #3 Intel Galileo Linux</title><link href="https://qiangu.cool/posts/linux/learn_arduino_series_3_intel_galileo_linux.html" rel="alternate"></link><published>2014-06-13T20:31:00+08:00</published><updated>2014-06-13T20:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-06-13:/posts/linux/learn_arduino_series_3_intel_galileo_linux.html</id><summary type="html">&lt;p&gt;学习 Arduino，#3 通过 Ethernet &amp;amp; Serial Port 登录到 Galileo 上的 Linux 系统&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. linux on galileo board"&gt;1. Linux on Galileo Board&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Galileo 不是简单的 Arduino 板子，实际上它运行着一个 Linux 操作系统。把它看作是 &amp;ldquo;兼容 Arduibo 接口的板子&amp;rdquo; 或许更合适一些。&lt;/p&gt;
&lt;p&gt;Galileo 板子上容量为 8 MB 的 SPI Flash 中已经烧写了一个精简版的 Linux 系统，因为容量的限制，这个系统去掉了一些不常用的模块，比如 wi-fi 驱动，python 支持等。&lt;/p&gt;
&lt;p&gt;Galileo 也支持从 SD 卡启动系统，并且 Intel 提供了一个基于 Yocto 项目，已经制作好的完整版 Linux 系统。当精简版系统不能满足我们的要求时（添加外设等），我们可以下载这个完整版系统镜像，烧录到 SD 卡中，并从 SD 卡中启动即可。（也可以自己基于 Yocto 项目按照自己的需求制作系统镜像）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们并不仅仅满足于通过 Arduino IDE 对 Galileo 进行操作，放着一个操作系统，为什么不去使用呢：-P 那么怎么才能登录到这个 Linux 系统中呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. using ethernet"&gt;2. Using Ethernet&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Intel 论坛的一个帖子列举了几种登录到 Galileo Linux 的方法&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the UART connector&lt;/li&gt;
&lt;li&gt;Use the LAN connection direct to your PC&lt;/li&gt;
&lt;li&gt;Use the LAN connection and connect to your local network &lt;/li&gt;
&lt;li&gt;You can also connect using WiFi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到我们目前有的材料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Galileo 开发板&lt;/li&gt;
&lt;li&gt;Galileo 电源&lt;/li&gt;
&lt;li&gt;micro USB 线&lt;/li&gt;
&lt;li&gt;5 类网线&lt;/li&gt;
&lt;li&gt;运行着 Linux (Ubuntu) 的 PC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为没有串口线，所以我们采用第 2 种方案，即直接连接 PC 和 Galileo，通过 Ethernet 登录。&lt;/p&gt;
&lt;h3 id="2.1. summary"&gt;2.1. Summary&lt;/h3&gt;
&lt;p&gt;Galileo 默认是不开启 &lt;code&gt;Lan&lt;/code&gt; 的，也不开启 &lt;code&gt;Telnet&lt;/code&gt; 服务，所以我们需要做的事就是写一个 &lt;code&gt;sketch&lt;/code&gt;，启动 Lan 连接服务和 Telnet 服务，然后分别给 PC 和 Galileo 一个属于同一子网的静态 IP 地址，这样就可以使用 PC 通过 Telnet 协议登录到 Galileo 上的 Linux 系统中。&lt;/p&gt;
&lt;h3 id="2.2. setp 1: write sketch"&gt;2.2. Setp 1: Write sketch&lt;/h3&gt;
&lt;p&gt;代码需要完成的功能一共有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启 telnet 服务&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;system&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"telnetd -l /bin/sh"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 IP 地址&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;system&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将板子的以太网配置状态显示在 serial monitor 中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;system&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"ifconfig eth0 &amp;gt; /dev/ttyACM0"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全部代码如下&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// put your setup code here, to run once:&lt;/span&gt;
  &lt;span class="c1"&gt;// Initial serial prot&lt;/span&gt;
  &lt;span class="nf"&gt;Serial&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9600&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// Start telnet service on board&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"telnetd -l /bin/sh"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;// Assign the IP address '169.254.1.1' to it&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// put your main code here, to run repeatedly: &lt;/span&gt;
  &lt;span class="c1"&gt;// Show the IP detial in the serial monitor of IDE&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ifconfig eth0 &amp;amp;&amp;gt; /dev/ttyGS0 &amp;amp;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="2.3. step 2: connect,upload"&gt;2.3. Step 2: Connect，Upload&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网线直连 PC 和 Galileo，设置 PC 的 IP 地址为 &lt;code&gt;link-local only&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_config" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_config.png"/&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给 Galileo 供电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接 USB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 Arduino IDE，&lt;code&gt;Upload&lt;/code&gt; 上面的 sketch&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="2.4. step 3: login"&gt;2.4. Step 3: Login&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 IDE 的 serial monitor，可以看到 Galileo 的 ethernet 配置信息&lt;/p&gt;
&lt;p&gt;&lt;img alt="galileo_ethernet_quary" src="/images/learning-arduino-series-3-intel-galileo-linux/galileo_ethernet_quary.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 PC 的网络配置&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ifconfig eth0
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;查询结果&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_quary" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_quary.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 PC 的终端 Terminal，使用 telnet 登录&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;telnet &lt;span class="m"&gt;169&lt;/span&gt;.254.1.1
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;登录结果，如图&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc_ethernet_login" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_telnet_login.png"/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这个精简版的 Linux 系统是不支持 Python 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. using uart_1"&gt;3. Using UART&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="3.1. about serial port"&gt;3.1. About serial port&lt;/h3&gt;
&lt;p&gt;如果有串口线的话，我们也可以通过串口来登录，包括 SPI 和 SD 卡上的系统。&lt;/p&gt;
&lt;p&gt;关于串口线，说明一下。估计是为了节省板子的面积，Intel 在板子上设置的是音频接口(AV jack)，所以，这里需要额外的一个将音频接口转接为串口的器件。有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上网买一个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自己 DIY 一个&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果上网买的话，注意 Galileo 用的是 RS232 电平，不要买错成 TTL 电平的。如果是自己 DIY 的话，Intel Galileo Get Started 里面有介绍串口线的接法，他们的论坛上也有相关的讨论：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208448#208448"&gt;UART cable pin-out&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pinouts.ru/SerialPorts/Serial9_pinout.shtml"&gt;RS 232 DE-9 port&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="3.2. linux platform"&gt;3.2. Linux Platform&lt;/h3&gt;
&lt;p&gt;我在 Ubuntu 下使用的终端软件是 &lt;code&gt;gtkterm&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="3.2.1. step 1: burn the full-linux sytem"&gt;3.2.1. Step 1: Burn the full-linux sytem&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Intel 官网提供的完整版 Linux 镜像是基于 &lt;code&gt;Yocto&lt;/code&gt; 项目裁剪出来的，取名叫 &lt;code&gt;Claton&lt;/code&gt;，目前(2014-6-13)的版本号为 &lt;code&gt;1.0.0&lt;/code&gt;，但是这个版本在我的SD卡中是无法启动的，浪费了大量时间，最后终于发现 &lt;code&gt;0.7.5&lt;/code&gt; 版本可以...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有就是 Get Started 中推荐不要使用 PC 操作系统提供的格式化功能，更好的选择应该是专业格式化软件，比如 &lt;code&gt;SDFormatter&lt;/code&gt;。但是我实际使用时，发现反而是 &lt;code&gt;SDFormatter&lt;/code&gt; 制作的不能启动...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="3.2.2. step 2: connect"&gt;3.2.2. Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;选择正确的端口（因为我使用的串口线是 &lt;code&gt;AV-RS232-USB&lt;/code&gt;，所以下面选择的端口是 &lt;code&gt;ttyUSB0&lt;/code&gt;）；&lt;code&gt;Baud Rate = 115200&lt;/code&gt;，&lt;code&gt;Bits =8&lt;/code&gt;，&lt;code&gt;Stopbits = 1&lt;/code&gt;，&lt;code&gt;Parity = none&lt;/code&gt;，&lt;code&gt;Flow control = none&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="3.2.3. step 3: login"&gt;3.2.3. Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_boot_information.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_grub.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_spi.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_sd_card.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="3.3. windows platform_1"&gt;3.3. Windows Platform&lt;/h3&gt;
&lt;p&gt;我在 Windows 下使用的终端软件是 &lt;code&gt;Putty&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="3.3.1. step 1: burn the full-linux system"&gt;3.3.1. Step 1: Burn the full-linux system&lt;/h4&gt;
&lt;p&gt;与 Linux 平台下相同。&lt;/p&gt;
&lt;h4 id="3.3.2. step 2: connect"&gt;3.3.2. Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;同样，选择正确的端口和波特率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="3.3.3. step 3: login"&gt;3.3.3. Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_boot_information.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_grub.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_spi.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_sd_card.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. another method_2"&gt;4. Another method&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;如果你觉得插网线、配置 IP 地址太麻烦，甚至懒得自己 DIY 串口线，也没有钱去买一个，别担心，因为 &amp;ldquo;天空飘来五个字，这都不是事～&amp;rdquo; 因为你可以借鉴下面这位大神的方法，只需要像下载普通 sketch 一样，将他提供的 sketch 下载到 Galileo 中就可以了，然后通过 IDE 的 serial monitor 就可以登录到 Linux 系统中：&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他的 sketch 的原理就是使用 &lt;code&gt;system()&lt;/code&gt; 函数将我们在 serial monitor 中的命令传到到 Linux shell 中 ，并将命令的结果返回到 serial monitor 中 。&lt;/p&gt;
&lt;p&gt;不过这种方法的缺点是每个命令传递到 Galileo 后会开辟一个新的进程，当命令执行完返回结果时，这个进程自动结束，所以会产生一些 &amp;ldquo;问题&amp;rdquo;：当我们 &lt;code&gt;cd&lt;/code&gt; 到某个子目录后，返回结果之后，我们又回到的之前的目录，举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; home
$ &lt;span class="nb"&gt;pwd&lt;/span&gt;

// result is root dirctory
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;解决方法就是将命令写在一行&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; home&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nb"&gt;pwd&lt;/span&gt;

// result is home directory
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. reference"&gt;5. Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/docs/DOC-22293"&gt;Tutorial 3: Connecting to Linux through telnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208564#208564"&gt;Using Galileo Linux over Ethernet(Telnet)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Arduino"></category><category term="Linux"></category></entry><entry><title>学习 Arduino #2 初识 Intel Galileo 开发板</title><link href="https://qiangu.cool/posts/linux/learn_arduino_series_2_intel_galileo_development_board.html" rel="alternate"></link><published>2014-05-29T23:27:00+08:00</published><updated>2014-05-29T23:27:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-05-29:/posts/linux/learn_arduino_series_2_intel_galileo_development_board.html</id><summary type="html">&lt;p&gt;学习 Arduino，#2 初识 Intel Galileo 开发板&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. preface"&gt;1. Preface&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Arduino 有很多开发板，分别针对不同的应用环境含有不同的模块。学习一款 Intel 推出的开发板 &amp;mdash;&amp;mdash; &lt;em&gt;Intel Galileo Development Board&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;Intel Gailileo Development Board 是 Intel 进入 Arduino 领域的试水产品，它含有一颗 Quark Soc X1000 CPU，这是一款 32 位、x86 构架、低功耗的 SoC 芯片，它的主频可以达到 400 MHz，内部有 512 KB 的 SRAM，同时 Galileo 有丰富的接口(USB, JTag, RS232, Ethernet, mPCIE...)，支持很多外围设备。&lt;/p&gt;
&lt;p&gt;Galileo 试图达到的目标是融合 Arduino 对硬件操作的便利和 Linux 系统对硬件操作完整支持。所以，Galileo 也兼容 Arduino 接口，你可以很方便的把 Arduino 项目移植到 Galileo 上运行，使用常用的一些 Arduino 库(Ethernet, Wi-Fi, SD, EEPROM...)也可以获得内部 Linux 系统的完整功能(Python, SSH, Telnet， OpenCV...)。&lt;/p&gt;
&lt;p&gt;总结一下我学习这块板子的知识，不仅仅为 Arduino 开发做准备，也为后面的一个竞赛(基于Yocto 项目)开发积累知识～&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. official arduino boards"&gt;2. Official Arduino Boards&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Arduino 官网上列出所有了官方开发板，其中也包含了官方认证过的开发板(Intel Galileo)，和一些推荐的第三方产品&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Main/Products"&gt;Arduino Products&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还详细列出了这些开发板上的微控制器的区别&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Products.Compare"&gt;Compare boards specs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;官方的开发板的核心都是 Atmel 的微控制器，基于市场战略的需求，看到数莓派、Arduino发展的热火朝天，Intel 也坐不住了(瞎猜的 =.=)，推出了新的基于 Intel 架构(x86)、可以和 Arduino 兼容的开发板。Galileo 是这个家族中的第一款，目前 Intel 又推出了一款新的开发板，取名叫 Edison。(Intel 这是要把所有科学家的名字都取个遍么)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. intel galileo board"&gt;3. Intel Galileo Board&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="3.1. arduinco.cc"&gt;3.1. Arduinco.cc&lt;/h3&gt;
&lt;p&gt;在 Arduino 官网上有一篇简单介绍 Galileo 的网页&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/ArduinoCertified/IntelGalileo"&gt;Intel Galileo on arduino.cc&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="3.2. intel official introduction"&gt;3.2. Intel Official Introduction&lt;/h3&gt;
&lt;p&gt;Arduino 官网上的介绍只是非常简单的介绍，Intel 自己的官网上有关于 Galileo 全部的详细资料&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.intel.cn/content/www/cn/zh/do-it-yourself/galileo-maker-quark-board.html"&gt;Galileo Maker Quark Board&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Galileo 的全部文档，包括 Datasheet、Schematic、Quick Start、User Guide 等：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/community/makers/documentation/galileodocuments"&gt;Intel Galileo Development Board Documents&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="3.3. other introductions"&gt;3.3. Other Introductions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt; 送上一篇非常好的介绍文章（来自 Ifanr.com），介绍了在 Maker 眼中，这个板子到底可以 hack 到什么程度～&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ifanr.com/388835"&gt;x86 版的 Arduino 来了，Intel Galileo 开发板的体验、分析和应用【超长文多图】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再&lt;/strong&gt; 附上一篇完爆我的总结的教程～&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.sparkfun.com/tutorials/galileo-getting-started-guide"&gt;Galileo Getting Started Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇教程基本就是按照 Intel 官方的 Getting Started 流程写的，总结一下我遇到的问题 (Windows 7 &amp;amp; Linux Ubuntu)。&lt;/p&gt;
&lt;p&gt;Arduino 官方的 IDE 中 &lt;code&gt;Board&lt;/code&gt; 选项中没有 Galileo，所以我们应该从 Intel 下载定制过的 IDE。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows IDE 闪退&lt;/p&gt;
&lt;p&gt;这个 IDE 在部分 Windows 下有闪退的现象。&lt;/p&gt;
&lt;p&gt;原因 是 Intel 的 IDE 版本采用的是未发布的 1.5.3, 它会检测系统的语言设置，当系统不是 En/US 时，就会退出。&lt;/p&gt;
&lt;p&gt;解决方法 更改系统语言设置 或者 使用一款名为 Locale Emulator 的软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDE 解压路径&lt;/p&gt;
&lt;p&gt;Windows 下的解压路径 &lt;em&gt;必须是顶层目录&lt;/em&gt;，比如 &lt;code&gt;D:\arduino-1.5.3&lt;/code&gt;，否则在 &lt;code&gt;Verify&lt;/code&gt; 时会提示找不到特定的文件/目录。Linux 下无此问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 连接板子和 PC&lt;/p&gt;
&lt;p&gt;在 Windows 下第一次连接系统自动安装驱动肯定会失败的，需要我们手动指定驱动文件的路径。&lt;/p&gt;
&lt;p&gt;在 Linux 终端下，必须以 &lt;code&gt;sudo&lt;/code&gt; 权限运行 IDE，否则即使板子已经连接了 PC，在 IDE 下的 &lt;code&gt;Tools\Serial Port&lt;/code&gt; 是 disable 的，不能选择端口&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo ./arduino &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 下 disable modem manager&lt;/p&gt;
&lt;p&gt;前面的教程中提到，在大多数 Linux 发行版下，都需要 disable modem manager 才能 &lt;code&gt;Upload&lt;/code&gt; 成功，不过我在 Ubuntu 下没有遇到这个问题...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt; 扯几句&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;硬件配置&lt;/p&gt;
&lt;p&gt;从 Board Guide 中找到的截图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="key_componets_1" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="key_componets_2" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_2.png"/&gt;&lt;/p&gt;
&lt;p&gt;从它的配置中可以看到，Galileo 并不是一款简单的 Arduino 开发板，它的硬件系统其实是按照 PC 来设计的，如果我们只是简单的把它当作 Arduino 开发板来应用，有点大材小用了，这样子完全没有体现出 Galileo 的优势，只是一个速度更快的 Arduino 罢了。&lt;/p&gt;
&lt;p&gt;事实上，如果功能上没有比传统的 Arduino 更强大的功能，估计 Intel 也不会推出这个产品了～Galileo 的真正强大的地方在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;背后基于 UEFI/Linux 的软件平台以及 Galileo 自身的硬件配置。为此，Intel 提供了丰富的开发文档、软件代码支持，方便开发人员真正的发挥出 Galileo 的所有潜力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件构架&lt;/p&gt;
&lt;p&gt;Galileo 不仅仅是硬件上按照 PC 设计的，事实上，它的软件构架也和 PC 一样。和普通的单片机不同，它并不是简单的运行用户开发的程序那么简单。它实际上运行着一个操作系统 &amp;mdash;&amp;mdash; 包含 UEFI(BIOS 的替代者)、Grub、嵌入式 Linux 系统，用户编写的 &lt;code&gt;Sketch&lt;/code&gt; 只是一个在 Linux 上面运行的应用而已。&lt;/p&gt;
&lt;p&gt;Galileo 启动时可以从 ISP Flash 中启动一个微型的 Linux 系统，也可以从 MicroSD 卡中启动一个完整版的 Linux 系统。我们 &lt;code&gt;Upload&lt;/code&gt; 时，Arduino IDE 将程序编译链接成一个标准的 Linux ELF 文件，并且下载到 Arduino 板子上运行，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="target_software" src="/images/learning-arduino-series-2-intel-galileo-development-board/target_software.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发嵌入式 Linux 设备&lt;/p&gt;
&lt;p&gt;或许这才是 Galileo 的 "正经" 用途吧...基于 Yocto Project，我们可以开发属于自己的 Linux 系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，送上一个别人的 Galileo 开箱视频&lt;/p&gt;
&lt;p&gt;&lt;embed align="middle" allowfullscreen="true" allowscriptaccess="always" height="400" quality="high" src="http://player.youku.com/player.php/sid/XNjQ0NTMzMjYw/v.swf" type="application/x-shockwave-flash" width="480"/&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Intel Galileo"></category><category term="Arduino"></category></entry><entry><title>学习 Arduino #1 Arduino 入门</title><link href="https://qiangu.cool/posts/linux/learn_arduino_series_1_getting_started.html" rel="alternate"></link><published>2014-05-27T12:34:00+08:00</published><updated>2014-05-27T12:34:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-05-27:/posts/linux/learn_arduino_series_1_getting_started.html</id><summary type="html">&lt;p&gt;学习 Arduino，#1 Arduino 入门&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. what is arduino"&gt;1. What is Arduino&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img alt="logo" src="/images/learning-arduino-series-1-getting-started/logo.png"/&gt;&lt;/p&gt;
&lt;p&gt;版权所有：Arduino.cc&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino 官网&lt;/a&gt; 首页的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARDUINO IS AN OPEN-SOURCE ELECTRONICS PROTOTYPING PLATFORM BASED ON FLEXIBLE, EASY-TO-USE HARDWARE AND SOFTWARE. IT'S INTENDED FOR ARTISTS, DESIGNERS, HOBBYISTS AND ANYONE INTERESTED IN CREATING INTERACTIVE OBJECTS OR ENVIRONMENTS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官方网站最权威的答案：&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino is a tool for making computers that can sense and control more of the physical world than your desktop computer. &lt;strong&gt;It's an open-source physical computing platform based on a simple microcontroller board, and a development environment for writing software for the board.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino can be used to develop interactive objects, taking inputs from a variety of switches or sensors, and controlling a variety of lights, motors, and other physical outputs. Arduino projects can be stand-alone, or they can communicate with software running on your computer (e.g. Flash, Processing, MaxMSP.) The boards can be assembled by hand or purchased preassembled; the open-source IDE can be downloaded for free.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Development Language：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino programming language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IDE：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt; &lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Wikipedia 上的介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino 是一个开放源代码的单片机，它使用了 Atmel AVR 单片机，采用了基于开放源代码的软硬件平台，构建于开放源代码 simple I/O 接口板。开发语言为 Arduino programming language（基于 Wiring 语言），开发环境基于 Processing 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. story of arduino"&gt;2. Story of Arduino&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;wikipedia 上的&lt;a href="http://zh.wikipedia.org/wiki/Arduino"&gt;小故事&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino的核心开发团队成员包括：Massimo Banzi，David Cuartielles，Tom Igoe，Gianluca Martino，David Mellis 和 Nicholas Zambetti。&lt;/p&gt;
&lt;p&gt;据说 Massimo Banzi 之前是意大利 Ivrea 一家高科技设计学校的老师。他的学生们经常抱怨找不到便宜好用的微控制器。2005年冬天， Massimo Banzi 跟 David Cuartielles 讨论了这个问题。David Cuartielles 是一个西班牙籍芯片工程师，当时在这所学校做访问学者。两人决定设计自己的电路板，并引入了 Banzi 的学生 David Mellis 为电路板设计编程语言。两天以后，David Mellis 就写出了程式码。又过了三天，电路板就完工了。这块电路板被命名为 Arduino。几乎任何人，即使不懂电脑编程，也能用 Arduino 做出很酷的东西，比如对传感器作出回应，闪烁灯光，还能控制马达。随后 Banzi，Cuartielles，和 Mellis 把设计图放到了网上。保持设计的开放源码理念，因为版权法可以监管开源软件，却很难用在硬件上，他们决定采用共享创意许可。共享创意是为保护开放版权行为而出现的类似 GPL 的一种许可（license）。在共享创意许可下，任何人都被允许生产电路板的复制品，还能重新设计，甚至销售原设计的复制品。你不需要付版税，甚至不用取得 Arduino 团队的许可。然而，如果你重新发布了引用设计，你必须说明原始 Arduino 团队的贡献。如果你调整或改动了电路板，你的最新设计必须使用相同或类似的共享创意许可，以保证新版本的 Arduino 电路板也会一样的自由和开放。唯一被保留的只有 Arduino 这个名字。它被注册成了商标。如果有人想用这个名字卖电路板，那他们可能必须付一点商标费用给 Arduino 的核心开发团队成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. why is arduino"&gt;3. Why is Arduino&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官网介绍&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are many other microcontrollers and microcontroller platforms available for physical computing. Parallax Basic Stamp, Netmedia's BX-24, Phidgets, MIT's Handyboard, and many others offer similar functionality. All of these tools take the messy details of microcontroller programming and wrap it up in an easy-to-use package. &lt;strong&gt;Arduino also simplifies the process of working with microcontrollers, but it offers some advantage for teachers, students, and interested amateurs over other systems:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inexpensive&lt;/li&gt;
&lt;li&gt;Cross-platform (Windows, Linux, Macintosh OSX)&lt;/li&gt;
&lt;li&gt;Simple, clear programming environment&lt;/li&gt;
&lt;li&gt;Open source and extensible software&lt;/li&gt;
&lt;li&gt;Open source and extensible hardware&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. how-to develope"&gt;4. How-to Develope&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="4.1. ide installation"&gt;4.1. IDE installation&lt;/h3&gt;
&lt;p&gt;官网上有 Windows, Linux, Mac 的详细安装步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://arduino.cc/en/Guide/Windows"&gt;for Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://playground.arduino.cc/Learning/Linux"&gt;for Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux 安装过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解决包依赖关系：安装 openjdk-7-jre (openjdk-6-jre, sun's java 6 runtime, the sun-java6-jre package, the oracle JRE 7 应该也可以)&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install openjdk-7-jre
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载合适的 &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;解压、切换到解压路径，运行目录下的 &lt;code&gt;arduino&lt;/code&gt; 脚本&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar -zxvf arduino-1.0.5-linux32.tgz
&lt;span class="nb"&gt;cd&lt;/span&gt; arduino-1.0.5
./arduino
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法二 (for Ubuntu)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 &amp;amp; 安装&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install arduino arduino-core
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ arduino
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="4.2. dev"&gt;4.2. Dev&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IDE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino IDE 是用 Java 写的跨平台的程序，它源自 &lt;a href="http://en.wikipedia.org/wiki/Processing_(programming_language)"&gt;Processing programming language&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Wiring_(development_platform)"&gt;Wiring&lt;/a&gt; 项目的 IDE 。它是为艺术家和其他不熟悉软件开发的新手而设计的。它包含一个有语法高亮、括号匹配、自动缩进功能的代码编辑器，还可以通过一个按键完成编译程序(compile)和烧录至电路板(upload)的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Programming&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 Arduino 程序/代码 称为 "&lt;em&gt;Sketch&lt;/em&gt;"。Arduino 程序是用 C/C++ 写成的，Arduino IDE 含有一个名叫 "Wiring" 的代码库(源自于 Wiring 项目)，这样子可以大幅度简化常用 I/O 操作，用户只需要定义两个函数就可以写出一个可以运行的程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;setup()&lt;/em&gt; : 系统上电或者复位时启动，只运行一次，初始化配置&lt;/li&gt;
&lt;li&gt;&lt;em&gt;loop()&lt;/em&gt; : 一直循环被调用，直到断电&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Arduino 的示例程序 "Blink"：(等同于 C 的 hello world，对于硬件最简单就是控制一个 LED 的亮灭)&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;Blink&lt;/span&gt;
&lt;span class="cm"&gt;Turns on an LED on for one second, then off for one second, repeatedly.&lt;/span&gt;

&lt;span class="cm"&gt;This example code is in the public domain.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="c1"&gt;// Pin 13 has an LED connected on most Arduino boards.&lt;/span&gt;
&lt;span class="c1"&gt;// give it a name:&lt;/span&gt;
&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;led&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// the setup routine runs once when you press reset:&lt;/span&gt;
&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                
  &lt;span class="c1"&gt;// initialize the digital pin as an output.&lt;/span&gt;
  &lt;span class="nf"&gt;pinMode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;OUTPUT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// the loop routine runs over and over again forever:&lt;/span&gt;
&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nf"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;HIGH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// turn the LED on (HIGH is the voltage level)&lt;/span&gt;
  &lt;span class="nf"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
  &lt;span class="nf"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;LOW&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// turn the LED off by making the voltage LOW&lt;/span&gt;
  &lt;span class="nf"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;               &lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;上面的这段代码对于一个标准 C++ 编译器来说是无效的，事实上当我们按下 IDE 界面上的 "Upload to I/O board" 按钮时，IDE 会拷贝一份代码，在开头加上 &lt;code&gt;include&lt;/code&gt; 指示，在结尾加上一个很简单的 &lt;code&gt;main()&lt;/code&gt; 函数，这样它就是一个有效的 C++ 程序了。&lt;/p&gt;
&lt;p&gt;Arduino 使用 &lt;a href="http://en.wikipedia.org/wiki/GNU_toolchain"&gt;GNU toolchain&lt;/a&gt; 和 AVR Libc 来编译程序的，使用 AVRdude 把程序下载到板子上。因为 Arduino 平台采用的是 Atmel 的微控制器，所以 Atmel 的开发环境 AVR Studio 或者更新的 Atmel Studio 应该也可以作为 Arduino 的开发环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习资源&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Arduino 的联合创始人 Massimo Banzi 的 Tutorial Series Vedio&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youku.com/playlist_show/id_19440139.html"&gt;优酷视频地址&lt;/a&gt;，一共 11 课，涵盖最基本的面包板搭电路、I/O 接口控制、传感器控制、网络应用等方面，如果有编程基础，很快就可以上手制作自己的设备了～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/thread-1066-1-1.html"&gt;论坛教程汇总帖&lt;/a&gt;，因为 Arduino 诞生的一个很大的目的就是为设计师、艺术家、业余爱好者提供更加方便的开发环境，所以，Arduino 的教程对于有编程基础的同学来说是很容易的 ：-P&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino Language Reference en&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 Arduino 编程语言的介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/reference/"&gt;Arduino Language Reference zh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Arduino 中文社区翻译的 编程语言介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Tutorial/HomePage"&gt;Arduino Core Functions, Libraries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 IDE 中 &lt;code&gt;File/Examples/&lt;/code&gt; 下示例程序的说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. can kao_1"&gt;5. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino official website&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Arduino on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Open-source Hardware"></category><category term="Arduino"></category></entry><entry><title>Yocto 从零单排 1 —— 入门</title><link href="https://qiangu.cool/posts/linux/learning_yocto_from_zero_1_getting_started.html" rel="alternate"></link><published>2014-05-12T12:46:00+08:00</published><updated>2014-05-12T12:46:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-05-12:/posts/linux/learning_yocto_from_zero_1_getting_started.html</id><summary type="html">&lt;p&gt;yocto 从零单排第一期，了解什么是 yocto&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近做嵌入式，开始学习 Yocto 项目相关的知识。网上关于 Yocto 的介绍、博客不少，但是大多数都是英文的。中文博客也有，不过都是一些大牛写的笔记，对于新手来说，并不是很容易懂,于是，就有了我的 &amp;ldquo;Yocto 从零单排&amp;rdquo; ^_^&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yocto 从零单排第 1 期 &amp;mdash;&amp;mdash; 入门，了解什么是 Yocto&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习一个新事物，当然是官网的东西最权威最简洁明了，不易出错（避免二次理解），以下内容来自 &lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto 官网&lt;/a&gt; 和对其的翻译，本文只是我的学习笔记，详细内容见官网：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto Project 官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. what &amp;amp; why yocto"&gt;1. What &amp;amp; Why Yocto&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="1.1. what is yocto"&gt;1.1. What is Yocto&lt;/h3&gt;
&lt;p&gt;官网上的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The Yocto Project is an open source collaboration project that provides templates, tools and methods to help you create custom Linux-based systems for embedded products regardless of the hardware architecture. &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 &lt;em&gt;&amp;ldquo;Yocto 是一个开源协作项目，它通过提供模板、工具和方法来帮助开发者为嵌入式产品订制基于 LInux 的系统，而不用关注硬件结构。&amp;rdquo;&lt;/em&gt; 这样，它就可以极大地简化开发过程，因为你不用再从头裁剪一个完整的Linux发布版本，后者通常包括许多你并不需要的软件。&lt;/p&gt;
&lt;p&gt;它由许多硬件制造商、开源操作系统提供商和电子器件公司一起合作于 2010 年建立，目的是为了使混乱的嵌入式 Linux 开发更简单有序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; Yocto 项目有时也被称为 "Umbrella" 项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.P.S.&lt;/strong&gt; yocto 的名字是委员会决定的，这个词本来是国际单位中的最小的单位，表示 10^-24，也就是千万亿分之一，在此寓意 &amp;ldquo;基本的粒子&amp;rdquo; &amp;mdash;&amp;mdash; 贯穿嵌入式 Linux 开发过程的工具。&lt;/p&gt;
&lt;h3 id="1.2. why using yocto"&gt;1.2. Why using Yocto&lt;/h3&gt;
&lt;p&gt;它是一个完整的嵌入式 Linux 开发环境，包含工具(tools)、元数据(metadata)和文档(documentation)&amp;mdash;&amp;mdash;你需要的一切。这些免费工具(包含仿真环境emulation environments、调试器debuggers、应用程序开发工具Application Toolkit Generator)很容易上手，功能强大，并且它们可以让系统开发以最优化的方式不断前进，而不用担心在系统原形阶段的投资损失。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. yocto project charter_1"&gt;2. Yocto Project Charter&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Yocto 作为一个开源项目，其本质就是欢迎大大小小的参与者。&lt;/p&gt;
&lt;p&gt;Yocto 的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为进一步的开发、定制 LInux 平台，基于 Linux 系统的开发提供一个写作平台&lt;/li&gt;
&lt;li&gt;鼓励 Linux 平台开发的标准化和组建的重利用&lt;/li&gt;
&lt;li&gt;专注于创造一个构建系统的基础设施和技术，能够满足所有用户的需求，并增加了缺失的功能&amp;mdash;&amp;mdash;来自于 OpenEmbedded 架构&lt;/li&gt;
&lt;li&gt;文档化可以用到的工具和方法，使开发人员更容易使用它们&lt;/li&gt;
&lt;li&gt;尽可能地保证这些开发工具和系统架构无关&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. governance &amp;amp; administration"&gt;3. Governance &amp;amp;  Administration&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Yocto 是一个开源项目，它由维护者和 &lt;a href="(https://www.yoctoproject.org/about/governance/advisory-board)"&gt;Yocto Project Advisory Board&lt;/a&gt; 领导。&lt;/p&gt;
&lt;h3 id="3.1. technical leadership"&gt;3.1. Technical Leadership&lt;/h3&gt;
&lt;p&gt;Yocto 项目的 &lt;a href="(https://www.yoctoproject.org/about/governance/technical-leadership)"&gt;technical leadership&lt;/a&gt; 和 Linux Kernel 的类似，是一个分级的、任人唯贤的，由一个 &amp;ldquo;仁慈的独裁者&amp;rdquo;(benevolent dictator) 领导的组织。组织的上层负责决策，同时也是下层子系统的领导者，下层维护者负责处理细节问题，比如bug 和补丁。&lt;/p&gt;
&lt;p&gt;Yocto 项目架构师：Richard Purdie&lt;/p&gt;
&lt;p&gt;子系统/ BSP 层维护者：...&lt;/p&gt;
&lt;h3 id="3.2. the yocto project community"&gt;3.2. The Yocto Project Community&lt;/h3&gt;
&lt;p&gt;Yocto 是由社区的专家和志愿者共同协助设计、开发的，他们统称为贡献者(contributors)，贡献者包括任何可能对 Yocto 有贡献的人，比如代码开发人员、文档编写者、兴趣小组、管理小组、维护者和技术领导小组等。&lt;/p&gt;
&lt;p&gt;下图简明说明了 Yocto 项目社区的各个成员之间的相互影响的关系：&lt;/p&gt;
&lt;p&gt;&lt;img alt="yocto-community" src="https://www.yoctoproject.org/sites/yoctoproject.org/files/page/os63yoctodev.org-diagramv11.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. linux foundation_1"&gt;4. Linux Foundation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="(http://www.linuxfoundation.org/)"&gt;Linux Foundation&lt;/a&gt; 是一个致力于促进 Linux 发展的非盈利组织，关于它的主要事实：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赞助 Linux 的创造者 Linus Torvalds 的工作&lt;/li&gt;
&lt;li&gt;持有 Linux 商标&lt;/li&gt;
&lt;li&gt;经营着 Linux.com，每个月拥有活跃的 2000,000 的 Linux 开发人员和用户 &lt;/li&gt;
&lt;li&gt;主持着多个推进或标准化 Linux 的工作小组&lt;/li&gt;
&lt;li&gt;举行世界上顶尖的 Linux 会议，包括 LinuxCon&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4.1. the linux foundation and the yocto project"&gt;4.1. The Linux Foundation and the Yocto Project&lt;/h3&gt;
&lt;p&gt;Linux Foundation 是业界最大的非盈利组织，作为 Linux 的维护者和 Linux 创造者 Linus Torvalds 的雇主，没有比它更适合 Yocto 项目生存的了。Linux Foundation 主持 Yocto 项目作为一个开源项目，它提供了一个厂商中立的协作环境。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. yocto project jian jie_1"&gt;5. Yocto Project 简介&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Yocto 项目中有很多独立的子项目，这些子项目在嵌入式 Linux 开发中扮演着重要的角色，Yocto 项目则整合它们使它们可以相互协同工作。&lt;/p&gt;
&lt;h3 id="5.1. openembedded core"&gt;5.1. Openembedded Core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Metadata Set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;元数据集(Metadata Set) 按 "层" 进行排列，这样一来每一层都可以为下面的层提供单独的功能。基层是 OpenEmbedded-Core 或 oe-core，提供了所有构建项目所必需的常见配方(recipes)、类和相关功能。&lt;/p&gt;
&lt;p&gt;Openembedded Core 包含了 核心方法(recipes)的基础层、类(classes) 和 相关文档，它们是各种嵌入式 Linux 系统(包含 Yocto 在内)的共同基础。Openembedded Core 由 Yocto Project 和 OpenEmbedded 项目共同维护，将 Yocto 和 Openembedded 分开的层是 meta-yocto 层，该层提供了 Pocky 发行版配置和一组核心的参考BSP。&lt;/p&gt;
&lt;p&gt;Openembedded 项目本身是一个ie独立的开源项目，具有可与 Yocto 项目交换的配方(recipes)，但两者具有不同的治理和范围。&lt;/p&gt;
&lt;h3 id="5.2. swabber"&gt;5.2. Swabber&lt;/h3&gt;
&lt;p&gt;Swabber 可以提供一种检测主机系统的机制，一旦检测到问题，你就可以分析这是否真的是个问题。&lt;/p&gt;
&lt;h3 id="5.3. application development toolkit (adt)"&gt;5.3. Application Development Toolkit (ADT)&lt;/h3&gt;
&lt;p&gt;Application Development Toolkit (ADT) 能够让系统开发人员为他们使用 Yocto Project 工具创建的发行版提供软件开发工具包 (SDK)，为应用程序开发人员提供了一种针对系统开发人员提供的软件栈进行开发的方法。ADT 包含一个交叉编译工具链、调试和分析工具，以及 QEMU 仿真和支持脚本。ADT 还为那些喜欢使用集成开发环境 (IDE) 的人提供了一个 Eclipse 插件。&lt;/p&gt;
&lt;h3 id="5.4. autobuilder"&gt;5.4. AutoBuilder&lt;/h3&gt;
&lt;p&gt;AutoBuilder 是一款能够不断自动构建 Yocto 的工具，它启用自动化的 Quality Assurance(QA) 活动。&lt;/p&gt;
&lt;h3 id="5.5. bitbake"&gt;5.5. BitBake&lt;/h3&gt;
&lt;p&gt;BitBake 是一个构建引擎。它读取配方(recipes)并按照配方来获取、构建程序包，并将结果导入可启动的系统映像中。BitBake 是 Yocto 项目的核心组件。&lt;/p&gt;
&lt;h3 id="5.6. build appliance"&gt;5.6. Build Appliance&lt;/h3&gt;
&lt;p&gt;Build Applicance 是一台运行 Hob 的虚拟机，它可以让你在非 Linux 环境下构建启动一个基于 Yocto 的嵌入式系统镜像。并不建议在日常开发中使用 Build Applicance，应该将其用在测试和体验 Yocto 项目上。&lt;/p&gt;
&lt;h3 id="5.7. cross-prelink"&gt;5.7. Cross-Prelink&lt;/h3&gt;
&lt;p&gt;Cross-Prelink 为交叉编译开发环境提供预链接，这样可以在应用程序启动时提高其性能表现。&lt;/p&gt;
&lt;h3 id="5.8. eclipse ide plug-in"&gt;5.8. Eclipse IDE Plug-in&lt;/h3&gt;
&lt;p&gt;Eclipse IDE Plug-in 把 Yocto ADT 和工具链集成到 Eclipse IDE 中。&lt;/p&gt;
&lt;h3 id="5.9. eglibc"&gt;5.9. EGLIBC&lt;/h3&gt;
&lt;p&gt;Embedded GLIBC (EGLIBC) 是 GNU C Library (GLIBC) 的一个变体，旨在能够在嵌入式系统上运行。EGLIBC 的目标包括减少内存占用、让组件可配置、更好地支持交叉编译和交叉测试。EGLIBC 是 Yocto Project 的一部分，但在它自己的治理结构内加以维护。&lt;/p&gt;
&lt;h3 id="5.10. hob"&gt;5.10. Hob&lt;/h3&gt;
&lt;p&gt;Hob 是 BitBake 的图形前端，它的主要目的是使常用命令更加方便使用。&lt;/p&gt;
&lt;h3 id="5.11. matchbox"&gt;5.11. Matchbox&lt;/h3&gt;
&lt;p&gt;Matchbox 是 一个基于 X Window 系统的开源环境，主要用于非桌面系统、屏幕大小、输入方式或系统资源有限的嵌入式设备中，比如手持设备、机顶盒、电话亭等。&lt;/p&gt;
&lt;h3 id="5.12. poky"&gt;5.12. Poky&lt;/h3&gt;
&lt;p&gt;Poky 是 Yocto Project 的一个参考构建系统。它包含 BitBake、OpenEmbedded-Core、一个板卡支持包 (BSP) 以及整合到构建过程中的其他任何程序包或层。Poky 这一名称也指使用参考构建系统得到的默认 Linux 发行版，它可能极其小 (core-image-minimal)，也可能是带有 GUI 的整个 Linux 系统 (core-image-sato)。&lt;/p&gt;
&lt;p&gt;你可以将 Poky 构建系统看作是整个项目的一个参考系统，即运行中进程的一个工作示例。在下载 Yocto Project 时，实际上也下载了可用于构建默认系统的这些工具、实用程序、库、工具链和元数据的实例。这一参考系统以及它创建的参考发行版都被命名为 Poky。你还可以将此作为一个起点来创建您自己的发行版，当然，你可以对此发行版随意命名。&lt;/p&gt;
&lt;p&gt;构建一个系统必须有工具链(toolchain)：一个编译器(compiler)、汇编器(assembler)、链接器(linker)以及为给定架构创建二进制可执行文件所需的其他二进制实用程序(other binary utilities)。Poky 使用了 GNU Compiler Collection (GCC)，不过你也可以指定其他工具链。Poky 使用了一种名为交叉编译(cross-compilation) 的技术：在一个架构上使用工具链为另一个架构构建二进制可执行文件（例如，在基于 x86 的系统上构建 ARM
发行版）。开发人员常常在嵌入式系统开发中使用交叉编译来利用主机系统的高性能。&lt;/p&gt;
&lt;h3 id="5.13. pseudo"&gt;5.13. Pseudo&lt;/h3&gt;
&lt;p&gt;构建一个系统时，有时候有必要把自己模拟为系统管理员进行一些操作，比如定义某个文件的归属权和权限配置等。Pseudo 是一个可以模拟 root 的程序，使普通用户也可以具有 root 权限。&lt;/p&gt;
&lt;h3 id="5.14. toaster"&gt;5.14. Toaster&lt;/h3&gt;
&lt;p&gt;Toaster 是一个 API，它基于 web 界面来使用 BitBake，你可以通过浏览器来查阅 Toaster 收集到的你的系统的相关信息。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="6. can kao_1"&gt;6. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="(https://www.yoctoproject.org/)"&gt;Yocto Project 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/linux/library/l-yocto-linux/index.html?ca=dat"&gt;Build custom embedded Linux distributions with the Yocto Projec&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Yocto"></category></entry><entry><title>学习 Linux 软件包依赖管理</title><link href="https://qiangu.cool/posts/linux/learning_linux_package_management.html" rel="alternate"></link><published>2014-04-21T13:43:00+08:00</published><updated>2014-04-21T13:43:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-21:/posts/linux/learning_linux_package_management.html</id><summary type="html">&lt;p&gt;安装软件时遇到依赖库版本过高的问题，学习总结 Linux 软件包管理 。&lt;/p&gt;</summary><content type="html">&lt;h2 id="1. linux ruan jian bao yi lai wen ti"&gt;1. Linux 软件包依赖问题&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;早期的 Linux 系统上的软件是通过源码方式发布的，大家下载下来，在自己的机器上编译，得到可执行程序 。&lt;/p&gt;
&lt;p&gt;但是，任何程序员写程序都有可能会依赖一些别人已经写成的库，所以几乎一定规模的程序必然有依赖 。尤其是对于 Linux 系统，因为它是 &lt;strong&gt;free（自由，not 免费）&lt;/strong&gt;，开源软件的开发者不是在一个体系下，软件包的依赖关系就比较伤脑筋了， 尤其是当我们的系统里有成百上千的软件时，软件包管理的必要性就更明显了 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;比如我们需要安装 package_a，而 package_a  依赖于 package_b 才能运行，但是我们的系统没有安装 package_b，如果强制安装 package_a，软件很可能不能正常运行 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;  其实在 Windows 下也存在相似的问题，只是因为有微软统一的体系，很多 &lt;code&gt;dll&lt;/code&gt; 被集成在系统中，所以这个问题不明显 。&lt;/p&gt;
&lt;p&gt;不同的系统对于这个问题有不同的处理方法，这也体现出它们不同的处理问题的哲学：&lt;/p&gt;
&lt;p&gt;知乎上的问题：&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有个回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GNU/Linux：通常这个系统大多数软件是自由软件，换句话说，他们通常依赖的库也是自由的，所以软件开发者认为你可以自由的获取这些依赖库，自然就不需要自己再提供了。由系统&amp;ldquo;发行版&amp;rdquo;负责维护属于这个系统的所有依赖库，并且安装软件时确定依赖
&lt;br/&gt;
这个体系的特点是：
&lt;br/&gt;
1. 系统依赖通常是统一的，如果有多个程序依赖同一个库，在这个系统中通常是同一份
&lt;br/&gt;
2. 具有庞大的资源。例如 Debian 系现成的可依赖软件多达 30G，所以通常不可能预先把所有依赖都安装全，但庞大的依赖库给编程人员提供了很多方便
&lt;br/&gt;
3. 你安装的软件越多，共同依赖所体现出的价值越高，解决依赖问题就越简单（因为当你安装足够多软件时，主流的依赖已经全部在你系统了）
&lt;br/&gt;
4. 由于巨大的共同依赖库存在，软件本身可以很小
&lt;br/&gt;
&lt;br/&gt;
Windows：通常而言，这个系统的软件是商业软件，因此，他们依赖的库也很有可能是商业软件，所以，不可能要求用户自行获取这些依赖，这些依赖通常在发布软件的时候提供。如果你安装的软件少，这个体系很方便 。
&lt;br/&gt;
不过这造成了一些缺点：
&lt;br/&gt;
1. 没有一个庞大的公共库，很多功能以及基础库都是每个公司自己实现一套，浪费很多劳动力，编程人员到每个公司得学习一套不同的库，给编程人员带来不便
&lt;br/&gt;
2. 所有应用程序都自己带依赖，因此很可能有许多程序同时附带了相同的依赖，并且这些相同依赖还有可能是不同的版本，这会造成许多混乱
&lt;br/&gt;
3. 由于所有应用程序都自己提供所有依赖，每个软件体积都很庞大
&lt;br/&gt;
4. 系统中安装的软件越多，越容易出问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. linux bao guan li xi tong"&gt;2. Linux 包管理系统&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Package_management_system"&gt;Package management system on wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;package management system&lt;/strong&gt;, also called &lt;strong&gt;package manager&lt;/strong&gt;, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites.
&lt;br/&gt;
&lt;br/&gt;
Package management systems are designed to save organizations time and money through remote administration and software distribution technology that eliminate the need for manual installs and updates. This can be particularly useful for large enterprises whose operating systems are based on Linux and other Unix-like systems, typically consisting of hundreds or even thousands of distinct software packages; in the former case, a package management system is a convenience, in the latter case it becomes essential.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 发行版中，几乎每一个发行版都有自己的软件包管理系统 。&lt;/p&gt;
&lt;h3 id="2.1. dpkg"&gt;2.1. Dpkg&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dpkg"&gt;Dpkg on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dpkg 是基于 Debian 系统的包管理软件 。&lt;code&gt;dpg&lt;/code&gt; 可以用来安装、删除、提供&lt;code&gt;.deb&lt;/code&gt; 格式软件包相关信息的文件 。&lt;/p&gt;
&lt;p&gt;dpkg 由 Matt Welsh、Carl Streeter、 Ian Murdock 用 Perl 语言编写，后来在 1994 年。 Ian Jackson 改用 C 重写了大部分内容 。&lt;/p&gt;
&lt;p&gt;dpkg 是 &amp;ldquo;Debian package&amp;rdquo; 的缩写，它最初是为 Debian 系统编写的，也可以在使用 &lt;code&gt;.deb&lt;/code&gt; 格式的 Ubuntu 系统上使用 。&lt;/p&gt;
&lt;h4 id="2.1.1. chang yong yu fa"&gt;2.1.1. 常用语法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dpkg -i peackage.deb        // install
dpkg -r package.deb         // remove
dpkg -l &lt;span class="o"&gt;[&lt;/span&gt;optional pattern&lt;span class="o"&gt;]&lt;/span&gt;  // list installed package
dpkg --configure package    // configure package
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h4 id="2.1.2. xiang xi yong fa"&gt;2.1.2. 详细用法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dpkg --help
man dpkg
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="2.2. apt_1"&gt;2.2. Apt&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Advanced_Packaging_Tool"&gt;Advanced Packaging Tool on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Advanced Packaging Tool, or APT, is a free software user interface that works with core libraries to handle the installation and removal of software on the Debian GNU/Linux distribution and its variants. APT simplifies the process of managing software on Unix-like computer systems by automating the retrieval, configuration and installation of software packages, either from precompiled files or by compiling source code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;apt 最初是设计为 dpkg 的前端，用来处理 &lt;code&gt;.deb&lt;/code&gt; 格式的文件，后来它被 &lt;code&gt;APT-RPM&lt;/code&gt; 组织改造可以支持 RPM 包管理系统 。&lt;/p&gt;
&lt;p&gt;apt 由 &lt;code&gt;apt-get&lt;/code&gt;、&lt;code&gt;apt-cache&lt;/code&gt; 和 &lt;code&gt;apt-config&lt;/code&gt; 等小工具组成&lt;/p&gt;
&lt;h4 id="2.2.1. chang yong yu fa"&gt;2.2.1. 常用语法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install package             // install
apt-get remove package              // remove
apt-cache search package            // search
apt-get update                      // update &lt;span class="nb"&gt;source&lt;/span&gt; list
apt-get upgrade                     // upgrade installed software
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h4 id="2.2.2. xiang xi yong fa"&gt;2.2.2. 详细用法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man apt
man apt-get
man apt-update
man apt-upgrade
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h4 id="2.2.3. cai dan"&gt;2.2.3. 彩蛋&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get -h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;help 内容结束的最后一样会有一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This APT has Super Cow Powers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get moo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会显示一头牛 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="c1"&gt;------\/ &lt;/span&gt;
   &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="o"&gt;||&lt;/span&gt;   
  &lt;span class="o"&gt;*&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;---/\ &lt;/span&gt;
     &lt;span class="o"&gt;~~&lt;/span&gt;   &lt;span class="o"&gt;~~&lt;/span&gt;   
   &lt;span class="p"&gt;....&lt;/span&gt;&lt;span class="ss"&gt;"Have you mooed today?"&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h3 id="2.3. aptitude_1"&gt;2.3. Aptitude&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Aptitude_(software)"&gt;aptitude on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aptitude is a front-end to the Advanced Packaging Tool (APT). It displays a list of software packages and allows the user to interactively pick packages to install or remove. It has an especially powerful search system utilizing flexible search patterns. It was initially created for Debian, but has appeared in RPM Package Manager (RPM) based distributions as well (such as Conectiva).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;aptitude 是 APT 的文本界面客户端，它的交互性比 apt 好，似乎在处理依赖问题上也更好一些（我遇到的问题，用 aptitude 可以很方便地解决而 apt 不行 ）&lt;/p&gt;
&lt;h4 id="2.3.1. chang yong yu fa"&gt;2.3.1. 常用语法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;aptitude install package
aptitude remove package
aptitude clean
aptitude search package
aptitude show string
aptitude update
aptitude dist-update
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h4 id="2.3.2. xiang xi yong fa"&gt;2.3.2. 详细用法&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man aptitude
aptitude -h
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h4 id="2.3.3. cai dan"&gt;2.3.3. 彩蛋&lt;/h4&gt;
&lt;p&gt;&lt;img alt="aptitude" src="/images/learning-linux-package-management/aptitude.png"/&gt;&lt;/p&gt;
&lt;h3 id="2.4. yum_1"&gt;2.4. YUM&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/Yum"&gt;Yellowdog Updater, Modified on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Yellowdog Updater, Modified (yum) is an open-source command-line package-management utility for Linux operating systems using the RPM Package Manager. Though yum has a command-line interface, several other tools provide graphical user interfaces to yum functionality.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;YUM 是一个基于 RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM 包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装 。被 Yellow Dog Linux 本身，以及 Fedora、Red Hat Enterprise Linux 采用 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. ju ge li zi_1"&gt;3. 举个栗子&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;有些软件要求的库的版本高于(&amp;gt;=)xx.xxx，有些软件要求库的版本必须是(=)xx.xxx，如果我们的库不能满足要求则无法安装软件 。一般 &lt;code&gt;apt-get&lt;/code&gt; 会处理比较简单的依赖关系，但是有些依赖关系 &lt;code&gt;apt-get&lt;/code&gt; 并不能解决 。这时候可以试试 &lt;code&gt;aptitude&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id="3.1. wen ti"&gt;3.1. 问题&lt;/h3&gt;
&lt;p&gt;为新安装的 Ubuntu 安装开发环境时，遇到了库版本过高的问题，执行下面的命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install build-essential
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;结果 apt-get 提示有不满足依赖关系的包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done
&lt;br/&gt;
Building dependency tree
&lt;br/&gt;
Reading state information... Done
&lt;br/&gt;
Some packages could not be installed. This may mean that you have
&lt;br/&gt;
requested an impossible situation or if you are using the unstable
&lt;br/&gt;
distribution that some required packages have not yet been created
&lt;br/&gt;
or been moved out of Incoming.
&lt;br/&gt;
The following information may help to resolve the situation:
&lt;br/&gt;
&lt;br/&gt;
The following packages have unmet dependencies:
&lt;br/&gt;
&lt;strong&gt;build-essential : Depends: dpkg-dev (&amp;gt;= 1.13.5) but it is not going to be installed&lt;/strong&gt;
&lt;br/&gt;
E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我们手动安装特定的库&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install dpkg-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;结果提示我们库版本过高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done
&lt;br/&gt;
Building dependency tree
&lt;br/&gt;
Reading state information... Done
&lt;br/&gt;
Some packages could not be installed. This may mean that you have
&lt;br/&gt;
requested an impossible situation or if you are using the unstable
&lt;br/&gt;
distribution that some required packages have not yet been created
&lt;br/&gt;
or been moved out of Incoming.
&lt;br/&gt;
The following information may help to resolve the situation:
&lt;br/&gt;
&lt;br/&gt;
The following packages have unmet dependencies:
&lt;br/&gt;
&lt;strong&gt;dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is to be installed&lt;/strong&gt;
&lt;br/&gt;
Recommends: build-essential but it is not going to be installed
&lt;br/&gt;
           Recommends: fakeroot but it is not going to be installed
&lt;br/&gt;
           Recommends: libalgorithm-merge-perl but it is not going to be installed
&lt;br/&gt;
E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="3.2. jie jue wen ti  ---- shi yong  aptitude"&gt;3.2. 解决问题 &amp;mdash;&amp;mdash; 使用 &lt;code&gt;aptitude&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;解决方法就是降级&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;方法有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;apt-get 直接指定安装特定的版本&lt;/p&gt;
&lt;p&gt;首先查询是否提供低版本的包&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-cache showpkg package_name
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;若有则指定安装某个版本&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install &lt;span class="nv"&gt;package_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;version
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 aptitude 自动处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我采用的第二种方法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo aptitude install build-essential
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;结果如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following NEW packages will be installed:
&lt;br/&gt;
 build-essential dpkg-dev{ab} 
&lt;br/&gt;
The following packages are RECOMMENDED but will NOT be installed:
&lt;br/&gt;
fakeroot libalgorithm-merge-perl 
&lt;br/&gt;
0 packages upgraded, 2 newly installed, 0 to remove and 18 not upgraded.
&lt;br/&gt;
Need to get 718 kB of archives. After unpacking 1,636 kB will be used.
&lt;br/&gt;
The following packages have unmet dependencies:
&lt;br/&gt;
 dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is installed.
&lt;br/&gt;
The following actions will resolve these dependencies:
&lt;br/&gt;
&lt;br/&gt;
Keep the following packages at their current version:
&lt;br/&gt;
1)     build-essential [Not Installed]
&lt;br/&gt;
2)     dpkg-dev [Not Installed]
&lt;br/&gt;
&lt;br/&gt;
Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然不是中止安装，选择 &lt;code&gt;n&lt;/code&gt;， aptitude 给出另外一个解决方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following actions will resolve these dependencies:
&lt;br/&gt;
 Downgrade the following packages:
&lt;br/&gt;
&lt;br/&gt;
1)     libdpkg-perl [1.16.12ubuntu1 (now) -&amp;gt; 1.16.10ubuntu1 (raring)]
&lt;br/&gt;
&lt;br/&gt;
Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这正是我们需要解决的版本过高的问题，将库软件版本降级&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following packages will be DOWNGRADED:
&lt;br/&gt;
libdpkg-perl 
&lt;br/&gt;
The following NEW packages will be installed:
&lt;br/&gt;
 build-essential dpkg-dev{a} 
&lt;br/&gt;
The following packages are RECOMMENDED but will NOT be installed:
&lt;br/&gt;
fakeroot libalgorithm-merge-perl 
&lt;br/&gt;
0 packages upgraded, 2 newly installed, 1 downgraded, 0 to remove and 18 not upgraded.
&lt;br/&gt;
Need to get 904 kB of archives. After unpacking 1,632 kB will be used.
&lt;br/&gt;
Do you want to continue? [Y/n/?] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选择 &lt;code&gt;y&lt;/code&gt;。然后 aptitude 会完成剩余的工作 。&lt;/p&gt;
&lt;p&gt;问题解决啦！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. can kao_1"&gt;4. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://daway320.blog.163.com/blog/static/3878369920107331733393/"&gt;apt-get install安装软件问题(安装包的依赖库版本过高问题)&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Package Management"></category></entry><entry><title>学习 Vim 保存项目设置</title><link href="https://qiangu.cool/posts/linux/learning_vim_save_project_configuration.html" rel="alternate"></link><published>2014-04-20T14:32:00+08:00</published><updated>2014-04-20T14:32:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-20:/posts/linux/learning_vim_save_project_configuration.html</id><summary type="html">&lt;p&gt;总结将 Vim 配置为 IDE 的过程之一，保存项目设置 。&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关于 Vim 和 IDE 的争论，这是程序猿的圣战，不再浪费时间 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在参考了很多人分享的博客和教程之后，终于把 Vim 搭建成为一个自己定制的 IDE（这种说法严格意义上说，是不对的，应该是 &amp;ldquo;组合一组工具成为一个 IDE &amp;rdquo;），总结一下～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本系列的内容很多都是参考别人的博客写的，也包含部分自己摸索的结果 。虽然部分内容和参考文章相同，但是总结一下自己的学习过程还是一件有必要的事 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;很多编辑器都有一个功能是以前打开过的文档会有记忆，再次打开时会直接跳转到上次编辑的地方，比如  &lt;a href="http://www.sublimetext.com/2"&gt;&lt;code&gt;Sublime Text 2&lt;/code&gt;&lt;/a&gt;，强大的 Vim 当然也有这个功能，&lt;strong&gt;我们的目标就是让 Vim 和其他 IDE 一样，可以记住上次的编辑状态 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vim 要实现这个功能，涉及到两个地方的配置：&lt;code&gt;session&lt;/code&gt; &amp;amp; &lt;code&gt;viminfo&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. session"&gt;1. Session&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="1.1. intro"&gt;1.1. Intro&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help session
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就可以看到关于 &lt;code&gt;session&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Session keeps the Views for all windows, plus the global settings.  You can save a Session and when you restore it later the window layout looks the same. You can use a Session to quickly switch between different projects, automatically loading the files you were last working on in that project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我使用的 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr_21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.4&lt;/code&gt;  节保存的就是关于 session 的说明，在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help &lt;span class="m"&gt;21&lt;/span&gt;.4
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就可以看到关于 session 的详细介绍 。&lt;/p&gt;
&lt;h3 id="1.2. config"&gt;1.2. Config&lt;/h3&gt;
&lt;p&gt;Session 保存的信息由 &lt;code&gt;sessionoptions&lt;/code&gt; 确定，详细用法可以查看 help&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help &lt;span class="s1"&gt;'sessionoption'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;'sessionoptions' 'ssop' string  (default: &lt;strong&gt;"blank,buffers,curdir,folds,help,options,tabpages,winsize"&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It is a comma separated list of words.  Each word enables saving and restoring something&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 session 保存的会话的属性默认的有 8 个 ：&lt;strong&gt;当前编辑的空窗口、缓冲区、当前目录、折叠信息、帮助信息、选项、标签页、窗口大小信息 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的设置中，不要同时包含 &lt;code&gt;curdir&lt;/code&gt; 和 &lt;code&gt;sesdir&lt;/code&gt; 两个选项，若两个选项都不包含，则保存 session 时，会保存绝路径 。添加 &lt;code&gt;sesdir&lt;/code&gt; 可以将当前目录设置为 &lt;code&gt;session-file&lt;/code&gt;  所在的目录，这个设置有个很有用的地方就是，当我们通过网络访问我们的工程或者有很多个工程版本，这时候只需要每个工程下保存一个 session-file 即可 。&lt;/p&gt;
&lt;p&gt;删除/加入 某个选项的方法&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:set sessionoptions-&lt;span class="o"&gt;=&lt;/span&gt;curdir
:set &lt;span class="nv"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;sesdir
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="1.3. save"&gt;1.3. Save&lt;/h3&gt;
&lt;p&gt;详细的语法可以在 help 中查看&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help mksession
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;使用 &lt;code&gt;mksession&lt;/code&gt; 命令保存会话&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:set sessionoptopms-&lt;span class="o"&gt;=&lt;/span&gt;curdir
:set &lt;span class="nv"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;sesdir
:mksession project.vim
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;如果 session-file 已经存在，则使用&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:mksession! project.vim
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="1.4. load"&gt;1.4. Load&lt;/h3&gt;
&lt;p&gt;然后退出 Vim，在别的目录下打开，干点别的事，这时候我们想起刚才的工程里面有个小 bug，想恢复过去，这时候就是只需要使用 &lt;code&gt;source&lt;/code&gt; 命令即可 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;source&lt;/code&gt; 命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;source&lt;/span&gt; PATHto/project.vim
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这时候可以看到，已经恢复了之前的状态 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;只使用 session 就可以恢复一些上次编辑的信息，但是这还不够，我们还可以配合使用 &lt;code&gt;viminfo&lt;/code&gt; 来恢复更多的信息 。在 Vim 的 &lt;code&gt;:help 21.4&lt;/code&gt; 中有介绍两者的关系&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sessions store many things, but not the position of marks, contents of registers and the command line history.&lt;/strong&gt;  You need to use the viminfo feature for these things.&lt;/li&gt;
&lt;li&gt;In most situations you will want to use sessions separately from viminfo. This can be used to switch to another session, but keep the command line history.  And yank text into registers in one session, and paste it back in another session.&lt;/li&gt;
&lt;li&gt;You might prefer to keep the info with the session.  You will have to do this yourself then.&lt;/li&gt;
&lt;li&gt;You could also use a Session file.  &lt;strong&gt;The difference is that the viminfo file does not depend on what you are working on.&lt;/strong&gt;  There normally is only one viminfo file.  Session files are used to save the state of a specific editing Session.  You could have several Session files, one for each project you are working on.  Viminfo and Session files together can be used to effectively
enter Vim and directly start working in your desired setup.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. viminfo_1"&gt;2. Viminfo&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="2.1. intro"&gt;2.1. Intro&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help viminfo
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就可以看到关于 &lt;code&gt;viminfo&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you exit Vim and later start it again, you would normally lose a lot of information.  The viminfo file can be used to remember that information, which enables you to continue where you left off.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr_21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.3&lt;/code&gt;  节保存的就是关于 viminfo 的说明，在 Vim 中输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help &lt;span class="m"&gt;21&lt;/span&gt;.3
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就可以看到关于 viminfo 的详细介绍 。&lt;/p&gt;
&lt;p&gt;viminfo 文件可以保存的内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The command line history 命令行历史&lt;/li&gt;
&lt;li&gt;The search string history 字符串搜寻历史&lt;/li&gt;
&lt;li&gt;The input-line history 输入行历史&lt;/li&gt;
&lt;li&gt;Contents of non-empty register 非空寄存器内容&lt;/li&gt;
&lt;li&gt;Marks for serval files 文件位置标记&lt;/li&gt;
&lt;li&gt;Last search/substitute pattern 最近模式匹配搜索历史&lt;/li&gt;
&lt;li&gt;The buffer list 缓冲区列表&lt;/li&gt;
&lt;li&gt;Global variables 全局变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2.2. save"&gt;2.2. Save&lt;/h3&gt;
&lt;p&gt;其实 Vim 每次退出时都会在 &lt;code&gt;～/&lt;/code&gt; 目录下保存一个 &lt;code&gt;.viminfo&lt;/code&gt; 的文件，但是每次打开关闭一个文件都会覆盖上次的记录，所以我们需要为工程手动保存一个 viminfo 文件，并且保存在工程目录下，防止被覆盖 。&lt;/p&gt;
&lt;p&gt;保存命令 &lt;code&gt;:wviminfo&lt;/code&gt; 的帮助&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help :wviminfo
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;使用 &lt;code&gt;wviminfo&lt;/code&gt; 保存&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:wviminfo project.viminfo
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="2.3. zai ru  viminfo wen jian"&gt;2.3. 载入 viminfo 文件&lt;/h3&gt;
&lt;p&gt;载入命令 &lt;code&gt;rviminfo&lt;/code&gt; 帮助&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:help :rviminfo
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;载入 viminfo 文件&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:rviminfo path/to/project.viminfo
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. zong jie_1"&gt;3. 总结&lt;/h2&gt;
&lt;p&gt;为了节省每次都要手动输入一些设置命令，我们可以把部分相同的设置放在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt; sessionoptions-&lt;span class="o"&gt;=&lt;/span&gt;curdir
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;sesdir
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;每次退出 Vim 时保存&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:mksession project.vim
:wviminfo project.viminfo
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;进入 Vim 想恢复项目设置时&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:source projetc.vim
:rviminfo projetc.viminfo
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. can kao"&gt;4. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-session-file-and-viminfo/"&gt;vi/vim使用进阶: 使用会话和viminfo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-save-project-configuration/"&gt;vi/vim使用进阶: 保存项目相关配置&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Vim"></category></entry><entry><title>学习 Vim 使用 Vundle 管理插件</title><link href="https://qiangu.cool/posts/linux/learning_vim_vundle.html" rel="alternate"></link><published>2014-04-16T17:06:00+08:00</published><updated>2014-04-16T17:06:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-16:/posts/linux/learning_vim_vundle.html</id><summary type="html">&lt;p&gt;学习 Vim，使用 Vundle 管理插件 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;学习 Vim，使用 Vundle 管理插件 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. vim cha jian"&gt;1. Vim 插件&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Vim 的强大之处在于它的可扩展性，你可以把它当作一个简单的文本编辑器，也可以安装各种功能强大的插件，把它武装成一个 IDE 。&lt;/p&gt;
&lt;p&gt;我们可以从以下几个地方找到 Vim 插件，一般比较常用的插件从官网上都可以找到，还有一些插件是大神们自己写的，托管在 GitHub 上 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script_search_results.php"&gt;Vim 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. shi yao shi  vundle"&gt;2. 什么是 Vundle&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Vim 的插件虽然强大，但是因为 Vim 根本就没有插件管理这个概念，所有插件的文件都散布在~/.vim下的几个文件夹中，配置 vim 的过程, 就是在网上不停的搜插件，拷贝到 &lt;code&gt;~/.vim&lt;/code&gt; 下，发现更新，要重新下载重新拷贝，想要删除某个不需要插件，更是要小心翼翼的不要删错。配置出顺手的 Vim, 需要极大的耐心和运气，而且如果换一台电脑，就要重复一次这样的痛苦经历 。&lt;/p&gt;
&lt;p&gt;自然地，因为管理插件的需求，最早出现了一些管理插件的脚本，但是写脚本需要一定的 shell 知识，直接 copy 别人的自己并不一定适用 。后来，出现了一些插件，比如 pathogen，muzuiget，vim-flavor，Vundle 等 。&lt;/p&gt;
&lt;p&gt;目前比较流行的方式是采用 Vundle 来管理插件（别的我也没有试过...）&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/gmarik/Vundle.vim"&gt;Vundle on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=3458"&gt;Vundle on vim.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vundle 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vundle is short for Vim bundle and is a Vim plugin manager.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vundle 可以在交互的方式下做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 中管理和配置插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按名字搜索插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. ru he shi yong  vundle guan li cha jian"&gt;3. 如何使用 Vundle 管理插件&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="3.1. an zhuang  vundle"&gt;3.1. 安装 Vundle&lt;/h3&gt;
&lt;p&gt;Vundle 的安装需要 &lt;a href="http://git-scm.com/"&gt;Git&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;从 GitHub 上 clone 下来就可以了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="3.2. pei zhi  vundle"&gt;3.2. 配置 Vundle&lt;/h3&gt;
&lt;p&gt;将下列内容加入到 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;set&lt;/span&gt; nocompatible              &lt;span class="s2"&gt;" be iMproved, required&lt;/span&gt;
&lt;span class="s2"&gt;filetype off                  "&lt;/span&gt; required

&lt;span class="s2"&gt;" set the runtime path to include Vundle and initialize&lt;/span&gt;
&lt;span class="s2"&gt;set rtp+=~/.vim/bundle/vundle/&lt;/span&gt;
&lt;span class="s2"&gt;call vundle#rc()&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; alternatively, pass a path where Vundle should install plugins
&lt;span class="s2"&gt;"let path = '~/some/path/here'&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;call vundle#rc&lt;span class="o"&gt;(&lt;/span&gt;path&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="s2"&gt;" let Vundle manage Vundle, required&lt;/span&gt;
&lt;span class="s2"&gt;Plugin 'gmarik/vundle'&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; The following are examples of different formats supported.

&lt;span class="s2"&gt;" Keep Plugin commands between here and filetype plugin indent on.&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; scripts on GitHub repos
Plugin &lt;span class="s1"&gt;'tpope/vim-fugitive'&lt;/span&gt;
Plugin &lt;span class="s1"&gt;'Lokaltog/vim-easymotion'&lt;/span&gt;
Plugin &lt;span class="s1"&gt;'tpope/vim-rails.git'&lt;/span&gt;
&lt;span class="s2"&gt;" The sparkup vim script is in a subdirectory of this repo called vim.&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; Pass the path to &lt;span class="nb"&gt;set&lt;/span&gt; the runtimepath properly.
Plugin &lt;span class="s1"&gt;'rstacruz/sparkup'&lt;/span&gt;, &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;'rtp'&lt;/span&gt;: &lt;span class="s1"&gt;'vim/'&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="s2"&gt;" scripts from http://vim-scripts.org/vim/scripts.html&lt;/span&gt;
&lt;span class="s2"&gt;Plugin 'L9'&lt;/span&gt;
&lt;span class="s2"&gt;Plugin 'FuzzyFinder'&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; scripts not on GitHub
Plugin &lt;span class="s1"&gt;'git://git.wincent.com/command-t.git'&lt;/span&gt;
&lt;span class="s2"&gt;" git repos on your local machine (i.e. when working on your own plugin)&lt;/span&gt;
&lt;span class="s2"&gt;Plugin 'file:///home/gmarik/path/to/plugin'&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; ...

filetype plugin indent on     &lt;span class="s2"&gt;" required&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; To ignore plugin indent changes, instead use:
&lt;span class="s2"&gt;"filetype plugin on&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="s2"&gt;" Brief help&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; :PluginList          - list configured plugins
&lt;span class="s2"&gt;" :PluginInstall(!)    - install (update) plugins&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; :PluginSearch&lt;span class="o"&gt;(&lt;/span&gt;!&lt;span class="o"&gt;)&lt;/span&gt; foo - search &lt;span class="o"&gt;(&lt;/span&gt;or refresh cache first&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; foo
&lt;span class="s2"&gt;" :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="s2"&gt;" see :h vundle for more details or wiki for FAQ&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; NOTE: comments after Plugin commands are not allowed.
&lt;span class="s2"&gt;" Put your stuff after this line&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;从上面的配置文件中可以看到，Vundle 把插件分为了 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;scripts on GitHub repos&lt;/p&gt;
&lt;p&gt;GitHub 上的脚本，需要按照 &lt;code&gt;usrname/repos&lt;/code&gt; 的格式写出插件的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scripts from http://vim-scripts.org/vim/scripts.html &lt;/p&gt;
&lt;p&gt;Vim scripts 上的脚本，不用作者名，直接写插件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scripts not on GitHub&lt;/p&gt;
&lt;p&gt;不是 GitHub 上的脚本，需要写出插件的详细路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="3.3. yun xing  vundle"&gt;3.3. 运行 Vundle&lt;/h3&gt;
&lt;p&gt;修改好 &lt;code&gt;.vimrc&lt;/code&gt; 文件后，打开 Vim，使用以下命令管理插件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列表&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:Bundles    // 列出所有插件（包括未安装的）
:BundleList // 列出已安装的插件
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleInstall
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleSearch   // 后面不接插件名时，同 Bundles，列出了 &lt;span class="m"&gt;4000&lt;/span&gt; 个插件
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleInstall!
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中删除/注释掉相应的插件名，然后输入命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:BundleClean
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; P.S. 我安装的插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;列出一些我安装的插件，这些插件都是大家比较常用的，可以从相关的网站或者帮助文档中找到使用说明或者 &lt;code&gt;README&lt;/code&gt;，计划在后续中写一写使用心得～&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bundle &lt;span class="s1"&gt;'taglist.vim'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'The-NERD-tree'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'SuperTab'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'snipMate'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'L9'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'FuzzyFinder'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'bufexplorer.zip'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'winmanager'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'a.vim'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'c.vim'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'Markdown'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'Conque-Shell'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'vimwiki'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'genutils'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'lookupfile'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'DoxygenToolkit.vim'&lt;/span&gt;
&lt;span class="s2"&gt;"Bundle 'ManPageView'&lt;/span&gt;
&lt;span class="s2"&gt;Bundle 'calendar.vim'&lt;/span&gt;
&lt;span class="s2"&gt;Bundle 'AutoClose'&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt;scripts on GitHub repos
Bundle &lt;span class="s1"&gt;'suan/vim-instant-markdown'&lt;/span&gt;
Bundle &lt;span class="s1"&gt;'godlygeek/tabular'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. can kao_1"&gt;4. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://zuyunfei.com/2013/04/12/killer-plugin-of-vim-vundle/"&gt;vim中的杀手级插件: vundle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zfanw.com/blog/vundle-vim-plugin-management.html"&gt;Vundle 管理 Vim 插件&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Vim"></category><category term="vundle"></category></entry><entry><title>学习 Vim 初步配置 Vim</title><link href="https://qiangu.cool/posts/linux/learning_vim_vimrc_preliminary.html" rel="alternate"></link><published>2014-04-16T12:44:00+08:00</published><updated>2014-04-16T12:44:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-16:/posts/linux/learning_vim_vimrc_preliminary.html</id><summary type="html">&lt;p&gt;总结初步配置 Vim，让 Vim 更顺手 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;总结初步配置 Vim，让 Vim 更顺手 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. zai na li pei zhi  vim"&gt;1. 在哪里配置 Vim&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习 Vi 和 Vim 编辑器&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim 依照特定顺序寻找初始化的信号，它执行找到的第一组指令（可以是 环境变量 or 配置文件），然后开始编辑工作 。所以，Vim 在下列清单中遇到的第一个项目，就是清单中被执行的唯一项目 。书寻如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VIMINIT&lt;/code&gt; 。它是环境变量，如果不为空，Vim 把它的内容当作 ex 命令执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户 &lt;code&gt;vimrc&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exrc&lt;/code&gt; 选项 。如果设置了 Vim 的 exrc 选项，它会寻找三个额外的配置文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;vimrc&lt;/code&gt;（vim runtime configure）文件一般有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/etc/vim/vimrc&lt;/p&gt;
&lt;p&gt;本配置文件影响所有的用户，一般不应该更改这个配置文件，因为谁也不能保证别人的喜好和自己一样 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/usr/share/vim/vimrc&lt;/p&gt;
&lt;p&gt;输入命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; ll /usr/share/vim/vimrc
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就可以看到，本文件是 &lt;code&gt;/etc/vim/vimrc&lt;/code&gt; 的软链接 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;~/.vimrc&lt;/p&gt;
&lt;p&gt;一般来说，配置 vim 就是在这个文件中配置，如果不存在的话 &lt;code&gt;touch&lt;/code&gt; 一个新文件并命名 &lt;code&gt;。vimrc&lt;/code&gt; 。我们在下面说的配置都是在本文件中配置 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. ying she  esc jian"&gt;2. 映射 &lt;code&gt;esc&lt;/code&gt; 键&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;因为历史原因，Joy 设计 vi 时采用的键盘和我们现在用的标准键盘布局并不一样，当时他的键盘的 &lt;code&gt;esc&lt;/code&gt; 键在现在我们的 &lt;code&gt;Caps Lock&lt;/code&gt; 键的位置，所以才设计使用 &lt;code&gt;esc&lt;/code&gt; 作为模式转换键 。为了更加方便顺手地使用 vim，当然要把这两个键相互调换一下 。&lt;/p&gt;
&lt;p&gt;在 vim 的官网上就有介绍如何实现两个按键的调换&lt;/p&gt;
&lt;p&gt;&lt;a href="http://vim.wikia.com/wiki/Map_caps_lock_to_escape_in_XWindows"&gt;Map caps lock to escape in XWindows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体方法，在 &lt;code&gt;～/&lt;/code&gt; 目录下新建一个文件，加入一下内容&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;! Swap caps lock and escape
remove &lt;span class="nv"&gt;Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; Caps_Lock
keysym &lt;span class="nv"&gt;Escape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; Caps_Lock
keysym &lt;span class="nv"&gt;Caps_Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; Escape
add &lt;span class="nv"&gt;Lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; Caps_Lock
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;保存为 .speedswrapper&lt;/p&gt;
&lt;p&gt;然后输入命令&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;xmodmap ~/.speedswrapper
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这时，对于整个系统范围，这两个键已经调换了位置 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. she zhi yan se zhu ti  colorscheme"&gt;3. 设置颜色主题 colorscheme&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Vim 自带一些颜色主题，一般存放在 &lt;code&gt;/usr/share/vim/vim7x&lt;/code&gt; 目录下（我的 Vim 版本为 7.3，所以路径为 &lt;code&gt;/usr/share/vim/vim73&lt;/code&gt;）.&lt;/p&gt;
&lt;p&gt;如果对系统自带的主题不满意，网上有很多不错的主题，个人最喜欢 &lt;a href="https://github.com/tomasr/molokai"&gt;molikai&lt;/a&gt; 主题，把下载下来的配色文件拷贝到 &lt;code&gt;usr/share/vim/vim73&lt;/code&gt; 路径下，打开 vim 后 输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:colorscheme molikai
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就 ok 了～ 不过这个方法在关闭 vim 后就恢复了，要想省去每次都输命令的烦恼，只需要在下一步 .vimrc 文件中加入以下内容就可以了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;colorscheme molikai
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. bian xie  .vimrc"&gt;4. 编写 .Vimrc&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;vimrc 文件是配置 Vim 编辑特性比较好的地方，差不多任何 Vim 选项都能在次文件中被设置为打开或者关闭，而且它特别适合设置全局变量与定义函数、缩写、按键映射 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注释以双引号 &lt;code&gt;&amp;ldquo;&lt;/code&gt; 开始，可位于一行的任何2位置，所有位于双引号后面的文本，包括双引号都会被视为注释而忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用冒号 &lt;code&gt;:&lt;/code&gt; 表示 ex 命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="4.1. pei zhi  vim te xing"&gt;4.1. 配置 Vim 特性&lt;/h3&gt;
&lt;p&gt;vimrc 配置很简单，网上有很多人都分享了自己的配置方案 。我找到一份注释良好的&lt;a href="https://github.com/amix/vimrc"&gt;配置范例&lt;/a&gt;，这篇博客的作者总结了自己 8 年的使用经验，给出了两份配置文件，基本版 &lt;a href="https://github.com/amix/vimrc/blob/master/vimrcs/basic.vim"&gt;Basic&lt;/a&gt; 和 终极版&lt;a href="https://github.com/amix/vimrc"&gt;Ultimate&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;作为码农，当然要选择终极版了～不过个人喜欢用 Vundle 管理我的 Vim 插件（计划下篇博客记录我的配置过程），不是很喜欢作者选择的所有插件，想自己定制插件组合，那么目前只需要看 基础版就足够了 。&lt;/p&gt;
&lt;p&gt;copy 了一份基础版到自己的 github 中，有备无患 :-D&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Copy of basic vimrc configure file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我自己的配置文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;My .vimrc file&lt;/a&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; General
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;set nocompatible&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; Set how many lines of &lt;span class="nb"&gt;history&lt;/span&gt; VIM has to rememer
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;history&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;800&lt;/span&gt;

&lt;span class="s2"&gt;" Enable filetype plugins&lt;/span&gt;
&lt;span class="s2"&gt;filetype plugin on&lt;/span&gt;
&lt;span class="s2"&gt;filetype indent on&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Set to auto &lt;span class="nb"&gt;read&lt;/span&gt; when a file is changed from the outside
&lt;span class="nb"&gt;set&lt;/span&gt; autoread

&lt;span class="s2"&gt;" Set leader key&lt;/span&gt;
&lt;span class="s2"&gt;let mapleader = "&lt;/span&gt;,&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;span class="s2"&gt;let g:mapleader = "&lt;/span&gt;,&lt;span class="s2"&gt;"&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; fast saving
nmap &amp;lt;leader&amp;gt;w :w!&amp;lt;cr&amp;gt;

&lt;span class="s2"&gt;" fast saving&lt;/span&gt;
&lt;span class="s2"&gt;nmap &amp;lt;leader&amp;gt;q :q!&amp;lt;cr&amp;gt;&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; fast editing
nmap &amp;lt;leader&amp;gt;aq :qa&amp;lt;cr&amp;gt;

&lt;span class="s2"&gt;""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Vim user interface&lt;/span&gt;
&lt;span class="s2"&gt;""""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; Set &lt;span class="m"&gt;20&lt;/span&gt; lines to the cursor
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;so&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;20&lt;/span&gt;

&lt;span class="s2"&gt;" Turn on the wild menu&lt;/span&gt;
&lt;span class="s2"&gt;set wildmenu&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Ignore complited files
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;wildignore&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;*.o,*~,*.pyc

&lt;span class="s2"&gt;" Always show current postion&lt;/span&gt;
&lt;span class="s2"&gt;set ruler&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Highlight current line
&lt;span class="nb"&gt;set&lt;/span&gt; cursorline

&lt;span class="s2"&gt;" Height of command bar&lt;/span&gt;
&lt;span class="s2"&gt;set cmdheight=2&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; A buffer becomes hidden when it is abandoned
&lt;span class="nb"&gt;set&lt;/span&gt; hid

&lt;span class="s2"&gt;" Configure backsapce so it acts as it should act&lt;/span&gt;
&lt;span class="s2"&gt;set backspace=eol,start,indent&lt;/span&gt;
&lt;span class="s2"&gt;set whichwrap+=&amp;lt;,&amp;gt;,h,l&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Ignore &lt;span class="k"&gt;case&lt;/span&gt; when searching
&lt;span class="nb"&gt;set&lt;/span&gt; ignorecase

&lt;span class="s2"&gt;" When searching try to be smart about cases&lt;/span&gt;
&lt;span class="s2"&gt;set smartcase&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Highlight search results
&lt;span class="nb"&gt;set&lt;/span&gt; hlsearch

&lt;span class="s2"&gt;" Make search act like in morden browsers&lt;/span&gt;
&lt;span class="s2"&gt;set incsearch&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Don&lt;span class="err"&gt;'&lt;/span&gt;t redraw &lt;span class="k"&gt;while&lt;/span&gt; executing marcros
&lt;span class="nb"&gt;set&lt;/span&gt; lazyredraw

&lt;span class="s2"&gt;" For regular expressions turn magic on&lt;/span&gt;
&lt;span class="s2"&gt;set magic&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Show matching brackets when text indicator is over them
&lt;span class="nb"&gt;set&lt;/span&gt; showmatch
&lt;span class="s2"&gt;" How many tenths of a second to blink when matching brackets&lt;/span&gt;
&lt;span class="s2"&gt;set mat=2&lt;/span&gt;

&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Colors and Fonts&lt;/span&gt;
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Enable syntax highlight&lt;/span&gt;
&lt;span class="s2"&gt;syntax enable&lt;/span&gt;
&lt;span class="s2"&gt;colorscheme molokai&lt;/span&gt;
&lt;span class="s2"&gt;set background=dark&lt;/span&gt;
&lt;span class="s2"&gt;:set t_Co=256&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Set utf8 as standard encoding and en_US as the standard language
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;utf8

&lt;span class="s2"&gt;" Use Unix as the standard file type&lt;/span&gt;
&lt;span class="s2"&gt;set ffs=unix,dos,mac&lt;/span&gt;

&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Files, backups and undo&lt;/span&gt;
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Turn backup off, since most stuff is in SVN. git et.c anyway&lt;/span&gt;
&lt;span class="s2"&gt;set nobackup&lt;/span&gt;
&lt;span class="s2"&gt;set nowb&lt;/span&gt;
&lt;span class="s2"&gt;set noswapfile&lt;/span&gt;

&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Text, tab and indent related&lt;/span&gt;
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Use sapce instead of tabs&lt;/span&gt;
&lt;span class="s2"&gt;set expandtab&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Be smart when using tabs
&lt;span class="nb"&gt;set&lt;/span&gt; smarttab

&lt;span class="s2"&gt;" 1 tab = 4 spaces&lt;/span&gt;
&lt;span class="s2"&gt;set shiftwidth=4&lt;/span&gt;
&lt;span class="s2"&gt;set tabstop=4&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Linebreak on &lt;span class="m"&gt;500&lt;/span&gt; characters
&lt;span class="nb"&gt;set&lt;/span&gt; lbr
&lt;span class="nb"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;tw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;500&lt;/span&gt;

&lt;span class="nb"&gt;set&lt;/span&gt; ai &lt;span class="s2"&gt;"Auto indent&lt;/span&gt;
&lt;span class="s2"&gt;set si "&lt;/span&gt;Smart indent
&lt;span class="nb"&gt;set&lt;/span&gt; wrap &lt;span class="s2"&gt;"Wrap lines&lt;/span&gt;

&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Moving around, tabs, windows and buffers&lt;/span&gt;
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Treat long lines as break lines&lt;/span&gt;
&lt;span class="s2"&gt;map j gj&lt;/span&gt;
&lt;span class="s2"&gt;map k gk&lt;/span&gt;

&lt;span class="s2"&gt;"&lt;/span&gt; Smart way to move between windows
map &amp;lt;C-j&amp;gt; &amp;lt;C-w&amp;gt;j
map &amp;lt;C-k&amp;gt; &amp;lt;C-w&amp;gt;k
map &amp;lt;C-h&amp;gt; &amp;lt;C-w&amp;gt;h
map &amp;lt;C-l&amp;gt; &amp;lt;C-w&amp;gt;l

&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; Status line
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;"&lt;/span&gt; Show line number
&lt;span class="nb"&gt;set&lt;/span&gt; number

&lt;span class="s2"&gt;" Always show the status line&lt;/span&gt;
&lt;span class="s2"&gt;set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}&lt;/span&gt;
&lt;span class="s2"&gt;""set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l&lt;/span&gt;


&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Spell checking&lt;/span&gt;
&lt;span class="s2"&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""&lt;/span&gt;
&lt;span class="s2"&gt;" Pressing ,ss will toggle and untoggle spell checking&lt;/span&gt;
&lt;span class="s2"&gt;map &amp;lt;leader&amp;gt;ss :setlocal spell!&amp;lt;cr&amp;gt;&lt;/span&gt;
&lt;span class="s2"&gt;map &amp;lt;leader&amp;gt;sn ]s&lt;/span&gt;
&lt;span class="s2"&gt;map &amp;lt;leader&amp;gt;sp [s&lt;/span&gt;
&lt;span class="s2"&gt;map &amp;lt;leader&amp;gt;sa zg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. can kao_1"&gt;5. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习vi 和 Vim 编辑器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/amix/vimrc"&gt;The Ultimate vimrc&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Vim"></category></entry><entry><title>在 Ubuntu 下运行 WarCraft</title><link href="https://qiangu.cool/posts/linux/run_warcraft_on_ubuntu.html" rel="alternate"></link><published>2014-04-10T10:58:00+08:00</published><updated>2014-04-10T10:58:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-10:/posts/linux/run_warcraft_on_ubuntu.html</id><summary type="html">&lt;p&gt;闲来无聊，在 Ubuntu 下 wine 了一个 WarCraft 3 玩&lt;/p&gt;</summary><content type="html">&lt;p&gt;闲来无聊，在 Ubuntu 下 wine 了一个 WarCraft 3 玩&lt;/p&gt;
&lt;p&gt;在实验室的 &amp;rdquo;老爷车&amp;ldquo; 电脑上运行。稍微有一点卡，在5年前买的笔记本（core 2 T6600, 4G RAM）上运行就感觉不到卡了 。&lt;/p&gt;
&lt;p&gt;实验室电脑配置：&lt;/p&gt;
&lt;p&gt;Processor: Pentium(R) Dual-Core CPU E5200 @ 2.50GHz &amp;times; 2 &lt;/p&gt;
&lt;p&gt;Graphics: Gallium 0.4 on NV86&lt;/p&gt;
&lt;p&gt;Memory: 2.0 GiB&lt;/p&gt;
&lt;p&gt;OS type: 32-bit&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. an zhuang  wine"&gt;1. 安装 Wine&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Wine_(software)"&gt;Wine&lt;/a&gt; 是 wine is not an emulator 的缩写，它可以在 x86、x86-64 上容许类 Unix 操作系统在 X Window System 下运行 Microsoft Windows 程序的软件 .它的官方网址：http://www.winehq.org/&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;Ubuntu 软件仓里搜索 Wine，就可以找到 &lt;code&gt;Wine Windows Program Loader&lt;/code&gt;，直接安装即可&lt;/p&gt;
&lt;p&gt;方法二：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;apt-get&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-cache search wine
suod apt-get install wine
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;P.S. 若是其他系统，找不到对应的二进制包，可以直接从官网上下载源码，自己编译（官网上有详细的 &lt;a href="http://wiki.winehq.org/FAQ_zhcn"&gt;FAQ&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. kao bei  warcraft"&gt;2. 拷贝 WarCraft&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;如果是双系统，则不必拷贝 WarCraft 文件夹，因为我电脑上只有 Ubuntu，所以从同学那里拷贝了一个，放在了 &lt;code&gt;～/&lt;/code&gt; 目录下 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. pei zhi  wine &amp;amp; warcraft"&gt;3. 配置 Wine &amp;amp; WarCraft&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="3.1. cd key zhu ce biao wen ti"&gt;3.1. CD key 注册表问题&lt;/h3&gt;
&lt;p&gt;直接以 wine 运行 &lt;code&gt;war3.exe&lt;/code&gt; 时提示没有 CD key，在 WarCraft 目录下找到了两个注册表文件，&lt;code&gt;War3.reg&lt;/code&gt; 和 &lt;code&gt;一键导入.reg&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在终端下导入注册表&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wine regedit
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;然后导入这两个文件，再次尝试，还是不行...&lt;/p&gt;
&lt;p&gt;不急，游戏目录下还有一个程序叫 &lt;code&gt;War3RegFixer.exe&lt;/code&gt;，看名字就知道是我们需要的&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wine War3RegFixer.exe
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;因为我的 Ubuntu 是英文版的，打开后是乱码...&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3regfixer" src="/images/run-warcraft-on-ubuntu/war3regfixer.png"/&gt;&lt;/p&gt;
&lt;p&gt;找了一台 Windows 电脑，运行了一下，按照向导就可以修复 CD key 的问题 。&lt;/p&gt;
&lt;h3 id="3.2. fen bian lu wen ti"&gt;3.2. 分辨率问题&lt;/h3&gt;
&lt;p&gt;第一次运行的结果一般不会全屏，处女座的强迫症犯了，还好比较简单 ：D&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wine regedit
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;找到 &lt;code&gt;HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/Video&lt;/code&gt;，里面有两个注册表值 &lt;code&gt;resheight&lt;/code&gt; 和 &lt;code&gt;reswidth&lt;/code&gt;，将他们设为和当前分辨率相同的十进制数值就可以了。&lt;/p&gt;
&lt;h3 id="3.3. hua mian qia"&gt;3.3. 画面卡&lt;/h3&gt;
&lt;p&gt;因为 Wine 对 DirectX 的支持还不够好，如果电脑配置比较低，运行的时候添加参数 &lt;code&gt;-opengl&lt;/code&gt; 就可以了，为了避免每次运行都要输入参数，可以在注册表 &lt;code&gt;HKEY_CURRENT_USER/Software/Blizzard Entertainment/Warcraft III/&lt;/code&gt; 下新建整数（DWORD），名为 &lt;code&gt;Gfx OpenGL&lt;/code&gt;，值为 1 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. yun xing_1"&gt;4. 运行&lt;/h2&gt;
&lt;h3 id="4.1. zhong duan xia"&gt;4.1. 终端下&lt;/h3&gt;
&lt;p&gt;现在就可以在终端下运行 war3.exe 了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wine war3.exe
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;熟悉的画面就出来了～&lt;/p&gt;
&lt;p&gt;这样子运行如果切出游戏，有时会导致 war3 崩溃或者切换不出去。一个解决方法是以窗口模式运行，只需要添加参数 &lt;code&gt;-window&lt;/code&gt; 即可&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wine war3.exe -window
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;效果如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3window" src="/images/run-warcraft-on-ubuntu/war3window.png"/&gt;&lt;/p&gt;
&lt;p&gt;不过个人不是很喜欢，因为鼠标总是超出窗口，极其不方便，影响游戏操作和感受 ：D&lt;/p&gt;
&lt;h3 id="4.2. zhuo mian qi dong qi"&gt;4.2. 桌面启动器&lt;/h3&gt;
&lt;p&gt;我们可以为 war3 添加一个桌面启动器，这样就不用进入终端启动了&lt;/p&gt;
&lt;p&gt;新建文件 &lt;code&gt;frozen-throne.desktop&lt;/code&gt; 文件，添加以下内容&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;Desktop Entry&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;Version&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;.0
&lt;span class="nv"&gt;Name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; Frozen Throne
&lt;span class="nv"&gt;Exec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; /home/chien/WarCraft/war3.exe
&lt;span class="nv"&gt;Terminal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;span class="nv"&gt;Icon&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; /home/chien/WarCraft/war3.jpg
&lt;span class="nv"&gt;Type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; Application
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;然后把这个文件移动到 &lt;code&gt;/usr/share/applicants/&lt;/code&gt; ，这时在 unity 中搜索 &lt;code&gt;froz&lt;/code&gt;，就能看到我们刚才新建的启动器了～&lt;/p&gt;
&lt;p&gt;&lt;img alt="war3desktop" src="/images/run-warcraft-on-ubuntu/war3desktop.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;至此，就可以在 Ubuntu 下享受 War3 了&lt;/p&gt;
&lt;p&gt;gl hf！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="5. can kao_1"&gt;5. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://linux-wiki.cn/wiki/zh-hans/%E7%94%A8Wine%E8%BF%90%E8%A1%8C%E9%AD%94%E5%85%BD%E4%BA%89%E9%9C%B8III"&gt;用Wine运行魔兽争霸III&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.ubuntusoft.com/wine-warcraft-3.html#.U0Xt11SSx38"&gt;Wine 魔兽争霸3的一些设置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://hi.baidu.com/chenwzox/item/4e6346f1575a7ab231c199b4"&gt;Wine魔兽争霸3，流畅运行+键盘操作+窗口化&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Wine"></category><category term="WarCraft"></category></entry><entry><title>学习 Linux SSH</title><link href="https://qiangu.cool/posts/linux/learning_linux_ssh.html" rel="alternate"></link><published>2014-04-04T17:00:00+08:00</published><updated>2014-04-04T17:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-04:/posts/linux/learning_linux_ssh.html</id><summary type="html">&lt;p&gt;学习 SSH、SCP 命令，建立两台电脑相互访问 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;实验室的师兄师姐毕业了，继承了他们的旧电脑 。宿舍的笔记本和实验室的电脑出现了相互之间传送同步文件的需求 。想到了两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;云同步&lt;/li&gt;
&lt;li&gt;SSH / SCP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决方案 1 是最省事的，也是目前最流行的，目前各大互联网公司都提供各种云服务，比如国外的 Google Drive、Dropbox，国内的百度云、360 网盘什么的。这种方案最大的有点是跨平台，不过这个方案是借助了第三方的服务器，需要连接到互联网才行，而且对网速是有一定要求的。&lt;/p&gt;
&lt;p&gt;解决方案 2 相比于方案 1 的优势是：不是必须要连接到互联网，在局域网内也可以同步文件 。一般局域网内传输文件的速度要比连外界的服务器快很多 。&lt;/p&gt;
&lt;p&gt;考虑到校园网的环境，明显方案 2 更加好 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="1. shi yao shi  ssh"&gt;1. 什么是 SSH&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑 。&lt;a href="http://en.wikipedia.org/wiki/Secure_Shell"&gt;SSH&lt;/a&gt; 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置 。&lt;/p&gt;
&lt;p&gt;最初的 SSH 协议是由芬兰的一家公司的研究员 Tatu Yl&amp;ouml;nen 于 1995 年设计开发的，但是因为受版权和加密算法等等的限制，现在很多人都转而使用 OpenSSH 。OpenSSH 是 SSH 的替代软件包，而且是开放源代码和免费的 。&amp;mdash;&amp;mdash; Wikipedia&lt;/p&gt;
&lt;p&gt;关于 SSH 的原理，找到了一系列 &lt;a href="http://www.ruanyifeng.com/blog/"&gt;阮一峰&lt;/a&gt;的文章，很简洁明了:&lt;/p&gt;
&lt;h3 id="1.1. ssh"&gt;1.1. SSH&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html"&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html"&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. ssh de yong fa_1"&gt;2. SSH 的用法&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;最简单明了的教程就是 man page 了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man ssh
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;内容为&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;NAME
    ssh &amp;mdash; OpenSSH SSH client &lt;span class="o"&gt;(&lt;/span&gt;remote login program&lt;span class="o"&gt;)&lt;/span&gt;

SYNOPSIS
 ssh &lt;span class="o"&gt;[&lt;/span&gt;-1246AaCfgKkMNnqsTtVvXxYy&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-b bind_address&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-c cipher_spec&lt;span class="o"&gt;]&lt;/span&gt;
     &lt;span class="o"&gt;[&lt;/span&gt;-D &lt;span class="o"&gt;[&lt;/span&gt;bind_address:&lt;span class="o"&gt;]&lt;/span&gt;port&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-e escape_char&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-F configfile&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-I pkcs11&lt;span class="o"&gt;]&lt;/span&gt;
     &lt;span class="o"&gt;[&lt;/span&gt;-i identity_file&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-L &lt;span class="o"&gt;[&lt;/span&gt;bind_address:&lt;span class="o"&gt;]&lt;/span&gt;port:host:hostport&lt;span class="o"&gt;]&lt;/span&gt;
     &lt;span class="o"&gt;[&lt;/span&gt;-l login_name&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-m mac_spec&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-O ctl_cmd&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-o option&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-p port&lt;span class="o"&gt;]&lt;/span&gt;
     &lt;span class="o"&gt;[&lt;/span&gt;-R &lt;span class="o"&gt;[&lt;/span&gt;bind_address:&lt;span class="o"&gt;]&lt;/span&gt;port:host:hostport&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-S ctl_path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-W host:port&lt;span class="o"&gt;]&lt;/span&gt;
     &lt;span class="o"&gt;[&lt;/span&gt;-w local_tun&lt;span class="o"&gt;[&lt;/span&gt;:remote_tun&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;user@&lt;span class="o"&gt;]&lt;/span&gt;hostname &lt;span class="o"&gt;[&lt;/span&gt;command&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;进阶的书籍有：&lt;a href="http://docstore.mik.ua/orelly/networking_2ndEd/ssh/index.htm"&gt;SSH, The Secure Shell: The Definitive Guide&lt;/a&gt;, O'reilly&lt;/p&gt;
&lt;p&gt;目前已经有两台安装了 Ubuntu 的电脑，实验室的一台 name 是 &lt;em&gt;lab&lt;/em&gt; ，宿舍的一台 name 是 &lt;em&gt;dom&lt;/em&gt; ，两台电脑上都有一个用户名为 &lt;em&gt;chien&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的目的是使两台电脑可以相互之间通过 SSH 访问。&lt;/strong&gt; 下面就是整个过程：&lt;/p&gt;
&lt;h3 id="2.1. an zhuang  ssh server"&gt;2.1. 安装 SSH server&lt;/h3&gt;
&lt;p&gt;SSH 只是一种协议，在 Ubuntu 下，具体实现使用的是 &lt;a href="http://www.openssh.com/"&gt;OpenSSH&lt;/a&gt; 。Ubuntu 默认是安装了 SSH 客户端 &lt;code&gt;openssh-client&lt;/code&gt;，而没有安装 SSH 服务程序 &lt;code&gt;openssh-server&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;检测本机是否已经安装了 SSH server&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh localhost
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;如果结果是&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh: connect to host localhost port &lt;span class="m"&gt;22&lt;/span&gt;: Connection refused
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;说明 SSH server 还没有安装 。&lt;/p&gt;
&lt;p&gt;安装方法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install openssh-server
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="2.2. qi dong  ssh fu wu"&gt;2.2. 启动 SSH 服务&lt;/h3&gt;
&lt;p&gt;启动 SSH server&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /etc/init.d/ssh start
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;查询服务是否正确启动&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ps -e &lt;span class="p"&gt;|&lt;/span&gt; grep ssh
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;返回结果应该类似于&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="m"&gt;4156&lt;/span&gt; ?        &lt;span class="m"&gt;00&lt;/span&gt;:00:00 ssh-agent
 &lt;span class="m"&gt;4606&lt;/span&gt; ?        &lt;span class="m"&gt;00&lt;/span&gt;:00:00 sshd
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;则说明服务已经正确启动 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;因为两台电脑要相互访问，所以它们的角色即使 server，又是 client，所以需要在两台电脑上都执行上面两步 。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="2.3. yuan cheng fang wen"&gt;2.3. 远程访问&lt;/h3&gt;
&lt;p&gt;首先，查询本机 IP 地址&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ifconfig
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;比如 lab 的 IP 地址是 &lt;code&gt;10.105.55.155&lt;/code&gt;, dom 的 IP 地址是 &lt;code&gt;10.210.111.116&lt;/code&gt; 。（因为是校园网，所以分配到的都是内网地址）&lt;/p&gt;
&lt;p&gt;然后，在宿舍用 dom 访问 lab 这台机器&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh chien@10.105.55.155
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login1" src="/images/learning-linux-ssh/login1.png"/&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 dom 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 lab 机器，远程机器 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;p&gt;同理，在实验室用 lab 访问 dom 这台机器&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh chien@10.210.111.116
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login2" src="/images/learning-linux-ssh/login2.png"/&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 lab 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 dom 机器，远程机器 home 目录下有有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;h3 id="2.4. sheng qu  ip di zhi"&gt;2.4. 省去 IP 地址&lt;/h3&gt;
&lt;p&gt;每次登录都需要记忆、手动输入 IP 地址，其实只需要改 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件，就能省去手动输入 IP 地址的烦恼。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vim /etc/hosts
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在 dom 的 hosts 文件后面添加&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lab    &lt;span class="m"&gt;10&lt;/span&gt;.105.55.155
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在 lab 的 hosts 文件后面添加&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dom     &lt;span class="m"&gt;10&lt;/span&gt;.210.111.116
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;以后，登录时只需要输入&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// from dom to lab
ssh lab

// from lab to domm
ssh dom
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就可以登录了。&lt;/p&gt;
&lt;h3 id="2.5. gong yao deng lu"&gt;2.5. 公钥登录&lt;/h3&gt;
&lt;p&gt;上一步解决了 IP 地址的问题，但是还是需要手动输入密码 。我们可以用公钥登录的方法，免去输密码的烦恼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，什么是数字签名 Digital Signature&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，生成数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 默认安装了 &lt;code&gt;ssh-keygen&lt;/code&gt;，可以生成公钥和私钥&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;命令执行过程中会询问保存密钥文件的路径，还可以为密钥文件设置口令（passphrase）。运行结束以后，在 &lt;code&gt;$HOME/.ssh/&lt;/code&gt; 目录下，会新生成两个文件：&lt;code&gt;id_rsa.pub&lt;/code&gt; 和 &lt;code&gt;id_rsa&lt;/code&gt; 。前者是你的公钥，后者是你的私钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后，发布数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ssh-copy-id&lt;/code&gt; 命令可以把公钥复制到远程机器中 。&lt;/p&gt;
&lt;p&gt;将 dom 的公钥发送到 lab 中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-copy-di chien@lab
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;将 lab 的公钥发送到 dom 中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-copy-di chien@dom
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;最后，使用公钥登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时，远程登录时就不再需要输入密码了&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// from dom to lab
ssh lab

// from lab to dom
ssh dom
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. shi yong  scp chuan shu wen jian_1"&gt;3. 使用 SCP 传输文件&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;SSH 提供了一些命令和 shell 用来登录远程服务器 。在默认情况下它不允许你拷贝文件,但是还是提供了一个 "scp" 命令 。scp 命令是 SSH 中最方便有用的命令了，试想，在两台服务器之间直接传送文件。仅仅用 scp 一个命令就完全解决了 。&lt;/p&gt;
&lt;p&gt;man page&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man scp
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;内容为&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;NAME
 scp &amp;mdash; secure copy &lt;span class="o"&gt;(&lt;/span&gt;remote file copy program&lt;span class="o"&gt;)&lt;/span&gt;

SYNOPSIS
 scp &lt;span class="o"&gt;[&lt;/span&gt;-12346BCpqrv&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-c cipher&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-F ssh_config&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-i identity_file&lt;span class="o"&gt;]&lt;/span&gt;
     &lt;span class="o"&gt;[&lt;/span&gt;-l limit&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-o ssh_option&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-P port&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-S program&lt;span class="o"&gt;]&lt;/span&gt;
     &lt;span class="o"&gt;[[&lt;/span&gt;user@&lt;span class="o"&gt;]&lt;/span&gt;host1:&lt;span class="o"&gt;]&lt;/span&gt;file1 ... &lt;span class="o"&gt;[[&lt;/span&gt;user@&lt;span class="o"&gt;]&lt;/span&gt;host2:&lt;span class="o"&gt;]&lt;/span&gt;file2
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;scp 可以实现把 [[user@]host1:]file1 复制到 [[user@]host2:]file2 的功能。所以&lt;/p&gt;
&lt;h3 id="3.1. shang chuan  dom ben di wen jian zhi fu wu qi  lab"&gt;3.1. 上传 dom 本地文件至服务器 lab&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp ~/dom chien@lab:~/
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="3.2. xia zai  lab fu wu qi wen jian zhi ben di  dom"&gt;3.2. 下载 lab 服务器文件至本地 dom&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp chien@lab:lab ~/
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;若发送文件夹则添加参数 &lt;code&gt;-r&lt;/code&gt; 即可&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp -r ~/test chien@lab:~/
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;至此，就实现了两台电脑的之间相互远程访问的功能 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. reference_1"&gt;4. Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html"&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="SSH"></category></entry><entry><title>学习 Vim 存活</title><link href="https://qiangu.cool/posts/linux/learning_vim_survival.html" rel="alternate"></link><published>2014-03-25T21:23:00+08:00</published><updated>2014-03-25T21:23:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-03-25:/posts/linux/learning_vim_survival.html</id><summary type="html">&lt;p&gt;这个系列的博客是我学习 Vim 过程中的记录和总结，希望可以帮助到和我一样的菜鸟～ 第一篇：入门/存活 Survival&lt;/p&gt;</summary><content type="html">&lt;p&gt;这个系列的博客是我学习 Vim 过程中的记录和总结，内容基本上来自网络上前辈们的博客，还有部分内容是我自己学习的心得。真心感谢前辈们的分享，我会尽量在后面的文章中标明内容出处，比如我学习 Vim 的路线就是按照这个博客&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/"&gt;vi/vim使用进阶: 目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来学习的。希望我的学习历程可以帮助到和我一样的菜鸟，能更好地使用这款神器～&lt;/p&gt;
&lt;p&gt;第一篇：入门/存活 Survival&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;br/&gt;
&lt;nr&gt;&lt;/nr&gt;&lt;/p&gt;
&lt;h2 id="1. vim shi shi yao"&gt;1. Vim 是什么&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;简单的说，&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim&lt;/a&gt; 就是广大的编辑器中的一员，但是对程序猿来说，她并不是一款简单的编辑器。她强大的编辑能力、苗条的身材（软件体积小、启动速度快）和 Linux 系统的血缘关系（几乎是 Linux 系统的标配），使其在全世界有成千上万的粉丝，以至于掌握 Vim 成为每个码农必备技能。&lt;/p&gt;
&lt;p&gt;Wikipedia 上 Vim 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim (an acronym for Vi IMproved) is a text editor written by Bram Moolenaar and first released publicly in 1991. Based on the vi editor common to Unix-like systems, Vim is designed for use both from a command line interface and as a standalone application in a graphical user interface. Vim is free and open source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The license is compatible with the GNU General Public License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="1.1. li shi"&gt;1.1. 历史&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;摘抄（翻译）自 &lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;Wikipedia&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 vi/Vim 的发展，还是从头说起：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ed_(text_editor)"&gt;ed&lt;/a&gt;&lt;/strong&gt; 是 UNIX 界最古老最基本的编辑器，它由 &lt;a href="http://en.wikipedia.org/wiki/Ken_Thompson_(computer_programmer)"&gt;Ken Thompson&lt;/a&gt; (UNIX 之父)于 1971 年在 &lt;a href="http://en.wikipedia.org/wiki/PDP-11"&gt;PDP-11&lt;/a&gt;/20 上用汇编写成 。ed 的许多特性来自于 &lt;a href="http://en.wikipedia.org/wiki/Ken_Thompson_(computer_programmer)"&gt;Thompson&lt;/a&gt; 在加州伯克利大学上学时受到的&lt;a href="http://en.wikipedia.org/wiki/QED_(text_editor)"&gt;qed&lt;/a&gt; 编辑器的影响 。Thompson 对 qed 非常熟悉，他在 &lt;a href="http://en.wikipedia.org/wiki/Compatible_Time-Sharing_System"&gt;CTSS&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Multics"&gt;Multics&lt;/a&gt; 操作系统上重新实现了一边 qed ，并且在他的版本中，第一次实现了正则表达式（ &lt;a href="http://en.wikipedia.org/wiki/Regular_expression"&gt;regular expressions&lt;/a&gt;）。虽然正则表达式也是 ed 的一部分，但是一般认为在 qed 中正则表达式的实现更多一些 。&lt;/p&gt;
&lt;p&gt;ed 是为电传机（&lt;a href="http://en.wikipedia.org/wiki/Teletype"&gt;teletype&lt;/a&gt;）而不是终端显示器（&lt;a href="http://en.wikipedia.org/wiki/Display_terminal"&gt;display terminals&lt;/a&gt;）设计的行编辑器，它是一个行编辑器。在它的起源地 &amp;mdash;&amp;mdash; AT&amp;amp;T 实验室，人们似乎很满意把 ed 设置为默认的编辑器，即使它的功能很基本而且很不友好。 &lt;a href="http://en.wikipedia.org/wiki/George_Coulouris_(computer_scientist)"&gt;George Coulouris&lt;/a&gt; 回忆说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] for many years, they had no suitable terminals. They carried on with TTYs and other printing terminals for a long time, and when they did buy screens for everyone, they got Tektronix 4014s. These were large storage tube displays. You can't run a screen editor on a storage-tube display as the picture can't be updated. Thus it had to fall to someone else to pioneer screen editing for Unix, and that was us initially, and we continued to do so for many years.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Coulouris 认为 ed 的隐藏的命令只适合于 &amp;ldquo;神人&amp;rdquo;（immortals），所以在 &lt;a href="http://en.wikipedia.org/wiki/Queen_Mary,_University_of_London"&gt;Queen Mary College&lt;/a&gt; 当讲师的期间，他在 Thompson 的代码的基础上加强了 ed，并且命名为 em （the "editor for mortals"）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;em&lt;/strong&gt; 是为终端显示器设计（display terminals）的，一次只显示一行的可视化编辑器，它是 UNIX 中第一个大量使用 "raw terminal input mode" 的程序，这种模式下，由应用程序而不是终端的驱动处理键盘的输入。1976 年夏天，Coulouris 参观 &lt;a href="http://en.wikipedia.org/wiki/University_of_California,_Berkeley"&gt;UC Berkeley&lt;/a&gt; 时，他带着一卷录有 em 的 DEC 磁带，他给很多人演示了 em ，有的人认为 em 只是有潜力，但是有的人却对此留下了深刻影响，其中就包括 &lt;a href="http://en.wikipedia.org/wiki/Bill_Joy"&gt;Bill Joy&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;受到 em 的鼓舞，加上他们自己使用 ed 时的技巧，Bill Joy 和 Chuck Haley 这两个刚从 UC Berkeley 的毕业的研究生使用 em 的代码，设计了一个叫 en 的编辑器，然后把 en 扩展为 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ex_(editor)"&gt;ex&lt;/a&gt;&lt;/strong&gt; v0.1 。&lt;/p&gt;
&lt;p&gt;ex 仍然只显示一行而非一屏的内容。后来，Chuck Haley 退出了开发，Bruce Englar 鼓励 Bill Joy 重新设计了 ex，在 1977 年 6 月到 10 月期间，他为 ex 添加了全屏可视化模式 ，ex 的 visual mode 也就是 &lt;strong&gt;vi&lt;/strong&gt; 的命名原因 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vi /ˈviːˈaɪ/ is a screen-oriented text editor originally created for the Unix operating system. The portable subset of the behavior of vi and programs based on it, and the ex editor language supported within these programs, is described by (and thus standardized by) the Single Unix Specification and POSIX.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;据 Bill Joy 讲，很多 vi 的可视化灵感来自于另外一个叫做 &lt;a href="http://en.wikipedia.org/wiki/Bravo_(software)"&gt;Bravo&lt;/a&gt; 的编辑器，在一次关于 vi 的起源的访谈中，他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A lot of the ideas for the screen editing mode were stolen from a Bravo manual I surreptitiously looked at and copied. Dot is really the double-escape from Bravo, the redo command. Most of the stuff was stolen. There were some things stolen from ed&amp;mdash;we got a manual page for the Toronto version of ed, which I think Rob Pike had something to do with. We took some of the regular expression extensions out of that.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于为什么 vi 要设计成这么不友好，其实是有历史原因的：&lt;/p&gt;
&lt;p&gt;Joy 使用的是 Lear Siegler ADM3A 终端，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="Terminal_ADM3A" src="/images/learning-vim-survival/Terminal_ADM3A.png"/&gt;&lt;/p&gt;
&lt;p&gt;在这个终端上，&lt;code&gt;ESC&lt;/code&gt; 键的位置是现在 &lt;a href="http://en.wikipedia.org/wiki/IBM_PC_keyboard"&gt;IBM PC keyboard&lt;/a&gt; 键盘的 &lt;code&gt;Tab&lt;/code&gt; 键的位置，所以，选择 &lt;code&gt;ESC&lt;/code&gt; 作为模式切换键是很方便的设计 。同时，&lt;code&gt;h&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 键也起方向键的作用，所以，vi 也采用相同的设计 。Joy 解释说，因为他开发软件时使用的 Modem 的速率只有 300 波特，显示器上的刷新速度还没有他的思考速度快，所以他设计了单字符这样的简洁风格的命令。&lt;/p&gt;
&lt;p&gt;1978 年 3 月，Joy 负责的 BSD Unix 发布了，系统自带了 ex 1.1，这为他的编辑器在 UC Berkeley 积攒了大量人气。从那时起，Unix 系统自带的编辑器只有 ed 和 ex 。在 1984 年的一次采访中，Joy 把 vi 的成功归功于免费，当时的其他编辑器，比如 Emacs 要花费数百美金 。&lt;/p&gt;
&lt;p&gt;观察显示基本上，所有的 ex 用户都是在 visual mode 下工作，所以在 ex 2.0（作为 1979 年 5 月的 BSD Unix 的一部分）中，Joy 把 vi 作为 ex 的硬链接，这样用户一打开 ex，就默认进入 visual mode ，所以说，vi 并不是 ex 的进化，vi 就是 ex 。&lt;/p&gt;
&lt;p&gt;虽然在今天看来，vi 是一个很小的，轻量级的程序，但是 Joy 把 ex 2.0(vi) 描述为一个非常大的程序，因为它几乎占据了 &lt;a href="http://en.wikipedia.org/wiki/PDP-11#Models"&gt;PDP-11/70&lt;/a&gt; 的所有内存。在 1979 年第3版 BSD 中，PDP-11 已经无法存储v3.1 的 vi 。&lt;/p&gt;
&lt;p&gt;Joy 一直领导着 vi 的开发，一直到 1979 年 6 月的 vi 2.7，到 1980 年 8 月的 v3.5 版本中，还作出偶尔的贡献。在谈及 vi 的起源和他为何退出开发时，他说，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I wish we hadn't used all the keys on the keyboard. I think one of the interesting things is that vi is really a mode-based editor. I think as mode-based editors go, it's pretty good. One of the good things about EMACS, though, is its programmability and the modelessness. Those are two ideas which never occurred to me. I also wasn't very good at optimizing code when I wrote vi. I think the redisplay module of the editor is almost intractable. It does a really good job for what it does, but when you're writing programs as you're learning... That's why I stopped working on it.&lt;/p&gt;
&lt;p&gt;What actually happened was that I was in the process of adding multiwindows to vi when we installed our VAX, which would have been in December of '78. We didn't have any backups and the tape drive broke. I continued to work even without being able to do backups. And then the source code got scrunched and I didn't have a complete listing. I had almost rewritten all of the display code for windows, and that was when I gave up. After that, I went back to the previous version and just documented the code, finished the manual and closed it off. If that scrunch had not happened, vi would have multiple windows, and I might have put in some programmability&amp;mdash;but I don't know.&lt;/p&gt;
&lt;p&gt;The fundamental problem with vi is that it doesn't have a mouse and therefore you've got all these commands. In some sense, its backwards from the kind of thing you'd get from a mouse-oriented thing. I think multiple levels of undo would be wonderful, too. But fundamentally, vi is still ed inside. You can't really fool it.
It's like one of those pinatas&amp;mdash;things that have candy inside but has layer after layer of paper mache on top. It doesn't really have a unified concept. I think if I were going to go back&amp;mdash;I wouldn't go back, but start over again.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 1979 年， &lt;a href="http://en.wikipedia.org/wiki/Mary_Ann_Horton"&gt;Mark Horton&lt;/a&gt; 接管了 vi 的开发，他添加了对方向键和功能键的支持，用  terminfo 代替了 termcap，提高了 vi 的性能 。&lt;/p&gt;
&lt;p&gt;到 1981 年的 8 月，v3.7 版的 vi 以前，UC Berkeley 是 vi 开发的中心，但是随着 1982 年初 Joy 的离开去创办 &lt;a href="http://en.wikipedia.org/wiki/Sun_Microsystems"&gt;Sun Microsystems&lt;/a&gt;，AT&amp;amp;T 的  &lt;a href="http://en.wikipedia.org/wiki/UNIX_System_V"&gt;UNIX System V&lt;/a&gt; (1983 年 1 月)采用 vi，vi 代码库的变化开始变得缓慢混乱，而且变得相互不兼容。在 UC Berkeley，虽然有修改代码，但是版本号一直没有超过 3.7 。商业的 Unix 制造商，比如 Sun, &lt;a href="http://en.wikipedia.org/wiki/HP"&gt;HP&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Digital_Equipment_Corporation"&gt;DEC&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/IBM"&gt;IBM&lt;/a&gt;，他们的系统 &lt;a href="http://en.wikipedia.org/wiki/Solaris_(operating_system)"&gt;Solaris&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/HP-UX"&gt;HP-UX&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Tru64_UNIX"&gt;Tru64 UNIX&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/AIX"&gt;AIX&lt;/a&gt;，今天仍然在使用从 3.7 release 中衍生出来的代码，但是加入了新的特性，比如可以调整的按键映射、加密等 。&lt;/p&gt;
&lt;p&gt;虽然商业的制造商可以使用 Joy 的代码库（直至今天），但是有许多人却不能使用。因为 Joy 是在 Thompson 的 ed 的基础上开发的，所以 ex 和 vi 是派生出来的产品，不能发布给没有 AT&amp;amp;T 的许可证的人使用。想在类 Unix 系统上找到一个编辑器的话必须在别的地方寻找。1985年，一个 Emacs 的版本（&lt;a href="http://en.wikipedia.org/wiki/MicroEMACS"&gt;MicroEmacs&lt;/a&gt;）在很多平台上可以使用，但是直到 1987 年 6 月才出现一个 vi 的克隆版本 &amp;mdash;&amp;mdash; Steive 。在 1990 年 1 月初，Steve Kirkendall 为发布了一个新的 vi 克隆版本 &lt;a href="http://en.wikipedia.org/wiki/Elvis_(text_editor)"&gt;Elvis&lt;/a&gt;，它比 Stive 更加完整更加忠实于 vi 。它很快就吸引了社区用户的热情，&lt;a href="http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum"&gt;Andrew Tanenbaum&lt;/a&gt; 马上在社区讨论在 &lt;a href="http://en.wikipedia.org/wiki/Minix"&gt;Minix&lt;/a&gt; 中使用哪一个当中 vi 的克隆，结果 Elvis 胜利了，直到今天仍然在 Minix 中当作 vi 的克隆体使用 。&lt;/p&gt;
&lt;p&gt;在 1989 年，&lt;a href="http://en.wikipedia.org/wiki/Lynne_Jolitz"&gt;Lynne Jolitz&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/William_Jolitz"&gt;William Jolitz&lt;/a&gt; 开始着手把 BSD Unix 移植到 386 系列的处理器上，为了发布一个免费版本，他们必须绕过 AT&amp;amp;T 含有的代码，其中就包括 Joy 的 vi 。为了填补 vi 的空白，他们在 1992 年的 386BSD 发布版中采用了 Elvis 作为 vi 的替代品，386BSD 后来的分支 &lt;a href="http://en.wikipedia.org/wiki/FreeBSD"&gt;FreeBSD&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/NetBSD"&gt;NetBSD&lt;/a&gt; 也延续了这一决定。但是在 UC Berkely，Keith Bostic 使用 Kirkendall 的 Elvis（v1.8）代码，编写了 &lt;a href="http://en.wikipedia.org/wiki/Nvi"&gt;nvi&lt;/a&gt;，并于 1994 年春发布。当 FreeBSD 和 NetBSD 在  4.4-Lite2 代码库的基础上重新同步以后，他们也采用了 nvi，并且一直延续到今天。&lt;/p&gt;
&lt;p&gt;虽然有很多 vi 的克隆体，而且它们都有很多加强的特性，但是在 2000 年前左右，Gunnar Ritter 使用了 2.11BSD 中的 Joy 的代码，并把 vi 移植到了类 Unix 系统中，比如 Linux 和 FreeBSD 。从技术上讲，他没有许可证而发布 vi 的做法是非法的，但是，到了 2002 年 1 月，AT&amp;amp;T 的许可证被取消了，vi 可以作为开源项目在其他发布版中使用。Ritter 继续在 Joy 的代码的基础上加强 vi 的特性，就像那些商业版一样。他的成果 &lt;a href="http://ex-vi.cvs.sourceforge.net/"&gt;Traditional Vi&lt;/a&gt; 在很多系统上运行。&lt;/p&gt;
&lt;p&gt;虽然 Joy 的 vi 现在又可以在 BSD Unix 上使用，但是 很多 BSD 的粉丝都转移到 更加强大、但仍然保留着 vi 的某些特性的 nvi 的阵地。从某种意义上说，这是一个奇怪的反常现象，在 Joy 的 vi 的发源地 BSD 中不再使用 vi，但是缺少它的 AT&amp;amp;T 的发行版却仍然保留了它并使用至今。&lt;/p&gt;
&lt;p&gt;在 1984 年 Emacs 发布以前，vi 几乎是所有 Hacker 使用的 Unix 标准编辑器，从 2006 年开始，作为 &lt;a href="http://en.wikipedia.org/wiki/Single_UNIX_Specification"&gt;&amp;rdquo;单一Unix标准&amp;ldquo;（Single UNIX Specification）&lt;/a&gt;的一部分，vi 和 vi 的变形体一定可以在今天的系统中找到。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Bram_Moolenaar"&gt;Bram Moolenaar&lt;/a&gt; 于 1988 年买了一台 [Amiga][Amiga] 计算机，Amiga 上没有他常用的 vi，于是他在开源的 Stevie 的基础上，于 1991 年发布了 Vim v1.14 。&lt;/p&gt;
&lt;p&gt;起初 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim&lt;/a&gt;&lt;/strong&gt; 是 &lt;em&gt;&amp;rdquo;Vi IMitation&amp;ldquo;&lt;/em&gt; 的缩写，但是后来 1993 年 12 发布的 Vim 2.0 版本中改名为 &lt;em&gt;"Vi IMproved"&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;vim 现在是 &lt;a href="http://en.wikipedia.org/wiki/GNU_General_Public_License"&gt;GNU General Public （GPL）&lt;/a&gt;下的自由软件，几乎在所有的 Linux 系统和 苹果 OS X 系统中都可以找到她的身影。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="2. wei shi yao xuan ze  vim_1"&gt;2. 为什么选择 Vim&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;程序猿界的 &lt;strong&gt;圣战：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt; vs &lt;strong&gt;Linux&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vim/Emacs&lt;/strong&gt; vs &lt;strong&gt;IDE&lt;/strong&gt; (&lt;strong&gt;Vim&lt;/strong&gt; vs &lt;strong&gt;Emacs&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt; vs &lt;strong&gt;JAVA&lt;/strong&gt; vs &lt;strong&gt;Python&lt;/strong&gt; vs ...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先是在 Vim 和 IDE 之间的争论。&lt;/p&gt;
&lt;h3 id="2.1. vim &amp;amp; ide"&gt;2.1. Vim &amp;amp; IDE&lt;/h3&gt;
&lt;p&gt;&amp;rdquo;到底是该选择 vim 还是 IDE ？&amp;ldquo; 在 Stackoverflow 和 知乎 上有非常多的这样的帖子。&lt;/p&gt;
&lt;p&gt;比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim"&gt;What is your most productive shortcut with Vim?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/21504638"&gt;为什么不少程序员极度推崇 Vim 和 Emacs，却对 IDE 嗤之以鼻？??&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总之，萝卜芹菜各有所爱，有 Geek 精神、喜欢折腾的人不用你去说服，他自然会去学习 Vim，没有心情、懒得折腾的人，你再怎么说 Vim 好，他也不会去尝试 。（是的，我就是喜欢折腾的人 ^_^）&lt;/p&gt;
&lt;p&gt;个人选择 Vim 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Vim 是 Linux 的 &amp;rdquo;标配&amp;ldquo; 编辑器，在 Linux 下开发，不会 Vim 的程序猿不是好程序猿&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还是因为 Linux 的原因。大多数 Linux 下的程序都是不需要界面的，终端才是 Linux 的精华，千万不要成迷于界面。在终端下，除了选择 Vim 你说还能选谁呢？ 因为 Vim 和 Linux 的 &amp;rdquo;血缘&amp;ldquo; 关系，终端 &amp;amp; Vim 给你纯正的 Linux 哲学体验（再说当你远程ssh登录时，总不能还用 IDE 吧？）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim 下有着高度的编码一致性体验。学会了 Vim，写不同语言不同代码的体验是一样的，妈妈再也不用担心我要花时间学习不同的 IDE 了~&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我写的代码基本只限定在底层开发，主要代码是 C/C++、Shell脚本、Python脚本，不会涉及到 JAVA，更不会涉及前端开发；而且都是我的 &amp;rdquo;玩具小程序&amp;ldquo;，几乎不涉及好几百个源文件的项目，所以我不需要 IDE 的强大的管理能力，写一个 makefile 就 OK 了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习过 CPU 知识的人都知道，频繁打断流水线才是最影响效率的东西。在调试代码的时候，显然纯键盘流要比不停的 &amp;rdquo;鼠标 -&amp;gt; 键盘 -&amp;gt; 鼠标 -&amp;gt; ...&amp;ldquo; 有效率的多，而且省事。&lt;a href="http://www.zhihu.com/question/22096642/answer/20290505"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;崇尚 Geek 文化，喜欢 &amp;rdquo;折腾&amp;ldquo;，Linux 哲学教导我要学习轻量级的 Vim，而不是笨重的 IDE 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2.2. vim &amp;amp; emacs"&gt;2.2. vim &amp;amp; emacs&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;来自 wiki 百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Editor_war"&gt;Editor war&lt;/a&gt; 是指两类文本编辑器 Vi（以及衍生版本） 和 Emacs 之间的争论，这已经成为 hacker 文化和自由软件社区文化的一部分 。&lt;/p&gt;
&lt;p&gt;因为他们都认为自己的选择是完美的，所以相互蔑视，相互之间争论（点燃战火）。相比其他的 IT 领域战争（如浏览器大战、操作系统之争、编程语言之争、代码缩进风格之战)，编辑器的选择其实通常只是个人问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;遵循&amp;ldquo;简单工具，多样组合&amp;rdquo;的理念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小，符合Unix哲学中的&amp;ldquo;只做一件事，并做好它&amp;rdquo;，避免了功能蔓延。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比Emacs快（至少历史上是这样的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可运行于任何实现了C标准库的系统之上，包括UNIX、Linux、AmigaOS、DOS、Windows、Mac、BeOS和POSIX兼容系统等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让&amp;ldquo;QWERTY&amp;rdquo;键盘用户将手指保持在默认键位上，使编辑时手指移动更少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更普及。基本上所有Unix和类Unix系统都默认提供了vi或其变体。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Emacs 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符合&amp;ldquo;厨房水槽&amp;rdquo;理念，提供了比 vi 更多的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移植最广泛的非试用计算机程序之一。它能在各种操作系统上运行，包括大多数类 Unix 系统（GNU/Linux、各种 BSD、Solaris、AIX、IRIX、AmigaOS、Mac OS X等）、MS-DOS、Microsoft Windows 和 OpenVMS。Unix 系统，无论自由版本或商业版本，均随系统提供 Emacs 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展和可定制（Lisp的变体 - Emacs Lisp）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;幽默&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Richard_Stallman"&gt;Richard Stallman&lt;/a&gt; 组建了 The Church of Emacs，它称 vi 为 &amp;ldquo;魔鬼的编辑器&amp;rdquo;（vi-vi-vi 在罗马数字中表示兽名数目）。然而它并不反对 vi；相反，它视私有软件为诅咒。（&amp;ldquo;使用自由版本的 vi 不是罪恶，而是赎罪。&amp;rdquo;）它还有专门的新闻组，alt.religion.emacs，发布主题宣扬这个滑稽的宗教。&lt;/p&gt;
&lt;p&gt;Stallman 曾称自己是St IGNU&amp;minus;cius，Emacs教会的圣人。&lt;/p&gt;
&lt;p&gt;vi支持者也成立了对立的 Cult of vi，较强硬的 Emacs 的用户攻击这是&amp;ldquo;抄袭他们的创意&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;关于vi的模式，一些 Emacs 用户说 vi 有两个模式 &amp;ndash; &amp;ldquo;不停地哔哔叫&amp;rdquo; 和 &amp;ldquo;搞砸一切&amp;rdquo;。vi 用户则指责 Emacs 的快捷键会引发 "腕管综合症"，或者拿 EMACS 这个缩写词作文章，比如 &amp;ldquo;Escape Meta Alt Control Shift&amp;rdquo;（攻击Emacs太依赖修改键）。一些人断定是代表 &amp;ldquo;Eight Megabytes And Constantly Swapping&amp;rdquo;（8 MB，还不断进行内存交换，过去这已经是很多内存了），或者 &amp;ldquo;EMACS Makes Any Computer Slow&amp;rdquo;（EMACS使一切计算机跑得慢，这是斯托曼惯用的递归缩写），讽刺Emacs对系统资源的高需求。&lt;/p&gt;
&lt;p&gt;针对 Emacs 的&amp;ldquo;功能蔓延&amp;rdquo;，vi 支持者认为 Emacs 是 &amp;ldquo;一个伟大的操作系统，只缺个体面的编辑器&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;UNIX 用户中流行一个游戏，考验一个 Emacs 用户对这个编辑器的理解深度，或者是拿 Emacs 的复杂性开玩笑，内容是：预测一下，如果一个用户按住修改键（比如 Control 或 Alt），然后键入自己的名字，会发生什么事。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="3. kai shi xue xi  vim_1"&gt;3. 开始学习 Vim&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;闲扯了这么多，终于开始学习 vim 了...&lt;/p&gt;
&lt;p&gt;结合我的痛苦的学习过程，至今还在痛苦ing，我觉得以下的学习顺序比较适合我这样的新手：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入门：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，在终端下输入 vimtutor 就能进入一个 vim 自带的教程，大概花半个小时的时间就能做完。完成以后基本上就可以说是可以使用这款 大(chou)名(ming)鼎(zhao)鼎(zhu) 的 &amp;rdquo;反人类&amp;ldquo;  的编辑器～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习 陈皓 大神在 &lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 的博客 &lt;a href="http://coolshell.cn/articles/5426.html"&gt;vim 练级攻略&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样，&lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 上介绍的一个关于 Vim 的游戏 &amp;mdash;&amp;mdash; &lt;a href="http://vim-adventures.com/"&gt;vim adventrue&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去图书馆借本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/3041178/"&gt;Learning the vi and Vim Editors&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阅读 Vim manpage 和 &lt;a href="https://github.com/asins/vimcdoc"&gt;安装 vim docs 中文版插件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/10599776/"&gt;Pratical Vim&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim 作者 Bram Moolenaar 的文档 &lt;em&gt;&lt;a href="http://www.moolenaar.net/habits.html"&gt;seven habits for effective text editing&lt;/a&gt;&lt;/em&gt;  和 &lt;a href="http://v.youku.com/v_show/id_XMTIwNDY5MjY4.html"&gt;演讲视频&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/"&gt;vi/vim使用进阶&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="4. can kao"&gt;4. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim_(text_editor)"&gt;Vim wikipedia&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Linux"></category><category term="Vim"></category></entry></feed>