<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Qian's Blog - IC</title><link href="https://qiangu.cool/" rel="alternate"></link><link href="https://qiangu.cool/feeds/ic.atom.xml" rel="self"></link><id>https://qiangu.cool/</id><updated>2020-11-22T14:51:00+08:00</updated><subtitle>Read &gt;&gt; Think &gt;&gt; Write</subtitle><entry><title>Patterson and Hennessy 学习笔记 #1 —— Chapter 1 Computer Abstractions and Technology</title><link href="https://qiangu.cool/posts/ic/learning_patterson_and_hennessy_notes_1_chapter_1.html" rel="alternate"></link><published>2020-11-22T14:51:00+08:00</published><updated>2020-11-22T14:51:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2020-11-22:/posts/ic/learning_patterson_and_hennessy_notes_1_chapter_1.html</id><summary type="html">&lt;p&gt;Patterson and Hennessy 读书笔记，前言 + 第一章&lt;/p&gt;</summary><content type="html">&lt;hr/&gt;
&lt;p&gt;写在前面的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Computer-Organization-Design-RISC-V-Architecture/dp/0128122757"&gt;Computer Organization and Design&lt;/a&gt; 俗称 Patterson and Hennessy&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Computer-Architecture-Quantitative-Approach-Kaufmann/dp/0128119055/"&gt;Computer Architecture: A Quantitative Approach&lt;/a&gt; 俗称 Hennessy and Patterson&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这两位大师和这两本计算机体系结构领域的圣经无需再赘述，这个系列是整理自以前的读书笔记，更新了一些 RISC-V 的相关内容，温故而知新。&lt;/p&gt;
&lt;p&gt;这两本书有共同内容但是因为定位不同，所以内容也相互补充。&lt;a href="https://www.amazon.com/Computer-Architecture-Quantitative-Approach-Kaufmann/dp/0128119055/"&gt;Computer Architecture: A Quantitative Approach&lt;/a&gt; 这本书是针对专业人士的，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用坚实的工程基础和量化的 cost/performance 折中分析方法来描述计算机体系结构中的主要原则&lt;/li&gt;
&lt;li&gt;基于商用的实际系统，结合例子和评测数据，总结出一些实际中的设计经验&lt;/li&gt;
&lt;li&gt;证明体系结构可以通过量化而不是描述性的方式学习&lt;/li&gt;
&lt;li&gt;目标读者是严肃的，想仔细理解计算机系统的专家&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 Patterson &amp;amp; Hennessy 这本书的读者并不是都想成为计算机体系结构的专家。这本书并不是前者的子集，还包括了一些其他知识，比如编译器、操作系统、数据库等等。作者的观点是：&lt;strong&gt;对于下一个十年内的大部分码农来说，如果想写出可以在并行计算机上高效运行的程序，则必须理解软硬件接口。&lt;/strong&gt;这本书的读者包括，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;几乎没有汇编 / 逻辑设计基础，但是需要理解基本的计算机组成原理&lt;/li&gt;
&lt;li&gt;有汇编 / 逻辑设计基础，但是想了解如何设计一个计算机，或者想理解一个系统是如何工作以及为何性能如此&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是第一章笔记的内容。&lt;/p&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;Civilization advances by extending the number of important operations which we can perform without thinking about them.&lt;/p&gt;
&lt;p&gt;-- Alfred North Whithead, An Introduction to Mathematics, 1911&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="understanding program performance"&gt;Understanding Program Performance&lt;/h2&gt;
&lt;p&gt;一个程序的性能取决于很多因素的组合，包括，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序用到的算法的效率&lt;/li&gt;
&lt;li&gt;把程序翻译成机器指令的软件工具&lt;/li&gt;
&lt;li&gt;计算机执行指令的效率（包括 I/O 操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下表总结了这些因素是如何影响程序性能的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件 / 硬件&lt;/th&gt;
&lt;th&gt;如何影响到性能&lt;/th&gt;
&lt;th&gt;哪一章会涉及到&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算法&lt;/td&gt;
&lt;td&gt;决定了源码级别的语句数量，I/O 操作的数量&lt;/td&gt;
&lt;td&gt;整本书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编程语言、编译器、架构&lt;/td&gt;
&lt;td&gt;决定了每句源码对应的计算机指令数量&lt;/td&gt;
&lt;td&gt;第 2, 3 章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理器、memory 系统&lt;/td&gt;
&lt;td&gt;决定了指令的执行速度&lt;/td&gt;
&lt;td&gt;第 4, 5, 6 章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O 系统（硬件 &amp;amp; 操作系统）&lt;/td&gt;
&lt;td&gt;决定了 I/O 操作的速度&lt;/td&gt;
&lt;td&gt;第 4, 5, 6 章&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;书里面以一个实例（矩阵和向量的乘法）来证明这些因素的影响，通过一系列的优化，例子的性能最终提高了大概 200 倍！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 3 章在 &lt;code&gt;data-level parallelism&lt;/code&gt; 层次，使用 C 语言的 intrinsics 可以使性能提高 3.8 倍&lt;/li&gt;
&lt;li&gt;第 4 章在 &lt;code&gt;instruction-level parallelism&lt;/code&gt; 层级，使用 loop unrolling 实现指令的多发射，乱序执行，可以使性能提高 2.3 倍&lt;/li&gt;
&lt;li&gt;第 5 章在 &lt;code&gt;memory hierarchy optimization&lt;/code&gt; 层次，使用 cache blocking 可以使性能提高 2.0 到 2.5 倍&lt;/li&gt;
&lt;li&gt;第 6 章在 &lt;code&gt;thread-level parallelism&lt;/code&gt; 层次，使用 parallel for loops in OpenMP 实现多核计算，可以使性能提高 4 到 14 倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="8 great ideas in computer architecture"&gt;8 Great Ideas in Computer Architecture&lt;/h2&gt;
&lt;p&gt;设计计算机系统中的 8 个最伟大的思想，从第一台计算机到现在，这些思想仍然被广泛采用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Design for Moore's Law&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;摩尔定律：电路的集成度每 18 ~ 24 个月翻一倍。&lt;/p&gt;
&lt;p&gt;Intel 的创始人之一 Gordon Moore 在 1965 年作出的预测。因为计算机的设计周期长达数年时间，很有可能项目结束时候的工艺和项目开始时相差非常大，所以设计者要预测未来技术的发展，不能对标当下的技术水平，防止做出来的时候 spec 已经落后了。&lt;/p&gt;
&lt;p&gt;从目前的趋势来看，由于物理技术的限制摩尔定律很有可能失效，Intel 也被大家戏称为牙膏厂。为了继续获得性能的提升，大家纷纷转向 ASIC 芯片，比如目前如火如荼的 AI 硬加速芯片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Use Abstraction to Simplify Desing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是硅农还是码农都要发明一些技术来提高自己的效率，否则由于摩尔定义，资源动不动翻倍会导致设计时间变得非常长。其中一个非常重要的技术就是在不同层次进行抽象，把底层的实现细节通过抽象隐藏起来，只提供一个高层的简单接口。&lt;/p&gt;
&lt;p&gt;通过抽象，顶层可以不关心底层的实现细节，只专注于自己的功能，抽象带来的 &amp;ldquo; 模块化设计 &amp;rdquo; 可以大幅提高效率。&lt;/p&gt;
&lt;p&gt;这个思想应用非常广泛，典型代表是 OSI 的参考模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Make the Common Case Fast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同领域的共同规律：common case 比 corner case 更重要，而且 common case 也比 corner case 更加容易提升性能。加速 common case 的前提是要知道什么是 common case，而这一点很多时候只有通过仔细的实验和分析才能确定。&lt;/p&gt;
&lt;p&gt;俗话常说 &amp;ldquo; 抓住主要矛盾 &amp;rdquo;，&amp;ldquo; 好钢用在刀刃上 &amp;rdquo;，这个思想就是要求我们能分清问题的主次，把大部分的精力投入到主要问题上，获得更高的全局收益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance via Parallelism&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显而易见，并行的性能更高。十个人搬转的速度当然比一个人更快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance via Pipelining&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流水线实际上是并行的一种，但是因为它实在是太重要，太基础了，在计算机系统中应用太广泛了，所以单独列出来。&lt;/p&gt;
&lt;p&gt;经典故事 &amp;ldquo; 汽车装配流水线 &amp;rdquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance via Prediction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，不一定非要等到完全确定之后再开始做一件事情，提前预测开始做往往获得的性能更高，前提是从错误中恢复的代价不高。&lt;/p&gt;
&lt;p&gt;典型代表：CPU 中的预测技术。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hierarchy of Memories&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码农一般都想要让 memory 尽可能的速度快、容量大、价格便宜，而这是矛盾的，硅农的解决方法是用 memories hierarchy 兼顾各个指标： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;L1 cache &amp;gt;&amp;gt; L2 cache &amp;gt;&amp;gt; L3 cache &amp;gt;&amp;gt; DDR &amp;gt;&amp;gt; Disk&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dependability via Redundancy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机不光要速度快，还要可靠。任何硬件都有可能出错，解决方法就是冗余。&lt;/p&gt;
&lt;p&gt;某些对可靠性要求非常高的应用系统都是通过冗余备份来提高可靠性，比如航天，大型服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;h3 id="defining performance"&gt;Defining Performance&lt;/h3&gt;
&lt;p&gt;套用知乎名言：&amp;ldquo; 先问是不是，再问为什么 &amp;rdquo;（狗头保命）。性能是一个很宽泛的问题，在仔细展开讨论之前必须先定义清楚一个问题：&lt;/p&gt;
&lt;p&gt;Q：计算机的性能是什么？&lt;/p&gt;
&lt;p&gt;因为计算机自身的类型多种多样（PC，server，embedded），它们使用了各种各样的技术来提升硬件性能；再加上软件的大小和复杂度也有区别，所以要确定计算机的性能是一个复杂的问题。书里面举例了一个 &amp;ldquo; 如何比较飞机性能 &amp;rdquo; 的问题，实际上下面三个问题是很类似的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定 / 比较 计算机的性能&lt;/li&gt;
&lt;li&gt;确定 / 比较 飞机的性能&lt;/li&gt;
&lt;li&gt;确定 / 比较 汽车的性能（更接地气）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;他们的共性就是评价标准是多维的，飞机 / 汽车有最大巡航里程、最快巡航速度、最大载客量等指标，计算机也有执行时间、典型功耗、体积（芯片的 PPA）等指标。下面我们做第一条约束，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们定义计算机的性能是一个时间的函数，也就是说我们并不关心其他因素（比如价格、体积等）。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;response time&lt;/code&gt; = &lt;code&gt;execution time&lt;/code&gt;：计算机完成一个任务的总时间，包括硬盘访问、内存访问、I/O 操作、操作系统开销、CPU 执行时间等等，一般 PC 和移动设备最关心这个指标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;throughput&lt;/code&gt; = &lt;code&gt;bandwidth&lt;/code&gt;：单位时间内完成的任务量。一般 servers 更关心这个指标&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以很多时候我们要根据类型来区分不同的计算机，对每个类型采用不同的 {performance matrics, applications} 的组合作为 benchmark。&lt;/p&gt;
&lt;p&gt;在接下来的前几章中我们主要关心的是 response time，对于这个指标，性能最大意味着 response time 最小，所以可以这么定义计算机的性能：&lt;/p&gt;
&lt;div class="math"&gt;$$Performance_X = \frac{1}{Execution\ time_X}$$&lt;/div&gt;
&lt;p&gt;在比较两个不同的计算机时，&amp;ldquo;X 比 Y 快 n 倍 &amp;rdquo; = &amp;ldquo;X 的速度是 Y 的 n 倍 &amp;rdquo; 指的是同一个意思，即&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{Performance_X}{Performance_Y} = n$$&lt;/div&gt;
&lt;p&gt;为了简单起见，统一使用 &amp;ldquo;X 的速度是 Y 的 n 倍 &amp;rdquo;（&lt;code&gt;as fast as&lt;/code&gt;）这种方式。因为 performance 和 execution time 是倒数关系，为了避免歧义，约定下面的描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;improve performance = increase performance&lt;/li&gt;
&lt;li&gt;improve execution time = decrease execution time&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="measuring performance"&gt;Measuring Performance&lt;/h3&gt;
&lt;p&gt;根据前面的讨论，我们把 time 作为 performance 的度量标准：完成等量的任务，花费时间最短的计算机的性能最高。但是即使把性能约束在时间这个维度上，依然不够明确，因为 &amp;ldquo; 时间 &amp;rdquo; 也有很多种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wall clock time&lt;/code&gt; = &lt;code&gt;response time&lt;/code&gt; = &lt;code&gt;elapsed time&lt;/code&gt;，表示完成任务的总时间，包含了所有因素&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CPU execution time&lt;/code&gt; = &lt;code&gt;CPU time&lt;/code&gt; = &lt;code&gt;user CPU time&lt;/code&gt; + &lt;code&gt;system CPU time&lt;/code&gt;，表示 CPU 在特定任务上花费的计算时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;user CPU time&lt;/code&gt;，表示 CPU 在这个程序本身上花费的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;system CPU time&lt;/code&gt;，表示 CPU 在这个程序相关的操作系统上花费的时间&lt;/li&gt;
&lt;li&gt;要区分这两个时间实际上是很困难的，因为很难明确定义操作系统的哪些活动是对应哪个特定程序的，而且不同的操作系统的功能也不相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了保持一致，使用下面的术语，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;system performance&lt;/code&gt; 指的是一个空载系统上的 &lt;code&gt;elapsed time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPU performance&lt;/code&gt; 指的是 &lt;code&gt;user time&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="the classic cpu performance equation"&gt;The Classic CPU Performance Equation&lt;/h3&gt;
&lt;p&gt;一个程序的执行时间 = 这个程序包含的 cycle 数 &amp;times; 每个 cycle 的时长，所以有下面的公式，&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ execution\ time = CPU\ clock\ cycles * clock\ cycle\ time\tag{1}$$&lt;/div&gt;
&lt;p&gt;其中一个程序包含的 cycle 数 = 包含的所有指令数 &amp;times; 平均每条指令的 cycle 数，即&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ clock\ cycles = Instructions * Average\ clock\ cycles\ per\ Instr\tag{2}$$&lt;/div&gt;
&lt;p&gt;这里涉及到一个非常重要的概念 &lt;code&gt;clock cycles per instruction&lt;/code&gt;，也简称为 &lt;strong&gt;&lt;code&gt;CPI&lt;/code&gt;&lt;/strong&gt;，表示执行一条指令花费的 cycle 数。因为不同的指令完成的任务不同，花费的时间也不同，所以 CPI 指的是所有指令的平均 cycle 数。有了 CPI， 两个使用相同 ISA 的不同计算机之间的比较就很容易了，因为它们的指令条数肯定是一样多的。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;CPI 不仅和具体的硬件实现有关，而且和程序也有关系，不同的程序用到的指令类型和数量必然是不相等的，算出来的平均数也不相等。&lt;/p&gt;
&lt;p&gt;CPI 实际上是有可能小于 1 的，所以有些人用 CPI 的倒数作为另外一个指标，&lt;code&gt;instructions per clock cycle&lt;/code&gt;，简称 &lt;code&gt;IPC&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;把公式 2 带入到公式 1 之中，就可以得到经典的 CPU 性能公式：&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ time = Instruction\ count * CPI * Clock\ cycle\ time\tag{3}$$&lt;/div&gt;
&lt;p&gt;也可以写成，&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ time = \frac{Instruction\ count * CPI}{Clock\ rate}\tag{4}$$&lt;/div&gt;
&lt;p&gt;这个公式其实就是下面公式，只不过给了每个元素一个新的定义，&lt;/p&gt;
&lt;div class="math"&gt;$$Time = \frac{Seconds}{Program} = \frac{Instructions}{Program} * \frac{Clock\ cycles}{Instruction} * \frac{Seconds}{Clock\ cycle}\tag{5}$$&lt;/div&gt;
&lt;p&gt;永远都要记住：&lt;strong&gt;只有 time 是最可靠的指标，其他子指标比如指令条数、CPI 等都不可靠。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下表列出了影响一个程序的 performance 的因素，以及具体的影响方式，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;硬件 / 软件&lt;/th&gt;
&lt;th&gt;影响到了什么&lt;/th&gt;
&lt;th&gt;如何影响的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算法&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI&lt;/td&gt;
&lt;td&gt;算法决定了一共有多少条指令和指令类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编程语言&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI&lt;/td&gt;
&lt;td&gt;不同的编程语言翻译出的指令数量和类型也不相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编译器&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI&lt;/td&gt;
&lt;td&gt;编译器是算法和底层指令之间的桥梁，必然会影响到具体的指令翻译&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISA&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI, clock rate&lt;/td&gt;
&lt;td&gt;ISA 对 3 个因素都有影响&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="the power wall_1"&gt;The Power Wall&lt;/h2&gt;
&lt;p&gt;功耗分为两部分：动态功耗、静态功耗。&lt;/p&gt;
&lt;p&gt;动态功耗可以通过公式算出来，&lt;/p&gt;
&lt;div class="math"&gt;$$Power \propto \frac{1}{2} * Capacitive\ load * Voltage^2 * Frequency\ switched\tag{6}$$&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;Frequency switched&lt;/code&gt; 是时钟频率的函数，&lt;code&gt;Capacitive load&lt;/code&gt; 是晶体管的 fanout 和工艺的函数。&lt;/p&gt;
&lt;p&gt;下图是 Intel X86 架构芯片 30 年间 8 代 CPU 的时钟频率和 power 关系图，&lt;/p&gt;
&lt;p&gt;&lt;img alt="power" src="/imges/patterson_and_hennessy/power.png"/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，随着时间发展，时钟频率提高了近 1000 倍，但是 power 只提高了大概 30 倍，原因就在于电压的不断降低。&lt;/p&gt;
&lt;p&gt;从前面 performance 的讨论可以知道，我们不能采用降低时钟频率的方式来降功耗，因为这会伤害到性能。那么我们可以无限降低电压吗？答案是不行，现在业界遇到的问题就是电压不能再低了，否则晶体管就像水龙头一样，无法完全关闭。虽然动态功耗是 CMOS 功耗中的大头，但是静态功耗也逐渐占据主角，在服务器中静态功耗能达到 40%，所以人们发明了各种技术来降低静态功耗，但是电压很难再进一步降低了。&lt;/p&gt;
&lt;p&gt;虽然有各种各样的昂贵技术来冷却芯片，但是继续提高功耗对于 PC（甚至是 servers）来说代价太高了，对移动设备就更不用说了，这就是所谓的功耗墙。&lt;/p&gt;
&lt;h2 id="the switch from uniprocessors to multiprocessors"&gt;The Switch from Uniprocessors to Multiprocessors&lt;/h2&gt;
&lt;p&gt;遇到了功耗墙怎么办？只能舍弃这 30 年来的老路线（提频），选择另外一条路线：多核。&lt;/p&gt;
&lt;p&gt;在过去，码农不需要改任何一行代码，就可以每 18 个月让自己的程序性能翻倍（摩尔定律），但是现在由于摩尔定律的失效，码农必须重新写他们的程序，以充分利用多个核。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;强制要求码农转换到显式的并行编程是一件高风险的事情（Intel 的安腾系列处理器）。但是，随着多核概念的普及，整个 IT 界已经接受了并行编程，码农们最终会转向显式的并行编程。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;为什么并行编程这么难推广呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编程困难，人的大脑更适合线性思维，很难处理并行的事情，编程也是同理&lt;/li&gt;
&lt;li&gt;调度困难，必须要减少核之间的通信和同步开销，防止这些额外的开销抵消并行带来的性能提升&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="fallacies and pitfalls"&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fallacies&lt;/code&gt; 谬论：错误概念&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pitfalls&lt;/code&gt; 陷阱：特定条件下成立的规律的错误推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;陷阱：期望局部的性能提升和整体性能成比例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;common case fast&lt;/code&gt; 思想对整体性能的提升效果取决于 common case 到底有多 common，典型例子就是 &lt;a href="https://en.wikipedia.org/wiki/Amdahl%27s_law"&gt;Amdahl's Law&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;假设一个程序运行时间是 100s，其中 80s 是乘法运算，那么应该把乘法运算的性能提高到原来的多少倍才能使总计算时间减小到 20s 呢？&lt;/p&gt;
&lt;p&gt;根据 Amdahl 定律，&lt;/p&gt;
&lt;div class="math"&gt;$$T^* = \frac{T_{improved}}{Amout\ of\ improve} + T_{unaffected}\tag{7}$$&lt;/div&gt;
&lt;p&gt;在这个例子里，有&lt;/p&gt;
&lt;div class="math"&gt;$$20 = \frac{80}{n} + 20$$&lt;/div&gt;
&lt;p&gt;可以知道实际上不可能达到 20s 的。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;CPU 性能计算公式和 Amdahl 定律是设计系统时候的常用工具。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;谬论：利用率低的计算机功耗也低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上 Google 的服务器上 10% 的负载消耗了 33% 的功耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：性能设计和能效设计是不相关的事情&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能量是功耗在时间上的积分，所以如果通过软硬件优化减少了程序的计算时间，就能同时降低功耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：把性能公式中的子集作为评价性能的标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面已经描述过，只有把 3 个因素都考虑进去，得到的性能结果才是可靠的，取其中任何一个、两个子指标都会导致不可靠的结果。比如，常用的 &lt;code&gt;MIPS(million instructions per second)&lt;/code&gt; 指标，&lt;/p&gt;
&lt;div class="math"&gt;$$MIPS = \frac{Instrcution\ count}{Execution\ time * 10^6}\tag{8}$$&lt;/div&gt;
&lt;p&gt;MIPS 描述的是指令执行速度，计算机越快相应的 MIPS 指标就越高。MIPS 指标非常容易理解，但是把它作为性能指标是有问题的，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只考虑了指令执行速度，但是没考虑指令的数量，对于不同 ISA 的计算机，不能直接比较它们的 MIPS&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使是同一台计算机，MIPS 值也会随着程序的不同而变化，没有固定值&lt;/p&gt;
&lt;p&gt;实际上，把公式 3 和公式 8 可以得到下面的公式，&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$MIPS = \frac{clock\ rate}{CPI * 10^6}$$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;因为 CPI 是个变化值，所以 MIPS 也是个变化值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个程序的指令数量变多，但是同时每条指令的执行速度变快，那么 MIPS 的值就完全不能反映出实际的真实性能&lt;/p&gt;
&lt;p&gt;比如下面这个例子，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;测量方式&lt;/th&gt;
&lt;th&gt;计算机 A&lt;/th&gt;
&lt;th&gt;计算机 B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;指令数&lt;/td&gt;
&lt;td&gt;10 billion&lt;/td&gt;
&lt;td&gt;8 billion&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;时钟频率&lt;/td&gt;
&lt;td&gt;4 GHz&lt;/td&gt;
&lt;td&gt;4 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPI&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;1.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以算出来 A 比 B 的 MIPS 指标高，但实际上 A 的性能比 B 差，MIPS 指标和真实情况背道而驰。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;h2 id="road map for this book"&gt;Road Map for This Book&lt;/h2&gt;
&lt;p&gt;计算机可以划分为经典的 5 部分：&lt;code&gt;datapath&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;, &lt;code&gt;memroy&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;，分别在后续几章介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;datapath&lt;/code&gt;：Chapter 3, Chapter 4, Chapter 6, Appendix B&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control&lt;/code&gt;：Chapter 4, Chapter 6, Appendix B&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory&lt;/code&gt;：Chapter 5&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Input&lt;/code&gt;：Chapter 5, Chapter 6&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ouptut&lt;/code&gt;：Chapter 5, Chapter 6&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="IC"></category><category term="Patterson and Hennessy"></category></entry><entry><title>FIFO 设计笔记</title><link href="https://qiangu.cool/posts/ic/fifo_design_notes.html" rel="alternate"></link><published>2015-10-02T22:13:00+08:00</published><updated>2015-10-02T22:13:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-10-02:/posts/ic/fifo_design_notes.html</id><summary type="html">&lt;p&gt;总结 FIFO 的注意事项&lt;/p&gt;</summary><content type="html">&lt;p&gt;FIFO 的重要性就不用再重复了，在笔试面试的时候也常常被问到，总结一下设计 FIFO 需要注意的问题。&lt;/p&gt;
&lt;p&gt;FIFO 可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Sync FIFO: write 和 read 使用同一个时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Async FIFO: write 和 read 分别使用两个时钟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计 FIFO 的时候，通常需要考虑的问题有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FIFO 的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO 空满的判断&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sync fifo"&gt;Sync FIFO&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Sync FIFO 的框图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync fifo" src="/images/fifo-design-notes/sync_fifo.png"/&gt;&lt;/p&gt;
&lt;p&gt;因为同步 FIFO 的读写速率是相同的，所以 FIFO 的大小设置不必考虑读写速率差这个因素，要简单很多。&lt;/p&gt;
&lt;p&gt;在 FIFO 内部，一般使用 dual port RAM 存储数据。双端口 RAM 有两套独立的读写地址，读地址和写地址分别由读指针和写指针来产生：写指针指向下一个数据被写入的地址，读指针指向下一个被读出的数据的地址，通过判断读写指针的相对大小，就可以得到 FIFO 的状态（full / empty）。&lt;/p&gt;
&lt;p&gt;还有另外一种方法来产生 full / empty 信号：FIFO 内部维护一个计数器，每次写入一个数据 cnt++，每次读出一个数据 cnt--。这种方法产生 full / empty 很简单：当 cnt == 0，表示 FIFO empty；当 cnt == max，表示 FIFO full。虽然这种方法产生 full / empty 很简单，但是需要额外的计数器，而且计数器的位宽随着 FIFO 的深度增加，不仅占用的资源更多，而且会降低 FIFO 最终可以达到的速度。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="async fifo"&gt;Async FIFO&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;一般异步 FIFO 的读写速率不同，如果写速度 &amp;gt; 读速度，则当数据量超过一定长度时，会出现溢出的情况，为了防止这种情况，可以采用两种措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;预先知道写速率和模式（burst / nonburst），最小的读速率，根据这些条件设置 FIFO 的深度&lt;/p&gt;
&lt;p&gt;通常发送端的数据都是突发的形式，FIFO 的深度至少要大于等于突发数据的最大长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;握手机制（full / empty）&lt;/p&gt;
&lt;p&gt;很多情况下，突发数据的长度和分布是预先不知道的，此时则无法确保 FIFO 的深度足够大，因此需要握手机制来告诉发送端已经没有多余的空地址保存数据 or 告诉接收端已经内部已经没有剩余的可以读取的数据。通常使用如下的 FSM 来实现：&lt;/p&gt;
&lt;p&gt;发送端，写数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt="wr fsm" src="/images/fifo-design-notes/wr_fsm.png"/&gt;&lt;/p&gt;
&lt;p&gt;接收端，读数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rd fsm" src="/images/fifo-design-notes/rd_fsm.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="gray code"&gt;Gray Code&lt;/h3&gt;
&lt;p&gt;在异步 FIFO 中，因为一些内部的信号要从写 / 读时钟域传递到读 / 写时钟域，所以必须要解决异步信号同步的问题，而且有的信号不止 1 bit，如果使用 &amp;ldquo; 同步桥 &amp;rdquo;，则因为各个 bit 的同步时延不一定（1~2T），所以不能用同步桥。&lt;/p&gt;
&lt;p&gt;这个问题可以使用 gray code 解决：gray code 是循环码，每次只有 1 bit 变化，这样就避免了多 bits 变化的数据同步问题。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync" src="/images/fifo-design-notes/sync.png"/&gt;&lt;/p&gt;
&lt;p&gt;gray code 与 binary code 的相互想换见另&lt;a href=""&gt;外一篇 blog&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="wr_ptr / rd_ptr sync lag"&gt;wr_ptr / rd_ptr Sync Lag&lt;/h3&gt;
&lt;p&gt;异步 FIFO 还有个问题是：地址信号跨时钟域时，可能会有 1T 的时延，这个多余的时延并不会导致 full /empty 错误置位，引起错误的 overf：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果地址信号传递到读时钟域时延时了 1T，此时接收端并不知道数据已经写入了 FIFO，仍然认为 FIFO 是空的，这种情况只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 underflow；&lt;/p&gt;
&lt;p&gt;如下图，先写满 FIFO，然后开始读：在 t6 时 FIFO 读空，empty = 1，在 t7 时，写入了一个新数据，此时 FIFO 内已经有有效数据了，但是 wr_ptr 同步到读时钟域要花费 2T，所以在 t9 时 empty = 0。有两个时钟周期（t7, t8） rd 被阻塞了，但是并不影响 FIFO 正常工作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="empty" src="/images/fifo-design-notes/empty.png"/&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="empty timing" src="/images/fifo-design-notes/empty_timing.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果地址信号传递到写时钟域时延是了 1T，此时发送端并不知道 FIFO 已经有空余地址了，仍然认为 FIFO 是满的，这种情况也是只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 overfl；&lt;/p&gt;
&lt;p&gt;如下图，先写满 FIFO，然后开始读：在 t5 时，full = 1，在 t6 时，读出了一个数据，此时 FIFO 已经有空余地址了，但是 rd_ptr 同步到写时钟域要花费 2T，所以在 t8 时 full = 0。有两个时钟周期（t6, t7） wr 被阻塞了，但是并不影响 FIFO 正常工作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="full" src="/images/fifo-design-notes/full.png"/&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="full timing" src="/images/fifo-design-notes/full_timing.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="full / empty generation"&gt;Full / Empty Generation&lt;/h3&gt;
&lt;p&gt;因为 wr_ptr 和 rd_ptr 相同时，FIFO 既可能是 full，也有可能是 empt，所以需要额外的 1 bit 来区别这两种情况：&lt;/p&gt;
&lt;p&gt;假设 FIFO 的深度是 8，则地址为 3 bits，初始时 wr_ptr 和 rd_ptr 都是 &lt;code&gt;0000&lt;/code&gt;，FIFO 此时是 empty：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当连续 8 个数据写入到 FIFO full，wr_ptr = &lt;code&gt;1000&lt;/code&gt;，而 rd_ptr = &lt;code&gt;0000&lt;/code&gt;，&lt;strong&gt;MSB 不同，剩余位相同&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当连续 8 次读取数据 FIFO empty，rd_ptr = wr_ptr = &lt;code&gt;1000&lt;/code&gt;，&lt;strong&gt;所有 bits 都相等&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;借助这多余的 1 bit，可以区分出是 wr_ptr 太快，将 rd_ptr 套圈了（wr_ptr = &lt;code&gt;1000&lt;/code&gt;，rd_ptr = &lt;code&gt;0000&lt;/code&gt;， 即 full），还是 rd_ptr 更快，追上了 wr_ptr（rd_ptr = wr_ptr = &lt;code&gt;1000&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="full empty gen" src="/images/fifo-design-notes/full_empty_gen.png"/&gt;&lt;/p&gt;
&lt;p&gt;这种 wr_ptr / rd_ptr 用 gray code 保存，比较 /+1 用 binary 保存的方式，使得 design / debug 变得很简单，但是需要的资源比较多。如果全部使用 gray code，虽然可以降低资源占用，但是需要其他逻辑。&lt;/p&gt;
&lt;h3 id="dual clock fifo design"&gt;Dual Clock FIFO Design&lt;/h3&gt;
&lt;p&gt;下图是使用 Dual port RAM 的异步 FIFO 框图，其中 wr_ptr 和 rd_ptr 直接使用 gray code，节省了 gray code 和 binary code 之间的转换逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img alt="dual clock fifo" src="/images/fifo-design-notes/dual_port_fifo.png"/&gt;&lt;/p&gt;
&lt;p&gt;和前面的逻辑类似，使用多 1 bit 来辅助区分 full / empt，不过因为改成用 gray code 来比较，所以稍有不同，下图显示了 FIFO 从 empty 到 full 再到 empty 的过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="full empty condition" src="/images/fifo-design-notes/full_empty_condition.png"/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FIFO empty&lt;/p&gt;
&lt;p&gt;当 wr_ptr = rd_ptr 时 FIFO empty&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO full&lt;/p&gt;
&lt;p&gt;如上图，FIFO 初始状态为 empty，然后连续写入 8 个数据，再读出 8 个数据，此时 wr_ptr = rd_ptr = 7，FIFO 又变为 empty。此时如果再写入一个数据，wr_ptr = 8，rd_ptr = 7，如果仍然使用前面介绍的方法（MSB 不同，剩余位相同 )，则会得出 FIFO full 的错误结论，实际上 FIFO 并没有满。&lt;/p&gt;
&lt;p&gt;仔细观察 gray code 的对称性，就可以知道，当 full 时（wr_ptr 将 rd_ptr 套圈时），MSB 不同，wr_ptr 的 2nd MSB 要先翻转，才和 rd_ptr 相同。所以，当下面 3 个条件都满足时，FIFO full：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;wr_ptr 和 rd_ptr 的 MSB 不相等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wr_ptr 的 2nd MSB 翻转后和 rd_ptr 的 2nd MSB 相等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;剩余 bits 全部相等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary_1"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;总结 FIFO 的设计，只要注意 FIFO 通过 wr_ptr 和 rd_ptr 得到 full / empty，而且使用 gray code 来跨时钟域，基本上就没问题了 :-D&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture: Design Methods and Techniques for Digital Circuits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1432020884&amp;amp;sr=1-1&amp;amp;keywords=advanced+fpga+design"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="FIFO"></category></entry><entry><title>低功耗设计</title><link href="https://qiangu.cool/posts/ic/low_power_design.html" rel="alternate"></link><published>2015-06-18T21:42:00+08:00</published><updated>2015-06-18T21:42:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-06-18:/posts/ic/low_power_design.html</id><summary type="html"></summary><content type="html">&lt;p&gt;在一些情况下，是不需要考虑低功耗设计的，但是更多的情况下，低功耗是必须考虑的，总结一下 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt; 中介绍的低功耗设计的方法。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="sources of power consumption"&gt;Sources of Power Consumption&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;首先，分析功耗的来源。&lt;/p&gt;
&lt;p&gt;功耗可以分为 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Inrush&lt;/p&gt;
&lt;p&gt;浪涌电流（Inrush current）也叫做启动电流（start-up current）。它指的是设备上电时产生的瞬间最大电流，这个值和设备有关。基于 SRAM 的 FPGA 有很大的浪涌电流，因为它需要从外部 ROM 中下载数据来配置内部逻辑资源，反之，基于 anti-fuse 的 FPGA 因为不需要上电配置，所以也就不存在浪涌电流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Static&lt;/p&gt;
&lt;p&gt;待机电流（Standby current）是指待机状态下的电流，由待机电流产生的功耗称为待机功耗（standby power），也就是静态功耗（static power）。静态功耗和浪涌功耗类似，也和器件的电气特性密切相关。（静态功耗包含了晶体管的漏电流导致的功耗）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamic&lt;/p&gt;
&lt;p&gt;动态功耗（Dynamic power）是门电路的逻辑值切换时产生的功耗。动态功耗可以从一个定义式中计算出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，ASIC 的总功耗定义为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Ptotal = Pdynamic + Pstatic&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，动态功耗占了主要部分，典型应用中，动态功耗占到总功耗的 80% 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="power reduction power reduction"&gt;Power Reduction Power Reduction&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;可以从系统的不同层次来降低功耗，下图展示了不同级别的不同技术，虽然可以在各个级别进行，但是在抽象层次越高的级别，得到的效果越有效，即在系统层（system level）和体系结构层（architecture level）进行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="level" src="/images/low-power-design/level.png"/&gt;&lt;/p&gt;
&lt;p&gt;下面一张表展示了各个级别对功耗降低程度的影响：&lt;/p&gt;
&lt;p&gt;&lt;img alt="opportunities" src="/images/low-power-design/opportunities.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下面分别从不同层次总结。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="system level"&gt;System Level&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="soc approach"&gt;SoC Approach&lt;/h3&gt;
&lt;p&gt;对于纳米级高端芯片，I/O 使用比芯片内核更高的电压，占到了总功耗的 50% 以上。如果有很多芯片的话，芯片之间的连线会消耗大量的功耗，所以就提出了 SoC，以缩减面积，降低成本。&lt;/p&gt;
&lt;h3 id="hw/sw partitioning"&gt;HW/SW Partitioning&lt;/h3&gt;
&lt;p&gt;相比于硬件，使用软件高级语言编程可以很方便的实现功能。但是，一些功能可以使用硬件来实现，来降低功耗。&lt;/p&gt;
&lt;p&gt;比如通信算法中有很多递归运算，实现递归的软件代码可能很少，但是这段只占代码量的 10% 的代码却花费了 90% 的执行时间，如果将这段代码使用硬件实现，就能够节约大量能源，显著降低功耗。&lt;/p&gt;
&lt;p&gt;常规的软硬件划分方法如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Partitioning" src="/images/low-power-design/partitioning.png"/&gt;&lt;/p&gt;
&lt;p&gt;典型的设计流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Specifications&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partitioning&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Synthesis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Integration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Co-Simulation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verification&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先，设计者根据规范和自身经验对系统性能做出推测，根据推测来决定系统哪部分用硬件实现，哪部分用软件实现。&lt;/p&gt;
&lt;p&gt;然后，对软硬件进行描述，硬件用 Verilog/VHDL，软件使用 C 。&lt;/p&gt;
&lt;p&gt;下一步对软硬件进行协同仿真，验证设计功能。如果不满足要求，则从系统划分开始重新再来。&lt;/p&gt;
&lt;h3 id="low power software"&gt;Low Power Software&lt;/h3&gt;
&lt;p&gt;软件设计部分也可以像硬件设计一样，在设计时就进行一些优化，得到更加绿色、高效的系统。&lt;/p&gt;
&lt;p&gt;比如，将下面的两个循环合并为一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;code1&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;code2&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为减少了循环计数器（初始化、递增、比较），所以循环指令数目就减少了。&lt;/p&gt;
&lt;h3 id="choice of processor"&gt;Choice of Processor&lt;/h3&gt;
&lt;p&gt;选择处理器会对整体功耗产生明显影响。（高级话题，以后再补）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="architecture level power reduction_1"&gt;Architecture Level Power Reduction&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="advanced clock gating"&gt;Advanced Clock Gating&lt;/h3&gt;
&lt;p&gt;同步设计中，时钟占据了整个动态功耗的绝大部分，在许多情况下都可以通过门控时钟将绝大多数不使用的电路关闭掉。&lt;/p&gt;
&lt;p&gt;门控时钟有如下的两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组合门控时钟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="combinational" src="/images/low-power-design/combinational.png"/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时序门控时钟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="sequential" src="/images/low-power-design/sequential.png"/&gt;&lt;/p&gt;
&lt;h3 id="dynamic voltage and frequency scaling (dvfs)"&gt;Dynamic Voltage and Frequency Scaling (DVFS)&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="cache based architecture"&gt;Cache Based Architecture&lt;/h3&gt;
&lt;p&gt;缓存一方面可以缓解内存和 CPU 之间速度的差异，还可以用来减少访问内存的次数，把需要频繁访问的数据保存在缓存中，可以使得计算能耗大量下降。&lt;/p&gt;
&lt;h3 id="log fft architecture"&gt;Log FFT Architecture&lt;/h3&gt;
&lt;p&gt;对于大规模运算的应用，使用对数系统（ logarithmic number system，LNS）比线性系统更好。LNS 在降低平均位元活跃度的同时用加法和奖罚实现乘除运算，使其效率比线性系统更高。&lt;/p&gt;
&lt;h3 id="asynchronous (clockless) design"&gt;Asynchronous (Clockless) Design&lt;/h3&gt;
&lt;p&gt;同步设计的时钟信号带来的问题很多，同时产生的功耗也很大，所以移除时钟是一个很有诱惑力的想法，这就是异步设计的基本意图，不过异步设计不是简单的移除时钟，仍然需要对电路进行某种控制。异步电路本质上进行自我控制，因此也成为自定时电路。&lt;/p&gt;
&lt;h3 id="power gating"&gt;Power Gating&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="multi-threshold voltage"&gt;Multi-threshold Voltage&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="multi-supply voltage"&gt;Multi-supply Voltage&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="gate memory power"&gt;Gate Memory Power&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="register transfer level (rtl) power reduction_1"&gt;Register Transfer Level (RTL) Power Reduction&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在大规模 ASIC 中，在 RTL 级完成时，至少 80% 的功耗已经确定了，后端流程无法解决所有的功耗问题，后端无法解决微架构、RTL 代码风格对动态和静态功耗的影响，所以在 RTL 阶段就要将功耗相关的问题一起解决。&lt;/p&gt;
&lt;h3 id="state machine encoding and decomposition"&gt;State Machine Encoding and Decomposition&lt;/h3&gt;
&lt;p&gt;在各种状态机编码类型中，格雷码是最符合低功耗设计的。因为格雷码相邻码之间只有一位翻转，所以消耗的能量最少。（格雷码是最优的，有个 条件就是状态机是按顺序跳转的，如果状态跳转的次序是不定的，那么格雷码的优势就不存在了）&lt;/p&gt;
&lt;p&gt;即使因为一些原因，没有使用格雷码，仍然可以通过降低翻转较多的状态的切换频率，来降低功耗。&lt;/p&gt;
&lt;p&gt;还有一种方法是将 FSM 进行分解为两个，两个小的 FSM 组合起来等效于原始的 FSM。当一个的 FSM 激活时，可以关闭另外一个 FSM，这样绝大多数时间内只需要给较小且更有效率的子 FSM 提供时钟，从而降低了功耗。&lt;/p&gt;
&lt;h3 id="binary number representation"&gt;Binary Number Representation&lt;/h3&gt;
&lt;p&gt;虽然在大多数应用中，补码比原码更方便，但是有些特殊应用中，在切换过程中原码更有优势。比如 0 和 -1 分别用原码和补码表示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Signed&lt;/span&gt; &lt;span class="n"&gt;Magnitude&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;00000000&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10000001&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;compliment&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;00000000&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;11111111&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当从 0 变为 1 时，原码只需要变化两位，而补码所有位都会变化。&lt;/p&gt;
&lt;h3 id="basic gated clock"&gt;Basic Gated Clock&lt;/h3&gt;
&lt;p&gt;门控时钟在 Architecture 部分已经说过了，这里从 RTL 的角度再重复一下。RTL 的代码风格会影响到最终的实现结果，所以应该在编写 RTL 的时候需要特别注意。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;bad&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;test_ff&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="s1"&gt;'b0;&lt;/span&gt;
&lt;span class="s1"&gt;    else&lt;/span&gt;
&lt;span class="s1"&gt;        test_ff &amp;lt;= test_next;&lt;/span&gt;
&lt;span class="s1"&gt;end&lt;/span&gt;

&lt;span class="s1"&gt;assign test_next = load_cond ? test_data : test_ff;&lt;/span&gt;

&lt;span class="s1"&gt;// good example&lt;/span&gt;
&lt;span class="s1"&gt;always @(posedge clk or negedge rst_n) begin&lt;/span&gt;
&lt;span class="s1"&gt;    if (!rst_n)&lt;/span&gt;
&lt;span class="s1"&gt;        test_ff &amp;lt;= 32'&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;load_cond&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;test_ff&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;test_data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="one hot encoded multiplexer"&gt;One Hot Encoded Multiplexer&lt;/h3&gt;
&lt;p&gt;Mux 的编码方案也可以采用独热码的方式，从而减少开关切换的数目，降低功耗。&lt;/p&gt;
&lt;h3 id="removing redundant transactions"&gt;Removing Redundant Transactions&lt;/h3&gt;
&lt;p&gt;有时候，一些没有意义的数据切换去掉，从而降低功耗。比如前级的逻辑产生一些数据，但是在后级逻辑中没有使用，这时候就可以修改设计，在前面一级就关闭，在需要数据的时候，让真正生成数据的电路工作。&lt;/p&gt;
&lt;h3 id="resource sharing"&gt;Resource Sharing&lt;/h3&gt;
&lt;p&gt;如果有一些相同的操作，那么可以使用资源共享的方法，避免运算逻辑重复出现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;bad&lt;/span&gt; &lt;span class="nt"&gt;example&lt;/span&gt;
&lt;span class="nt"&gt;always&lt;/span&gt; &lt;span class="o"&gt;@*&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;
    &lt;span class="nt"&gt;case&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;SEL&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b000: OUT = 1'&lt;/span&gt;&lt;span class="nt"&gt;b0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b001: OUT = 1'&lt;/span&gt;&lt;span class="nt"&gt;b1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b010: OUT = (value1 == value2);&lt;/span&gt;
&lt;span class="s1"&gt;        3'&lt;/span&gt;&lt;span class="nt"&gt;b011&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;OUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;value1&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nt"&gt;value2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b100: OUT = (value1 &amp;gt;= value2);&lt;/span&gt;
&lt;span class="s1"&gt;        3'&lt;/span&gt;&lt;span class="nt"&gt;b101&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;OUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;value1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nt"&gt;value2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b110: OUT = (value1 &amp;lt;  value2);&lt;/span&gt;
&lt;span class="s1"&gt;        3'&lt;/span&gt;&lt;span class="nt"&gt;b111&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;OUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;value1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  &lt;span class="nt"&gt;value2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;endcase&lt;/span&gt;
&lt;span class="nt"&gt;end&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;good&lt;/span&gt; &lt;span class="nt"&gt;example&lt;/span&gt;
&lt;span class="nt"&gt;assign&lt;/span&gt; &lt;span class="nt"&gt;cmp_equal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;value1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nt"&gt;value2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;assign&lt;/span&gt; &lt;span class="nt"&gt;cmp_greater&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;value1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;value2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="nt"&gt;always&lt;/span&gt; &lt;span class="o"&gt;@*&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;
    &lt;span class="nt"&gt;case&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;SEL&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b000: OUT = 1'&lt;/span&gt;&lt;span class="nt"&gt;b0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b001: OUT = 1'&lt;/span&gt;&lt;span class="nt"&gt;b1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b010: OUT = cmp_equal;&lt;/span&gt;
&lt;span class="s1"&gt;        3'&lt;/span&gt;&lt;span class="nt"&gt;b011&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;OUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nt"&gt;cmp_equal&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b100: OUT = (cmp_equal || cmp_greater);&lt;/span&gt;
&lt;span class="s1"&gt;        3'&lt;/span&gt;&lt;span class="nt"&gt;b101&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;OUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nt"&gt;cmp_greater&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;'b110: OUT = !cmp_equal &amp;amp;&amp;amp; !cmp_greater;&lt;/span&gt;
&lt;span class="s1"&gt;        3'&lt;/span&gt;&lt;span class="nt"&gt;b111&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;OUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;cmp_greater&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="nt"&gt;endcase&lt;/span&gt;
&lt;span class="nt"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="using ripple counters for low power"&gt;Using Ripple Counters for Low Power&lt;/h3&gt;
&lt;p&gt;行波计数器属于异步设计，会给时序分析，电路的可靠性带来很多问题。所以一般要避免使用的。不过在一些低速的应用中（比如数码管显示），仍然可以使用行波计数器来降低功耗。&lt;/p&gt;
&lt;h3 id="bus inversion"&gt;Bus Inversion&lt;/h3&gt;
&lt;p&gt;当总线上的当前数据和下一个数据之间的汉明距离大于 N/2 时（N 是总线宽度），就将下一个数据反向再传输。这样做可以降低总线上出现的转换次数，从而降低功耗。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bus" src="/images/low-power-design/bus_trans.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="transistor level power reduction_1"&gt;Transistor Level Power Reduction&lt;/h2&gt;
&lt;p&gt;寄存器级别的技术基本属于后端 &amp;amp; 微电子科学了，就不再总结了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category></entry><entry><title>流水线 pipeline 的艺术</title><link href="https://qiangu.cool/posts/ic/the_art_of_pipelining.html" rel="alternate"></link><published>2015-05-19T00:00:00+08:00</published><updated>2015-05-19T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-05-19:/posts/ic/the_art_of_pipelining.html</id><summary type="html">&lt;p&gt;总结流水线设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;PC 世界永恒不变的信条就是提高性能，其中一个方法就是提高系统的时钟频率。&lt;/p&gt;
&lt;p&gt;在另外一篇 blog &lt;a href="http://guqian110.github.io/pages/2015/03/18/static_timing_analysis_1_basic.html"&gt;静态时序分析 STA&lt;/a&gt; 中已经总结过了，限制系统最大工作频率的因素有很多，设计者能够控制的是 DFF 之间的组合逻辑的时延 Tcomb，降低最大时延路径（关键路径，critical path）的时延 Tcomb，就可以提高系统的工作频率。&lt;/p&gt;
&lt;p&gt;如何降低呢？方法就是流水线（pipeline）。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="pipeline intro"&gt;Pipeline Intro&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;所谓流水线（pipeline）设计，应该是从汽车工业中的 流水生产线 借鉴过来的说法吧。&lt;/p&gt;
&lt;p&gt;在汽车生产的时候，假设分为 5 个阶段，每个阶段都需要 1 个工人花费 1 小时完成，因为后续的阶段必须等前面阶段完成后才能进行，所以总共需要 5 个小时才能完成一辆汽车。但是采用流水线方式，在进行后续阶段时，前面的阶段可以进行新的工作，那么每个小时都可以生产出一辆汽车了，生产效率提高了 5 倍。&lt;/p&gt;
&lt;p&gt;可以看到，流水线之所以可以大大提高效率的原因在于：传统的方式，某个阶段进行时，其他阶段是空闲等待的，浪费时间；而流水方式中，在处理后续阶段时，前面的阶段可以进行新的加工，每时每刻，每个工人都是在工作的，这就是流水线能提高生产效率的原因。&lt;/p&gt;
&lt;p&gt;和汽车生产类似，组合逻辑路径可以看作是一条生产线，路径上的每个逻辑单元都可以看作是一个阶段，都会产生时延。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果不采用流水设计，前后级组合逻辑依次工作，那么这条路径的模型就是原始的生产线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果采用流水设计，那么前后级组合逻辑可以同时工作，就像新的生产线一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="a simple example"&gt;A Simple Example&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;采用流水设计的方法就是：&lt;strong&gt;在较长的组合逻辑路径中插入 DFF，将其分割为几个小的组合逻辑，新的 Tcomb 显然小于原来的 Tcomb，所以系统的时钟频率就可以提高了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例来说明：设计一个电路完成 i = (a + b + c + d) + (e + f + g + h) 运算。&lt;/p&gt;
&lt;p&gt;下面是没有流水的设计：&lt;/p&gt;
&lt;p&gt;&lt;img alt="no_pipe" src="/images/the-art-of-pipelining/no_pipeline.png"/&gt;&lt;/p&gt;
&lt;p&gt;可以计算出第一级 DFF 到第二级 DFF 之间数据路径的时延为 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Tff = Tco + Tcomb&lt;/span&gt;
&lt;span class="err"&gt;    = Tco + 3*Tadder&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是插入两级流水的设计：&lt;/p&gt;
&lt;p&gt;&lt;img alt="piple" src="/images/the-art-of-pipelining/pipeline.png"/&gt;&lt;/p&gt;
&lt;p&gt;现在相邻的两级 DFF 之间的组合逻辑只有 1 级加法器，而不是原来的 3 级，这时数据路径的时延为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Tff = Tco + Tcomb&lt;/span&gt;
&lt;span class="err"&gt;    = Tco + Tadder&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，采用流水后 Tff 更小，系统能够达到的工作时钟频率也就更高。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="performance increase from pipelining"&gt;Performance Increase from Pipelining&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;下面更加详细地分析一下流水带来的速度性能的提升。&lt;/p&gt;
&lt;p&gt;首先说明，可以使用系统的流量 throughout 和系统的时滞 latency 来衡量速度性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;throughout&lt;/code&gt;: 每个时钟周期处理的数据量，单位一般是 bps&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;latency&lt;/code&gt;: 数据输入到数据输出之间的时间，一般用 时钟周期的个数 来表示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示，两个 DFF 之间存在着大规模的组合逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img alt="before" src="/images/the-art-of-pipelining/before.png"/&gt;&lt;/p&gt;
&lt;p&gt;组合逻辑的时延决定了系统的最大工作频率（也即时钟周期 T 的最小值），此时&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;latency = Tcomb + Treg + Tclk               -- Eq1&lt;/span&gt;
&lt;span class="err"&gt;Tbefore = latency = Tcomb + Treg + Tclk     -- Eq2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 Treg 表示 DFF 带来的时延，Tclk 表示时钟的 skew 和 jitter 带来的时延。&lt;/p&gt;
&lt;p&gt;在使用流水之后，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="after" src="/images/the-art-of-pipelining/after.png"/&gt;&lt;/p&gt;
&lt;p&gt;此时，每个 stage 的周期为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Tstage = (Tcomb)stage + Treg + Tclk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而时延最大的那个 stage 决定了系统的最大工作频率（也即时钟周期 Tclk 的最小值），此时&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Tpipe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;max&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Treg&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Tclk&lt;/span&gt;

&lt;span class="n"&gt;latency&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Tpipe&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在理想状况下，各 stage 的时延应该相等，从而达到最小的 latency。即&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Tcombi = Tcomb / n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，最小的流水周期 Tpipe 为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;(Tpipe)min = Tcomb / n + Treg + Tclk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代入 latency 的表达式，有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;latency&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tpipe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;min&lt;/span&gt;
        &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Tcomb&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;-- Eq3&lt;/span&gt;

&lt;span class="n"&gt;Tafter&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Tpipe&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Tcomb&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Treg&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Tclk&lt;/span&gt;       &lt;span class="c1"&gt;-- Eq4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先比较系统的工作频率，或者 throughout（Eq2 和 Eq4）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Fafter / Fbefore = Tbefore / Tafter&lt;/span&gt;
&lt;span class="err"&gt;                 = (Tcomb + Treg + Tclk) / (Tcomb/n + Treg + Tclk)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然这个数 &amp;gt; 1，即&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: 系统的工作频率和 throughout 得到了提升。&lt;/p&gt;
&lt;p&gt;如果定义 k = (Treg + Tclk) / (Tcomb  + Treg + Tclk)，为 reg 和 clk 占的总周期的比例，则&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Fafter / Fbefore = 1 / [(1-k/n) + k]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次，比较 latency（Eq1 和 Eq3）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Lafter / Lbefore = [Tcomb + n(Treg + Tclk)] / (Tcomb + Treg + Tclk)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然这个数 &amp;gt; 1，即&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: 系统的 latency 增加了（增加的很小，近似可以忽略）。&lt;/p&gt;
&lt;p&gt;最后比较面积：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: 使用流水比不使用流水多使用了 n * m 个 DFF，还使用了更多的连线资源。&lt;/p&gt;
&lt;p&gt;综上，可以看到，虽然流水可以提高系统的工作频率和吞吐率，但是它付出的代价是面积和功耗的增加，这也是&lt;strong&gt;速度和面积之间相互转化&lt;/strong&gt;的体现。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="dxl instruction"&gt;DXL Instruction&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt; 中还介绍了 DXL 指令集的实现，简单记录一下笔记，详细过程还是看书吧。&lt;/p&gt;
&lt;p&gt;DXL 指令是 32 位的 RISC 微处理器，每条指令最多由 5 个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Instruction Fetch (IF)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instruction Decode/Register Fetch (ID)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execution/Effective address cycle (EX)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory access/branch completion cycle (MEM)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write Back Cycle (WB)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;非流水的方式实现如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl nopipe" src="/images/the-art-of-pipelining/dxl_nopipeline.png"/&gt;&lt;/p&gt;
&lt;p&gt;因为是非流水的方式，所以指令不能并行执行，必须等到前一条指令执行完之后才能开始执行下一条指令，如下图所示，假设每条指令需要 8 ns，那么执行 4 条指令总共需要 8 * 4 = 32 ns。&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl order1" src="/images/the-art-of-pipelining/dxl_order1.png"/&gt;&lt;/p&gt;
&lt;p&gt;采用流水的方式，在 5 级操作中都加上一个流水阶段（即每个阶段加入一组 DFF），实现如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl pipeline" src="/images/the-art-of-pipelining/dxl_pipeline.png"/&gt;&lt;/p&gt;
&lt;p&gt;因为是流水的方式，所以指令可以并行执行，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl order2" src="/images/the-art-of-pipelining/dxl_order2.png"/&gt;&lt;/p&gt;
&lt;p&gt;假设执行每条指令花费 10 ns，那么执行 5 条指令：&lt;/p&gt;
&lt;p&gt;非流水的方式总共花费 10 * 5 = 50 ns；流水的方式每条指令花费 5 个时钟周期，每个周期只有 2 ns，完成 5 条指令只需要 5 个时钟周期，总共花费 9 * 2 = 18 ns；性能是原来的 50/18 = 2.8 倍。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="pipelining principles"&gt;Pipelining Principles&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt; 还总结了流水需要注意的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所有的中间值必须在各周期锁存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能复用任何模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个阶段的所有操作必须在一个周期内完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冒险会给流水带来问题，冒险分为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;结构冒险，由于资源不够，无法同时支持所有指令同时执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据冒险，执行需要的中间数据还没有计算出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制冒险，分支点流水线和其他指令改变程序的计数器的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决以上问题的方法就是停止流水线直至风险解除，在流水线中插入多个 &amp;ldquo; 气泡 &amp;rdquo;（缺口）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="another example"&gt;Another Example&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;将前面总结的 &amp;ldquo; 在组合逻辑路径中插入 DFF，形成流水 &amp;rdquo; 的思路进一步扩展，可以得到更加上层的流水思想。&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1432020884&amp;amp;sr=1-1&amp;amp;keywords=advanced+fpga+design"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt; 中介绍了一个算法中使用流水的例子，其关键在于 &amp;ldquo; 拆开环路 &amp;rdquo;：&lt;/p&gt;
&lt;p&gt;假设要计算 x^3 这个值，下面这段软件的代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Xpower = 1;&lt;/span&gt;
&lt;span class="err"&gt;for (i = 0; i &amp;lt; 3; i++)&lt;/span&gt;
&lt;span class="err"&gt;    Xpower = X * Xpower;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将这段软件代码翻译成 Verilog 代码，重复使用相同的寄存器和计算资源，得到的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="iterative" src="/images/the-art-of-pipelining/iterative.png"/&gt;&lt;/p&gt;
&lt;p&gt;这种迭代的方法无法实现并行计算，其性能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Throughput = 8 /1, or 8 bits /clock&lt;/span&gt;
&lt;span class="err"&gt;Latency = 3 clocks&lt;/span&gt;
&lt;span class="err"&gt;Timing = One multiplier delay in the critical path&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而使用 pipeline 的方法&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// stage 1&lt;/span&gt;
&lt;span class="n"&gt;X1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Xpower1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// stage 2&lt;/span&gt;
&lt;span class="n"&gt;X2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;X1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Xpower2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;Xpower1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// stage 3&lt;/span&gt;
&lt;span class="n"&gt;Xpower&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;Xpower2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;得到的结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="pipeline" src="/images/the-art-of-pipelining/pipelined.png"/&gt;&lt;/p&gt;
&lt;p&gt;可以并行计算，其性能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Throughput = 8 bits / clock (assuming one new input per clock)&lt;/span&gt;
&lt;span class="err"&gt;Latency = Betw een one and two multiplier delays, 0 clocks&lt;/span&gt;
&lt;span class="err"&gt;Timing = Two multiplier delays in the critical path&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，throughout 的提升是以面积为代价的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1432020884&amp;amp;sr=1-1&amp;amp;keywords=advanced+fpga+design"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="pipeline"></category></entry><entry><title>Verilog HDL coding style</title><link href="https://qiangu.cool/posts/ic/verilog_hdl_coding_style_guide.html" rel="alternate"></link><published>2015-04-21T10:12:00+08:00</published><updated>2015-04-21T10:12:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-04-21:/posts/ic/verilog_hdl_coding_style_guide.html</id><summary type="html">&lt;p&gt;参考网上的资料和书籍，总结一份自己的 Coding Style Guide&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Update (2015/04/21):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考了网上流传的 华为 coding style guide 和 其他的一些资料，还有 &lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr_1_1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt; 的内容，重新整理一下自己的 Coding Style Guide，以便做项目的时候参考对比。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Version&lt;/strong&gt; : 2.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Date&lt;/strong&gt; : 2015-04-21&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Author&lt;/strong&gt; : Qian Gu (guqian110@gmail.com)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt; : This is a personal Verilog HDL coding style guide for designs on FPGA.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="goal"&gt;Goal&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;干干净净的代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码整洁、结构合理、层次清晰、注释明了、没有烂代码、没有冗余代码，合理地建立目录，合理地分配到不同文件中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下面分几个方面来总结，如何达到这样的目的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="module partition"&gt;Module Partition&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;把代码划分为 模块、函数、任务，形成合理的层次结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划分的原则：高内聚、低耦合&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般来说，每个模块、函数、任务完成一个功能，隐藏内部实现细节，提供一个干净的接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灵活掌握，不要划分出太多的模块，不必拘泥于 &amp;ldquo; 模块最好在 500 行左右 &amp;rdquo;（太多的实例和连线反而容易出错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低耦合的原则就是模块之间尽量用少的连线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提取公共代码、常用代码形成模块、函数、任务，便于使用和以后移植，有可能的话，参数化、通用化、IP 化（比如 CRC 计算、时钟分频、同步电路、通用 GPIO 控制等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;划分模块时，将相关组合逻辑划分到同一模块，以便综合时进行优化（一般工具不会越过模块边界来优化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在模块内部，合理切分逻辑，让相关代码组合在一起形成逻辑块，合理安排逻辑块的顺序，并且用固定长度的横线分割这些逻辑块，加以注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块内部不要存在重复的代码（子模块、函数、任务、循环语句、寄存器组、for/generate）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了减少修改内容、避免出错、移植方便、创建可重用模块，在编写代码的时候使用 define、parameter、localparam 定义可重定义的参数（如 SIZE、WIDTH、DEPTH 等）。如果可能，把所有 define 放在一个 definition.vh 中，编译时首先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="coding style"&gt;Coding Style&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;灵活合理地运用，才能设计出强壮的、简洁的代码，目标是可以清晰地表达出设计意图。&lt;/p&gt;
&lt;h3 id="part a"&gt;Part A&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计时把应用文档和设计文档写好，在设计文档中要把设计思路、数据通路、实现细节等描述清楚，在经过评审之后才能开始编写代码（磨刀不误砍柴工，节约时间，而且项目可控、可实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用可靠的 IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个模块放到一个单独的文件中，&amp;lt; 文件名 &amp;gt;=&amp;lt; 模块名 &amp;gt;.&amp;lt; 扩展名 &amp;gt;（很多小模块则可以放到一个文件中，便于管理，如 cell 库）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Top 模块只包含子模块的例化（即使有逻辑，也是简单的 glue 逻辑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照合理的层次结构组织各个模块，存放在合理的目录结构中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part b"&gt;Part B&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;避免书写可能导致竞争冲突（race condition）的语句（给仿真调试带来很大的麻烦）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免实例化具体的门级电路（可读性差、难于理解维护、不可移植）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免使用内部三态电路，使用 MUX 代替&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免任何器件的输入悬空（会导致很大的电流消耗）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免使用嵌入式的综合指令（synthesis directive）（仿真工具忽略这些指令，仿真和综合结果不一致）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免 Latch，避免无意中形成的 Latch（常规设计中，只有顶层模块的 clock_gate 会使用 latch，以节省功耗）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part c"&gt;Part C&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证时钟和复位信号没有 glitch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量保持时候总和复位信号的简单，不要使用复杂的组合逻辑（便于测试、后端生成时钟树和复位树）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量做到所有寄存器同时复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心使用门控时钟（Gated clock）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在模块内部产生时钟，最好使用同步设计，用 clock enable 来实现低频时钟操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在模块内部产生复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果确实要使用门控时钟、内部时钟、内部复位，把这些信号的代码放到一个独立的模块里，并在顶层模块例化这个独立模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个模块内尽量只使用一个时钟。多时钟设计中，时钟域隔离带逻辑（同步电路）放到一个独立的模块中
只使用时钟的一个沿（上升 or 下降）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对跨时钟域的信号要进行同步处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免多周期路径（multicycle_path）和假路径（false_path），一旦有这种路径，在代码和设计文档中标注写明
写可测性的设计（DFT, Design for Test）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part d"&gt;Part D&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于组合逻辑，使用 always @*&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意 "=" 和 "&amp;lt;="&lt;/p&gt;
&lt;p&gt;不要在一个 always 块中混杂使用两者&lt;/p&gt;
&lt;p&gt;组合逻辑，使用 "="&lt;/p&gt;
&lt;p&gt;时序逻辑，使用 "&amp;lt;="&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写合理的 FSM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无优先级的多路复用器使用 case，有优先级的多路复用器使用 if-else 或者是 ? :&lt;/p&gt;
&lt;p&gt;通常，case 的时序比 if-else 的时序好，优先级编码器只有在信号先后到来的时候才使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part e"&gt;Part E&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;模块的输入信号尽量用 DFF 先锁存再使用（若输入是其他的寄存器输出则不必）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块的输出信号尽量用 DFF 先锁存再输出（便于综合和 STA，处理起来简单，Timing 更好）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用端口名映射法进行模块实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明每一个用到的信号（若无声明，默认是 1 bit 的 wire）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计代码中，reg 只能在一个 always 中复制；验证代码无此要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计代码中，函数、任务不要使用全局变量；验证代码无此要求&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part f"&gt;Part F&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;`include 的文件名不要包含路径名（后期编译、综合、移植困难）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用 &lt;code&gt;define 做常数声明，把&lt;/code&gt;define 定义的参数放在一个独立的文件中，然后在模块头部 `include 这个文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;头文件保护&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有全局的，不会被修改的常量采用 define 定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用域只在一个模块内，使用 localparam 代替 `define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了模块可配置、可移植，使用 parameter&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part g"&gt;Part G&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用简洁的写法（可省略的 begin-end 省略不写）&lt;/p&gt;
&lt;p&gt;我看到有一些 coding style 中要求即使只有一条语句，if-else、case 等语句的 begin-end 也要写上，这样是为了方便以后添加代码，而且减少出错的机会。&lt;/p&gt;
&lt;p&gt;不过我更认同 Cummings 的观点：&lt;a href="http://www.sunburst-design.com/papers/Wheres_Waldo_Coding.pdf"&gt;The Sunburst Design - "Where's Waldo" Principle of Verilog Coding&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am a big fan of very concise coding. In general (but not always), the shorter the code,
the better. The more code I can see, nicely spaced and formatted on one page, the easier
it is to understand the intent of the design or verification code.&lt;/p&gt;
&lt;p&gt;I call this the "Where's Waldo" Principle based on the child puzzle-books of the same
name. Even though Waldo is dressed in a bright red and white stripped shirt, when he is
surrounded by enough additional clutter, he is hard to find. Just as Waldo is hard to find
when surrounded by clutter, simple RTL coding bugs can be obscured when surrounded
by poorly spaced and formatted RTL code and silly comments that state the obvious.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如下面这段 11 行、129 个字符的代码可以使用 3 行、57 个字符的代码代替：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// code1&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="c1"&gt;// end-if-begin&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="c1"&gt;// end-else-begin&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="c1"&gt;// end-always-begin&lt;/span&gt;

&lt;span class="c1"&gt;// code2&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="naming_1"&gt;Naming&lt;/h2&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;建立一套命名约定和缩略语清单，以文档的形式记录下来，严格遵守&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用有意义而且有效的名字，含义清楚、名副其实，避免含糊误导&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块名大写，所在文件名小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数、任务、信号、变量、端口名字用小写字母&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;`define、parameter、localparam、const、enum 用大写字母&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子模块的名字应该使用调用模块的名字作为前缀，如 emi、emi_ahb、emi_reg、emi_sram&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用协议定义的标准名字，根据需要在这些名字前附加前缀（模块名）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一信号的名字在各个子模块中保持一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入到同一个模块的连线用模块的名字作前缀（前缀比后缀更清晰）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每行定义一个信号，上面一行 / 同一行的尾部加上简短注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号名的定义顺序：控制信号、相应信号、数据信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词首字母缩写，大写。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;DMI&lt;/span&gt;     &lt;span class="c1"&gt;// Data Memory Interface&lt;/span&gt;
&lt;span class="n"&gt;DEC&lt;/span&gt;     &lt;span class="c1"&gt;// Decoder&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块间信号名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为两部分，第一部分表示信号方向，大写，第二部分表示信号意义，小写，下划线连接。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;CPUMMU_wr_req&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// write request form CPU to MMU&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块内命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词缩写，下划线连接，小写。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;sdram_wr_en&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// SDRAM write enable&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统级命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时钟信号、置位信号、复位信号等需要输送到各个模块的全局信号，以 &lt;code&gt;SYS_&lt;/code&gt; 前缀开头。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_clk_100MHz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// system clock&lt;/span&gt;
&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_set_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter set&lt;/span&gt;
&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;SYS_rst_cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// system counter reset&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;低电平有效信号命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;低电平有效信号加后缀 &lt;code&gt;_n&lt;/code&gt;，举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// low valid reset&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;经过锁存器的信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过锁存器的信号加后缀 &lt;code&gt;_r&lt;/code&gt;，以和锁存前区别。举例&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// latch input data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;parameter 全部大写，用 parameter 定义有实际意义的常数，比如 LED 亮灯状态、状态机状态等，避免 "magic number"。举例：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="mi"&gt;'d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="mi"&gt;'d1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;常用信号名缩写：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;acknowledge&lt;/td&gt;
&lt;td&gt;ack&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ready&lt;/td&gt;
&lt;td&gt;rdy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;adress&lt;/td&gt;
&lt;td&gt;addr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;enable&lt;/td&gt;
&lt;td&gt;en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;receive&lt;/td&gt;
&lt;td&gt;rx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arbiter&lt;/td&gt;
&lt;td&gt;arb&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;frame&lt;/td&gt;
&lt;td&gt;frm&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;req&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;check&lt;/td&gt;
&lt;td&gt;chk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;generate&lt;/td&gt;
&lt;td&gt;gen&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;resest&lt;/td&gt;
&lt;td&gt;rst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;clk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;grant&lt;/td&gt;
&lt;td&gt;gnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;segment&lt;/td&gt;
&lt;td&gt;seg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;cfg&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;increase&lt;/td&gt;
&lt;td&gt;inc&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;source&lt;/td&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;control&lt;/td&gt;
&lt;td&gt;ctrl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;statistic&lt;/td&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;counter&lt;/td&gt;
&lt;td&gt;cnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;switcher&lt;/td&gt;
&lt;td&gt;sf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data in&lt;/td&gt;
&lt;td&gt;din&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;timer&lt;/td&gt;
&lt;td&gt;tmr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data out&lt;/td&gt;
&lt;td&gt;dout&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;packet&lt;/td&gt;
&lt;td&gt;pkt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;tmporary&lt;/td&gt;
&lt;td&gt;tmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decode&lt;/td&gt;
&lt;td&gt;de&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;priority&lt;/td&gt;
&lt;td&gt;pri&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;transmit&lt;/td&gt;
&lt;td&gt;tx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decrease&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ptr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;valid&lt;/td&gt;
&lt;td&gt;vld&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delay&lt;/td&gt;
&lt;td&gt;dly&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;rd&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write enable&lt;/td&gt;
&lt;td&gt;wr_en&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable&lt;/td&gt;
&lt;td&gt;dis&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read enbale&lt;/td&gt;
&lt;td&gt;rd_en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;wr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="format"&gt;Format&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="poart declaration"&gt;Poart Declaration&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽量使用 Verilog-2001 标准，减少代码行，便于修改和删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每行只声明一个端口，这样可以在上面 / 后面添加简短注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明顺序：按照功能分组，分组前添加注释，分组之间空行分割，便于阅读&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在功能分组内，哪个信号最主控，哪个就最靠前。（控制信号、数据信号），顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;test_mode 信号，工作模式（=0）或 测试模式（=1）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使能信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据信号&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="module instantiate"&gt;Module Instantiate&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;例化名和模块名保持一致，加统一的前缀，如 u1_&lt;module_name&gt;、u2_&lt;module_name&gt;&lt;/module_name&gt;&lt;/module_name&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口名映射法，not 位置映射法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化端口顺序 = 模块端口声明顺序，不用的端口也列出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化&lt;em&gt;大模块&lt;/em&gt;时，每个端口占用一行，&lt;code&gt;.port_name&lt;/code&gt; 对齐，&lt;code&gt;.(signal_name)&lt;/code&gt; 也对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化&lt;em&gt;大量小模块&lt;/em&gt;时，可以多个端口放在同一行的紧凑形式（如大量 PAD 实例化）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="task &amp;amp; function"&gt;Task &amp;amp; Function&lt;/h3&gt;
&lt;p&gt;使用 C 语言的习惯，在合适的位置添加空格&lt;/p&gt;
&lt;h3 id="statement"&gt;Statement&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个语句单独成行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 always、for、while 语句，begin 最好在它们的下一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 initial、if、elseif、else 语句，begin 最好与它们同行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;end 占用单独一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个逻辑块内不加空行，表明它们之间的紧密关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同逻辑块之间添加空行，表明每个逻辑块实现不同的功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;7。 每行不多于 80 个字符，以提高可读性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;采用缩进，不要嵌套太深&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合理使用 tab （1 tab = 4 space）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="expression"&gt;Expression&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用括号表示优先级（括号有可能影响综合结果的情况不在此列）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双目、三目操作符左右空格，如 =、+、-、&amp;times;、/、%、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、&amp;amp;、&amp;amp;&amp;amp;、|| 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逗号 (,) 只在逗号后加空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分号 (;) 只在分号后加空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行尾不加空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上下行有关时，使用空格对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达式很长时，适当位置断行，使用空格对齐某些变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="comments"&gt;Comments&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件头，使用 doxverilog 注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在逻辑块、重要代码行的上方添加注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释简明扼要，足够说明设计意图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证注释和代码一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有效实用的注释格式，Doxygen&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;英文注释，标点后空一格，英文习惯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释复杂过程，列出要点和步骤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块开始要有模块级的注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块端口，简要注释，描述功能和有效电平&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊注释：note、warning、todo&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="lint"&gt;Lint&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编译时，打开 vcs 或 ncveriog 的 lint 检查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查编译的输出结果，Warning 可能导致仿真失败、综合失败，尽量修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否生成 latch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检测 always 敏感列表是否完全&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="appdidx_1"&gt;Appdidx&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;FSM 的模板&lt;a href="http://guqian110.github.io/pages/2014/06/05/fsm_design.html"&gt;另外一篇博客&lt;/a&gt;中已经总结过了。下面是一个简单的模块模板格式。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Module Declaration                                                            //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;MODULE_NAME&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;  &lt;span class="n"&gt;PARAM1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PARAM2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;
     &lt;span class="c1"&gt;//----------------------------------&lt;/span&gt;
     &lt;span class="c1"&gt;// Interface1&lt;/span&gt;
     &lt;span class="n"&gt;port_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c1"&gt;// comments&lt;/span&gt;
     &lt;span class="n"&gt;port_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="p"&gt;...&lt;/span&gt; 
     &lt;span class="c1"&gt;//----------------------------------&lt;/span&gt;
     &lt;span class="c1"&gt;// Interface2&lt;/span&gt;
     &lt;span class="n"&gt;port_n&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="k"&gt;localparam&lt;/span&gt;  &lt;span class="n"&gt;DIN&lt;/span&gt;     &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                &lt;span class="n"&gt;DOUTA&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;DOUTE&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;DOUTCTR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Main Body of Code                                                             //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;

    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// Instantiate sub module                                //&lt;/span&gt;
    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="n"&gt;MODULE_NAMW_A&lt;/span&gt; &lt;span class="n"&gt;U_MODULE_NAMW_A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;


    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// Some Logic                                            //&lt;/span&gt;
    &lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;

    &lt;span class="c1"&gt;//----------------------------------------&lt;/span&gt;
    &lt;span class="c1"&gt;// sequential logic&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// do something&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;//---------------------------------------&lt;/span&gt;
    &lt;span class="c1"&gt;// combinational logic&lt;/span&gt;
    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;wire_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wire_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</content><category term="IC"></category><category term="Verilog"></category><category term="coding style"></category></entry><entry><title>Verilog 项目配置</title><link href="https://qiangu.cool/posts/ic/verilog_project_setting.html" rel="alternate"></link><published>2015-04-20T00:00:00+08:00</published><updated>2015-04-20T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-04-20:/posts/ic/verilog_project_setting.html</id><summary type="html">&lt;p&gt;一份简单的 verilog 项目设置&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考书和网上的资料，自己总结的一个简单的项目设置，虽然实验室的项目和公司比起来很不规范，都是学生自己做的玩具类型的项目，但是聊胜于无，给自己一个参考。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="directory"&gt;Directory&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;分类存放文件，项目的目录结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;project&lt;/span&gt;
&lt;span class="err"&gt; |___ src             // 设计代码&lt;/span&gt;
&lt;span class="err"&gt; |     |___ header    // header file&lt;/span&gt;
&lt;span class="err"&gt; |     |___ module1   // module1.v&lt;/span&gt;
&lt;span class="err"&gt; |     |___ module2   // module2.v&lt;/span&gt;
&lt;span class="err"&gt; |     |___ ...&lt;/span&gt;
&lt;span class="err"&gt; |___ sim             // 验证代码&lt;/span&gt;
&lt;span class="err"&gt; |     |___ module1   // tb_module1.v&lt;/span&gt;
&lt;span class="err"&gt; |     |___ module2   // tb_module2.v&lt;/span&gt;
&lt;span class="err"&gt; |     |___ ...&lt;/span&gt;
&lt;span class="err"&gt; |___ vrf             // 编译、运行脚本&lt;/span&gt;
&lt;span class="err"&gt; |___ doc             // 文档&lt;/span&gt;
&lt;span class="err"&gt;       |___ html      // doxverilog 文档&lt;/span&gt;
&lt;span class="err"&gt;       |___ ref       // 设计参考文档&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="document"&gt;Document&lt;/h2&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;省略应用文档（Datasheet、SPEC）&lt;/p&gt;
&lt;p&gt;实验室的小项目，设计很简单，而且是自己用，就不需要应用文档了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计文档 &amp;mdash;&amp;mdash; doxverilog 生成&lt;/p&gt;
&lt;p&gt;最重要的文档，可以使用 doxverilog 生成。但是貌似 doxverilog 对 verilog 的支持实际上并不是非常好。结果勉强可以接受。&lt;/p&gt;
&lt;p&gt;除了常规的信息注释外，在源文件的注释中主要包含以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;模块需要的文件列表（子模块文件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块的功能描述&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块的端口描述（直接在 ASNI-C 风格的端口声明处注释）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块的参数配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意事项（&lt;code&gt;//% @note&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参考文档列表&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;</content><category term="IC"></category><category term="project setting"></category></entry><entry><title>时钟生成</title><link href="https://qiangu.cool/posts/ic/clock_generate_unit.html" rel="alternate"></link><published>2015-04-19T00:00:00+08:00</published><updated>2015-04-19T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-04-19:/posts/ic/clock_generate_unit.html</id><summary type="html">&lt;p&gt;总结时钟生成&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;&lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr_1_1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt; 时钟生成 笔记，内容基本上都是书上的内容，还有我自己的总结，混合在一起，就不加引用符号了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;如果说总线互连（Bus Matrix）是系统各骨架，CPU 是系统的大脑，那么时钟生成模块（CGM）就是系统的心脏，整个系统就是在时钟的脉搏下有序协调地工作。&lt;/p&gt;
&lt;p&gt;我们在设计时钟生成模块时，我们需要考虑下面这些问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;芯片需要多少时钟？它们之间的关系是同步到还是异步的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;芯片需要几个时钟源？时钟源是在芯片内还是芯片外？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要使用 PLL 吗？需要几个 PLL？PLL 最高工作频率是多少？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何分频生成各个模块所需要的时钟频率？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了节省功耗需要几种工作模式？它们之间如何切换？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试模式下如何处理时钟信号？综合时如何插入扫描链？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码如何编写才能方便后端做时钟树综合？后端如何做时钟树综合？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="clock"&gt;Clock&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;我们都知道，电路设计可以分为 &lt;strong&gt;同步设计&lt;/strong&gt; 和 &lt;strong&gt;异步设计&lt;/strong&gt; 两种，两者的优缺点就不再赘述。由于同步设计的一些优点，一般推荐使用同步设计，即使有异步信号，也将其转化为同步信号，来避免异步信号导致的问题。&lt;/p&gt;
&lt;p&gt;虽然同步电路有很多优点，但是它也有一些缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首要问题是 &lt;strong&gt;时序收敛问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是要保证所有的 flip-flop 的输入端和时钟端之间满足 setup/hold time 的要求，否则就会出现亚稳态，导致电路无法正常工作。&lt;/p&gt;
&lt;p&gt;不满足 setup time 的要求，可以通过降低工作频率的方法解决，但是不满足 hold time 时，芯片根本就无法工作。&lt;/p&gt;
&lt;p&gt;时序收敛点工作都是由 EDA 工具自动完成的，我们只要设置合理的时间约束，综合及布局布线工具就可以实现时钟平衡，时序分析工具就可以检查电路是否满足时序收敛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，对时钟信号要求高&lt;/p&gt;
&lt;p&gt;同步设计的基础是时钟信号。关于时钟信号，另外一篇博客 &lt;a href="http://guqian110.github.io/pages/2015/03/18/static_timing_analysis_1_basic.html"&gt;静态时序分析 STA 1 &amp;mdash;&amp;mdash; 基础知识&lt;/a&gt; 有一些总结，比如时钟偏斜 skew、时钟抖动 jitter、占空比失真 Duty Cycle Distortion。&lt;/p&gt;
&lt;p&gt;时钟偏斜 skew 的解决方法是采用 EDA 工具进行时钟树综合，它的原理就是按照时钟树的最大长度去平衡其他的时钟路径。但是这种方法会引入大量延迟单元的插入，使得电路的面积和功耗大大增加。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="design principle"&gt;Design Principle&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;下面是设计时钟生成模块（CGM）时要遵守的一些原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CGM 要独立于系统的其他模块，其他模块所使用的时钟都要从 CGM 中引出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CGM 要有很好的层次结构，既便于前端定义时钟和分析时序，又便于后端做时钟树综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了调整性能和功耗，CGM 应该支持分频器和停时钟，而且软件能灵活控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在时钟切换和启停时钟时，一定不能出现毛刺，否则电路不能正常工作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="clock divider"&gt;Clock Divider&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在一个系统中，各个模块可能需要不同的工作频率，这就需要通过 PLL 把时钟源的频率提高到高频，然后通过不同的分频器为每个模块分出不同的工作频率。&lt;/p&gt;
&lt;p&gt;以前总结一篇关于 &lt;a href="http://guqian110.github.io/pages/2014/10/13/clock_dividers.html"&gt;时钟分频器&lt;/a&gt; 的博客。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="clock switch"&gt;Clock Switch&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;有时候，我们需要在模块运行的过程中切换时钟，切换时钟最简单的方法就是使用 MUX。但是这种方法会造成毛刺（glitch）。如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;clk_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;clk_b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="n"&gt;out_clk&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;clk_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;out_clk&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;clk_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;书上提供了一个通用的没有 glitch 的时钟切换模块，支持多个时钟的切换，其中 select 信号必须使用 one-hot 编码。（代码略 ...）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="clock generation"&gt;Clock Generation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;有了上面的基础，就可以设计时钟生成模块了。书里面以一个 时钟切换 + 时钟分频 的组合来说明如何设计。&lt;/p&gt;
&lt;p&gt;书后面一章还提供了一个实际项目中的 CGM 的设计文档，以供参考。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr_1_1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock generate unit"></category></entry><entry><title>可配置设计</title><link href="https://qiangu.cool/posts/ic/configurable_design.html" rel="alternate"></link><published>2015-04-17T00:00:00+08:00</published><updated>2015-04-17T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-04-17:/posts/ic/configurable_design.html</id><summary type="html">&lt;p&gt;总结可配置设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr_1_1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt; 的可配置设计一章 学习笔记。&lt;/p&gt;
&lt;h2 id="configurable design"&gt;Configurable design&lt;/h2&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;我们做设计的时候，就要考虑做成可以灵活配置的设计，不管是小模块，还是大模块，这样便于以后维护和移植。可配置模块的设计方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 parameter 和 `define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 for 语句生成多条语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 generate、for、if 等语句生成多条语句和多个实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过工具或脚本生成配置参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过工具或脚本直接生成 Verilog 代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;书里面总结了上面的这些方法，以前总结过另外一篇博客：&lt;a href="http://guqian110.github.io/pages/2014/07/09/parameterization_modeling_in_veriog.html"&gt;Verilog 中的参数化建模&lt;/a&gt;，里面总结了 条件编译、`define、parameter、localparam 的用法和区别。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Reuse-Methodology-Manual-System-Designs/dp/0387740988"&gt;Reuse Methodology Manual for System-on-a-Chip Designs&lt;/a&gt; 是一本很经典的书，里面有全面详细的可重用设计的方法，有时间了看了再补上。&lt;/p&gt;
&lt;p&gt;下面是一些实际例子，展示如何设计可配置模块。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="gray-2-binary"&gt;Gray-2-Binary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Binary 编码是最自然的、最符合平常的思维的，但是这种编码方式有时候存在一些问题：比如在 DAC 中，数字 3(011) 变为 数字 4(100) 时，每 1 bit 都发生了变化，电路中会产生很大的尖峰电流脉冲。&lt;/p&gt;
&lt;p&gt;而 Gray 编码就没有这样的问题，Gray 码有很多优点，应用很广泛，就不再重复了。（比如在 FIFO 设计中，内部就有 Gray 和 Binary 的相互转换）&lt;/p&gt;
&lt;p&gt;下面的例子，通过&lt;strong&gt;将端口位宽参数化&lt;/strong&gt;，实现了可配置的转换模块：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example1:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;#verilog&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gray2bin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE-1 : 0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE-1 : 0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;generate&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;genvar&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="nc"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE-1 : i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;endgenerate&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;#verilog&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bin2gray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE-1 : 0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE-1 : 0&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE-1 : 1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="crc"&gt;CRC&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Cyclic Redundancy Check，循环冗余检测。不同的协议使用的 CRC 多项式不相同，在硬件上体现在 LSR 的宽度和抽头位置不同，我们可以写一个通用的 CRC 模块。&lt;/p&gt;
&lt;p&gt;下面的例子，通过&lt;strong&gt;将端口位宽参数化&lt;/strong&gt;，实现了可配置的 CRC 模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example2&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;general_crc&lt;/span&gt;
    &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;  &lt;span class="n"&gt;WIDTH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WIDTH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;INIT_VALUE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WIDTH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;CRC_EQUATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;                          &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="k"&gt;input&lt;/span&gt;                          &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="k"&gt;input&lt;/span&gt;                          &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;       &lt;span class="c1"&gt;// if init = 1, initialize crc_value &lt;/span&gt;
                                                &lt;span class="c1"&gt;// with INIT_VALUE&lt;/span&gt;
     &lt;span class="k"&gt;input&lt;/span&gt;                          &lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;     &lt;span class="c1"&gt;// if enbale = 1, calculate crc_value&lt;/span&gt;
                                                &lt;span class="c1"&gt;// from din&lt;/span&gt;
     &lt;span class="k"&gt;input&lt;/span&gt;                          &lt;span class="n"&gt;drain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;      &lt;span class="c1"&gt;// if drain = 1, crc_value is  shifted&lt;/span&gt;
                                                &lt;span class="c1"&gt;// out from dout&lt;/span&gt;
     &lt;span class="k"&gt;input&lt;/span&gt;                          &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="k"&gt;output&lt;/span&gt;                         &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
     &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WIDTH&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;crc_value&lt;/span&gt;   &lt;span class="c1"&gt;// parallel out crc_value&lt;/span&gt;
     &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// implementation code&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在调用时，通过传递合适的参数即可实现不同的 CRC 模块。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="fifo controller"&gt;FIFO controller&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;略 ...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ram wrapper"&gt;RAM wrapper&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="problem"&gt;problem&lt;/h3&gt;
&lt;p&gt;FPGA 中的 RAM/ROM 是用厂家的工具生成的，而 ASIC 中的 RAM/ROM 是用 ARM 公司的 Memory Compiler 生成的，两者的端口名不一样，有些控制信号的极性也不相同。&lt;/p&gt;
&lt;p&gt;通常的做法是&lt;strong&gt;使用条件编译&lt;/strong&gt;，写如下的代码&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="no"&gt;`ifdef&lt;/span&gt;  &lt;span class="n"&gt;FPGA&lt;/span&gt;
    &lt;span class="c1"&gt;// instantiate module for FPGA&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// instantiate module for ASIC&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这种方法的缺点主要有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;但内部有几十个到上百个 RAM/ROM 时，手动连接的工作量很大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;做 ATPG 时，手工写代码很容易出错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;做 BIST 测试时，需要添加额外的逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外一种更好的方法是 &lt;strong&gt;写 wrapper&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="wrapper"&gt;wrapper&lt;/h3&gt;
&lt;h4 id="name"&gt;name&lt;/h4&gt;
&lt;p&gt;命名规范：按照 ARM 公司的规范，&lt;/p&gt;
&lt;p&gt;RAM/ROM type:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;little/large&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Ports&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Comments&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RF1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;little&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;single&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RA1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;large&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;single&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RF2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;little&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;dual&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;one read port &amp;amp; one write port&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RA2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;large&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;dual&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;two read port &amp;amp; two write port&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ROM&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;single&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RAM/ROM write enable (WEN) type:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;IW&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;bit-write-enable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BW&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;byte-write-enable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WW&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;word-write-enable&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;命名时按照 &lt;code&gt;&amp;lt;ram_type&amp;gt;_&amp;lt;wen_type&amp;gt;_&amp;lt;depth&amp;gt;x&amp;lt;width&amp;gt;&lt;/code&gt; 的规则，在 FPGA 上则加上前缀 &lt;code&gt;F_&lt;/code&gt;，即：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F_&amp;lt;ram_type&amp;gt;_&amp;lt;wen_type&amp;gt;_&amp;lt;depth&amp;gt;x&amp;lt;width&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;F_RA1_BW_2kx32：RA1 类型，支持 byte 写，4 个 WEN，深度为 2k，宽度为 32-bit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;F_RF1_IW_128x8：RF1 类型，支持 bit 写，8 个 WEN，深度为 129，宽度为 8-bit&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="generate wrapper"&gt;generate wrapper&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提前写好的 Perl 脚本 和 参数化模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据实际需求，写配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 Perl 脚本，读取配置文件，生成 wrapper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将生成的 wrapper 加入到 project 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个步骤的具体实现方法以后再补 ...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="gpio_2"&gt;GPIO&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;运用模块化的设计思想，提取公共代码，设计子模块，通过子模块实现大模块的设计，虽然参数化以后 GPIO 看起来比较复杂，但是这个模块是很通用的，设计好之后只需要修改参数就可以重复使用了。这在设计期间，修改起来非常方便。&lt;/p&gt;
&lt;p&gt;整个 GPIO 由 5  个模块组成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;gpio.v (module gpio)&lt;/span&gt;
&lt;span class="err"&gt; |___gpio_params.v (parameters define)&lt;/span&gt;
&lt;span class="err"&gt; |___gpio_reg.v    (module gpio_reg)&lt;/span&gt;
&lt;span class="err"&gt; |___gpio_check.v  (module gpio_check)&lt;/span&gt;
&lt;span class="err"&gt; |___gpio_sync.v   (module gpio_sync2_reg/gpio_sync3_reg/gpio_sync_pulse)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体代码略，直接看书&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="busmatrix"&gt;BusMatrix&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="andes core n801"&gt;Andes Core N801&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="arm926ejs"&gt;ARM926EJS&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="coreconsultant"&gt;coreConsultant&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr_1_1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="configurable design"></category></entry><entry><title>Verilog 的 case 小结</title><link href="https://qiangu.cool/posts/ic/summary_of_case_in_verilog.html" rel="alternate"></link><published>2015-04-15T15:50:00+08:00</published><updated>2015-04-15T15:50:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-04-15:/posts/ic/summary_of_case_in_verilog.html</id><summary type="html">&lt;p&gt;总结 case 的用法和需要注意的细节&lt;/p&gt;</summary><content type="html">&lt;p&gt;学习了 Cummings 大神 的 paper：&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase.pdf"&gt;"full_case parallel_case", the Evil Twins of Verilog Synthesis&lt;/a&gt; 和 &lt;a href="http://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=38848"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结一下笔记。&lt;/p&gt;
&lt;h2 id="def"&gt;Def&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="syntax:"&gt;Syntax:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;case (case_expression)&lt;/span&gt;
&lt;span class="err"&gt; case_item1 : case_item_statement1;&lt;/span&gt;
&lt;span class="err"&gt; case_item2 : case_item_statement2;&lt;/span&gt;
&lt;span class="err"&gt; case_item3 : case_item_statement3;&lt;/span&gt;
&lt;span class="err"&gt; case_item4 : case_item_statement4;&lt;/span&gt;
&lt;span class="err"&gt; default : case_item_statement5;&lt;/span&gt;
&lt;span class="err"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;if (case_expression === case_item1) case_item_statement1;&lt;/span&gt;
&lt;span class="err"&gt;else if (case_expression === case_item2) case_item_statement2;&lt;/span&gt;
&lt;span class="err"&gt;else if (case_expression === case_item3) case_item_statement3;&lt;/span&gt;
&lt;span class="err"&gt;else if (case_expression === case_item4) case_item_statement4;&lt;/span&gt;
&lt;span class="err"&gt;else                                     case_item_statement5;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先说明一些基本名词的定义：&lt;/p&gt;
&lt;h3 id="case statement header"&gt;Case statement header&lt;/h3&gt;
&lt;p&gt;header 由 关键字 &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;casex&lt;/code&gt;/&lt;code&gt;casez&lt;/code&gt; + case expression 两部分组成，它们通常写在同一行（上面语法的第一行）。添加 "parallel_case" 或者 "full_case" 综合指令的方法就是把指令当作注释写在 header 的那一行，后续 case item 之前。&lt;/p&gt;
&lt;h3 id="case expression"&gt;Case expression&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;case&lt;/code&gt; 关键字之后，括号中间的内容。它可以是一个常量（如 '1'），也可以是一个表达式，或者更常见的一个 1 bit / n bits 的向量，用来和后面的 case item 做比较。&lt;/p&gt;
&lt;h3 id="case item"&gt;Case item&lt;/h3&gt;
&lt;p&gt;可以是单比特、向量、表达式，用来和 case expression 做比较。和高级编程语言（C 语言）不同的是，verilog 中的 case 自带隐含的 &lt;code&gt;break&lt;/code&gt; 语句，所以就不用再费心多写代码了。&lt;/p&gt;
&lt;h3 id="case item statement"&gt;Case item statement&lt;/h3&gt;
&lt;p&gt;case item 内的语句，多于 1 句时，要用 &lt;code&gt;begin-end&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="case default"&gt;Case default&lt;/h3&gt;
&lt;p&gt;默认分支，虽然这个分支不是强制要求的，但是在所有分支后面加上 default 分支是一个良好的编程习惯。&lt;/p&gt;
&lt;h3 id="casez"&gt;Casez&lt;/h3&gt;
&lt;p&gt;case 语句的变种，casez 把 expression 或者是 item 中的 "z"/"?" 忽略，当作不关心的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Exercise caution when coding synthesizable models using the Verilog casez statement&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coding Style Guideline:&lt;/strong&gt; When coding a case statement with "don't cares," use a casez statement
and use "?" characters instead of "z" characters in the case items to indicate "don't care" bits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="casex"&gt;casex&lt;/h3&gt;
&lt;p&gt;类似于 casez，不关心的值为 "z" / "?" / "x"。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Do not use casex for synthesizable code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="process"&gt;Process&lt;/h3&gt;
&lt;p&gt;case 的执行过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算 case expression，只计算一次，然后按照代码顺序从上向下和 case item 逐个比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较过程中，如果有 default 分支，则暂时先忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有某个 item 和 expression 匹配，则执行此 item 下的语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果匹配失败，有 default 分支，则执行该 default 分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果匹配失败，没有 default 分支，则终止&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个按照顺序比较的过程就是可能导致 priority encoder 的原因。&lt;/p&gt;
&lt;h3 id="reverse case"&gt;reverse case&lt;/h3&gt;
&lt;p&gt;reverse case 是 case 的一个变形，也叫做 &lt;code&gt;case if true&lt;/code&gt;。这种风格中 case expression 是一个常量，而 case items 是由变量构成的表达式。这种风格通常用在 One-hot FSM 中，并且采用 parallel 方式。&lt;/p&gt;
&lt;p&gt;见另外一篇博客：&lt;a href="http://guqian110.github.io/pages/2014/06/05/fsm_design.html"&gt;有限状态机设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;下面讨论 full_case 和 parallel_case 的相关问题。很多人都会使用这两个综合指令，他们的理由是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;"full_case parallel_case" makes my designs smaller and faster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"full_case" removes latches from my designs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"parallel_case" removes large, slow priority encoders from my designs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而这些理由都不够准确或者说是危险的，因为这两个综合指令有时候完全不影响设计，有时候反而会使设计速度变慢、面积变大，有时候甚至会改变设计的功能。&lt;strong&gt;通常，这些指令都很危险。&lt;/strong&gt; 所以，Cummings 给他的 paper 起了如下的别名 ...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An alternate title for this paper could be: "How to add $200,000 to the cost and 3-6 months to the schedule of your ASIC design without trying!"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id='"full" case statement_1'&gt;"full" case statement&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;"full" 的意思就是 expression 的任何取值都有一个 item/default 分支与其对应，否者就不是 "full case"。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example1: Non-"full" case&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;mux3a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在这个例子中，当 sel 的取值是 2'b11 时，由于没有定义输出值 y 为多少，仿真器会保持之前的取值，综合器会综合出一个 latch。&lt;/p&gt;
&lt;p&gt;（基于 Virtex-4 器件，XST 的 synthesis report 给出的结果是 1 bit latch + 1 bit 3-to-1 multiplexers）&lt;/p&gt;
&lt;h3 id="hdl full case"&gt;HDL full case&lt;/h3&gt;
&lt;p&gt;从 HDL 仿真器的角度看，full case 语句就是 case item 包含了 expression 可以取的任何值。&lt;/p&gt;
&lt;h3 id="synthesis full case"&gt;Synthesis full case&lt;/h3&gt;
&lt;p&gt;从综合工具的角度看，full case 语句就是 expression 的每种可能的取值组合都被包含在 item 中。&lt;/p&gt;
&lt;p&gt;虽然 Verilog 语法不要求 case 语句必须是 HDL full 或者 synthesis full ，但是我们可以通过手动添加一个 default 分支来使得 case 变为 full。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example2: "full" case&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;mux3a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;'&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在这个例子中，因为有了 default 分支，所以它是一个 full case。在仿真时，如果 sel 是 2'b11，那么 y 取值为 x（不确定，unknown），而综合器会把 x 当作 &amp;ldquo; 不关心 &amp;rdquo;（don't care，有可能为 1，也有可能为 0）。这就导致了仿真和综合不一致。解决这个问题的方法就是给 y 赋值一个常数 or 像其他 item 一样赋值一个输入。&lt;/p&gt;
&lt;p&gt;（基于 Virtex-4 器件，XST 的 synthesis report 给出的结果是 1 bit 3-to-1 multiplexers）&lt;/p&gt;
&lt;p&gt;P.S. 我们可以利用前后仿真不同这一点来帮助我们调试。在设计 FSM 时，default 分支处，next_state 赋值为 x，这样如果存在错误转换，next_state 就会保持为 x，在波形上很方便看到。&lt;/p&gt;
&lt;p&gt;还有一种方法是在所有的 item 之前，给输出赋一个默认值，这样即使不是 full，也不会产生 latch：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="xst full case"&gt;XST full case&lt;/h3&gt;
&lt;p&gt;综合指令是一些特殊的可以被综合工具识别，并指导综合工具工作的语句。不同的综合工具的综合指令语法不相同。我用的是 ISE 自带的 XST。查看 XST User Guide 就可以找到 full case 的相关指令：&lt;/p&gt;
&lt;p&gt;这个指令与架构（Architecture）无关、只适用于 verilog 的 case 语句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只对 Verilog 有效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识所有的取值都被包含在 item 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻止 XST 对那些没有被包含的情况生成额外的电路&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这个指令的方法有很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Verilog Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;(* full_case *)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 case header 的上面一行&lt;/p&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;// synthesis full_case&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式，注释必须在 case header 的同一行&lt;/p&gt;
&lt;p&gt;example3:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;(* full_case *)&lt;/span&gt;
&lt;span class="n"&gt;casex&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;rsquo;&lt;/span&gt;&lt;span class="n"&gt;b1xxx&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;rsquo;&lt;/span&gt;&lt;span class="n"&gt;bx1xx&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;rsquo;&lt;/span&gt;&lt;span class="n"&gt;bxx1x&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="err"&gt;&amp;rsquo;&lt;/span&gt;&lt;span class="n"&gt;bxxx1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;example4:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;casex select // synthesis full_case&lt;/span&gt;
&lt;span class="err"&gt;    4&amp;rsquo;b1xxx: res = data1;&lt;/span&gt;
&lt;span class="err"&gt;    4&amp;rsquo;bx1xx: res = data2;&lt;/span&gt;
&lt;span class="err"&gt;    4&amp;rsquo;bxx1x: res = data3;&lt;/span&gt;
&lt;span class="err"&gt;    4&amp;rsquo;bxxx1: res = data4;&lt;/span&gt;
&lt;span class="err"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST Command Line&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;xst run -vlgcase [full|parallel|full-parallel]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISE Design Suit&lt;/p&gt;
&lt;p&gt;Process &amp;gt; Process Properties &amp;gt; Synthesis Options &amp;gt; Full Case.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 XST User Guide 中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XST automatically determines the characteristics of the case statements and generates
logic using multiplexers, priority encoders, and latches that best implement the exact
behavior of the case statement.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，如果我们不添加综合指令，XST 会根据代码自动判断，选择 MUX、priority encoder、latch 来生成最合适的实现电路。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果生成 MUX，那么 synthesis report 在 Macro Recognition 步骤中会给出 MUX  macro 的内容&lt;/p&gt;
&lt;p&gt;注意，XST 是否会把 case 推译成 MUX，还取决于器件。对于 LUT4-based 器件，如果输入端口是 4 个，输出是 1 个，那么就会推译出 MUX；对于 LUT6-based 的器件，如 Virtex-5，那么需要输入端口是 8 个以上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果生成 Latch，那么 synthesis report 会给出 warning（只要生成 latch，不管是设计有意还是设计失误无意产生的，都会给出 warning，毕竟 latch 是很容易导致错误的）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如上面的例子，如果改成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;always @* begin;&lt;/span&gt;
&lt;span class="err"&gt;    (* full_case *)&lt;/span&gt;
&lt;span class="err"&gt;    case (sel)&lt;/span&gt;
&lt;span class="err"&gt;        2'b00: y = a;&lt;/span&gt;
&lt;span class="err"&gt;        2'b01: y = b;&lt;/span&gt;
&lt;span class="err"&gt;        2'b10: y = c;&lt;/span&gt;
&lt;span class="err"&gt;    endcase&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;always @* begin&lt;/span&gt;
&lt;span class="err"&gt;    case (sel)  // synthesis full_case&lt;/span&gt;
&lt;span class="err"&gt;        2'b00: y = a;&lt;/span&gt;
&lt;span class="err"&gt;        2'b01: y = b;&lt;/span&gt;
&lt;span class="err"&gt;        2'b10: y = c;&lt;/span&gt;
&lt;span class="err"&gt;    endcase&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么就只会生成 1 bit 3-to-1 multiplexers，不会有多余的 latch。&lt;/p&gt;
&lt;p&gt;虽然这些指令有好处，但是一定要谨慎使用，而且使用时需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这些综合指令只对综合工具有用，仿真工具会自动忽略这些指令，所以有可能造成前后仿真不一致的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有时候使用指令，会适得其反，导致结果面积变大、速度变慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般有迷信的说法：&amp;ldquo; 使用 full case 指令，可以消除 latch。&amp;rdquo; 这个说法太绝对了，事实上并不总是这样。如果有多个输出需要赋值，而有些分支只忽略了一些赋值，那么即使使用 full_case 指令，也不能避免 latch 的产生。&lt;/p&gt;
&lt;p&gt;举例，在下面的例子中，仍然会产生 latch&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;always @* begin&lt;/span&gt;
&lt;span class="err"&gt;    casez (sel) // synthesis full_case&lt;/span&gt;
&lt;span class="err"&gt;        3'b100: y1 = 3'b100;&lt;/span&gt;
&lt;span class="err"&gt;        3'b010: y1 = 3'b010;&lt;/span&gt;
&lt;span class="err"&gt;        3'b001: y2 = 3'b001;&lt;/span&gt;
&lt;span class="err"&gt;    endcase&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们使用 full case 指令的目的就是为了避免生成意外的 latch，但是这种方法有以上的各种弊端。其实还有一种更加简单的方法来避免 latch，就是前面说的，&lt;strong&gt;在 case 前，给所有的输出赋一个默认值。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id='"parallel" case statement_1'&gt;"parallel" case statement&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;"parallel" 的意思就是 expression 的取值每次有且只有一个 item 与其对应，否则就不是 "parallel" case，而匹配的 items 称为 "overlapping" case items。&lt;/p&gt;
&lt;h3 id="non-parallel case statements"&gt;Non-parallel case statements&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;always @sel begin&lt;/span&gt;
&lt;span class="err"&gt;    casez (sel)&lt;/span&gt;
&lt;span class="err"&gt;        3'b1??: y = 3'b100;&lt;/span&gt;
&lt;span class="err"&gt;        3'b?1?: y = 3'b010;&lt;/span&gt;
&lt;span class="err"&gt;        3'b??1: y = 3'b001;&lt;/span&gt;
&lt;span class="err"&gt;    endcase&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当输入是 3'b011, 3'b101, 3'b110, 3'b111 时，会有多个 item 与 expression 对应，所以不是 parallel 的，会综合出一个 priority encoder。&lt;/p&gt;
&lt;h3 id="parallel case statements"&gt;Parallel case statements&lt;/h3&gt;
&lt;p&gt;对上面的例子稍微修改一下，就得到了 parallel case：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;always @sel begin&lt;/span&gt;
&lt;span class="err"&gt;    casez (sel)&lt;/span&gt;
&lt;span class="err"&gt;        3'b1??: y1 = 1'b1;&lt;/span&gt;
&lt;span class="err"&gt;        3'b01?: y2 = 1'b1;&lt;/span&gt;
&lt;span class="err"&gt;        3'b001: y3 = 1'b1;&lt;/span&gt;
&lt;span class="err"&gt;    endcase&lt;/span&gt;
&lt;span class="err"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="xst parallel case"&gt;XST parallel case&lt;/h3&gt;
&lt;p&gt;语法同 full case，只需要将 full_case 替换为 parallel_case 即可。如果 case 本来就是 parallel 的，那么这个指令就完全不起作用，只是一些额外的代码。&lt;/p&gt;
&lt;p&gt;不要故意使用 Non-parallel case 来推译 priority encoder，这是不好的编程习惯。如果我们的目的就是要生成 priority encoder，应该使用级联的 if-else 语句，这样更能表达意图。&lt;/p&gt;
&lt;p&gt;下面的这些 guideline 可以帮助我们避免 case 生成 priority encoder，从而避免前后仿真不一致：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Code all intentional priority encoders using if-else-if statements. It is easier for a typical design engineer to recognize a priority encoder when it is coded as an if-else-if statement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Case statements can be used to create tabular coded parallel logic. Coding with case statements is recommended when a truth-table-like structure makes the Verilog code more concise and readable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Examine all synthesis tool case-statement reports &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Change the case statement code, as outlined in the above coding guidelines, whenever the synthesis tool reports that the case statement is not parallel (whenever the synthesis tool reports "no" for "parallel_case")&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="synthesis coding styles_1"&gt;Synthesis coding styles&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在总结了 full_parallel_case 之后，Cummings 大神给出了建议：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sunburst Design Assumption: it is generally a bad coding practice to give the synthesis tool
different information about the functionality of a design than is given to the simulator.&lt;/p&gt;
&lt;p&gt;Guideline: In general, do not use "full_case parallel_case" directives with any Verilog case
statements.&lt;/p&gt;
&lt;p&gt;Guideline: There are exceptions to the above guideline but you better know what you're doing if
you plan to add "full_case parallel_case" directives to your Verilog code.&lt;/p&gt;
&lt;p&gt;Guideline: Educate (or fire) any employee or consultant that routinely adds "full_case
parallel_case" to all case statements in their Verilog code, especially if the project involves the
design of medical diagnostic equipment, medical implants, or detonation logic for thermonuclear
devices!&lt;/p&gt;
&lt;p&gt;Guideline: only use full_case parallel_case to optimize onehot FSM designs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;甚至建议要开除写 full_parallel_case 的员工 ...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;总结一下所有的 guidelines：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Exercise caution when coding synthesizable models using the Verilog casez statement&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Do not use casex for synthesizable code&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; In general, do not use "full_case parallel_case" directives with any Verilog case
statements.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; There are exceptions to the above guideline but you better know what you're doing if you plan to add "full_case parallel_case" directives to your Verilog code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Code all intentional priority encoders using if-else-if statements. It is easier for a typical design engineer to recognize a priority encoder when it is coded as an if-else-if statement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Coding with case statements is recommended when a truth-table-like structure makes the Verilog code more concise and readable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Examine all synthesis tool case-statement reports.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Change the case statement code, as outlined in the above coding guidelines, whenever the synthesis tool reports that the case statement is not parallel (whenever the synthesis tool reports "no" for "parallel_case").&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; only use full_case parallel_case to optimize onehot FSM designs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coding Style Guideline:&lt;/strong&gt; When coding a case statement with "don't cares," use a casez statement and use "?" characters instead of "z" characters in the case items to indicate "don't care" bits.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Educate (or fire) any employee or consultant that routinely adds "full_case parallel_case" to all case statements in their Verilog code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; "full_case" and "parallel_case" directives are most dangerous when they work! It is better to code a full and parallel case statement than it is to use directives to make up for poor coding practices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase.pdf"&gt;"full_case parallel_case", the Evil Twins of Verilog Synthesis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.phei.com.cn/module/goods/wssd_content.jsp?bookid=38848"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="case"></category></entry><entry><title>静态时序分析 STA 2 —— Xilinx STA</title><link href="https://qiangu.cool/posts/ic/static_timing_analysis_2_xilinx_sta.html" rel="alternate"></link><published>2015-03-22T00:00:00+08:00</published><updated>2015-03-22T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-03-22:/posts/ic/static_timing_analysis_2_xilinx_sta.html</id><summary type="html">&lt;p&gt;总结 Xilinx 时序约束的一些基本内容&lt;/p&gt;</summary><content type="html">&lt;p&gt;*&lt;em&gt;总结 Xilinx 时序约束的一些基本内容，基本上是 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_2/ug612.pdf"&gt;UG612 Timing Closure User Guide&lt;/a&gt; 的翻译和概括。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;P.S. 找到一篇 Xilinx 的文章，也很简洁实用：&lt;a href="http://china.xilinx.com/china/xcell/xl37/e10-14.pdf"&gt;赛灵思 FPGA 设计时序约束指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="xilinx sta"&gt;Xilinx STA&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;按照路径所覆盖的范围，可以将时序路径要求分为 4 大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Input paths&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Register-to-register paths&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Output paths&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Path specific exceptions&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;添加约束最有效的方法就是先添加全局约束，然后根据需求考虑是否添加指定路径上的特殊约束。在很多案例中，只需要添加全局约束就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FPGA 器件执行工具都是由指定的时序要求驱动的。如果时序约束过头的话，就会导致内存使用增加，工具运行时间增加。更重要的是，过约束还会导致性能下降。因此，推荐使用实际设计要求的约束值。&lt;/p&gt;
&lt;p&gt;下面分别讨论每种路径上的约束。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="input paths"&gt;Input paths&lt;/h2&gt;
&lt;p&gt;所谓 &amp;ldquo; 输入路径 &lt;code&gt;input paths&lt;/code&gt;&amp;rdquo;，指的是从 &amp;ldquo;FPGA 外部引脚 ---&amp;gt; 内部读取这个数的寄存器 &amp;rdquo; 之间的路径。&lt;/p&gt;
&lt;p&gt;在输入路径模型中，发送端是一个外部设备（当然也可以是 FPGA），接收端是 FPGA 芯片，输入路径讨论的就是以接收端的 FPGA 为视角，如何正确接收输入的数据。&lt;/p&gt;
&lt;p&gt;依据接口类型，可以将输入路径的时序分为 2 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;System Synchronous Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Source Synchronous Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而对于输入路径的约束方法就是使用 &lt;code&gt;OFFSET IN&lt;/code&gt; 来约束，它约束了 输入数据 和 用于捕获这个数据的时钟沿 之间的关系。（顾名思义，输入路径约束的是方向为 IN 的数据和时钟的相对偏移 OFFSET 的关系）&lt;/p&gt;
&lt;p&gt;下面分别对两类输入路径进行讨论：&lt;/p&gt;
&lt;h3 id="system synchronous inputs"&gt;System Synchronous Inputs&lt;/h3&gt;
&lt;p&gt;所谓 System Synchronous Inputs 其实就是指 &amp;ldquo; 发送端 和 接收端 使用同一个系统（system）时钟 &amp;rdquo;。布线延时和时钟倾斜会限制这种接口的工作时钟频率，由于这个原因，这种接口一般应用在 SDR 中。&lt;/p&gt;
&lt;p&gt;system synchronous SDR 应用示例如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="system synchronous SDR" src="/images/static-timing-analysis-2-xilinx-sta/system_synchronous_in_sdr.png"/&gt;&lt;/p&gt;
&lt;p&gt;其时序为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发送器件在某个时钟的上升沿将数据发送出去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FPGA 在下一个时钟的上升沿捕获到数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于这种接口的时序，使用 &lt;code&gt;OFFSET IN&lt;/code&gt; 是最有效方便的添加约束的方法。对于接口中的每个时钟，都有一个对应的 offset in 约束，这个约束覆盖了所有的使用该时钟来捕获输入数据的路径。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加约束的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先对接口的时钟添加周期约束（period constraint）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 其次为接口添加全局 offset in 约束（global Offset In）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;OFFSET = IN value VALID value BEFORE clock;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OFFSET=IN &lt;value&gt; 约束了数据变有效的沿和时钟的捕获数据的沿之间的距离&lt;/value&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VALID &lt;value&gt; 约束了数据保持有效的时间长度&lt;/value&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 1. 在下面理想的 system synchronous SDR interface 时序图中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example1" src="/images/static-timing-analysis-2-xilinx-sta/example1.png"/&gt;&lt;/p&gt;
&lt;p&gt;数据在时钟沿的前 5 ns 变为有效，并且保持了 5 ns 时间，所以在这个实例中的时序约束应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "SysClk" TNM_NET = "SysClk";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_SysClk" = PERIOD "SysClk" 5 ns HIGH 50%;&lt;/span&gt;
&lt;span class="err"&gt;OFFSET = IN 5 ns VALID 5 ns BEFORE "SysClk";&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而且这个约束对于 data1 和 data2 共同有效。&lt;/p&gt;
&lt;p&gt;例 2. 不是理想的 system synchronous SDR interface 中，假设时钟周期为 5 ns，并且占空比为 50%，数据在发送时钟上升沿之后的 500 ps 之后变有效，并且持续 4 ns。则时序约束应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "clock" TNM_NET = CLK; &lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC TS_CLK = PERIOD CLK 5.0 ns HIGH 50%; &lt;/span&gt;
&lt;span class="err"&gt;OFFSET = IN 4.5 ns VALID 4 ns BEFORE clock;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="source synchronous inputs"&gt;Source Synchronous Inputs&lt;/h3&gt;
&lt;p&gt;所谓 Source Synchronous Inputs 其实就是指 &amp;ldquo; 发送端重新生成一个时钟信号，并且将数据和时钟信号有着相似的布线，两者的延时基本相同，在接收数据的 FPGA 端，使用这个时钟来捕获这个数据 &amp;rdquo;。布线延时和时钟倾斜不再是限制这种接口工作速度的因素，所以这种接口一般应用在双倍数据速率的 DDR 中。&lt;/p&gt;
&lt;p&gt;source synchronous DDR 应用示例如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="source synchronous SDR" src="/images/static-timing-analysis-2-xilinx-sta/source_synchronous_in_ddr.png"/&gt;&lt;/p&gt;
&lt;p&gt;其时序为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发送器件在某个时钟的上升沿和下降沿都会发送一个独立的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收端的 FPGA 使用发送端传递过来的这个再生时钟来捕获数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于这种接口的时序，使用 &lt;code&gt;OFFSET IN&lt;/code&gt; 是最有效方便的添加约束的方法。对于接口中的每个时钟，都有一个对应的 offset in 约束，这个约束覆盖了所有的使用该时钟来捕获输入数据的路径。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加约束的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先对接口的时钟添加周期约束（period constraint）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 其次为时钟的上升沿添加全局 offset in 约束（global Offset In）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 最后为时钟的下降沿添加全局 offset in 约束（global offset in）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;OFFSET = IN value VALID value BEFORE clock RISING;&lt;/span&gt;
&lt;span class="err"&gt;OFFSET = IN value VALID value BEFORE clock FALLING;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例： &lt;/p&gt;
&lt;p&gt;例 3. 在下面理想的 source synchronous DDR interface 时序图中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example3" src="/images/static-timing-analysis-2-xilinx-sta/example3.png"/&gt;&lt;/p&gt;
&lt;p&gt;输入时钟的周期为 5 ns，并且占空比为 50%，两 bit 的数据的有效时间都为 1/2 时钟周期，所以在这个实例中的时序约束应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="ss"&gt;"SysClk"&lt;/span&gt; &lt;span class="n"&gt;TNM_NET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"SysClk"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;TIMESPEC&lt;/span&gt; &lt;span class="ss"&gt;"TS_SysClk"&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;PERIOD&lt;/span&gt; &lt;span class="ss"&gt;"SysClk"&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="n"&gt;HIGH&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;OFFSET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;IN&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="k"&gt;VALID&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="k"&gt;BEFORE&lt;/span&gt; &lt;span class="ss"&gt;"SysClk"&lt;/span&gt; &lt;span class="n"&gt;RISING&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;OFFSET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;IN&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="k"&gt;VALID&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;ns&lt;/span&gt; &lt;span class="k"&gt;BEFORE&lt;/span&gt; &lt;span class="ss"&gt;"SysClk"&lt;/span&gt; &lt;span class="n"&gt;FALLING&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例 4. 不是理想的 source synchronous DDR（数据和时钟的边沿对齐），假设时钟周期为 5 ns，并且占空比为 50%，上升沿和下降沿的数据都保持有效 2ns，并且位于时钟波形的高低电平的中间位置，也就是说，在数据有效的前后各有 250 ps 的空白。&lt;/p&gt;
&lt;p&gt;对于上升沿，因为数据相对于捕获它的时钟沿后了 250 ps，并且有效时间持续了 2 ns；对于下降沿，数据也沿后了 250 ps， 并且有效时间持续了 2 ns，所以时序约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "clock" TNM_NET = CLK; &lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC TS_CLK = PERIOD CLK 5.0 ns HIGH 50%; &lt;/span&gt;
&lt;span class="err"&gt;OFFSET = IN -250 ps VALID 2 ns BEFORE clock RISING; &lt;/span&gt;
&lt;span class="err"&gt;OFFSET = IN -250 ps VALID 2 ns BEFORE clock FALLING&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例 5. 不是理想的 source synchronous DDR（数据和时钟的中间位置对齐），假设时钟周期为 5 ns，并且占空比为 50%，上升沿和下降沿的数据都保持有效 2 ns，并且时钟沿对齐数据的中间位置，可以得出结论，在数据有效的前后各有 250 ps 的空白。&lt;/p&gt;
&lt;p&gt;对于上升沿，因为数据相对于捕获它的时钟提前了 1 ns，并且有效时间持续了 2 ns；对于下降沿，数据也提前了 1 ns，并且有效时间持续了 2 ns，所以时序约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "clock" TNM_NET = CLK; &lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC TS_CLK = PERIOD CLK 5.0 ns HIGH 50%; &lt;/span&gt;
&lt;span class="err"&gt;OFFSET = IN 1 ns VALID 2 ns BEFORE clock RISING; &lt;/span&gt;
&lt;span class="err"&gt;OFFSET = IN 1 ns VALID 2 ns BEFORE clock FALLING;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="register-to-register paths_1"&gt;Register-to-register paths&lt;/h2&gt;
&lt;p&gt;这部分讨论寄存器 - 寄存器之间同步路径上的周期约束（period constraint）。&lt;/p&gt;
&lt;p&gt;period constraint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义了时钟域的时序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖了内部寄存器之间的同步数据路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析单个时钟域内的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析两个相关联的时钟域之间的所有路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在分析时考虑了时钟域之间的相位、频率、不确定性因素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步时钟域的约束可以分为以下 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Automatically Related Synchronous DLL, DCM, PLL, and MMCM Clock Domains&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Manually Related Synchronous Clock Domains&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Asynchronous Clock Domains&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;使用工具对 DCM、PLL 和 MMCM 的输出时钟自动添加时钟关系，并且手动定义外部的相关时钟的关系。通过这种方法，可以保证所有的跨时钟域的同步路径都被正确约束、分析，使用这种方法来添加 period constraint 可以避免再添加额外的跨时钟域约束。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="automatically related synchronous dll, dcm, pll, and mmcm clock domains"&gt;Automatically Related Synchronous DLL, DCM, PLL, and MMCM Clock Domains&lt;/h3&gt;
&lt;p&gt;最常见的时钟信号就是下面两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入到 DCM、PLL 或者是 MMCM 的时钟信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从这些单元输出，用来驱动内部的同步路径的时钟信号&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐的约束方法是 &lt;strong&gt;对输入到 DCM、PLL 或者是 MMCM 的时钟信号添加周期约束（period constraint）。&lt;/strong&gt; 通过对输入时钟添加周期约束，Xilinx 工具会&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自动为 DCM、PLL 或者是 MMCM 的输出生成一个新的周期约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定输出时钟之间的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析这些同步域之间的任何路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "ClockName" TNM_NET = "TNM_NET_Name";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_name" = PERIOD "TNM_NET_Name" PeriodValue HIGH HighValue%;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PeriodValue 定义时钟周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HighValue 定义时钟的占空比&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 6. 在下图的例子中&lt;/p&gt;
&lt;p&gt;&lt;img alt="example6" src="/images/static-timing-analysis-2-xilinx-sta/example6.png"/&gt;&lt;/p&gt;
&lt;p&gt;输入时钟连接到 DCM 的输入端，因为输入时钟的时钟周期为 5 ns，并且占空比为 50%，所以添加的约束为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "ClkIn" TNM_NET = "ClkIn";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_ClkIn" = PERIOD "ClkIn" 5 ns HIGH 50%;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，我们给出上面的约束条件之后，DCM 会自动为它的两个输出添加约束，并且分析这两个时钟域&lt;/p&gt;
&lt;h3 id="manually related synchronous clock domains"&gt;Manually Related Synchronous Clock Domains&lt;/h3&gt;
&lt;p&gt;在有些情况中，Xilinx 工具无法自动分析指定同步时钟域之间的关系（比如相关的时钟信号从两个不同的管脚输入进入到 FPGA），&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种情形下，Xilinx 推荐的约束方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为每一个输入时钟都创建一个周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 手动定义时钟之间的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦我们定义了时钟约束，工具会自动分析两个同步域之间的所有路径，并且在分析时会把频率、相位、不确定因素都考虑进去。&lt;/p&gt;
&lt;p&gt;Xilinx 的约束系统可以通过在周期约束中加入频率和相位信息来添加更加复杂的周期约束（complex manual relationship）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为主时钟定义周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 以主时钟的约束为参考，为其他的相关时钟添加周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "PrimaryClock" TNM_NET = "TNM_Primary";&lt;/span&gt;
&lt;span class="err"&gt;NET "RelatedClock" TNM_NET = "TNM_Related";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_primary" = PERIOD "TNM_Primary" PeriodValue HIGH HighValue%;&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_related" = PERIOD "TNM_Related" TS_Primary_relation PHASE value;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 related PERIOD 的约束中，PERIOD 的值定义了相关时钟和主时钟之间的关系（以时钟周期为单位），这种关系用主时钟的 TIMESPEC 形式来定义；PHASE 的值定义了主时钟和相关时钟的上升沿之间的关系。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 7. 如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="example7" src="/images/static-timing-analysis-2-xilinx-sta/example7.png"/&gt;&lt;/p&gt;
&lt;p&gt;CLK2X180 的频率是 CLK1X 的 2 倍，所以 PERIOD 的值为 1/2；CLK2X180 的相位相比于主时钟，偏移了 180 度，所以它的上升沿比主时钟的上升沿晚了 1.25 ns；所以这个例子的约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "Clk1X" TNM_NET = "Clk1X";&lt;/span&gt;
&lt;span class="err"&gt;NET "Clk2X180" TNM_NET = "Clk2X180";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_Clk1X" = PERIOD "Clk1X7 5 ns HIGH 50%;&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_Clk2X180" = PERIOD "Clk2X180" TS_Clk1X/2 PHASE +1.25 ns;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="asynchronous clock domains"&gt;Asynchronous Clock Domains&lt;/h3&gt;
&lt;p&gt;异步时钟是指频率或相位有一个不同或者都不相同的时钟。因为时钟是不相关的，所以在进行 setup/hold time 分析时，是无法确定时钟的最终关系的。因此，&lt;strong&gt;Xilinx 推荐在设计时使用一些特殊的方法来确保数据能被正确捕获。&lt;/strong&gt;然而，有时候设计者希望不考虑频率和相位之间的关系，在孤立的条件下限制数据传输的最大时延。&lt;/p&gt;
&lt;p&gt;Xilinx 约束系统允许不考虑源和目的时钟之间的频率、相位关系，直接约束数据路径的最大时延。语法就是使用带 &lt;code&gt;DATAPATHONLY&lt;/code&gt; 关键字的 &lt;code&gt;From-To&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为源同步寄存器定义时钟组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 为目的同步寄存器定义时钟组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 用带 &lt;code&gt;DATAPATHONLY&lt;/code&gt; 关键字的 &lt;code&gt;From-To&lt;/code&gt; 来约束两个时钟域之间的最大数据时延&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "CLKA" TNM_NET = FFS "GRP_A";&lt;/span&gt;
&lt;span class="err"&gt;NET "CLKB" TNM_NET = FFS "GRP_B";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC TS_Example = FROM "GRP_A" TO "GRP_B" Delay DATAPATHONLY&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 8. 以前面的图为例，假设 CLKA 输入到第一个寄存器 R1，CLKB 输入到第二个寄存器 R2，R1 的输出连接到 R2 的输入，能忍受的最大的数据时延为 5 ns，则约束为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "CLKA" TNM_NET = FFS "GRP_A";&lt;/span&gt;
&lt;span class="err"&gt;NET "CLKB" TNM_NET = FFS "GRP_B";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC TS_Example = FROM "GRP_A" TO "GRP_B" 5 ns DATAPATHONLY&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="output paths_1"&gt;Output paths&lt;/h2&gt;
&lt;p&gt;这部分讨论如何为输出路径添加约束。输出约束覆盖了从 &amp;ldquo; 内部同步单元 / 寄存器 ---&amp;gt; FPGA 输出管脚 &amp;rdquo; 之间的所有路径。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="output example" src="/images/static-timing-analysis-2-xilinx-sta/output_example.png"/&gt;&lt;/p&gt;
&lt;p&gt;在输出路径模型中，发送端是 FPGA 芯片，接收端是一个外部设备（当然也可以是 FPGA），输入路径讨论的就是以发送端的 FPGA 为视角，如何将待发送定数据正确发送出去。&lt;/p&gt;
&lt;p&gt;和输入路径对应，输出路径使用 &lt;code&gt;OFFSET OUT&lt;/code&gt; 来约束以达到时序要求。&lt;/p&gt;
&lt;p&gt;OFFET OUT 定义了输出数据和将该数据发送到输出管脚的时钟之间的关系。OFFSET OUT 的分析会自动将影响输出数据 / 输出时钟的内部因素考虑在内：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;时钟的频率和相位畸变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟的不确定性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据时延的调整&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和输入路径类似，输出路径的时序要求也可以依据接口的类型（system/source synchronous）和数据速率（SDR/DDR）来分类讨论。&lt;/p&gt;
&lt;h3 id="system synchronous output"&gt;System Synchronous Output&lt;/h3&gt;
&lt;p&gt;在 system synchronous output 中，发送端和接收端使用同一个时钟，所以发送端的 FPGA 只需要发生数据部分就可以了。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="system synchronous output" src="/images/static-timing-analysis-2-xilinx-sta/system_synchronous_out.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于 system synchronous output 接口，使用全局 OFFSET OUT 是最有效的方法。每个 OFFSET OUT 都约束了一个对应的输出时钟，并且所有使用这个时钟来触发的输出数据路径都被这个约束所覆盖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为输出时钟定义一个时钟名（TNM）来分组，这个时钟组包含了所有被这个时钟触发的输出寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 定义接口的全局 OFFSET OUT 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;OFFSET = OUT value AFTER clock;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;OFFSET = OUT &amp;lt;value&amp;gt;&lt;/code&gt; 规定了 &amp;ldquo; 接收器件的输入时钟（= 发送端 FPGA 的时钟）上升沿 ---&amp;gt; 发送端 FPGA 输出数据变有效 &amp;rdquo; 直接的最大时延。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 9. 如下图所示的 System Synchronous SDR output interface&lt;/p&gt;
&lt;p&gt;&lt;img alt="example9" src="/images/static-timing-analysis-2-xilinx-sta/example9.png"/&gt;&lt;/p&gt;
&lt;p&gt;假设发送端的输出数据必须在时钟上升沿之后的 5 ns 内变为有效，则约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "ClkIn" TNM_NET = "ClkIn";&lt;/span&gt;
&lt;span class="err"&gt;OFFSET = OUT 5 ns AFTER "ClkIn";&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="source synchronous output"&gt;Source Synchronous Output&lt;/h3&gt;
&lt;p&gt;在 source synchronous output interface，发送端的 FPGA 会重新生成一个时钟信号，并且将时钟信号和数据一起发送出去，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="source synchronous output" src="/images/static-timing-analysis-2-xilinx-sta/source_synchronous_out.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于 source synchronous output 接口，使用全局 OFFSET OUT 是最有效的方法。每个 OFFSET OUT 都约束了一个对应的输出时钟，并且所有使用这个时钟来触发的输出数据路径都被这个约束所覆盖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为输出时钟定义一个时钟名（TNM）来分组、，这个时钟组包含了所有被这个时钟触发的输出寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 为时钟上升沿添加 global Offset Out 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 为时钟下降沿添加 global Offset Out 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OFFSET = OUT &amp;lt;value&amp;gt;&lt;/code&gt; 约束了从 &amp;ldquo; 输入时钟的上升沿 ---&amp;gt; 发送端 FPGA 输出端口数据变为有效 &amp;rdquo; 的最大时延。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键词 &lt;code&gt;REFERENCE_PIN&lt;/code&gt; 约定以重新生成的时钟作为参考，输出数据的 skew 报告就是以这个时钟作为参考生成的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 10. 下图是一个理想的 Source Synchronous DDR interface 时序图&lt;/p&gt;
&lt;p&gt;&lt;img alt="example10" src="/images/static-timing-analysis-2-xilinx-sta/example10.png"/&gt;&lt;/p&gt;
&lt;p&gt;时钟周期为 5 ns，并且占空比为 50%，数据保持有效的时间为 1/2 时钟周期。所以，这个示例的约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "ClkIn" TNM_NET = "ClkIn";&lt;/span&gt;
&lt;span class="err"&gt;OFFSET = OUT AFTER "ClkIn" REFERENCE_PIN "ClkOut" RISING;&lt;/span&gt;
&lt;span class="err"&gt;OFFSET = OUT AFTER "ClkIn" REFERENCE_PIN "ClkOut" FALLING&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="path specific exceptions_1"&gt;Path specific exceptions&lt;/h2&gt;
&lt;p&gt;通过前面的 3 节的讨论，对输入、寄存器 - 寄存器、输出路径进行约束，大部分时序路径都得到了正确约束，然后在一些情况中，存在少数不适应于全局约束的少数路径，这些例外最常见的就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;False Paths (Paths Between Registers That Do Not Affect Timing)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multi-Cycle Paths&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论。&lt;/p&gt;
&lt;h3 id="false paths (paths between registers that do not affect timing)"&gt;False Paths (Paths Between Registers That Do Not Affect Timing)&lt;/h3&gt;
&lt;p&gt;如果有些路径不影响时序性能，那么我们就可以将这些路径从时序分析中移除。&lt;strong&gt;最常用的方法就是使用带 time ignore (&lt;code&gt;TIG&lt;/code&gt;) 关键词的 &lt;code&gt;FROM_TO&lt;/code&gt; 约束。&lt;/strong&gt; 使用这种约束，可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从源时钟域指定一组寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从目标时钟域指定一组寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将源到目标域的路径从时序分析中移除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 在源时钟域指定一组寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 在目标时钟域指定一组寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 使用带 TIG 关键词的 FROM-TO 来移除这两个域之间的路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;TIMESPEC "TSid" = FROM "SRC_GRP" TO "DST_GRP" TIG;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 11. 假设下图中的两个寄存器之间的路径并不影响设计的时序，希望将这条路径从时序约束中移除&lt;/p&gt;
&lt;p&gt;&lt;img alt="example11" src="/images/static-timing-analysis-2-xilinx-sta/example11.png"/&gt;&lt;/p&gt;
&lt;p&gt;则本例的约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "CLK1" TNM_NET = FFS "GRP_1";&lt;/span&gt;
&lt;span class="err"&gt;NET "CLK2" TNM_NET = FFS "GRP_2";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC TS_Example = FROM "GRP_1" TO "GRP_2" TIG;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="multi-cycle paths"&gt;Multi-Cycle Paths&lt;/h3&gt;
&lt;p&gt;在多周期路径中，从发送端到接收端的同步单元，数据以低于周期约束中的 PERIOD 速率传输。这种情况最常见的场景是同步单元使用一个共同的 clock enable 来门控。&lt;/p&gt;
&lt;p&gt;通过定义一个多周期路径（Multi-Cycle path），这些同步单元的约束条件会比默认的周期约束宽松很多。方法就是先给周期约束定义一个标识，然后再声明 Multi-Cycle path 包含多少个时钟周期。然后工具就可以合理分配这些路径的优先级。&lt;/p&gt;
&lt;p&gt;定义一个多周期路径的 &lt;strong&gt;最常用的方法就是用 clock enable 信号定义一个时钟组，这样我们就可以用这个 clock enable 来定义一个包含了源、目的寄存器的时钟组，然后将多周期约束应用到这些寄存器之间的路径上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 对公用时钟域进行周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 定义所有基于同一个 clock enable 信号的寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 对新的时序要求进行 From:To(Multi-Cycle) 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;TIMESPEC "TSid" = FROM "MC_GRP" TO "MC_GRP" &amp;lt;value&amp;gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MC_GRP&lt;/code&gt; 定义了一组公用时钟的寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有从 &lt;code&gt;MC_GRP&lt;/code&gt; 开始，到 &lt;code&gt;MC_GRP&lt;/code&gt; 结束的路径就是需要进行多周期约束的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 12. 如下图所示的假设情形中&lt;/p&gt;
&lt;p&gt;&lt;img alt="example12" src="/images/static-timing-analysis-2-xilinx-sta/example12.png"/&gt;&lt;/p&gt;
&lt;p&gt;两个寄存器直接的路径被一个共同点 clock enable 控制，并且 clock enable 的变化速率是时钟频率的一半。则本例的时序约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NET "CLK1" TNM_NET = "CLK1";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC "TS_CLK1" = PERIOD "CLK1" 5 ns HIGH 50%;&lt;/span&gt;
&lt;span class="err"&gt;NET "Enable" TNM_NET = FFS "MC_GRP";&lt;/span&gt;
&lt;span class="err"&gt;TIMESPEC TS_Example = FROM "MC_GRP" TO "MC_GRP" TS_CLK1*2;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary_1"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;通过对这四种类型的 timing path 进行约束，基本上系统内所有路径都得到了合理约束。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_2/ug612.pdf"&gt;Timing Closure User Guide&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="STA"></category><category term="Xilinx"></category></entry><entry><title>静态时序分析 STA 1 —— 基础知识</title><link href="https://qiangu.cool/posts/ic/static_timing_analysis_1_basic.html" rel="alternate"></link><published>2015-03-18T00:00:00+08:00</published><updated>2015-03-18T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-03-18:/posts/ic/static_timing_analysis_1_basic.html</id><summary type="html">&lt;p&gt;静态时序分析 STA 系列之 1，基础知识。&lt;/p&gt;</summary><content type="html">&lt;p&gt;静态时序分析（Static Timing）是数字 IC 设计中不可避免的话题，也是一个菜鸟成长必须掌握的技术。本文先总结 STA 中常见的定义、名词等。&lt;/p&gt;
&lt;h2 id="clock"&gt;Clock&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;时钟是数字电路的动力系统，可以说数字电路中最重要的信号就是时钟信号了。一般时钟信号的时序特性分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;偏移 Skew&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抖动 Jitter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;占空比时钟 Duty Cycle Distortion&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于低速设计，基本不用考虑这些特征，但是对于高速设计，由于时钟本身造成的问题越来越普遍，因此有必要关注高速设计中的时序特性。&lt;/p&gt;
&lt;h3 id="skew"&gt;Skew&lt;/h3&gt;
&lt;p&gt;时钟信号要提供给整个电路的时序单元，所以时钟信号线非常长，并构成分布式的 RC 网路。它的延时与时钟线的长度、时序单元的负载电容、个数有关，由于时钟线长度及负载不同，会导致时钟信号到达相邻两个时序单元的时间不同，这个时间上的偏差就是 时钟偏移 &lt;code&gt;Skew&lt;/code&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="skew" src="/images/static-timing-analysis-1-basic/skew.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;假设时钟信号达到两个 DFF 的延时分别为 Tc1 和 Tc2，用 Tskew 来表示它们之间的时钟偏移，则计算公式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Tskew = Tc2 - Tc1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据差值可以分为正偏移和负偏移：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当时钟到达 DFF1 的延时更大时，也就是 C1 &amp;gt; C2 时，Tskew 为正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当时钟到达 DFF2 的延时更大时，也就是 C1 &amp;lt; C2 时，Tskew 为负&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意到是，时钟偏移永远存在，当其大到一定程度时，就会严重影响电路的时序。&lt;/p&gt;
&lt;p&gt;FPGA 在设计架构时，专门针对这种现象进行优化，采用全铜工艺和树状结构，并且设计了专用的时钟缓冲和驱动网络，这么做的目的就是尽量使时钟到达不同时序单元的路径一样长，从而使时钟偏移非常小，可以忽略不计。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;Skew 问题的解决方法就是：设计中的主要信号应该走全局时钟网络。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使采用了这样的设计，在实际电路中，时钟信号到达每个 DFF 的时间也不可能完全相等，Skew 是肯定存在的。所以 STA 仍然需要考虑该因素。在 PAR 之前，STA 只能根据设计的面积来粗略估计 Skew，在 PAR 之后，因为有了更具体的信息（线段长度、宽度、信号分布情况）STA 的估计值更加精确。&lt;/p&gt;
&lt;h3 id="jitter"&gt;Jitter&lt;/h3&gt;
&lt;p&gt;理想的时钟信号是方波，但是实际中的时钟信号边沿不可能是瞬间变化的，是个斜坡，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="clock" src="/images/static-timing-analysis-1-basic/clock.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;时钟抖动 &lt;code&gt;Jitter&lt;/code&gt; 的定义很多，最常见的有 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;周期抖动 &lt;code&gt;Period Jitter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Period Jitter" src="/images/static-timing-analysis-1-basic/period_jitter.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;实际时钟信号周期与理想时钟周期的差值的变化。这是最早最直接的一种衡量抖动的方式，这个指标说明了时钟信号每个周期的变化。&lt;/p&gt;
&lt;p&gt;因为这个差值是个随机变量，并且满足高斯分布，所以可以用期望和方差来描述。一般随机选择很多个周期，然后计算平均周期、标准差、峰峰值。标准差称为 &amp;ldquo;&lt;code&gt;RMS 抖动&lt;/code&gt;&amp;rdquo;，峰峰值称为 &amp;ldquo;&lt;code&gt;Pk-Pk 周期抖动&lt;/code&gt;&amp;rdquo;。知道 Pk-Pk 周期抖动，对于恰当配置系统和保持时间很有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周期差抖动 &lt;code&gt;Cycle-to-cycle Jitter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="c2c_jitter" src="/images/static-timing-analysis-1-basic/cycle_to_cycle_jitter.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;两个相邻时钟周期的差值的变化。根据定义可知，对周期抖动做一阶差分，就可以得到周期差抖动。&lt;/p&gt;
&lt;p&gt;这个差值也是一个服从高斯分布的随机变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相位抖动 &lt;code&gt;Phase Jitter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="phase_jitter" src="/images/static-timing-analysis-1-basic/phase_jitter.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;一个时钟沿相对于基准对齐之后，经过一段时间后，与理想位置的偏差。这个指标说明了周期抖动在各个时期的累计效应。&lt;/p&gt;
&lt;p&gt;因为需要累积一段时间，所以这个误差又称为 时间间隔误差（TIE, Timer Interval Error）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 周期抖动 和 周期差抖动 是单个周期或者相邻周期的偏差，所以表征为短期抖动行为。而相位抖动需要累积一段时间，所以表征为长期抖动行为。&lt;/p&gt;
&lt;p&gt;时钟抖动的原因就是噪声。&lt;strong&gt;时钟抖动是永远存在的&lt;/strong&gt;，当其大到可以和时钟周期相比拟的时候，会影响到设计，这样的抖动是不可接受的。&lt;/p&gt;
&lt;h3 id="duty cycle distortion"&gt;Duty Cycle Distortion&lt;/h3&gt;
&lt;p&gt;&lt;img alt="dcd" src="/images/static-timing-analysis-1-basic/dcd.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;占空比失真，即时钟不对称，有脉冲的时间和无脉冲的时间发生了变化。DCD 会吞噬大量的时序裕量，造成数字信号的失真，使过零区间偏离理想的位置。DCD 通常是由信号的上升沿和下降沿之间时序不同而造成的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ohters_1"&gt;Ohters&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;除去时钟信号，还有一些其他的相关定义。&lt;/p&gt;
&lt;h3 id="fan-out/fan-out"&gt;Fan-out/Fan-out&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Fan-out&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数字电路中，逻辑门相互连接，组成更加复杂的电路，所以大多数逻辑门的输出端都连接着多个别的单元的输入。所以需要一个术语来描述逻辑门的驱动能力的大小，也就是扇出 &lt;code&gt;Fan-out&lt;/code&gt;。最大扇出数 &lt;code&gt;maximum fan-out&lt;/code&gt; 定义为一个逻辑门可以驱动的同类逻辑门的最大数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数 TTL 逻辑门能够为 10 个其他数字门或驱动器提供信号。因而，一个典型的 TTL 逻辑门有 10 个扇出信号。&lt;/p&gt;
&lt;p&gt;在一些数字系统中，必须有一个单一的 TTL 逻辑门来驱动 10 个以上的其他门或驱动器。这种情况下，被称为缓冲器（buf）的驱动器可以用在 TTL 逻辑门与它必须驱动的多重驱动器之间。这种类型的缓冲器有 25 至 30 个扇出信号。逻辑反向器（非门）在大多数数字电路中能够辅助这一功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块的扇出&lt;/strong&gt; 是指模块的直属下层模块的个数。一般认为，设计得好的系统平均扇出是 3 或 4。一个模块的扇出数过大或过小都不理想，过大比过小更严重。一般认为扇出的上限不超过 7。扇出过大意味着管理模块过于复杂，需要控制和协调过多的下级。解决的办法是适当增加中间层次。一个模块的扇入是指有多少个上级模块调用它。扇入越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇入而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇入数高了，但这样的模块内聚程度必然低。这是我们应避免的。&lt;/p&gt;
&lt;p&gt;设计得好的系统，上层模块有较高的扇出，下层模块有较高的扇入。其结构图像清真寺的塔，上面尖，中间宽，下面小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Fan-in&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与扇出相对的概念是 扇入 &lt;code&gt;Fan-in&lt;/code&gt;，它描述的是一个逻辑门能够处理的外部输入的能力。扇入大的逻辑门的速度要比扇入小的慢，原因是增加扇入相当于增加逻辑门的输入电容。我们可以用使用多级逻辑门来代替高扇入的设计。&lt;/p&gt;
&lt;h3 id="setup/hold/recovery/removal time"&gt;Setup/Hold/Recovery/Removal Time&lt;/h3&gt;
&lt;p&gt;建立 / 保持时间是在同步设计中的概念：&lt;/p&gt;
&lt;p&gt;建立时间 &lt;code&gt;setup time&lt;/code&gt; ：触发器在时钟信号上升沿到来以前，要求输入数据必须保持稳定不变一段时间，这段时间就是器件需要的建立时间。如不满足 setup time，这个数据就不能被这一时钟打入触发器。&lt;/p&gt;
&lt;p&gt;保持时间 &lt;code&gt;hold time&lt;/code&gt; ：触发器在时钟信号上升沿到来以后，要求数据保持稳定不变一段时间，以便能够稳定读取，这段时间就是器件需要的保持时间。如果不满足 hold time，数据同样不能被打入触发器。&lt;/p&gt;
&lt;p&gt;恢复 / 撤销时间是在异步设计中的概念：&lt;/p&gt;
&lt;p&gt;恢复时间 &lt;code&gt;recovery time&lt;/code&gt; : 对于异步信号（比如异步复位 / 置位），信号变无效的边沿和下一个时钟沿之间必须满足一个最小的间隔。其意义在于，如果保证不了这个最小时间，也就是异步信号无效边离时钟边沿太近了，异步信号解除（无效）之后，没有给 DFF 足够的时间来恢复（recovery）到正常状态，那么就不能保证在时钟沿到来时 DFF 可以正常工作。&lt;/p&gt;
&lt;p&gt;撤销时间 &lt;code&gt;removal time&lt;/code&gt; : 对于异步信号（比如异步复位 / 置位），信号变有效的边沿和前一个时钟沿之间必须满足一个最小的间隔。其意义在于，如果保证不了这个最小时间，也就是异步信号的有效沿离时钟太近了，在时钟信号去除（无效）之前，异步信号提前有效了，可能会造成 DFF 处于不确定状态。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog_72c14a3d01013tpi.html?type=-1"&gt;更加详细的总结：锁存器 Latch v.s. 触发器 Flip-Flop&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="sta intro_1"&gt;STA Intro&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Static_timing_analysis"&gt;STA 的 wiki&lt;/a&gt; 已经说的很明白了，下面的内容基本就是引用和翻译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Static timing analysis (STA) is a method of computing the expected timing of a digital circuit without requiring simulation.&lt;/p&gt;
&lt;p&gt;High-performance integrated circuits have traditionally been characterized by the clock frequency at which they operate. Gauging the ability of a circuit to operate at the specified speed requires an ability to measure, during the design process, its delay at numerous steps. Moreover, delay calculation must be incorporated into the inner loop of timing optimizers at various phases of design, such as logic synthesis, layout (placement and routing), and in in-place optimizations performed late in the design cycle. While such timing measurements can theoretically be performed using a rigorous circuit simulation, such an approach is liable to be too slow to be practical. Static timing analysis plays a vital role in facilitating the fast and reasonably accurate measurement of circuit timing. The speedup comes from the use of simplified timing models and by mostly ignoring logical interactions in circuits. It has become a mainstay of design over the last few decades.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="definitions"&gt;Definitions&lt;/h3&gt;
&lt;p&gt;STA 中的一些术语定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;timing path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog_72c14a3d01013tpi.html?type=-1"&gt;FPGA STA( 三 ) --- STA 的基本概念&lt;/a&gt; 中说的很明白：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在做 STA 时，首先要把电路分解为一条条的 timing path。实际上我们也可以把 timing path 称为 data path，其本质就是指信号传播的途径。每一条 timing path 都具有一个起始点和一个终点。起始点是指电路中信号被时钟沿锁存的点；而信号经过一系列的组合逻辑的通道或者走线后被另外一个时钟沿捕获，这个点被称为终点。信号从起始点到终点所经过的通道就被称为 timing path。&lt;/p&gt;
&lt;p&gt;起点有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时序器件的 时钟输入端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路的 输入端口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;终点也有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时序器件的 数据输入端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路的 输出端口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入和输出排列组合一共就有 4 种 path：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电路输入端口  -&amp;gt;  触发器的数据 D 端 (Pad-to-Setup)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触发器的 clk 端  -&amp;gt;  触发器的数据 D 端 (Clock-to-Setup)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触发器的 clk 端  -&amp;gt;  电路输出端口 (Clock-to-Pad)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路输入端口  -&amp;gt;  电路输出端口 (Pad-to-Pad)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="path" src="/images/static-timing-analysis-1-basic/path.jpg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;critical path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关键路径：从输入到输出，延时最大的那条路径称为 critical path。关键路径是系统中延时最大的路径，它决定了系统所能达到的最大时钟频率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arrival time&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;到达时间：信号到达某个特定位置所消耗的时间。一般将时钟信号到达的时刻作为参考的 0 时刻，为了计算到达时间，需要对路径中的所有组件的延时都进行计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;required time&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需求时间：所能容忍的路径最大延时，也就是信号到达的最晚的时间。如果路径上的延时再大一些，则必须降低时钟频率，否则会产生 setup/hold time violation。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slack&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;时序裕量：&lt;code&gt;slack = required time - arrival time&lt;/code&gt;。如果计算出某条路径的 slack 是正数，说明这条路径的时延是满足要求的；如果计算出某条路径的 slack 是负数，则表示路径上的延时太大了，必须做出修改（修改设计 or 修改约束 or 换芯片），否则包含它的电路不能以预期的频率工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="purpose"&gt;Purpose&lt;/h3&gt;
&lt;p&gt;在同步设计中，数据的流动是统一步伐的，即时钟信号每改变一次，数据跟随改变一次。这种运作方式是基于同步器件（DFF 或者 Latch）来实现的，这类器件以时钟信号作为指示，将其输入端的数据复制到输出端。在同步设计中只存在两种时序错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setup time violation&lt;/p&gt;
&lt;p&gt;输入数据和时钟的关系不满足 setup time 的要求，即在时钟有效沿之前，输入数据没有保持稳定足够长的时间，数据将不能被这个时钟沿记录下来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hold time violation&lt;/p&gt;
&lt;p&gt;输入数据和时钟的关系不满足 hold time 的要求，即在时钟有效沿之后，输入数据没有保持稳定足够长的时间，数据将不能被时钟信号记录下来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;导致数据和时钟不同步的原因很多，比如数据本身和时钟不同步、或者是电路进行了不同的操作，器件的温度、电压、制造工艺等因素也会产生影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态时序分析 STA 的主要目的是在上述可能的电路偏移情况存在的情况下，验证所有信号能够准时到达，并保证电路的正常功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;工作频率对数字电路而言至关重要。提高工作频率意味着更强大的处理能力，但是也带来了时序瓶颈：时序冲突的概率变大，电路的稳定性降低。所以为了使电路的性能达到设计的预期目标，并满足电路工作环境的要求，必须对一个电路设计进行时序、面积、负载等多方面的约束，并自始至终使用这些约束来驱动 EDA 软件工作。&lt;/p&gt;
&lt;p&gt;ISE 具有一定的自动优化能力，对于一般的低速设计（处理时钟不超过 100MHz），基本上不需要时序方面的任何手动分析和处理；但是对于高速和大规模设计，需要设计人员自行添加时序方面的控制和处理，通过多次反复操作，根据反馈结果逐步调整设定，直到满足要求为止。&lt;/p&gt;
&lt;p&gt;以前小规模 FPGA 设计，只需要做动态的门级时序仿真就课同时完成逻辑功能验证和时序验证；随着 FPGA 设计规模和速度的提升，有必要将逻辑功能验证和时序验证分开：首先，逻辑功能的正确性，可以通过 RTL 级或者门级的功能仿真来验证；其次，时序分析通过 STA（Static Timing Analysis，静态时序分析）验证。&lt;/p&gt;
&lt;p&gt;时序分析的主要作用就是查看 FPGA 内部逻辑和布线的延迟，验证其是否满足设计者的约束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定芯片最高工作频率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制工程的综合、映射、布局布线等关键环节，减少逻辑和布线的延迟，从而尽可能提高工作频率。一般情况下，处理时钟高于 100MHz 的时候，必须添加合理的时序约束文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查时序约束是否满足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查目标模块是否满足约束，若不满足，通过时序分析器定位程序中不满足的部分，并给出具体原因，然后设计人员修改程序，直到满足约束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析时钟质量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当采用了全局时钟等优质资源后，仍然不满足目标约束，则需要降低所约束的时钟频率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定分配引脚的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过时序分析可以指定 I/O 引脚所支持的接口标准、接口速率和其他电气特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STA 的目的就是要保证 DUT（Device Under Test）中所有的路径满足内部时序单位对 setup time 和 hold
 time 的要求。信号可以及时的从任一时序路径的起点传递到终点，同时要求在电路正常工作所需的时间内保持恒定。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="theory"&gt;Theory&lt;/h3&gt;
&lt;p&gt;STA 是基于前面介绍的时序路径的，在分析时，计算时序路径上数据信号的到达时间和要求时间的差值，以判断是否存在违反设计规则的错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Slack = Trequired_time - Tarrival_time&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果时序裕量 Slack 为正，表示满足时序，负值表示不满足时序。STA 按照上式分析设计中所有路径，如果 Slack 为负值，则该路径为影响设计的关键路径，需要修改设计以达到时序要求。&lt;/p&gt;
&lt;p&gt;STA 是通过 &amp;ldquo; 穷举法 &amp;rdquo; 抽取整个设计电路的所有时序路径，按照约束条件分析电路中是否有违反设计规则的问题，并计算出设计的最高频率。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;========= Update 05/18/2015===========================&lt;/p&gt;
&lt;p&gt;很多笔试题里面都有考计算最大时钟频率的题，看到几篇文章 :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-101/"&gt;Static Timing Analysis 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-102-setup-failures/"&gt;Static Timing Analysis 102 : Setup Failures.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-103-hold-failures/"&gt;Static Timing Analysis 103 : Hold Failures.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解释的很清楚，记一下笔记，顺便总结一下。&lt;/p&gt;
&lt;p&gt;首先，电路中的元件一般分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑，比如与非门、或非门等组合逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序逻辑，受时钟驱动的元件，比如 flip-flop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般时序分析都是分析前面介绍的 Path2 的路径，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="path2" src="/images/static-timing-analysis-1-basic/path2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;在这个图中，第一级的 DFF 的输出经过组合逻辑进入第二级 DFF，图中的时序是满足条件的，电路可以正常工作；但是如果违反 setup / hold time 的话，电路就无法正常工作，下面分别说明：&lt;/p&gt;
&lt;h3 id="setup time failure"&gt;Setup Time Failure&lt;/h3&gt;
&lt;p&gt;前面已经提到了，对于任何 DFF，都必须满足 setup time 的要求：&lt;strong&gt;数据信号要在时钟信号之前到达 DFF，并保持稳定至少 setup time 时间，才能被成功打入 DFF&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分类讨论一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果中间的组合逻辑较少，产生的时延很小，那么在下一个时钟沿到来之前，数据满足 setup time，没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果中间的组合逻辑较多，产生的时延足够大，导致数据和时钟的关系不满足 setup time，则有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图是一个 setup time failure 的具体例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="setup failure" src="/images/static-timing-analysis-1-basic/setup_fail.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;第一级的 DFF 在时钟的上升沿对输入数据 In 进行采样，并经过一段时间（Tco，clock to output delay）后输出为 FF1_out，输出数据经过中间的组合逻辑变为 FF2_in 输入到第二级 DFF，因为中间的组合逻辑的时延太大，FF2_in 违反了 setup time 的要求（图中橙色线条所示）。由于第二级 DFF 的输入不满足 setup time，所以这个 DFF 会进入亚稳态，它将花费 1
个或多个时钟周期才能脱离亚稳态，在这期间它的输出都是不确定的，那么下游逻辑将会在这期间采样到错误数值，电路会发生错误。&lt;/p&gt;
&lt;p&gt;如果中间的组合逻辑过多，产生的时延过大，以至于 FF2_in 的变化落在了第二个时钟沿的后面，这时所然没有违反 setup time 的要求，第二个 DFF 不会进入亚稳态，但是它采样的数据是旧数据，这个数据可能是错误的，同样会导致下游逻辑发生错误。&lt;/p&gt;
&lt;p&gt;如果我们将时钟频率降到足够低，那么就可以避免 setup time failure 的问题。&lt;/p&gt;
&lt;p&gt;通过上面的分析，可以知道 setup time 限制了中间组合逻辑的最大时延，所以这个 setup time constraint 也叫做 max delay constraint。为了保证在最恶劣的情况下设计仍然能够满足要求，在计算 setup time 时中应该使用最大的数据时延路径。&lt;/p&gt;
&lt;p&gt;P.S. 上面的图中还包含了 clock skew，clk1 和 clk2 没有对齐，这加剧了 setup time failure 的机率。在实际中，时钟信号到达各个 DFF 的时间是不同的，设计者必须将这个因素考虑在内。&lt;/p&gt;
&lt;h3 id="hold time failure"&gt;Hold Time Failure&lt;/h3&gt;
&lt;p&gt;和 setup time 对应，对于任何时序器件（DFF)，都必须满足 hold time 的要求：&lt;strong&gt;数据信号要在时钟信号达到之后保持稳定至少 hold time 的时间，否则输出是错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下图是一个 hold time failure 的具体例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="hold failure" src="/images/static-timing-analysis-1-basic/hold_fail.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;第一级 DFF 在时钟的上升沿对输入数据 In 进行采样，经过一段时间（Tco）后，输出为 FF1_out，输出数据经过中间的组合逻辑变为 FF2_in，输入到第二级 DFF。因为中间的组合逻辑时延非常小，而且由于 clock skew 的原因，导致第二级 DFF 在第一个时钟周期的 hold time 内输入的 FF2_in 发生了变化，违法了 hold time 要求，DFF2 进入亚稳态，它将花费 1 个或多个时钟周期才能退出亚稳态，在此期间输出的是错误数据。&lt;/p&gt;
&lt;p&gt;在现实中，导致这个问题的因素有可能是设计的问题（比如两个 DFF 邻接，中间没有其他逻辑），也有可能是器件的原因。&lt;/p&gt;
&lt;p&gt;因为传输时延太小，从而导致在第一个时钟沿信号就被 DFF2 采样了，而设计本意是在第二个时钟沿采样，看起来好像是信号跑（racing）的太快了，所以 hold time failure 也叫做 race。&lt;/p&gt;
&lt;p&gt;通过上面的分析，可以知道 hold time 限制了中间组合逻辑的最小时延，所以这个 hold time constraint 也叫做 min delay constraint。为了保证在最恶劣的情况下设计仍然能够满足要求，在计算 hold time 时中应该使用最小的数据时延路径。&lt;/p&gt;
&lt;p&gt;P.S. 上面的例子中 clock skew 加剧了 hold time failure 的机率，如果两个时钟是对齐的，那么就不会出现 hold time failure，输出也就不会出错。&lt;/p&gt;
&lt;h3 id="summary"&gt;summary&lt;/h3&gt;
&lt;p&gt;假设理想的时钟为 clk，它的周期为 T，它连接到 DFF1 和 DFF2 的时钟为 clk1 和 clk2，它们相对于理想时钟的时延分别为 Tc1 和 Tc2；DFF 的参数分别为 Tsu，Th 和 Tco，中间组合逻辑的时延为 Tcomb。&lt;/p&gt;
&lt;p&gt;数据的时延：Tc1 + Tco + Tcomb&lt;/p&gt;
&lt;p&gt;时钟的时延：Tc2 + T  &lt;/p&gt;
&lt;p&gt;要满足 setup time 的要求，则有 Tc2 + T - (Tc1 + Tco + Tcomb) &amp;gt;= Tsu，整理一下即：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;T &amp;gt;= Tsu + Tco + Tcomb - Tskew     --Eq1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以可以确定出系统的最大工作频率：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Fmax &amp;lt;= 1 / (Tsu + Tco + Tcomb - Tskew)     -- Eq2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 Tc1, Tc2, Tco, Tsu 都是固定值，所以一个系统的最大工作频率取决 Tcomb。&lt;/p&gt;
&lt;p&gt;而对于 hold time，则有不等式：Tc1 + Tco + Tcomb &amp;gt; Tc2 + Th，整理一下就有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Tco + Tcomb - Tskew &amp;gt; Th        -- Eq3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上一级 DFF 的输出数据不能传输太快，侵占了下一级 DFF 正在锁存的 hold time，也就是说限制了数据的传输速度的上限。&lt;/p&gt;
&lt;p&gt;有了前面的 3 个公式，就可以解决大部分问题了。比如华为某年的笔试题：&lt;/p&gt;
&lt;p&gt;下图中时钟周期为 T, 触发器 D1 的建立时间最大为 T1max，最小为 T1min。组合逻辑电路最大延迟为 T2max, 最小为 T2min。问，触发器 D2 的建立时间 T3 和保持时间应满足什么条件 ?&lt;/p&gt;
&lt;p&gt;&lt;img alt="huawei" src="/images/static-timing-analysis-1-basic/huawei.png"/&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;题目中 Tco = 0，Tskew = 0&lt;/p&gt;
&lt;p&gt;对于 setup time 的要求，将 Tco = 0，Tskew = 0 代入 Eq1 得：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Tsu &amp;lt;= {T - Tcomb}min = T - T2max&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 hold time 的要求，将 Tco = 0，Tskew = 0 代入 Eq2 得：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Th &amp;lt;= {Tcomb}min = T2min&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref_1"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ictest8.com/debug/rf_pcb.htm"&gt;RF 类 IC demo 板 loadboard 设计参考资料之时钟部分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ti.com.cn/cn/lit/an/zhca492/zhca492.pdf"&gt;正确理解时钟器件的抖动性能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://m.ee.ofweek.com/2014-10/ART-11000-2813-28889698.html"&gt;技术解析：详解各种抖动技术规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.elecfans.com/article/85/126/2008/2008112718522.html"&gt;时间抖动 (jitter) 的概念及其分析方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog_72c14a3d01013tpi.html?type=-1"&gt;锁存器 Latch v.s. 触发器 Flip-Flop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/shanghaiqianlun/article/details/8685047"&gt;TimeQuest 定时分析的基本概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Static_timing_analysis"&gt;Static timing analysis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog_72c14a3d01013tpi.html?type=-1"&gt;FPGA STA( 三 ) --- STA 的基本概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-101/"&gt;Static Timing Analysis 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-102-setup-failures/"&gt;Static Timing Analysis 102 : Setup Failures.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-103-hold-failures/"&gt;Static Timing Analysis 103 : Hold Failures.&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="STA"></category></entry><entry><title>关于冒险和毛刺</title><link href="https://qiangu.cool/posts/ic/summary_of_hazard_and_glitch.html" rel="alternate"></link><published>2015-03-13T21:44:00+08:00</published><updated>2015-03-13T21:44:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-03-13:/posts/ic/summary_of_hazard_and_glitch.html</id><summary type="html">&lt;p&gt;总结电路设计中的冒险现象和毛刺，及解决方法。&lt;/p&gt;</summary><content type="html">&lt;h2 id="hazards &amp;amp; glitch"&gt;Hazards &amp;amp; Glitch&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;所谓 &amp;ldquo; 冒险 &amp;rdquo; &lt;code&gt;Hazard&lt;/code&gt;，是指一种数字电路中由于设计或者是外部因素，造成的数字信号错误的现象，而这个错误的信号就叫做毛刺 &lt;code&gt;Glitch&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Hazard_(logic)"&gt;Hazard on wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In digital logic, a hazard in a system is an undesirable effect caused by either a deficiency in the system or external influences. Logic hazards are manifestations of a problem in which changes in the input variables do not change the output correctly due to some form of delay caused by logic elements (NOT, AND, OR gates, etc.) This results in the logic not performing its function properly. The three different most common kinds of hazards are usually referred to as static, dynamic and function hazards.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据导致冒险的原因，一般将冒险分类如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态冒险 &lt;code&gt;Static hazards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;静态冒险，是指输入信号发生变化前后，输出信号保持不变，但是在输入信号变化时，输出信号可能产生瞬间错误输出。&lt;/p&gt;
&lt;p&gt;根据发生的错误的值，可以将静态冒险分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Static-1 Hazard: 输入变化前后，输出应该保持 1，但是在输入变化瞬间输出发生错误，变为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Static-0 Hazard: 输入变化前后，输出应该保持 0，但是在输入变化瞬间输出发生错误，变为 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据导致冒险的原因分类，可以将静态冒险分为以下两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑冒险 &lt;code&gt;logic hazard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;只有 1 个输入发生变化，导致的静态冒险。&lt;/p&gt;
&lt;p&gt;经分析可知产生逻辑冒险的原因是门的延迟。（参考&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能冒险 &lt;code&gt;function hazard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2 个或者 2 个以上的输入发生变化，导致的静态冒险。&lt;/p&gt;
&lt;p&gt;经分析可知产生功能冒险的原因是两个或两个以上的输入不可能同时发生变化，它们的变化总有先有后。参考&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态冒险 &lt;code&gt;Dynamic hazards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;动态冒险，是指输入信号变化前后，输入信号发生变化，而且在输入信号发生变化时，输出信号会变化 3 次以上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="solution"&gt;Solution&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;首先我们应该尽可能避免存在冒险的设计，这样就不存在解决毛刺的问题。&lt;/p&gt;
&lt;p&gt;比如在数字电路设计中，常常采用格雷码计数器取代普通的二进制计数器，这是因为格雷码计数器的输出每次只有一位跳变，消除了竞争冒险的发生条件，避免了毛刺的产生。&lt;/p&gt;
&lt;p&gt;再比如遵循同步设计原则，即使有毛刺，一般也不会对系统造成危害。（因为同步电路信号的变化都发生在时钟沿，只要毛刺不出现在时钟的沿口并且不满足数据的建立和保持时间，就不会对系统造成危害。一般毛刺很短，多为几纳秒，基本上都不可能满足数据的建立和保持时间）&lt;/p&gt;
&lt;p&gt;设计无冒险的电路，会导致电路变复杂，成本上升。对于简单电路中的冒险，我们可以采用以下的方法来解决。&lt;/p&gt;
&lt;h3 id="static hazards"&gt;Static hazards&lt;/h3&gt;
&lt;p&gt;首先判断输入信号是否会同时发生变化，可以分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只有一个输入变化，对应的就是 logic hazards&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断是否存在冒险（&lt;strong&gt;代数法&lt;/strong&gt; or &lt;strong&gt;卡诺图法&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;代数法比较繁琐，但是适用范围广，对两级以上的电路均适用。注意函数表达式不能化简，否则对应的逻辑电路改变，由电路延迟造成的冒险也随之改变。&lt;/p&gt;
&lt;p&gt;卡诺图法方便直观，但是只适用于两级电路。&lt;/p&gt;
&lt;p&gt;函数表达式中的积项或和项是和卡诺图中的合并圈一一对应的，由此可知，&lt;strong&gt;函数的最简不一定是最佳的，必要的冗余反而可增加电路工作的可靠性。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冒险（&lt;strong&gt;增加冗余项 / 冗余圈&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;至少有 2 个输入同时变化，对应的就是 function hazards&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断是否存在冒险&lt;/p&gt;
&lt;p&gt;产生功能冒险的充要条件（同时满足以下 3 个条件）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;必须有 P （P &amp;gt;= 2) 个变量同时发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入变量变化前后函数值相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由变化的 P 个变量组合所构成的 2^P 个格，既有 1 又有 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冒险（&lt;strong&gt;选通脉冲&lt;/strong&gt; or &lt;strong&gt;滤波电路&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;只要输入信号不是按照循环码的方式变化，就会产生功能冒险。功能冒险是函数的逻辑功能决定的，所以不能在设计中消除，需要加额外的选通脉冲。&lt;/p&gt;
&lt;p&gt;选通脉冲的思路：一般说来，冒险出现在信号发生电平转换的时刻，也就是说在输出信号的建立时间内会发生冒险，而在输出信号的保持时间内是不会有毛刺信号出现的。如果在输出信号的保持时间内对其进行 " 采样 "，就可以消除毛刺信号的影响。&lt;/p&gt;
&lt;p&gt;需要注意的是必须对选通脉冲的宽度及产生时间有严格的要求。加上选通脉冲之后，电路的输出就不再是电平信号，而是变为脉冲信号。&lt;/p&gt;
&lt;p&gt;还有另外一种方法：在对输出波形要求不高的时候，可以在输出端接一个滤波电容来消除冒险，但是这种方法会破坏波形的边沿，所以只适用于低速电路。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较 3 种消除冒险的方法：&lt;/p&gt;
&lt;p&gt;增加冗余只能消除 logic hazards，而不能消除 function hazards；&lt;/p&gt;
&lt;p&gt;增加滤波电路虽然简单，但是会破坏波形；&lt;/p&gt;
&lt;p&gt;加选通脉冲的方法则对两种类型的冒险都有效。&lt;/p&gt;
&lt;p&gt;目前很多中规模集成电路（Medium Scale Integrated, MSI）中都设有使能端，其作用之一就是作为选通脉冲的输入端，待电路稳定之后才使输出有效。&lt;/p&gt;
&lt;h3 id="dynamic hazards"&gt;Dynamic hazards&lt;/h3&gt;
&lt;p&gt;要解决动态冒险，首先就得知道动态冒险产生的原因：&lt;/p&gt;
&lt;p&gt;产生动态冒险的原因是输入可以有多条变化路径到达输出，而这些路径的时延都各不相同，显然这就会导致输出变化多次，比如一个输出应该从 1 变为 0，但是实际中却先从 1 变为 0，然后又从 0 变回 1，最终返回到正确值 0。&lt;/p&gt;
&lt;p&gt;动态的解决相对比较复杂，但是 &lt;strong&gt;只要消除了静态冒险，那么就不会存在动态冒险。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="in fpga design_1"&gt;in FPGA Design&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;本部分来自：&lt;a href="http://www.fpga.com.cn/advance/glitch/giltch.htm"&gt;关于毛刺问题的探讨&lt;/a&gt; 和 &lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;信号在 FPGA 器件内部通过连线和逻辑单元时，都有一定的延时。延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化 , 往往会出现一些不正确的尖峰信号，即毛刺信号。与分立元件不同，由于 PLD 内部不存在寄生电容电感，这些毛刺将被完整的保留并向下一级传递，因此毛刺现象在 PLD、FPGA 设计中尤为突出。&lt;/p&gt;
&lt;p&gt;可以概括的讲，&lt;strong&gt;只要输入信号同时变化，（经过内部走线）组合逻辑必将产生毛刺。将它们的输出直接连接到时钟输入端、清零或置位端口的设计方法是错误的，这可能会导致严重的后果。所以我们必须检查设计中所有时钟、清零和置位等对毛刺敏感的输入端口，确保输入不会含有任何毛刺。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前所述，优秀的设计方案，如采用格雷码计数器，同步电路等，可以大大减少毛刺，但它并不能完全消除毛刺。 毛刺并不是对所有输入都有危害，例如 D 触发器的 D 输入端，只要毛刺不出现在时钟的上升沿并且满足数据的建立和保持时间，就不会对系统造成危害。因此我们可以说 D 触发器的 D 输入端对毛刺不敏感。但对于 D 触发器的时钟端，置位端，清零端，则都是对毛刺敏感的输入端，任何一点毛刺就会使系统出错，但只要认真处理，我们可以把危害降到最低直至消除。下面我们就对几种具体的信号进行探讨。&lt;/p&gt;
&lt;h3 id="clock"&gt;clock&lt;/h3&gt;
&lt;p&gt;时钟信号是系统中非常关键的信号，参见其他&lt;a href="http://guqian110.github.io/tag/clock-design.html"&gt;几篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="set/clear"&gt;set/clear&lt;/h3&gt;
&lt;p&gt;清除和置位信号要求象对待时钟那样小心地考虑它们，因为这些信号对毛刺也是非常敏感的。正如使用时钟那样，最好的清除和置位是从器件的引脚单直接地驱动。有一个主复位 Reset 引脚是常用的最好方法，主复位引脚给设计项目中每个触发器馈送清除或置位信号。几乎所有 PLD 器件都有专门的全局清零脚和全局置位。如果必须从器件内产生清除或置位信号，则要按照 &amp;ldquo; 门控时钟 &amp;rdquo; 的设计原则去建立这些信号，确保输入无毛刺。 &lt;/p&gt;
&lt;h3 id="combinational output"&gt;combinational output&lt;/h3&gt;
&lt;p&gt;当 PLD 输出引脚给出系统内其它部分的边沿敏感信号或电平敏感信号时，这些出信号必须象内部时钟、清除和置位信号一样小心地对待。只要可能就应在 PLD 输出端寄存那些对险象敏感的组合输出。如果你不能寄存险象敏感的输出，则应符合 &amp;ldquo; 门控时钟 &amp;rdquo; 中讨论的门控时钟的条件。决不能用多级逻辑驱动毛刺敏感的输出。&lt;/p&gt;
&lt;h3 id="asynchronous input"&gt;asynchronous input&lt;/h3&gt;
&lt;p&gt;对于异步输入信号导致的毛刺，解决思想就是 同步化。参见&lt;a href="http://guqian110.github.io/pages/2014/10/09/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html"&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref_1"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Hazard_(logic)"&gt;Hazard on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2883561/"&gt;Digital Design (4th Edition)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.fpga.com.cn/advance/glitch/giltch.htm"&gt;关于毛刺问题的探讨&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="hazard"></category><category term="glitch"></category></entry><entry><title>针对 Verilog 的 Doxygen</title><link href="https://qiangu.cool/posts/ic/doxygen_for_verilog.html" rel="alternate"></link><published>2015-01-21T10:25:00+08:00</published><updated>2015-01-21T10:25:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-01-21:/posts/ic/doxygen_for_verilog.html</id><summary type="html">&lt;p&gt;学习 Doxverilog。&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近学习了 Doxygen，它可以帮助我们生成美观的文档。Doxygen 支持的程序语言中包含 VHDL，但是不包含 Verilog。&lt;/p&gt;
&lt;p&gt;那么问题就又来了：&lt;strong&gt;有没有一个支持 Verilog 的类似 Doxygen 的程序？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案当然是：&lt;strong&gt;有， Doxverilog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;机智的网友早就遇到了和我一样的问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.edaboard.co.uk/documentation-generator-for-verilog-t241923.html"&gt;Documentation generator for Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sndegroot.blogspot.com/2011/08/documenting-verilog-ams-using.html"&gt;Documenting Verilog (AMS) using Doxygen/Doxverilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sndegroot.blogspot.com/2014/04/doxverilog-has-been-updated.html"&gt;Doxverilog has been updated&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我搜到了两个工具：一个是 perl 脚本&lt;a href="http://www.burbleland.com/v2html/v2html.html"&gt;v2html&lt;/a&gt;，另一个就是 Doxverilog。前者生成的页面美观性实在不敢恭维，理想工具当然是 Doxverilog。&lt;/p&gt;
&lt;h2 id="doxverilog"&gt;Doxverilog&lt;/h2&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxverilog  is a nativ verilog parser (Verilog 2001) for Doxygen. After installing this patch you can documentate your verilog project  similar to VHDL in Doxygen.
Patch against the doxygen-1.7.0 version. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Doxverilog 基于 Doxygen ，只是额外添加了对 Verilog 语言的支持。它托管在 &lt;a href="http://sourceforge.net/projects/doxverilog.berlios/"&gt;sourceforge&lt;/a&gt; 上的压缩包貌似是损坏的，不能正常解压，幸好在 Github 上的还是好的：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ewa/doxverilog/tree/master/Doxverilog2.7"&gt;Doxverilog on Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Doxverilog 的安装使用方法，github 上已经说的很清楚了，下面只记录一下我遇到的问题。&lt;/p&gt;
&lt;h3 id="installation"&gt;Installation&lt;/h3&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;patch&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;patch -F3 -p0  &amp;lt; linux.patch&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compile&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;./configure&lt;/span&gt;
&lt;span class="err"&gt;make&lt;/span&gt;
&lt;span class="err"&gt;make install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写本文时，Doxverilog 的版本号是 2.7，对应的 Doxygen 的版本号是 1.8.1，而 Doxygen 官网上的版本已经更新到了 1.8.9，如果最新版本可能在编译的时候报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 patch 时，可能会遇到询问，一路 y 下去即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 compile 时，可能会报错，我遇到的报错是 vhdlparse.cpp 缺少行末分号的小问题，自己添加就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译安装完成之后，我们应该可以使用一个文档来测试一下，如果生成的配置文件中包含 &lt;code&gt;OPTIMIZE_OUTPUT_VERILOG&lt;/code&gt; 这个选项，那么就说明破解安装成功了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="configuration"&gt;Configuration&lt;/h3&gt;
&lt;p&gt;在修改配置文档时，除了常规的配置选项之外，对于 Verilog 我们还需要额外注意一下几个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OPTIMIZE_OUTPUT_VERILOG = YES&lt;/code&gt; 针对 Verilog 进行输出优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FILE_PATTERNS = *.v&lt;/code&gt; 标明选择 verilog 源文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="documenting verilog/vhdl"&gt;Documenting Verilog/VHDL&lt;/h3&gt;
&lt;p&gt;注释规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于 Verilog 的注释规则，和 VHDL 类似，唯一的不同之处在于 VHDL 使用 &lt;code&gt;--!&lt;/code&gt; 来开始注释，Verilog 使用 &lt;code&gt;//%&lt;/code&gt; 作为注释的开头。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VHDL 中使用单行的 &lt;code&gt;--!&lt;/code&gt; 来开始 brief description，使用多行的 &lt;code&gt;--!&lt;/code&gt; 开始 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 使用单行的 &lt;code&gt;//%&lt;/code&gt; 开始 brief description，使用多行的 &lt;code&gt;//%&lt;/code&gt; 开始 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的注释都在对应代码的前面，只有一个例外：端口的 brie description 可以写在代码后，而且不用像 C++ 中一样修改注释的头部&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是 Doxygen 官网是 VHDL 注释的例子：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;-------------------------------------------------------&lt;/span&gt;
&lt;span class="c1"&gt;--! @file&lt;/span&gt;
&lt;span class="c1"&gt;--! @brief 2:1 Mux using with-select&lt;/span&gt;
&lt;span class="c1"&gt;-------------------------------------------------------&lt;/span&gt;

&lt;span class="c1"&gt;--! Use standard library&lt;/span&gt;
&lt;span class="k"&gt;library&lt;/span&gt; &lt;span class="nn"&gt;ieee&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;--! Use logic elements&lt;/span&gt;
    &lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;ieee.std_logic_1164.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--! Mux entity brief description&lt;/span&gt;

&lt;span class="c1"&gt;--! Detailed description of this &lt;/span&gt;
&lt;span class="c1"&gt;--! mux design element.&lt;/span&gt;
&lt;span class="k"&gt;entity&lt;/span&gt; &lt;span class="nc"&gt;mux_using_with&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
    &lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;din_0&lt;/span&gt;   &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;--! Mux first input&lt;/span&gt;
        &lt;span class="n"&gt;din_1&lt;/span&gt;   &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;--! Mux Second input&lt;/span&gt;
        &lt;span class="n"&gt;sel&lt;/span&gt;     &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;  &lt;span class="kt"&gt;std_logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;--! Select input&lt;/span&gt;
        &lt;span class="n"&gt;mux_out&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;out&lt;/span&gt; &lt;span class="kt"&gt;std_logic&lt;/span&gt;  &lt;span class="c1"&gt;--! Mux output&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--! @brief Architecture definition of the MUX&lt;/span&gt;
&lt;span class="c1"&gt;--! @details More details about this mux element.&lt;/span&gt;
&lt;span class="k"&gt;architecture&lt;/span&gt; &lt;span class="nc"&gt;behavior&lt;/span&gt; &lt;span class="k"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;mux_using_with&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;
    &lt;span class="n"&gt;mux_out&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din_0&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="sc"&gt;'0'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="n"&gt;din_1&lt;/span&gt; &lt;span class="k"&gt;when&lt;/span&gt; &lt;span class="k"&gt;others&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt; &lt;span class="k"&gt;architecture&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;生成的 &lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/examples/mux/html/index.html"&gt;结果&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我写的 Verilog 的注释：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//% @file mycounter.v&lt;/span&gt;
&lt;span class="c1"&gt;//% @brief Implementation file of module mycounter.&lt;/span&gt;
&lt;span class="c1"&gt;//% &lt;/span&gt;
&lt;span class="c1"&gt;//% @author Qian Gu&lt;/span&gt;
&lt;span class="c1"&gt;//% @version 1.0&lt;/span&gt;
&lt;span class="c1"&gt;//% @date 2015-01-20&lt;/span&gt;

&lt;span class="c1"&gt;//% This is a test project,&lt;/span&gt;
&lt;span class="c1"&gt;//% it's a increase counter module 256.&lt;/span&gt;
&lt;span class="c1"&gt;//%&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;mycounter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;
 &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Port Declaratiosn&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//% clock signal&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//% reset siganl, active high&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//% count result&lt;/span&gt;

&lt;span class="c1"&gt;// Main Body of Code&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref_1"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#vhdlblocks"&gt;doxygen manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ewa/doxverilog/tree/master/Doxverilog2.7"&gt;doxverilog&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="doxygen"></category><category term="doxverilog"></category><category term="verilog"></category></entry><entry><title>利用 Graphviz 画 FSM 状态图</title><link href="https://qiangu.cool/posts/ic/drawing_fsm_state_diagram_using_graphviz.html" rel="alternate"></link><published>2015-01-20T17:55:00+08:00</published><updated>2015-01-20T17:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2015-01-20:/posts/ic/drawing_fsm_state_diagram_using_graphviz.html</id><summary type="html">&lt;p&gt;学习使用 Graphviz 画 FSM 的状态转移图&lt;/p&gt;</summary><content type="html">&lt;h2 id="graphviz"&gt;Graphviz&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Graphviz 是一个由 AT&amp;amp;T 实验室启动的开源工具包，用于绘制 DOT 语言脚本描述的图形。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Graphviz"&gt;wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Graphviz (short for Graph Visualization Software) is a package of open-source tools initiated by AT&amp;amp;T Labs Research for drawing graphs specified in DOT language scripts. It also provides libraries for software applications to use the tools. Graphviz is free software licensed under the Eclipse Public License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据介绍，我们知道 Graphviz 基于一种叫做 DOT 的图形描述语言，Graphviz 由一组可以处理 DOT 文件的工具组成，最终生成图形。&lt;/p&gt;
&lt;p&gt;既然是画图，那么问题就来了：很多软件都可以画图，&lt;strong&gt;为什么偏偏要用 Graphviz 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不用鼠标绘制，也不用手动调整坐标。使用 Visio 或者其他的画图工具的人都体验过手动对齐的不便，而且很多时候手动调整根本就对不齐，强迫症患者心中永远的痛 T_T&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改更新方便。手绘的图修改起来很麻烦，而使用 DOT 语言的话，只需要修改脚本就 Ok 了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 的缺点：要想用好，需要投入时间和精力去学习使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Graphviz 可以帮助我们画数据结构图、模块图、流程图等，是程序猿的画图利器。这里我们只用它来画简单的 流程图 / 状态图 ，所以只要有基本的图论知识，不涉及高级主题，所以学习起来是很轻松的。&lt;/p&gt;
&lt;p&gt;因为在&lt;a href="http://guqian110.github.io/pages/2015/01/11/how_to_analyse_code_elegantly.html"&gt;前面一篇博客&lt;/a&gt;中我们已经简单介绍了 &lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt; 这个工具软件的安装方法，所以下面直接进入正题：&lt;strong&gt;如何使用 Graphviz 画 FSM 的状态转移图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;下面的内容是我精简出来了的最小学习方法，使用方法的详细攻略请看 Graphviz 官网上的 &lt;a href="http://www.graphviz.org/Documentation.php"&gt;Documentation&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="dot"&gt;DOT&lt;/h3&gt;
&lt;p&gt;DOT 语法在 &lt;a href="http://www.graphviz.org/Documentation.php"&gt;Documentation&lt;/a&gt; 里面有介绍，它的定义方法和 C/C++ 中的 &lt;code&gt;struct&lt;/code&gt; 类似。由图论的基本知识，我们知道描述一个图，只要用节点（&lt;code&gt;node&lt;/code&gt;)、边（&lt;code&gt;edge&lt;/code&gt;） 这两个要素就能描述清楚，而 DOT 语言也就是利用这两个信息来描述一个图的。下面用几个基本的例子来说明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 3 个节点组成的一个无向图。
脚本（example1.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;graph example1 {&lt;/span&gt;
&lt;span class="err"&gt;    node1 -- node2&lt;/span&gt;
&lt;span class="err"&gt;    node2 -- node3&lt;/span&gt;
&lt;span class="err"&gt;    node3 -- node4&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example1" src="/images/drawing-fsm-state-diagram-using-graphviz/example1.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是上面的例子，不过修改为有向图。&lt;/p&gt;
&lt;p&gt;脚本（example2.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;digraph example2 {&lt;/span&gt;
&lt;span class="err"&gt;    node1 -&amp;gt; node2&lt;/span&gt;
&lt;span class="err"&gt;    node2 -&amp;gt; node3&lt;/span&gt;
&lt;span class="err"&gt;    node3 -&amp;gt; nod31&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example2" src="/images/drawing-fsm-state-diagram-using-graphviz/example2.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们还可以控制 node 的属性（节点形状、颜色、边箭头的形状等），来产生不同的结果。&lt;/p&gt;
&lt;p&gt;脚本（example3.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;digraph&lt;/span&gt; &lt;span class="n"&gt;example3&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node2&lt;/span&gt;
    &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node3&lt;/span&gt;
    &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node1&lt;/span&gt;

    &lt;span class="n"&gt;node1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;circle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="ss"&gt;"state1"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fillcolor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"#123456"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;filled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;node2&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;triangle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="ss"&gt;"state2"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fillcolor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"#345678"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;filled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;node3&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="ss"&gt;"state3"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fillcolor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"#567890"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;unfilled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example3" src="/images/drawing-fsm-state-diagram-using-graphviz/example3.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的结果和我们的状态转移图相比，还差一点就是转移箭头边上的标注，我们可以在 edge 后面加上 &lt;code&gt;label&lt;/code&gt; 属性来标注信息。&lt;/p&gt;
&lt;p&gt;脚本（example4.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;digraph example4 {&lt;/span&gt;
&lt;span class="err"&gt;    node1 -&amp;gt; node2 [label = "condition1"]&lt;/span&gt;
&lt;span class="err"&gt;    node2 -&amp;gt; node3 [label = "condition2"]&lt;/span&gt;
&lt;span class="err"&gt;    node3 -&amp;gt; node1 [label = "condition3"]&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example4" src="/images/drawing-fsm-state-diagram-using-graphviz/example4.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的 4 个例子就足够我们画 FSM 的状态转移图了。更加详细的说明参考官方文档和一篇文章：&lt;a href="http://www.openfoundry.org/en/foss-programs/8820-graphviz-"&gt;Graphviz - 用指令來畫關係圖吧！&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="command"&gt;Command&lt;/h3&gt;
&lt;p&gt;Graphviz 的命令格式为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;cmd&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，cmd 可以是它包含的几个工具 &lt;code&gt;dot&lt;/code&gt;、&lt;code&gt;neato&lt;/code&gt;、&lt;code&gt;circo&lt;/code&gt;、&lt;code&gt;fdp&lt;/code&gt;、&lt;code&gt;osage&lt;/code&gt;、&lt;code&gt;sfdp&lt;/code&gt;、&lt;code&gt;twopi&lt;/code&gt;，我们可以查看 man &lt;cmd&gt; 来看它们的区别，也可以直接运行看结果中的区别。&lt;/cmd&gt;&lt;/p&gt;
&lt;p&gt;其中，flags 可以设置相关属性，比如 &lt;code&gt;-Tformat&lt;/code&gt;，如果我们需要产生 PNG 图片，那么这里就应该是 &lt;code&gt;-Tpng&lt;/code&gt;；再比如 &lt;code&gt;-o&lt;/code&gt; 设置输出目的地。&lt;/p&gt;
&lt;p&gt;所以我们上面 example1 的命令格式为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;dot example1.dot -Tpng -o exampl1.png&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;example2，example3，exampl4 同理。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="example_1"&gt;Example&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;下面是实际程序中的一个例子：&lt;/p&gt;
&lt;p&gt;dot 脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;digraph fsm {                                                               &lt;/span&gt;
&lt;span class="err"&gt;       "a" -&amp;gt; "a" [label= "0/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "a" -&amp;gt; "b" [label= "1/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "b" -&amp;gt; "c" [label= "0/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "b" -&amp;gt; "d" [label= "1/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "c" -&amp;gt; "a" [label= "0/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "c" -&amp;gt; "d" [label= "1/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "d" -&amp;gt; "e" [label= "0/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "d" -&amp;gt; "f" [label= "1/1"]&lt;/span&gt;
&lt;span class="err"&gt;       "e" -&amp;gt; "a" [label= "0/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "e" -&amp;gt; "f" [label= "1/1"]&lt;/span&gt;
&lt;span class="err"&gt;       "f" -&amp;gt; "f" [label= "1/1"]&lt;/span&gt;
&lt;span class="err"&gt;       "f" -&amp;gt; "g" [label= "0/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "g" -&amp;gt; "a" [label= "0/0"]&lt;/span&gt;
&lt;span class="err"&gt;       "g" -&amp;gt; "f" [label= "1/1"]&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 dot 生成的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fsm_dot" src="/images/drawing-fsm-state-diagram-using-graphviz/fsm_dot.png"/&gt;&lt;/p&gt;
&lt;p&gt;使用 circo 生成的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fsm_circo" src="/images/drawing-fsm-state-diagram-using-graphviz/fsm_circo.png"/&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/aix/library/au-aix-graphviz/"&gt;使用 Graphviz 生成自动化系统图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.openfoundry.org/en/foss-programs/8820-graphviz-"&gt;Graphviz - 用指令來畫關係圖吧！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.163.com/prevBlogPerma.do?host=lockriver&amp;amp;srl=487232242010101761749383&amp;amp;mode=prev"&gt;Graphviz 使用简介 ( 中文乱码的问题 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://gary-digital.blogspot.com/2006/08/dot.html"&gt;使用 DOT 來描述你的狀態機&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="fsm"></category><category term="graphviz"></category></entry><entry><title>FPGA 中的延时</title><link href="https://qiangu.cool/posts/ic/delay_in_fpgas.html" rel="alternate"></link><published>2014-11-23T14:03:00+08:00</published><updated>2014-11-23T14:03:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-11-23:/posts/ic/delay_in_fpgas.html</id><summary type="html">&lt;p&gt;总结电路中的时延及其 FPGA 中的实现&lt;/p&gt;</summary><content type="html">&lt;h2 id="delay in circuits"&gt;Delay in circuits&lt;/h2&gt;
&lt;p&gt;从模拟电路的知识，我们可以知道 &lt;strong&gt;电路中存在很多类型不同的延时。&lt;/strong&gt; 比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;propagation delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们通常假设信号在电平之间变化时瞬间完成的，但是实际情况并不是瞬间完成，电路需要花费一段时间才能完成电平的转化。晶体管的开关特性对于不同的变化有不同的表现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上升延时 (&lt;code&gt;rising delay&lt;/code&gt;)，输出变为 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下降延时 (&lt;code&gt;falling delay&lt;/code&gt;)，输出变为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭延时 (&lt;code&gt;turn-off delay&lt;/code&gt;)，输出变为高阻 Z&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出变为 X 的时延&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因就是（&lt;a href="http://www.amazon.cn/Digital-Design-An-Embedded-Systems-Approach-Using-Verilog-Ashenden-Peter-J/dp/0123695279"&gt;Digital Design (Verilog): An Embedded Systems Approach Using Verilog&lt;/a&gt;）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One factor that causes signal changes to occur over a nonzero time
interval is the fact that the switches in the output stage of a digital component, illustrated in Figure 1.15, do not open or close instantaneously. Rather, their resistance changes between near zero and a very large value over some time interval. However, a more significant factor, especially in CMOS circuits, is the fact that logic gates have a significant amount of capacitance at each input.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个答案也解释了为什么在设计中要避免大扇出信号：因为大扇出意味着输出端并联着很多电容，电容负载较大时造成连接信号转换相对较慢的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The total capacitive load is thus the sum of the individual capacitive loads. The effect is to make transitions on the connecting signal correspondingly slower. For CMOS components, this effect is much more significant than the static load of component inputs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以把对晶体管的讨论推广到其他的数字元件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A similar argument regarding time taken to switch transistors on and off and to charge and discharge capacitance also applies within a digital component. Without going into the details of a component&amp;rsquo;s circuit, we can summarize the argument by saying that, due to the switching time of the internal transistors, it takes some time for a change of logic level at an input to cause a corresponding change at the output. We call that time the &lt;code&gt;propagation delay&lt;/code&gt;, denoted by &lt;code&gt;tpd&lt;/code&gt;, of the component.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;wire delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外一种延时是信号在导线上传播时产生的延时，一般我们都把这种延时假设也 0，也就是说导线时理想的导体，信号经由导线的传输没有任何延迟。如果导线很短，或者芯片上不超过 1mm 的导线来说，这种假设是合理的。但是当设计高速电路时，不能忽略这种导线存在的寄生电容和电感，这时候导线应该被视为传输线，必须精心设计。&lt;/p&gt;
&lt;p&gt;至于如何设计应该属于模拟电路的部分，这里不讨论。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于上面的两种延时，&lt;a href="http://www.amazon.com/FPGA-Based-System-paperback-Prentice-Semiconductor/dp/0137033486"&gt;FPGA-Based System Design&lt;/a&gt; 里面有详细讨论如何建模、如何计算具体时延的值。&lt;/p&gt;
&lt;p&gt;即使对于同一种信号跳变，延时也分为不同的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最小值 (&lt;code&gt;minimum&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型值 (&lt;code&gt;typical&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大值 (&lt;code&gt;maximum&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="models in verilog hdl"&gt;Models in Verilog HDL&lt;/h2&gt;
&lt;p&gt;为了对电路中的时延现象进行建模，Verilog HDL 定义了延时语法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于上升、下降、关闭时延，可以使用逗号按照顺序将三者分开：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;A_xor_wire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eq0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;A_xor_wire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eq0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;第一句表示一个异或门上升时延为 1，下降时延为 2，关闭和 X 时延为两者中的最小值，即 1；&lt;/p&gt;
&lt;p&gt;第二句表示一个异或门的上升、下降、关闭时延分别是 1，2，3，X 时延为 3 者中的最小值，即 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于最小值、典型值、最大值可以使用分号按照 min:typ:max 的顺序，将 3 者分开：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;assgin&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;A_xor_wire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eq0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;表示上升时延的 min:typ:max = 2:3:4，下降时延的 min:typ:max = 3:4:5。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意到一点是，&lt;strong&gt;当延时出现在 wire 信号的定义处时，会和普通的赋值语句中的延时稍有不同。&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt; &lt;span class="n"&gt;wireA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这个叫做 &lt;code&gt;net delay&lt;/code&gt;，它是和 wireA 绑定的，对 wireA 进行的任何赋值必须延迟 10 个时间单位之后才有效。当在连续赋值语句中，延时是属于连续赋值语句的一部分，而不属于 net，所以只在这一句中有效，对其他赋值语句没有影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般来说，assign 语句中的延时特性会被综合工具忽略。&lt;/strong&gt;因为综合工具需要完成的功能就是将代码描述映射为逻辑电路，而逻辑电路中的延时是由最基本的单元库和走线延时决定的，用户是无法对逻辑单元指定延时长度的，只能在综合、实现时添加时序约束条件，使工具尽量满足要求。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="implement"&gt;Implement&lt;/h2&gt;
&lt;p&gt;Verilog HDL 中的延时语法不可综合并不代表就不能在实际电路中实现延时。&lt;/p&gt;
&lt;p&gt;在实际电路中，不同的情况下需要采用不同的方法来实现延时：一般来说，异步电路的时延通过门延时来完成，比较难预测，而同步电路的时延通过触发器或者计数器来实现。&lt;/p&gt;
&lt;h3 id="in asics"&gt;in ASICs&lt;/h3&gt;
&lt;p&gt;在早期的逻辑电路图设计阶段，有且设计者养成了手工加入 Buffer 或者非门调整数据
延时的习惯，以保证本级模块的时钟对上级模块数据的建立及保持时间的要求。这些做法目
前主要应用于两种场合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分离电路&lt;/p&gt;
&lt;p&gt;使用分立逻辑单元（如 74 系列）搭建数字电路一般为复杂度比较低、系统灵活性比较低的场合。使用分立元件时，由于可以使用的元件比较少，而且一般设计频率比较低，时序裕量比较大，所以采用 Buffer、非门等单元来调整时延时可以接受的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ASIC 领域&lt;/p&gt;
&lt;p&gt;在 ASIC 中采用这种方法，是以严格的仿真和时序约束为前提的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="in fpgas"&gt;in FPGAs&lt;/h3&gt;
&lt;p&gt;在 ASIC 中采用的添加 Buffer、非门的设计方法并不适合 FPGA/CPLD 等可编程逻辑，在 FPGA 中应该尽量避免这种设计。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Delay chains occur when two or more consecutive nodes with a single fan-in and a single fan-out are used to cause delay. Often inverters are chained together to add delay. Delay chains generally result from asynchronous design practices, and are sometimes used to resolve race conditions created by other combinational logic. In both FPGA and ASIC, delays can change with each place-and-route. Delay
chains can cause various design problems, including an increase in a design&amp;rsquo;s sensitivity to operating conditions, a decrease in a design&amp;rsquo;s reliability, and difficulties when migrating to different device architecture. &lt;strong&gt;Avoid using delay chains in a design, rely on synchronous practices instead.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结下来主要就是 3 个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计的可靠度低&lt;/p&gt;
&lt;p&gt;Buffer、非门都是组合逻辑，组合逻辑最大的问题就是容易出现毛刺，电路可靠度不高，这种方法的时序裕量小，对环境敏感（特别是温度），一旦外界环境发生变化，时序可能就会完全紊乱、导致电路瘫痪。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计的移植难度大&lt;/p&gt;
&lt;p&gt;一旦芯片换代，或者需要将设计移植到不同的器件上时，就必须对延时进行重新调整，电路的可维护性和扩展性差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号通过多级非门时，综合器可能会将其优化掉。&lt;/p&gt;
&lt;p&gt;虽然可以在代码中添加约束，防止综合器将其优化掉，但是不推荐这种方法，理由见前两条。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Xilinx-FPGA%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%B1%A4%E7%90%A6/dp/B007TLVUT8"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt; 介绍了 FPGA 中应该采用的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;专门的延时器件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 FPGA/CPLD 内部延时电路结构由一种标准的宏单元描述。虽然各家芯片的宏单元描述不同，但总的来说都是 &lt;strong&gt;一些逻辑 + 一个 / 两个触发器构成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Altera FPGA 中可以对信号加一个或多个 LCELL 来产生一个延时。（Xilinx 的没有查到 ...）&lt;/p&gt;
&lt;p&gt;虽然厂家提供了延时单元，但是这种延时并不稳定，会随着外界环境（比如温度）的变化而变化，所以并不提倡这种方法。&lt;/p&gt;
&lt;p&gt;网上有人讨论这种方法的应用：&lt;a href="http://bbs.eccn.com/viewthread.php?tid=181856"&gt;fpga 内部的延时单元&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;触发器 or 计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果延时相对较小，可以使用高频时钟来驱动一个移位寄存器，将待延时的信号当作输入，按照需要的延时来设置移位寄存器的级数，最后的输出即延时的结果。&lt;/p&gt;
&lt;p&gt;如果延时相对较大，可以使用计数器来延时输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;====================== Update 01/31/2015 ========================&lt;/p&gt;
&lt;h2 id="simulation_1"&gt;Simulation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;我们知道，仿真器使用 &amp;ldquo; 事件 &amp;rdquo; (&lt;code&gt;event&lt;/code&gt;) 来模拟实际的电路行为，但是毕竟软件和硬件还是不同的，而 Verilog 语言又是很灵活的，如果不加注意，很可能不能对电路进行正确的建模。Clifford E. Cummings 大神写了一篇 paper 介绍了 Verilog HDL 中应该如何正确使用延时，才能保证建模的正确性：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON1999_BehavioralDelays_Rev1_1.pdf"&gt;Correct Methods For Adding Delays To Verilog Behavioral Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我的笔记，摘录一部分内容和结论：&lt;/p&gt;
&lt;p&gt;要讨论正确的延时的代码风格，首先要了解仿真器在对延时进行建模时，通常使用的两种不同类型的 Delay 模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Inertial delay&lt;/code&gt; 模型 
    惯性时延，专门描述一些特殊信号传播到输出端口所耗费的时延，这部分信号特殊在于：输入信号必须保持稳定一段时间（等于或大于传播时延）。如果输入信号的变化时间间隔小于过程赋值延时 / 连续赋值延时 / 门延时（也就是说在计算出一个结果并且还没有来得及输出，输入信号又发生了变化），那么前一时刻值的旧事件会被新值的事件代替，重新触发计算，并输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Transport delay&lt;/code&gt; 模型&lt;/p&gt;
&lt;p&gt;传播时延，用来描述当任何一个输入信号一旦发生变化后，所有信号到输出的延时。所有的输出变化值会按照顺序排队输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;有了上面两个延时的概念之后，我们就可以分类讨论下面三种情况下应该如何添加延时了。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="blocking assignment"&gt;Blocking assignment&lt;/h3&gt;
&lt;p&gt;在阻塞赋值中，通常添加延时的方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;left-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是这两种方法都有可能存在问题：&lt;/p&gt;
&lt;p&gt;以描述一个输出延迟为 12ns 的加法器，如果我们在左边添加延时，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在下图时序中可以看到，当 t = 15 时，a 发生变化，触发 always 块，模块计算新的求和结果。但是，在接下来的 t = 15 ~ 24 内，a、b、ci 分别发生了变化，所以当从触发开始，到 12ns 过后该输出结果时，计算结果的值使用的是当前最新的值（可以看到，ci 的变化和输出之间仅仅有 3ns &amp;lt; 12ns），而非触发时刻的值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing1" src="/images/delay-in-fpgas/timing1.png"/&gt;&lt;/p&gt;
&lt;p&gt;事实上，在任何阻塞赋值的左边添加延时都会存在类似的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the LHS of blocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; placing delays on the LHS of blocking assignments in a testbench is reasonable since the delay is just being used to time-space sequential input stimuls events.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们在右边添加延时，同样也会有问题。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;假设在 t = 15 时刻，a 发生变化，触发 always 块，模块会对当前的值进行采样，并且在 12ns 之后将采样结果输出，而在这 12ns 期间，输入端的任何变化都会被忽略，这意味着错误的旧值会一直保持下去，直到有新的变化重新触发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the RHS of blocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; do not place delays on the RHS of blocking assignments in a testbench.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;General Guideline:&lt;/strong&gt; placing a delay on the RHS of any blocking assignment is both confusing and a poor coding style. This Verilog coding practice should be avoided.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="non-blocking assignment"&gt;Non-blocking assignment&lt;/h3&gt;
&lt;p&gt;在非阻塞赋值中，同样有两种方法来添加延时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;left-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right-hand-side&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;仍然使用上面加法器的例子，如果我们在左边添加延时，会和阻塞赋值存在一样的问题：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;当 t = 15 时，触发 always 块，但是输出时结果时，使用的是最新时刻的值。&lt;/p&gt;
&lt;p&gt;事实上，在任何非阻塞赋值的左边添加延时都会存在类似的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the LHS of nonblocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; nonblocking assignments are less efficient to simulate than blocking assignments; therefore, in general, placing delays on the LHS of nonblocking assignments for either modeling or testbench generation is discouraged.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在非阻塞赋值的右边添加延时，会准确地描述前面介绍的 &lt;code&gt;transport delays&lt;/code&gt;：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;当 t = 15 时刻，a 发生变化触发 always 块，此时会立刻对输入进行采样，然后等待 12ns 之后输出；在将这一时间存放在时间队列之后，always 块会被下一个变化时间重新触发，这意味着输出会随着输入的变化在 12ns 之后变化，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing2" src="/images/delay-in-fpgas/timing2.png"/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recommended Application:&lt;/strong&gt; Use this coding style to model behavioral delay-line logic.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; place delays on the RHS of nonblocking assignments only when trying to model transport output-prapagation behavior. This coding style will accurately model delay lines and combinational logic with pure &lt;code&gt;transport delays&lt;/code&gt;; however, this coding style generally causes slower simulations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; This coding style is ofen used in testbenches when stimulus must be scheduled on future clock edges or after a set delay, while not blocking the assignment of subsequent stimulus events in the same procedural blocks,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; in general, do not place delays on the RHS of nonblocking assignments to model &lt;em&gt;combinational logic&lt;/em&gt;. This coding style can be confusing and is not very simulation efficient. It is a common and sometimes useful practice to palce delays n the RHS of nonblocking assignments to model clock-to-output behavior on &lt;em&gt;sequential logic&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; there are some multi-clock design verification suites that benefit from using multiple nonblocking assignments with RHS delays; however, this coding style can be confusing, therefore placing delays on the RHS of nonblocking assignments in testbenches is not generally recommended.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="continuous assignment"&gt;Continuous assignment&lt;/h3&gt;
&lt;p&gt;连续赋值语句中，只能在左侧添加延时，在右边添加延时是非法的：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在连续赋值语句的左边添加延时，会准确描述惯性延时（&lt;code&gt;inertial delay&lt;/code&gt;），一般推荐使用这种方式。&lt;/p&gt;
&lt;p&gt;以上面的加法器为例：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;如下图，在 t = 15 时刻，a 发生变化触发 assign 语句，应该在 t = 27 时刻输出结果，但是在 t = 17, 19, 21 时刻，a，b 分别发生了变化，这会导致有 3 个新的值，最终会只输出最后一个值（在 t = 21 + 12 = 33 时刻）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing3" src="/images/delay-in-fpgas/timing3.png"/&gt;&lt;/p&gt;
&lt;p&gt;因为连续赋值语句不会排队输出这个概念，它只会跟踪输出结果，所以，连续赋值语句中的延时是对惯性延时（&lt;code&gt;inertial delay&lt;/code&gt;）的建模。&lt;/p&gt;
&lt;p&gt;混合方式：无延时的 always 块 + 连续赋值语句&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;仍然会准确描述组合逻辑中的 inertial delay。在每个输入变化时，tmp 的值都会改变，在 tmp 改变的 12ns 之后，连续赋值的输出发生变化。tmp 一旦发生变化，assign 会重新赋值，重新延时，所以这种方式会准确描述组合逻辑的 inertial delay。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guide:&lt;/strong&gt; Use continuous assignments with delays to model simple combinational logic. This coding style will accurately model combinational logic with inertial delays.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guide:&lt;/strong&gt; Use always blocks with no delays to model complex combinational logic that are more easily rendered sing Verilog behavroral constructs such as "case-casez-casex", "if-else", etc. The outputs from the no-delay always blocks can be driven into continuous assignments to apply behavioral delays to the models. This coding style will accurately model complex combinational logic with inertial delays.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; Continuous assignments can be used anywhere in a testbench to drive stimulus values onto input port and bi-directional port and bi-directional ports of instantiated models.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="conclusions"&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;always 块中的任何延时都无法准确对真实硬件的行为进行准确建模，应该避免这种延时建模。有一个例外：在非阻塞复制的右边添加延时，来描述 transport delay，但是这种方式是以仿真性能的下降为代价的。&lt;/p&gt;
&lt;p&gt;在 连续赋值语句 / 无延时的 always + 连续赋值语句 中添加延时，这两种方式都会对 inertial delays 建模，推荐使用这种方式来对组合逻辑建模。&lt;/p&gt;
&lt;h2 id="reference_1"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Digital-Design-An-Embedded-Systems-Approach-Using-Verilog-Ashenden-Peter-J/dp/0123695279"&gt;Digital Design (Verilog): An Embedded Systems Approach Using Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Based-System-paperback-Prentice-Semiconductor/dp/0137033486"&gt;FPGA-Based System Design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1882474/"&gt;设计与验证 Verilog HDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Xilinx-FPGA%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%B1%A4%E7%90%A6/dp/B007TLVUT8"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture: Design Methods and Techniques for Digital Circuits&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="delay"></category></entry><entry><title>计数器设计小结</title><link href="https://qiangu.cool/posts/ic/counter_design_summary.html" rel="alternate"></link><published>2014-11-04T20:40:00+08:00</published><updated>2014-11-04T20:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-11-04:/posts/ic/counter_design_summary.html</id><summary type="html">&lt;p&gt;总结 FPGA 中的计数器设计&lt;/p&gt;</summary><content type="html">&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;计数器 在数字电路设计 和 计算机程序设计 中都应用非常广泛，其功能顾名思义，就是用来计数。这里只讨论数字电路设计中的计数器。&lt;/p&gt;
&lt;p&gt;通常，将包含触发器 flip-flop 的电路（即使含有组合电路部分）认为是时序电路。时序电路通常不以电路命名，而是以功能进行分类，分别是 &lt;strong&gt;寄存器&lt;/strong&gt; 和 &lt;strong&gt;计数器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;计数器 &lt;a href="http://en.wikipedia.org/wiki/Counter"&gt;counter&lt;/a&gt; 从本质上来说也是寄存器，不过它是在预先设定好的状态序列中转移，尽管计数器是寄存器的一种特殊形式，通常还是以不同的名称来加以区分。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="type"&gt;Type&lt;/h2&gt;
&lt;p&gt;按照不同的标准来划分，计数器可以有不同的划分方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;触发方式&lt;/p&gt;
&lt;p&gt;同步 / 异步 计数器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数增减&lt;/p&gt;
&lt;p&gt;加法 / 减法 / 可逆计数器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为第二种方法没有明确显示计数器的计数方式，所以一般使用第一种方法。&lt;/p&gt;
&lt;p&gt;这里总结了一些常见的计数器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Basic Binary Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BCD Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ring Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Johnson Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ripple Counter&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计数器在数字电路中的用途非常广，可以作为定时器、实用计数器、状态机等。在具体实现时，有前面总结的不同的计数器类型可供选择，每种计数器由其特点决定了适用场合，我们要做到就是在不同计数器类型和配置之间进行权衡，选择正确的设计，以节省大量逻辑资源，并提高性能。&lt;/p&gt;
&lt;p&gt;下面分别讨论各种计数器的特点和 HDL 实现。&lt;/p&gt;
&lt;h2 id="implement"&gt;Implement&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="binary counter"&gt;Binary Counter&lt;/h3&gt;
&lt;p&gt;最简单、最基本的计数器就是 二进制计数器 Binary Counter。它的计数方式就是从 0 开始每个脉冲进行 &amp;ldquo;+1&amp;rdquo; 操作，直到最大值，然后重新从 0 开始。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Prototyping-Verilog-Examples-Spartan-3/dp/0470185325"&gt;FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version&lt;/a&gt; 里面有个例子，这里稍作修改就可以当作通用模块，供其他模块调用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;free_run_bin_counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;                     &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;                     &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;               &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// count&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;  &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;// max_tick&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;}})&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="bcd counter (mod-m counter)"&gt;BCD Counter (mod-m counter)&lt;/h3&gt;
&lt;p&gt;人类更习惯使用十进制进行计数，十进制一共有 10 个符号，我们只需要从 4 bit 的二进制计数器中选取 10 个数字，只使用这 10 个数字进行计数即可，通常去掉 1010 ~ 1111 这 6 个数字，即使用 8421BCD 码 来对十进制数进行编码、计数，即 BCD Counter。&lt;/p&gt;
&lt;p&gt;将十进制进行推广，我们就可以写出任意的 模 m 的计数器，在下面的例子中，M 表示计数器的模值（默认为 10），N 表示计数器需要的位数（默认为 4）。在例化时如果要修改，则需要手动计算这两个参数进行赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;bcd_counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// number of bits in counter&lt;/span&gt;
                &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// mod-M&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;                 &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="ring counter"&gt;Ring Counter&lt;/h3&gt;
&lt;p&gt;基于线性移位寄存器 &lt;a href="http://en.wikipedia.org/wiki/Linear_feedback_shift_register"&gt;&lt;code&gt;LFSR&lt;/code&gt; (Linear feedback shift register) &lt;/a&gt; 可以衍生出两种计数器：&lt;a href="http://en.wikipedia.org/wiki/Ring_counter"&gt;环形计数器 (ring counter)&lt;/a&gt; 和 扭环计数器（约翰逊计数器）。&lt;/p&gt;
&lt;p&gt;将 LFSR 中存储的数字设置为独热码的形式，即只有一位为 1，其他位为 0。然后把最后一级的输出直接反馈到第一级的输入，这样，输入和输出组成了一个环形，所以称为 环形计数器。4 bit 的环形计数器电路图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ring counter" src="/images/counter-design-summary/ring_counter.png"/&gt;&lt;/p&gt;
&lt;p&gt;(ref: http://electronics-course.com/ring-counter)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;相比于 binary counter，ring counter 不需要后者必需的加法器来实现计数，所以它在电路上占用的资源要更少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为没有额外的加法器，所以 ring counter 也不存在加法器带来的进位时延，它的最大时延是固定值，和计数器的模值无关。所以它的时序性能也比 binary counter 好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 ring counter 的汉明距离为 2，所以它可以检查单比特翻转的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Disadv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ring counter 最大的缺点就是它的低密度码，同样适用 N 个寄存器，binary counter 可以计数到 2^N，而 ring counter 只能计数到 N，经过改良后的 Johnson counter 也才能到 2N。所以，如果寄存器比组合逻辑更加珍贵的情况下，不适合使用 ring counter。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;ring_counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;                 &lt;span class="n"&gt;max_tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;    &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]};&lt;/span&gt;    &lt;span class="c1"&gt;// right shift&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="johnson counter"&gt;Johnson Counter&lt;/h3&gt;
&lt;p&gt;在 ring counter 的反馈链路中加入一个反相器，就好象把一个环扭了一下，所以称为 扭环计数器 (Johnson Counter)&lt;/p&gt;
&lt;p&gt;4 bit 的 Johnson Counter 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="johnson counter" src="http://upload.wikimedia.org/wikipedia/commons/e/e8/JohnsonCounter2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大的优点就是它可以计数的范围和 ring counter 相比，扩大了一倍，达到了 2N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大的缺点就是一旦它进入了错误状态，则永远无法返回到正确状态，除非外界干预。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，将前面例子第 行的反馈语句修改一下，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]};&lt;/span&gt;    &lt;span class="c1"&gt;// right shift&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;同时，计数器的终点也要进行相应的修改，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;max_tick&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="ripple counter"&gt;Ripple Counter&lt;/h3&gt;
&lt;p&gt;前面总结的这些计数器都是同步计数器，组成它们的 flip-flop 是由同一个脉冲信号触发的。还有一种计数器是异步计数器，它内部的 flip-flop 不是由同一个脉冲信号触发的。由于 FPGA 特殊的结构原因，在 FPGA 中应该使用同步设计，所以一般 FPGA 不会使用这种计数器。&lt;/p&gt;
&lt;p&gt;ripple counter 的每个 flip-flop 使用前一级的 flip-flop 的输出信号作为触发信号，所以后一级的触发器必须等到前一级的触发器输出之后才能工作，所以对于一个长度为 N 的触发器链，从输入时间开始，要等 N 个触发器依次工作完之后才能输出有效结果。&lt;/p&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ripple counter" src="/images/counter-design-summary/ripple_counter.png"/&gt;&lt;/p&gt;
&lt;p&gt;(ref: http://www.eecs.tufts.edu/~dsculley/tutorial/flopsandcounters/flops6.html)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面积小（不需要电路来实现 &amp;ldquo;+1&amp;rdquo; 功能）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功率少（因为面积小）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以在一些对面积、成本、功率敏感的应用中，ripple counter 很有用。比如：一个电子时钟，因为秒 s 对于纳秒 ns 来说是很缓慢的，所以可以忍受这种累积误差的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 flip-flop 不是同时触发的，每个 flip-flop 的时延会累积到输出，当所有的时延累积到一起，有时候（很长的 flip-flop 级联在一起）相对于时钟信号而言，就不能忽略这种时延了，严重时会导致系统出错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码在&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Hdl-Chip-Design-Synthesizing-Simulating/dp/0965193438"&gt;Hdl Chip Design: A Practical Guide for Designing, Synthesizing &amp;amp; Simulating Asics &amp;amp; Fpgas Using Vhdl or Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有介绍。&lt;/p&gt;
&lt;h3 id="gray code counter"&gt;Gray Code Counter&lt;/h3&gt;
&lt;p&gt;Gray 码和普通的二进制编码相比，优势就是它相邻数字之间只有一位不同，这样在计数时，就避免的多位不是同时变化导致的毛刺。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Gray_code"&gt;Gray Code wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A typical use of Gray code counters is building a FIFO (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.[10] The updated read and write pointers need to be passed between clock domains when they change, to be able to track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a "wrong" binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大神 Clifford E. Cummings 的论文 &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;synthesis and scripting techniques for designing multi-asynchronous clock designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中有详细介绍如何设计一个 Gray Code Counter 的过程，其基本思想就是利用一个 binary counter 来实现目的，计数器的计数功能由内部的 binary counter 实现，将 binary 的计数结果通过一个 binary2gray 的转换电路转化为 gray code 后再输出；输出的 gray code 反馈回计数器之前，再通过一个 gray2bianry 的电路转化回 binary 形式，以供内部的 binary counter 使用。模块示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gray code counter" src="/images/counter-design-summary/gray_code_counter.png"/&gt;&lt;/p&gt;
&lt;p&gt;代码略 ...&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference_1"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Prototyping-Verilog-Examples-Spartan-3/dp/0470185325"&gt;FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Hdl-Chip-Design-Synthesizing-Simulating/dp/0965193438"&gt;Hdl Chip Design: A Practical Guide for Designing, Synthesizing &amp;amp; Simulating Asics &amp;amp; Fpgas Using Vhdl or Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;synthesis and scripting techniques for designing multi-asynchronous clock designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Design-Recipes-FPGAs-Embedded-Technology/dp/0750668458/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1415197345&amp;amp;sr=1-1&amp;amp;keywords=design+recipes+for+fpgas"&gt;Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology) &lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category></entry><entry><title>时钟分频器</title><link href="https://qiangu.cool/posts/ic/clock_dividers.html" rel="alternate"></link><published>2014-10-13T22:26:00+08:00</published><updated>2014-10-13T22:26:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-10-13:/posts/ic/clock_dividers.html</id><summary type="html">&lt;p&gt;总结常用的时钟分频方法&lt;/p&gt;</summary><content type="html">&lt;p&gt;在 &lt;a href="http://guqian110.github.io/pages/2014/09/12/the_clock_design_in_fpga_2_clock_design.html"&gt;时钟设计&lt;/a&gt; 中提到过：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline：&lt;/strong&gt; 尽量避免使用分频时钟&lt;/p&gt;
&lt;p&gt;如果要进行分频，可以使用 PLL/DLL 来实现，但是对于时钟要求不高的基本设计，通过语言进行时钟的分频相移仍然非常流行，首先这种方法可以节省芯片内部的锁相环资源，再者，消耗不多的逻辑单元就可以达到对时钟操作的目的。另一方面，通过语言设计进行时钟分频，可以看出设计者对设计语言的理解程度。&lt;/p&gt;
&lt;p&gt;如果一定要使用分频时钟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于资源比较丰富的 FPGA&lt;/p&gt;
&lt;p&gt;使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频 / 分频）和相位，这样的分频时钟是最稳定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于无法使用 PLL/DLL 的 FPGA&lt;/p&gt;
&lt;p&gt;对于这些情况，首先检查是否可以用 &lt;code&gt;CE&lt;/code&gt; (clock enable) 来代替分频时钟，如果不行，则使用下面讨论的分频方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="counter"&gt;Counter&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;时钟分频一般都是通过计数器 counter 来实现的，计数器是分频的基础。&lt;/p&gt;
&lt;p&gt;计数器可以分为很多种，&lt;a href="http://en.wikipedia.org/wiki/Counter"&gt;Counter on wiki&lt;/a&gt;，这里不再跑题展开了，关于计数器的讨论见：&lt;a href="http://guqian110.github.io/pages/2014/11/04/counter_design_summary.html"&gt;Counter in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="clock divider"&gt;Clock divider&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="even clock divider"&gt;even clock divider&lt;/h3&gt;
&lt;p&gt;偶数分频是最简单的情况，使用计数器就可以完成。比如，产生一个分频系数为 N（偶数）的 50% 占空比的分频器一般有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计数器计数到 (N/2-1) 时，将输出翻转，同时将计数器复位到 0，重新开始计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数器从 0 计数到 (N/2-1) 时，输出 1/0，从 N/2 计数到 (N-1) 时，输出 0/1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方案一只能实现固定的 50% 占空比，方案二则可以实现可以有限调整占空比。&lt;/p&gt;
&lt;h3 id="odd clock divider"&gt;odd clock divider&lt;/h3&gt;
&lt;p&gt;如果对占空比没有要求，那么使用和偶数分频类似的方法，一个计数器就可以解决；如果要求占空比是 50%，则可以使用以下的方法：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conceptually, the easiest way to create an odd divider with a 50% duty cycle is to  generate two clocks at half the desired output frequency with a quadrature-phase relationship (constant 90&amp;deg; phase difference between the two clocks).&lt;/p&gt;
&lt;p&gt;The output frequency can then be generated by exclusive-ORing the two waveforms together.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Steps&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 ref_clk 上升沿触发的 0 ~ (N - 1) 的计数器 cnt（N 为奇数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用两个 T flip-flop，分别产生各自的 enable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tff1_en: 当 cnt = 0 时，使能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tff2_en: 当 cnt = (N + 1) / 2 时，使能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产生以下信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;div1：在 ref_clk &lt;em&gt;上升沿&lt;/em&gt; 触发 tff1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;div2：在 ref_clk &lt;em&gt;下降沿&lt;/em&gt; 触发 tff2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异或 div1 和 div2，得到输出 clk_out&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中，举例介绍了 3 分频的情况：&lt;/p&gt;
&lt;p&gt;Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic" src="/images/clock-dividers/divide_3_sch.png"/&gt;&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing" src="/images/clock-dividers/divide_3_timing.png"/&gt;&lt;/p&gt;
&lt;h3 id="half integer clock divider"&gt;half integer clock divider&lt;/h3&gt;
&lt;p&gt;这种分频系数为 (N+1/2)，应该归类到小数分频中，但是因为它的小数部分是特殊的 1/2，所以可以在前面的讨论的基础上得到。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中分类讨论了半整数分频：&lt;/p&gt;
&lt;h4 id="50% duty cycle"&gt;50% Duty Cycle&lt;/h4&gt;
&lt;p&gt;以 1.5 分频为例，&lt;/p&gt;
&lt;p&gt;Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="1.5 sch" src="/images/clock-dividers/divide_1_5_sch.png"/&gt;&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="1.5 timing" src="/images/clock-dividers/divide_1_5_timing.png"/&gt;&lt;/p&gt;
&lt;p&gt;这种方法在仿真的时候是没有问题的，但是综合时可能会产生致命的问题：在切换时钟时，如果两路时钟信号的时延不相等，那么切换的时候就会产生毛刺。&lt;/p&gt;
&lt;p&gt;(Xilinx 提供的原语 &lt;code&gt;BUFGMUX&lt;/code&gt; 有去除切换时钟时候的毛刺的功能，但是它只适用于全局时钟网络 )&lt;/p&gt;
&lt;h4 id="non 50% duty cycle"&gt;Non 50% Duty Cycle&lt;/h4&gt;
&lt;p&gt;如果占空比不是 50%，则可以通过以下的方法得到：&lt;/p&gt;
&lt;p&gt;从&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;N + 1/2 = (2N + 1) / 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可知，N+1/2 分频也就是要求在 (2N+1) 个时钟周期内产生两个脉冲即可，这两个脉冲必须是等间隔分布的。&lt;/p&gt;
&lt;p&gt;首先，可以采用长度为 (2N+1) 的移位寄存器，这些寄存器中只有一个是 1，其他都是 0，然后在时钟的驱动下循环移位，则就有了 (2N+1) 个时钟周期的计数。&lt;/p&gt;
&lt;p&gt;其次，两个脉冲可以从这个移位寄存器中选取两个作为输出，但是不能简单地直接使用，因为无论怎样选择，这两个脉冲都不是等间隔分布的（一共 2N+1 个计数，抽取 2 个，剩余 2N-1 个计数，那么 2N-1 是个奇数，无法平分为两部分，所以不是等间隔的）。所以难点就在于如何得到两个等间隔的分布。The Art 的解决方法如下，以 4.5 分频为例：&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="4.5 timing" src="/images/clock-dividers/divide_4_5_timing.png"/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，当选择了两个连续的寄存器 (A, B) 相或作为第一个脉冲输出之后，再选取相隔 N 的两个连续的寄存器 (C, D)，把它们移动半个时钟周期后，和原始的 D 相或，作为第二个脉冲输出，容易分析，它们是等间隔的。&lt;/p&gt;
&lt;h3 id="fraction divider_1"&gt;fraction divider&lt;/h3&gt;
&lt;p&gt;大概有两种方法吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数逼近法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多次分频&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小数分频，最普通的方法是采用整数分频逼近法，比如 50 MHz 的时钟分频为 880 Hz，那么分频计数器 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;50000000/880 = 56818.18182&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么就用 56818 来近似，但是这种方法只有在分频系数很大时才比较好，分频系数越小，则误差越大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考一篇博文：&lt;a href="http://blog.sina.com.cn/s/blog_6840802c0100izey.html"&gt;verilog 实现小数分频（小数分频器）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过可变分频和多次平均的方法，然后通过控制单位时间内两种分频比出现的不同次数来获得所需要的小数分频值。&lt;/p&gt;
&lt;p&gt;假设分频系数为 N+A/B，其中 N, A, B 都是整数，N 代表整数部分，A/B 表示小数部分。&lt;/p&gt;
&lt;p&gt;由&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NB+A = N*(B-A) + (N+1)*A&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可知，通过 (B-A) 次 N 分频 + A 次 (N+1) 分频即可得到 N+A/B 分频。&lt;/p&gt;
&lt;p&gt;到此还没有结束，还需要对这两种分频方式进行均匀的放置。可以借助一个计数器到达这个目的：每进行一次分频，计数值为 10 减去分频系数的小数部分，各次计数值累加。若累加结果小于 10，则进行 N +1 分频，若大于或等于 10，则进行 Ｎ 分频。&lt;/p&gt;
&lt;p&gt;不同时钟分频组合时，&amp;ldquo; 按照累积量和 10 比较 &amp;rdquo; 原理： 当采用一种分频比，小数部分累积量大于 10，则表示小数部分累积达到了可以向整数部分进位的大小，这时候就应该插入另外一种分频比将小数部分积累的误差去掉，否则结果就不是均匀周期的时钟信号了。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;比如 8.7 分频&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;87 = 8*3 + 9*7&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以可以用 3 次 8 分频 + 7 次 9 分频得到 8.7 分频。因为 &lt;code&gt;10 -7 = 3&lt;/code&gt;，前 3 次累积之和都小于 10，所以前 3 次进行 9 分频，第四次累积值为 12，去除进位后余 2，待下次继续累积，第四次结果 12 &amp;gt; 10，所以进行 8 分频。分频方案如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="/images/clock-dividers/example.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary_1"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;本文总结了一些常用的时钟分频技术，虽然不推荐使用逻辑来对时钟信号进行分频，但是在一些要求比较的的情况下，使用逻辑分频不仅可以满足要求，还能降低资源消耗，不失为一种好方法。而且时钟分频也可以训练我们的设计能力。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://read.pudn.com/downloads126/sourcecode/embed/533229/VHDL%E5%88%86%E9%A2%91%E5%99%A8%E8%AE%BE%E8%AE%A1.pdf"&gt;使用 VHDL 进行分频器设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_6840802c0100izey.html"&gt;verilog 实现小数分频（小数分频器）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetop.cn/blog/html/11/317611-13680.html"&gt;任意分频的 verilog 语言实现&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category><category term="clock dividers"></category></entry><entry><title>FPGA 时钟设计 3 —— 跨时钟域设计</title><link href="https://qiangu.cool/posts/ic/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html" rel="alternate"></link><published>2014-10-09T23:01:00+08:00</published><updated>2014-10-09T23:01:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-10-09:/posts/ic/the_clock_design_in_fpga_3_multiasynchronous_clock_design.html</id><summary type="html">&lt;p&gt;总结 FPGA 中跨时钟域的设计&lt;/p&gt;</summary><content type="html">&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在前面一篇总结 &lt;a href="http://guqian110.github.io/pages/2014/09/23/latch_versus_flip_flop.html"&gt;Latch V.S. Flip-flop&lt;/a&gt; 的博文中，已经解释了 flip-flop 的一些参数：建立时间 &lt;code&gt;setup time&lt;/code&gt;、保持时间 &lt;code&gt;hold time&lt;/code&gt;、恢复时间 &lt;code&gt;recovery time&lt;/code&gt;、撤销时间 &lt;code&gt;removal time&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不满足这些参数的要求，则会发生所谓的 亚稳态 &lt;code&gt;Metastability&lt;/code&gt; 的问题。下面是 Altera 官方的一篇关于亚稳态的 white paper，详细介绍了亚稳态的产生原因、它是如何导致设计出现问题、以及描述它的参数 MTBF (Mean Time Between Failures) 如何计算。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们知道，一般只涉及单时钟域的设计并不多见，尤其是对于一些复杂的应用，FPGA 往往需要和多个时钟域的信号进行通信，而这些时钟之间的关系一般都是频率不同、相位也不同，也就是不同频不同相的多异步时钟域设计 &lt;code&gt;Mulit-Asynchronous Clock Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为这些时钟信号之间的关系一般既不同频也不同相，所以一个时钟域的信号对于另外一个时钟域来说是异步信号，那么就无法保证进入新时钟域的信号和新的时钟信号之间满足 setup/hold time 的要求，自然就会引起亚稳态的问题。&lt;/p&gt;
&lt;p&gt;在 Clifford E. Cummings 大神的 paper：&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 里面就举例说明了这种现象：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"When sampling a changing data signal with a clock ... the order of the events determines the outcome. The smaller the time difference between the events, the longer it takes to determine which came first. When two events occur very close together, the decision process can take longer than the time allotted, and a synchronization failure occurs."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Illustation 1: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="failure" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronization_failure.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Illustation 2: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不加处理，亚稳态产生的错误值将会传播到设计的其他部分，导致更加严重的问题&lt;/p&gt;
&lt;p&gt;&lt;img alt="propagatetion" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/propagation.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="synchronous design"&gt;Synchronous Design&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;多时钟域导致的亚稳态的问题的根本原因就是：信号和时钟是异步的，也就是设计不是同步设计 &lt;code&gt;Synchronous Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步化设计思想&lt;/strong&gt; 是 FPGA 中非常重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asynchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 组合逻辑 &lt;code&gt;combination logic&lt;/code&gt; 实现的，比如异步 FIFO/RAM 读写信号、地址译码等电路。电路的主要信号、输出信号不依赖任何一个时钟信号，不是由时钟信号驱动 flip-flop 产生的。&lt;em&gt;异步电路最大的缺点就是容易产生毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 时序逻辑 &lt;code&gt;sequential logic&lt;/code&gt; 实现的。电路的主要信号、输出信号是由某个时钟沿驱动 flip-flop 产生的。&lt;em&gt;同步电路可以很好的避免毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous V.S. Asynchronous&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从 ASIC 设计的角度来看，大约需要 7 个门来实现一个 D 触发器，而一个门即可实现一个 2 输入与非门，所以一般来说，在 ASIC 设计中，同步时序电路比异步电路占用更大的面积。但是，由于 FPGA 是定制好的底层单元，对于 Xilinx 器件，一个底层可编程单元 Slice 包含两个触发器（FF）和一个查找表（LUT）。其中触发器用以实现同步电路，查找表用以实现组合电路。FPGA 最终使用率用 Slice 来衡量。所以对于某个选定器件，其可实现的同步电路和异步电路的资源数量和比例是固定的，这点造成了过度使用查找表会浪费触发器资源，反之亦然。因而对于 FPGA，同步时序设计不一定比异步设计多消耗资源。单从节约资源的角度考虑，应该按照芯片配置的资源比例实现设计，但是设计者还要时刻权衡同步设计没有毛刺、信号稳定等优点，&lt;strong&gt;所以对于 FPGA 设计推荐采用同步设计。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是用离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字逻辑，为了成功操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为，FPGA 同步设计中最好的时钟解决方案是由专用全局时钟输入引脚驱动单个主时钟去控制设计项目中的每一个触发器。系统中各个功能模块使用同一同步复位信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FPGA 同步设计中，时序电路应尽量采用同步电路，尽可能使用同步器件，尽量减小或不使用门控时钟（为了降低系统功耗以外）。设计中不用系统主时钟经过逻辑运算得到控制信号，避免使用非时钟信号作为触发器的时钟输入。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面提到的所有方法，就是同步化思想的应用，其核心目的就是将本时钟域外的 &lt;strong&gt;异步信号同步化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="solution"&gt;Solution&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="solution 1: daul rank synchronizer"&gt;Solution 1: Daul Rank Synchronizer&lt;/h3&gt;
&lt;p&gt;通常使用 &lt;code&gt;MTBF (Mean Time Between Failures)&lt;/code&gt; 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。&lt;/p&gt;
&lt;p&gt;以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57&amp;times;109 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。&lt;/p&gt;
&lt;p&gt;理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer.png"/&gt;&lt;/p&gt;
&lt;p&gt;通常，同步器 synchronizer 由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。&lt;/p&gt;
&lt;p&gt;为了让 synchronizer 正常工作，从某个 时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入 synchronizer。之所以这样要求，是因为 synchronizer 的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过 synchronizer，给新时钟域后续逻辑一个虚假的信号。&lt;/p&gt;
&lt;p&gt;synchronizer 有很多设计方法，因为一种方法不能满足所有的应用需求。synchronizer 的类型基本上分为 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;level synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edge-detecting synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pulse synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;h4 id="level synchronizer"&gt;level synchronizer&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;paper&lt;/a&gt; 中有更详细的图解说明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="level" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/level.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;LVLSYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;           &lt;span class="n"&gt;clk_src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;input&lt;/span&gt;           &lt;span class="n"&gt;rst_src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;           &lt;span class="n"&gt;dat_src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;           &lt;span class="n"&gt;clk_dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;           &lt;span class="n"&gt;rst_dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dat_dst&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// source time domain&lt;/span&gt;
    &lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dat&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dat&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dat_src&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// destination time domain&lt;/span&gt;
    &lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;dat_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// using two level DFF to synchronize the din_q&lt;/span&gt;
    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dat_r&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dat_dst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dat_r&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;dat_dst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dat_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="level rtl" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/lvl_rtl.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 level synchronizer 的要求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;源时钟域的信号应先通过源时钟域的一个 DFF 后输出，然后直接进入目的时钟域的 synchronizer 的第一级 DFF。这样做的&lt;/p&gt;
&lt;p&gt;这么做到原因是：synchronizer 的第一级 DFF 对组合逻辑产生的毛刺（glitch）非常敏感。如果一个足够长的毛刺刚好满足了 setup/hold time，那么 synchronizer 会将其放行，产生一个虚假的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨域时钟域的这个信号持续时间 &amp;gt;= 2 个新时钟域时钟周期。&lt;/p&gt;
&lt;p&gt;虽然 &lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt; 中是这么写的，但是我觉得这个条件应该是保险条件，而不是最低条件。level synchronizer 的最低条件应该和 edge-detecting synchronizer 相同：&lt;/p&gt;
&lt;p&gt;输入信号的宽度 &amp;gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。&lt;/p&gt;
&lt;p&gt;首先，待同步到信号宽度 &amp;gt; 源时钟周期，这样它才能被源时钟域的 DFF 采样到，然后输出；&lt;/p&gt;
&lt;p&gt;其次，源时钟域采样输出端信号的宽度当然是源时钟周期的整数倍，它的宽度 &amp;gt; 目标时钟域周期 + 第一个 flip-flop 的 hold time，这样它才能被目的时钟域的时钟采样到，然后进行同步。&lt;/p&gt;
&lt;p&gt;所以，保险一点的条件是：待同步到信号有效时间至少是目的时钟周期的 2 倍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;level synchronizer 是其他两种同步器的基础：&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="edge-detecting synchronizer"&gt;edge-detecting synchronizer&lt;/h4&gt;
&lt;p&gt;边沿检测同步器 是在 level synchronizer 的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="edge-detecting" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/edge-detecting.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;EDGESYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;clk_src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;rst_src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;dat_src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;clk_dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="n"&gt;rst_dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="n"&gt;dat_dst&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// source time domain&lt;/span&gt;
    &lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dat&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dat&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dat_src&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="c1"&gt;// destination time domain&lt;/span&gt;
    &lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;sync_reg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;sync_reg&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;sync_reg&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;sync_reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="c1"&gt;// AND to get the output&lt;/span&gt;
    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dat_dst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sync_reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;sync_reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 edge-detecting synchronizer 的要求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入信号的宽度 &amp;gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。&lt;/p&gt;
&lt;p&gt;实际上，因为在源时钟域，要先用 DFF 寄存一下再输出，所以源时钟域输出的信号的宽度是其时钟周期的整数倍，它肯定是 &amp;gt; 目标时钟周期的，因为 edge-detecting synchronizer 只能工作在慢时钟域到快时钟域的情况下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;edge-detecting synchronizer 在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用 pusle synchronizer。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="pulse synchronizer"&gt;pulse synchronizer&lt;/h4&gt;
&lt;p&gt;脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。&lt;/p&gt;
&lt;p&gt;源时钟域的单时钟宽度的脉冲不是直接输出的，而是先经过一个源时钟域的翻转电路。这个翻转电路在每次输入一个脉冲时，它的输出会在高、低电平之间翻转。&lt;/p&gt;
&lt;p&gt;而在目的时钟域，翻转电路的输出先通过一个 level synchronizer，其输出到达异或门的一个输入端，而这个输出再经过一个 DFF，延时一个时钟周期后进入异或门的另外一个输入端。最后异或门的输出即最终的同步结果：&lt;/p&gt;
&lt;p&gt;源时钟域每有一个单时钟脉冲（源时钟），synchronizer 的输出端产生一个单时钟宽度（目的时钟）的脉冲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pusle" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/pulse.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;module&lt;/span&gt; &lt;span class="nt"&gt;PULSESYNC&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;
    &lt;span class="nt"&gt;input&lt;/span&gt;   &lt;span class="nt"&gt;clk_src&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;input&lt;/span&gt;   &lt;span class="nt"&gt;rst_src&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;input&lt;/span&gt;   &lt;span class="nt"&gt;pulse_src&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;

    &lt;span class="nt"&gt;input&lt;/span&gt;   &lt;span class="nt"&gt;clk_dst&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;input&lt;/span&gt;   &lt;span class="nt"&gt;rst_dst&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;output&lt;/span&gt;  &lt;span class="nt"&gt;pulse_dst&lt;/span&gt;
    &lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="o"&gt;///////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;source&lt;/span&gt; &lt;span class="nt"&gt;time&lt;/span&gt; &lt;span class="nt"&gt;domain&lt;/span&gt;
    &lt;span class="o"&gt;///////////////////////////////////////////////////&lt;/span&gt;
    &lt;span class="nt"&gt;reg&lt;/span&gt; &lt;span class="nt"&gt;toggle_reg&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="nt"&gt;always&lt;/span&gt; &lt;span class="o"&gt;@(&lt;/span&gt;&lt;span class="nt"&gt;posedge&lt;/span&gt; &lt;span class="nt"&gt;clk_src&lt;/span&gt; &lt;span class="nt"&gt;or&lt;/span&gt; &lt;span class="nt"&gt;posedge&lt;/span&gt; &lt;span class="nt"&gt;rst_src&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;
        &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;rst_src&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;
            &lt;span class="nt"&gt;toggle_reg&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="s1"&gt;'b0;&lt;/span&gt;
&lt;span class="s1"&gt;        end&lt;/span&gt;
&lt;span class="s1"&gt;        else begin&lt;/span&gt;
&lt;span class="s1"&gt;            if (pulse_src) begin&lt;/span&gt;
&lt;span class="s1"&gt;                toggle_reg &amp;lt;= ~toggle_reg;&lt;/span&gt;
&lt;span class="s1"&gt;            end&lt;/span&gt;
&lt;span class="s1"&gt;        end&lt;/span&gt;
&lt;span class="s1"&gt;    end&lt;/span&gt;

&lt;span class="s1"&gt;    ///////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="s1"&gt;    // destination time domain&lt;/span&gt;
&lt;span class="s1"&gt;    ///////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="s1"&gt;    reg     &lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="s1"&gt;   sync_reg;&lt;/span&gt;

&lt;span class="s1"&gt;    always @(posedge clk_dst) begin&lt;/span&gt;
&lt;span class="s1"&gt;        if (rst_dst) begin&lt;/span&gt;
&lt;span class="s1"&gt;            sync_reg &amp;lt;= 3'&lt;/span&gt;&lt;span class="nt"&gt;b0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;end&lt;/span&gt;
        &lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;
            &lt;span class="nt"&gt;sync_reg&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;sync_reg&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt; &lt;span class="err"&gt;toggle_reg&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="nt"&gt;end&lt;/span&gt;
    &lt;span class="nt"&gt;end&lt;/span&gt;

    &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;XOR&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;generate&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;pusle_dst&lt;/span&gt;
    &lt;span class="nt"&gt;assign&lt;/span&gt; &lt;span class="nt"&gt;pulse_dst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;sync_reg&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="nt"&gt;sync_reg&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="nt"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 pusle synchronizer 的要求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入脉冲之间的最小间隔 &amp;gt;= 2 个同步时钟周期。如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻，形成一个比单时钟周期宽的输出脉冲。&lt;/p&gt;
&lt;p&gt;实际上，在一些情况下，少于 2 个时钟周期（&amp;gt; 1 个时钟周期）也是可以同步上的。只要 synchronizer 的两个 DFF 的值不一样即可同步上，也就是说异步信号在连续的两个目的时钟采样的值不同即可，由于异步信号和时钟的相位关系不确定，所以在没有对齐的情况下，大于 1 个时钟时也能满足两个采样值不同的条件。&lt;/p&gt;
&lt;p&gt;一般为了保险起见，要求其保持至少两个时钟宽度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="timing"&gt;Timing&lt;/h4&gt;
&lt;p&gt;synchronizer 需要花费 1～2 个时钟周期来完成同步，所以粗略的估计可以认为 synchronizer 会造成目的时钟域的 2 个周期的延迟，我们在设计时需要考虑 synchronizer 对时序产生的影响。&lt;/p&gt;
&lt;h4 id="summary"&gt;Summary&lt;/h4&gt;
&lt;p&gt;总结 3 种同步器的特点，有下表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer_sum.png"/&gt;&lt;/p&gt;
&lt;p&gt;虽然还有其他类型的 synchronizer，但是这 3 种基本上就可以解决设计中遇到的多数问题了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;synchronizer 仅适用于简单的数据跨时钟域传输的同步，除了简单的信号之外，还有数据、地址、控制总线信号等也要跨时钟域。对于这些需求，可以使用其他的工具，比如握手协议、FIFO 等。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="solution 2: handshaking_1"&gt;Solution 2: Handshaking&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Handshaking allows digital circuits to effectively communicate with each other when the response time of one or both circuits is unpredictable. For example, an arbitrated bus allows more than one circuit to request access to a single bus, such as PCI or AMBA (Advanced Microcontroller Bus Architecture), using arbitration to determine which circuit gains access to the bus. Each circuit signals a request, and the arbitration logic determines which request &amp;ldquo;wins.&amp;rdquo; This winning circuit receives an acknowledgment indicating that it has access to the bus. It then discontinues its request and begins the bus transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意就是：对于（单边 / 双边）电路响应时间不确定的应用，握手协议可以有效地传输信号。比如（PCI、AMBA）总线仲裁电路，有多个电路申请访问总线时，每个电路都发出请求，由仲裁电路来决定哪个有访问权。&amp;ldquo; 获胜 &amp;rdquo; 的电路会收到确认信号，然后才可以访问总线。&lt;/p&gt;
&lt;p&gt;这种交互方式就是握手协议，简而言之就是双方首先要握手达成一致，然后才能传输数据。&lt;/p&gt;
&lt;p&gt;有两种基本握手协议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Full-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partial-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种握手协议都要用到 synchronizer，每种都有各自的优缺点，下面分别讨论：&lt;/p&gt;
&lt;h4 id="full handshaking"&gt;full handshaking&lt;/h4&gt;
&lt;p&gt;&lt;img alt="full" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/full.png"/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路 A 声明它的请求信号，然后接收方电路 B 检测到该请求有效后，声明它的效应信号；当电路 A 检测到响应信号有效之后，中止自己的请求信号；最后，当电路 B 检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非 A 检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路 A 必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。&lt;/p&gt;
&lt;p&gt;这种类型的握手使用了 level synchronizer。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端 A 需要 5 个周期，接收端 B 需要 6 个周期。&lt;/p&gt;
&lt;p&gt;全握手鲁棒性很好，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。&lt;/p&gt;
&lt;h4 id="partial handshaking"&gt;partial handshaking&lt;/h4&gt;
&lt;p&gt;另一中类型是部分握手。部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。&lt;/p&gt;
&lt;p&gt;部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。&lt;/p&gt;
&lt;p&gt;有两种类型的部分握手：&lt;/p&gt;
&lt;p&gt;第一种握手方法中，电路 A 以有效电平声明其请求信号，电路 B 以一个单时钟宽度脉冲作为响应。此时，电路 B 并不关心电路 A 何时中止它的请求。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;但是为了这种方法成立，电路 A 中止请求信号至少要 1 个时钟周期长度，否则，电路 B 就不能区别前一个和后一个新的请求。&lt;/p&gt;
&lt;p&gt;在这种握手方式下，电路 B 为请求信号使用一个 level synchronizer；电路 A 为响应信号使用一个 pusle synchronizer。只有当电路 B 检测到请求信号时才发出响应脉冲，这样电路 A 控制请求信号的时序，就能控制自己 synchronizer 接收到的脉冲间隔。&lt;/p&gt;
&lt;p&gt;同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路 A 需要花费 3 个时钟周期，接收端 B 需要花费 5 个时钟周期。&lt;/p&gt;
&lt;p&gt;第二种握手方法中，电路 A 使用一个单时钟宽度脉冲发出它的请求，电路 B 也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial_2.png"/&gt;&lt;/p&gt;
&lt;p&gt;这种握手使用的是 pusle synchronizer。完整的时序是：电路 A 需要花费 2 个时钟周期，电路 B 需要花费 3 个时钟周期。&lt;/p&gt;
&lt;h4 id="summary_1"&gt;summary&lt;/h4&gt;
&lt;p&gt;&lt;img alt="handshaing sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/handshaking_sum.png"/&gt;&lt;/p&gt;
&lt;p&gt;因为 handshaking 内部采用了 synchronizer，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的 synchronizer 和握手信号，就有了前面介绍的 3 种不同的 handshaking：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;full handshaking
是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial handshaking 是对 full 的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的 partial shandshaking。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial I 精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了 1 次半的握手。而且修改了 full 中 level synchronizer 的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路 A 则必须使用 pusle synchronizer 来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的 synchronizer，partial I 就比 full 方式节约了很多时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial II 则更进一步，在 partial I 的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成 1 次握手。而且两部分电路的 synchronizer 同时修改为 pusle 方式。这样子进一步减少了握手花费的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial 和 full 的本质区别不在于 synchronizer 的类型和握手信号的多少，而在于握手的方式。 partial 不用再等待对方的回答，就继续进行自己的下一步操作，而 full 必须等到对方的回复才进行下一步的操作，所以从某种意义上，full 方式才是真正的 &amp;ldquo; 握手 &amp;rdquo;，而 partial 并不符合 &amp;ldquo; 握手 &amp;rdquo; 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手 =.=&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在许多应用中，跨时钟域传送的不只是简单的信号，数据总线、地址总线、控制总线都会同时跨域传输。因为 synchronizer 需要花费的时间是不确定的（1 or 2 个时钟周期），所以对于这些多 bit 的数据，synchronizer 无法完成同步功能，通常采用其他的方法，比如使用 FIFO。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="solution 3: datapath design_1"&gt;Solution 3: Datapath Design&lt;/h3&gt;
&lt;p&gt;在进行信号同步时，有一个重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不应该在设计中的多个地方对同一信号进行同步，即禁止单个信号扇出至多个同步器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 synchronizer 要花 1~2 个时钟周期，设计者不能确切预测到每个信号何时跨越时钟域，此外，在新时钟域中一组经过同步后的信号其时序是不定的，因为 synchronier 的延迟可以是 1～2 个时钟周期，这种情况下各个同步信号间形成一种 &amp;ldquo; 竞争状况 &amp;rdquo;，这种竞争状况在需要跨域时钟域传输的多组信号间也会发生，例如数据总线、地址总线、控制总线等。因此，&lt;strong&gt;不能对组中的每个信号单独使用 synchronizer，也不能对数据 / 地址总线的每一位单独使用同步器&lt;/strong&gt;，因为在新的时钟域中，要求每个信号同时有效。&lt;/p&gt;
&lt;h4 id="problem_1"&gt;problem&lt;/h4&gt;
&lt;p&gt;Clifford E. Cummings 在他的文章中举例说明了几种常见的错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. &lt;strong&gt;Simply using synchronizers on all control signals is not always good enough&lt;/strong&gt; as will be shown in the following examples. &lt;/p&gt;
&lt;p&gt;If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two simultaneously required control signals&lt;/strong&gt;
 a register in the new clock domain requires both a load signal and an
enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Solution - Consolidating control signals before passing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two phase-shifted sequencing control signals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem_2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Solution - Logic to generate the proper sequencing signals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution_2.png"/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="solution_1"&gt;solution&lt;/h4&gt;
&lt;p&gt;有一种解决这个问题的方法是：&lt;strong&gt;使用一个保持寄存器 + 一个握手信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath.png"/&gt;&lt;/p&gt;
&lt;p&gt;保持寄存器保持信号总线的数据，握手信号指示目标时钟域何时可以对总线进行采样，源时钟域何时可以更换当前寄存器中保存的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In this design, the transmitting circuit stores the data (signal bus) in the holding register as it asserts the request signal. These two actions can happen at once because the request signal takes at least one clock cycle before the receiving circuit detects it (the minimum handshake-synchronization delay). When the receiving circuit samples the data (signal bus), it asserts the acknowledgment signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细分析一下，其实这里采用的原理类似于握手协议。&lt;/p&gt;
&lt;p&gt;当有一组新的数据出现在数据总线上需要跨时钟域时，额外添加一对握手信号 request/acknowledge，这对信号对于两个时钟域来说分别是异步信号（接收电路不知道何时会收到 request，发送电路也不知道何时会获得 acknowledge），可能会产生亚稳态的问题，所以在两个时钟域对它们分别用 synchronizer 进行同步。&lt;/p&gt;
&lt;p&gt;和 request 一起送过来的还有数据总线 上的数据信号，但是对于数据信号，不能简单地对每一位使用 synchronizer 来同步（原因前面已经说过了）。虽然对于接收电路来说，数据总线上的数据也是异步的，但是我们可以强制要求在握手过程中，数据保持不变，这样虽然数据是异步的，只要发送端满足保持寄存器数据在握手过程中不变化这一条件，那么即使数据总线上的数据到达接收时钟域有一些小的偏差 skew，但是不会超出 1 个时钟周期，在 synchronizer 最好的状态下，只花费了 1 个时钟周期就同步到了握手请求 request，这时候数据总线上的数据已经是稳定不变的有效数据了，所以可以采样到正确的有效数据，不会存在亚稳态的问题。&lt;/p&gt;
&lt;p&gt;采用这种方法可以避免亚稳态的出现的原因就是它规定了异步信号（保持寄存器）什么时候可以变化，虽然是异步信号，但是在采样的时候人为地确保了它保持稳定，满足 setup/hold time 的要求，所以不会有亚稳态的问题。&lt;/p&gt;
&lt;p&gt;这里的握手机制可以采用 full handshaking，也可以采用 partial handshaking，设计者应该根据实际需求来选择。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt; 这本书中，有详细的时序图来说明了一种握手机制下，这种机制采用了 full handshaking 中等待对方的方法，但是对握手信号进行了精简（partial II 类型）。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="datapath timing" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath_timing.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果发送端的数据速率很快 / 无法控制发送端发送数据的速度，那么就有可能无法满足握手机制中要求数据保持稳定这一要求，这时候这种方法就不再适用，而应该采用其他的方法，比如 FIFO。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="solution 4: advanced datapath design_1"&gt;Solution 4: Advanced Datapath Design&lt;/h3&gt;
&lt;p&gt;有时候，数据在跨时钟域时需要 &amp;ldquo; 堆积 &amp;rdquo; 起来，这时候只使用单个的寄存器就无法完成工作。比如某个传输电路突发式地发送数据，接收电路来不及采样，为了保持数据不丢失，就必须先把数据存储起来；还有一种情况是接收电路的采样速率比发送速度快，但是位宽却不够，仍然需要将没有采样的数据先暂存起来，这时候就需要使用 FIFO。&lt;/p&gt;
&lt;p&gt;基本上，使用 FIFO 的目的有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;速度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宽度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FIFO 的实现可以直接使用 IP core，也可以自己写代码实现。&lt;/p&gt;
&lt;p&gt;如果是自己写代码实现，那么异步信号的问题还是需要我们在实现 FIFO 是仔细考虑的；如果是采用 IP core 的方式，那么可以很大程度地缓解我们的压力，因为事实上我们是把异步信号的问题交给了设计 IP core 的人来处理 ... 这些 IP core 在内部针对异步数据读写的问题作了非常严谨复杂的设计，对外提供了非常简单的接口。采用这种方式虽然轻松，但是相应的地也有缺点：耗费更多的资源。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 和 &lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt; 两篇 paper 和 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中都有一些实现 FIFO 使用的相关技术的介绍，比如指针逻辑的处理，内部 gray code 计数器的实现等。这里就偷懒不细说了（以后再补） :P&lt;/p&gt;
&lt;p&gt;=============Update March/12/2015===========================&lt;/p&gt;
&lt;p&gt;FIFO 的目的在于解决数据跨时钟域传输的问题，但是在实现 FIFO 本身时，一些内部的握手信号也需要跨时钟域，这时候需要用到之前讨论过的 dual rank synchronizer 等技术。&lt;/p&gt;
&lt;p&gt;比如 FIFO 内部的地址计数器，如果使用 dual rank synchronizer 来同步，计数器的不同的 bit 可能会在不同的时钟周期内传递过去，这时接收到的数据就是错误的，对导致致命性的问题。&lt;/p&gt;
&lt;p&gt;而对应这个问题的解决方法就是使用 gray code。&lt;/p&gt;
&lt;p&gt;==============end of update==================================&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于跨时钟域 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;papaer1&lt;/a&gt; 中还有一些其他方面的技巧，可以帮助我们更好的实现设计。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="design partitioning"&gt;Design Partitioning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Only allow one clock per module.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Static timing analysis and creating synthesis scripts is more easily accomplished on single-clock modules or groups of single-clock modules.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Create a synchronizer module for each set of signals that pass from just one clock domain into another clock domain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is given that any signal passing from one clock domain to another clock domain is going to have setup and hold time problems. No worst-case (max time) timing analysis is required for synchronizer modules. Only best case (min time) timing analysis is required between first and second stage flip-flops to ensure that all hold times are met. Also, gate-level simulations can more easily be configured to ignore setup and hold time violations on the first stage of each synchronizer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;采用这种设计方式的原因如上所示，可以减少不必要的时序验证，而且脚本也更容易写，总之可以使时序验证工作更容易。&lt;/p&gt;
&lt;p&gt;举例如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="partitioning" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partitioning.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="clock name conventions"&gt;Clock Name Conventions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use a clock naming convention to identify the clock source of every signal in a design.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A naming convention helps all team members to identify the clock domain for every signal in a design and also makes grouping of signals for timing analysis easier to do using regular expression "wild-carding" from within a synthesis script.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者还举例说明了一个这样的例子：1995 年为 In Focus projectors 设计 video ASIC 时，他们就采用了这样的方法，对于 mircroprocessor 的时钟命名为 uClk，对于 video 的时钟则命名为 vClk。对应的时钟域中的信号的名字也添加了对应的前缀，比如 udata，uwrite，uadder 等。&lt;/p&gt;
&lt;p&gt;使用了这样的策略后，整个设计团队的攻城狮们都可以很方便地确定某个信号是否为异步信号，如何处理。当时有个攻城狮没有按照这种策略，使用了自己的命名方式，在一次会议之后，大家墙裂建议他修改命名，结果也证明修改之后遇到的问题、出错的概率都小了很多。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="gated clock_1"&gt;Gated Clock&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;虽然 FPGA 可以用来为 ASIC 搭建原型，但是一些 ASIC 中的技术并不适用于 FPGA，比如 gated clock。一般也没有必要在 FPGA 中模拟 ASIC 的低功耗优化。事实上，由于 FPGA 时钟资源的的粗颗粒度性，并不是总能模拟成功。&lt;/p&gt;
&lt;p&gt;下面简单讨论一下 ASIC 中 gated clock 的问题。（更详细的内容见 gated clock 文章，未写）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;dedicated clock module&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;guideline&lt;/strong&gt;: 将全部的 gated clock 时钟放在一个专门的时钟模块中，并将其从功能模块中分离出来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reason&lt;/strong&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;约束更加容易处理&lt;/li&gt;
&lt;li&gt;FPGA 设计修改起来更容易（比如通过 #define 来选择编译 ASIC 还是 FPGA 设计，选择两者各自的实现代码）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gating removal&lt;/p&gt;
&lt;p&gt;在 FPGA 上建立模型时，有很多巧妙的方法去除 gated clock。比如下面这个例子就是最直观，但也是最繁琐的方法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;`define FPGA&lt;/span&gt;
&lt;span class="c1"&gt;// `define ASIC&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;clock_blocks&lt;/span&gt; &lt;span class="p"&gt;(...)&lt;/span&gt;

    &lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;ASIC&lt;/span&gt;
        &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;clock_domain_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;system_clock_1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;clock_enable_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="no"&gt;`else&lt;/span&gt;
        &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;clock_domain_1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;system_clock_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这种方法的缺点是当做出改动时，需要对 FPGA 和 ASIC 代码都作出修改。很多人对这种方式很不爽，因为他们必须写两种不同的 RTL 代码。&lt;/p&gt;
&lt;p&gt;一种更加高级的方法是依靠工具，现代的很多综合工具都可以通过适当的约束，通过将条件并到数据通路，来自动消除 gated clock。&lt;/p&gt;
&lt;p&gt;比如下面的这段代码：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;clockstest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="kt"&gt;reg&lt;/span&gt;  &lt;span class="n"&gt;oDat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;        &lt;span class="n"&gt;iClk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;        &lt;span class="n"&gt;iEnable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;        &lt;span class="n"&gt;iDat&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;wire&lt;/span&gt;  &lt;span class="n"&gt;gated_clock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;iClk&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iEnable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;gated_clock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;oDat&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;iDat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;如果不打开自动消除的开关，产生的 gated clock 电路如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="circuit1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit1.png"/&gt;&lt;/p&gt;
&lt;p&gt;如果打开自动消除的开关，产生的没有 gated clock 电路如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="circuit2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit2.png"/&gt;&lt;/p&gt;
&lt;p&gt;现在大多数器件都提供了一个时钟使能（clock enable）端口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果器件提供了这种接口，那么就没有必要使用上述方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件没有提供这种端口，那么使用这种技术虽然可以消除 gated clock，但是付出的代价是增加了 data path 的 delay。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary_2"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;以上，就是一些在多时钟域设计中处理异步数据的常用方法，总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于简单的单比特的数据，根据实际情况选择对应的 synchronizer 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于其他的信号，比如数据总线、地址总线、控制总线等数据，可以使用握手协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总线上的数据要求同时到达新的时钟域，所以不要对总线上的信号分别进行同步，而要采用一个保持寄存器 + 握手信号的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还可以采用 FIFO 来处理异步数据的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分块设计，尽可能保证一个模块只有一个时钟域，对于跨时钟域信号，写独立的同步模块，这样可以减轻时序验证的工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用良好的命名习惯，如前缀的方式，可以帮助设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意 ASIC 和 FPGA 中对时钟信号的不同处理方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ_AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_174906.HTM"&gt;ASIC 中的异步时序设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_175526.HTM"&gt;跨越鸿沟：同步世界中的异步信号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2878096/"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category></entry><entry><title>锁存器 Latch v.s. 触发器 Flip-Flop</title><link href="https://qiangu.cool/posts/ic/latch_versus_flip_flop.html" rel="alternate"></link><published>2014-09-23T23:02:00+08:00</published><updated>2014-09-23T23:02:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-09-23:/posts/ic/latch_versus_flip_flop.html</id><summary type="html">&lt;p&gt;总结 Latch 和 Flip-Flop&lt;/p&gt;</summary><content type="html">&lt;p&gt;根据 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;Wiki: Flip-flop (electronics)&lt;/a&gt; 上的介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In electronics, a &lt;code&gt;flip-flop&lt;/code&gt; or &lt;code&gt;latch&lt;/code&gt; is a circuit that has two stable states and can be used to store state information. A flip-flop is a &lt;code&gt;bistable multivibrator&lt;/code&gt;. The circuit can be made to change state by signals applied to one or more control inputs and will have one or two outputs. It is the basic storage element in sequential logic. Flip-flops and latches are a fundamental building block of digital electronics systems used in computers, communications, and many other types of systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区别一下名字：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or opaque) or clocked (synchronous or edge-triggered). Although the term flip-flop has historically referred generically to both simple and clocked circuits, in modern usage it is common to reserve the term flip-flop exclusively for discussing clocked circuits; the simple ones are commonly called latches.&lt;/p&gt;
&lt;p&gt;Using this terminology, a latch is level-sensitive, whereas a flip-flop is edge-sensitive. That is, when a latch is enabled it becomes transparent, while a flip flop's output only changes on a single type (positive going or negative going) of clock edge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以按照现在的约定习惯区分，latch 指的是电平触发的触发器，翻译为 &amp;ldquo; 锁存器 &amp;rdquo;；flip-flop 指边沿触发的触发器，就叫 &amp;ldquo; 触发器 &amp;rdquo;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id="history"&gt;History&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;em&gt;翻译自 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;wiki&lt;/a&gt;:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;第一个电子触发器 (electronic flip-flop) 由  William Eccles 和 F. W. Jordan 于 1918 年发明的。它最早被称为 ：  &lt;code&gt;Eccles&amp;ndash;Jordan trigger circuit&lt;/code&gt;，由两个真空管组成。虽然现在由逻辑门 (logic gates) 组成的触发器很常见，但是在集成电路 (intergrated circuits) 中，这种元件及它的晶体管版本仍然也很常见。早期的触发器常用来构成触发电路或者多谐振荡器 (multivibrators)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flip-flop" src="http://upload.wikimedia.org/wikipedia/commons/9/98/Eccles-Jordan_trigger_circuit_flip-flip_drawings.png"/&gt;&lt;/p&gt;
&lt;p&gt;根据一个 JPL 的工程师，P. L. Lindley 介绍，Montgomery Phister 于 1954 年在 UCLA 的 computer design 的课程上第一次对触发器进行了分类的讨论（RS、D、T、JK），然后在他的书 Logical Design of Digital Computers 中也进行了讨论。Lindley 当时在 Hughes Aircraft 的 Eldred Nelson 手下工作，而 Nelson 命名了 JK 触发器。其他的名字则是 Phister 命名的。Lindley 解释说他是从 Nelson 口中得知 JK 触发器的故事的，当时 Hughes Aircraft 使用的触发器都是 JK 触发器。在设计逻辑系统时，Nelson 给触发器的输入命名为 A&amp;amp;B、C&amp;amp;D、E&amp;amp;F、G&amp;amp;H、J&amp;amp;K。在 1953 年 Nelson 申请专利时，采用了 J&amp;amp;K 的命名方案。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or asynchronous) or clocked (synchronous); the transparent ones are commonly called latches. The word latch is mainly used for storage elements, while clocked devices are described as flip-flops.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不会翻译了 ... 大意就是说 flip-flop 可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;simple&lt;/p&gt;
&lt;p&gt;也可以说是 透明的 (transparent) 或者是 异步的 (asynchronous)，通常称为 &lt;code&gt;锁存器 Latch&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;clocked&lt;/p&gt;
&lt;p&gt;也可以说是 同步的 (synchronous)，称为 &lt;code&gt;触发器 flip-flop&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分类讨论：&lt;/p&gt;
&lt;h3 id="latch"&gt;Latch&lt;/h3&gt;
&lt;p&gt;Latch 可以由一对真空管、三极管、场效应管组成，在实际应用中也可以用逻辑门组成 latch。&lt;/p&gt;
&lt;h4 id="sr latch"&gt;SR Latch&lt;/h4&gt;
&lt;p&gt;当使用逻辑门搭建模块时，最基本的 latch 就是 &lt;code&gt;SR latch&lt;/code&gt; (set-reset latch)，所有的 latch 和 flip-flop 都是建立在它的基础之上。&lt;/p&gt;
&lt;p&gt;SR latch 的实现可以有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SR NOR Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用或非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="http://upload.wikimedia.org/wikipedia/commons/c/c6/R-S_mk2.gif"/&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="/images/latch_versus_flip_flop/nor.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;S'R' NAND Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用与非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/92/SR_Flip-flop_Diagram.svg/500px-SR_Flip-flop_Diagram.svg.png"/&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="/images/latch_versus_flip_flop/nand.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="d latch"&gt;D Latch&lt;/h4&gt;
&lt;p&gt;Latch 是 &lt;code&gt;透明的 (transparent)&lt;/code&gt;，就是说输入的变换立即就能传递到输出端口，当几个透明的 latch 级联时，输入端的信号也能立即传递到输出端。当给 latch 添加额外的逻辑电路（比如使能信号 enable 无效时），就会使它变为 &lt;code&gt;不透明的 (non-transparent)&lt;/code&gt;。下面的 D latch 就是这样的例子。&lt;/p&gt;
&lt;p&gt;仔细观察 SR latch 的功能表，就可以发现，R 的取值为 S 的补。D latch 利用了这一特点，而且避免了 SR latch 中的禁止状态的出现。&lt;/p&gt;
&lt;p&gt;因为 SR latch 的实现有两种，所以 &lt;code&gt;D latch&lt;/code&gt; 的实现也对应有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NOR D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/D-type_Transparent_Latch_%28NOR%29.svg/500px-D-type_Transparent_Latch_%28NOR%29.svg.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NAND D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/D-Type_Transparent_Latch.svg/500px-D-Type_Transparent_Latch.svg.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;D latch 的功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="d latch" src="/images/latch_versus_flip_flop/d_latch.png"/&gt;&lt;/p&gt;
&lt;p&gt;D latch 也称为  non-transparent、data latch、gated latch。它有一个数据输入端和一个使能端 enable(clock、control)。之所以叫透明，是因为当它使能时，输入端口的信号立刻就能传递到输出端口。&lt;/p&gt;
&lt;h3 id="flip-flop_1"&gt;Flip-Flop&lt;/h3&gt;
&lt;p&gt;如果 D latch 的控制端口加入时钟信号，就得到了基本触发器，只要时钟信号 CP = 1，则触发器就会受到触发，当 CP 保持为 1 时，数据输入端口的任何变化都将影响到 latch 的状态。&lt;/p&gt;
&lt;p&gt;latch 的这个特点应用到 时序电路中，就会出现比较严重的问题：&lt;/p&gt;
&lt;p&gt;一般时序逻辑的输出会经过组合电路的反馈通道，返回到时序逻辑的输入。当时钟信号有效时，latch 的输出通过组合电路反馈到 latch 的输入端，如果经过组合逻辑后，反馈的信号和之前的信号不同，则反馈信号会导致 latch 的输出变为新的值。在时钟信号有效的期间内，latch 的输出一直在变化，出现了不可预测的结果，这是不可靠的工作。&lt;/p&gt;
&lt;p&gt;latch 的&lt;strong&gt;问题&lt;/strong&gt;就在于：&lt;em&gt;它在时钟有效期间内一直在被触发，这种触发时间过长。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个问题的&lt;strong&gt;解决方法&lt;/strong&gt;就是：&lt;em&gt;将触发条件变为时钟沿触发，这样就得到了触发器 &lt;code&gt;flip-flop&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="d flip-flop"&gt;D flip-flop&lt;/h4&gt;
&lt;p&gt;将 latch 改造为边沿敏感的触发器，最简单的就是 &lt;code&gt;D flip-flop&lt;/code&gt; (data or delay)，搭建电路最经济有效的方法就是使用 DFF，因为它需要的门电路最少，其他类型的触发器都是在 DFF 的基础上得到的。&lt;/p&gt;
&lt;p&gt;实现 DFF 可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Classical positive-edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="classical" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/99/Edge_triggered_D_flip_flop.svg/500px-Edge_triggered_D_flip_flop.svg.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Master&amp;ndash;slave edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="master-slave" src="http://upload.wikimedia.org/wikipedia/en/thumb/5/52/Negative-edge_triggered_master_slave_D_flip-flop.svg/500px-Negative-edge_triggered_master_slave_D_flip-flop.svg.png"/&gt;&lt;/p&gt;
&lt;p&gt;clk = 1 时，master D-latch 使能，D 传递到输出端 Q；&lt;/p&gt;
&lt;p&gt;clk = 0 时，slave D-latch 使能，输入 D (master D-latch 的输出 Q) 传递到输出 Q；&lt;/p&gt;
&lt;p&gt;可以看到，当 clk 从 1 变为 0 时，输入端的 D 才传递到输出端 Q，也就是说在时钟的下降沿才触发，其他时刻都保持输出不变。（如果需要上升沿触发，只需要在 clk 输入端键入一个反相器）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFF 的特点就是在时钟信号的特定点触发（上升沿 or 下降沿），功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/latch_versus_flip_flop/dff.png"/&gt;&lt;/p&gt;
&lt;h4 id="jk flip-flop"&gt;JK flip-flop&lt;/h4&gt;
&lt;p&gt;在 DFF 的基础上，可以得到 JK FF。&lt;/p&gt;
&lt;p&gt;JK FF 的特点和 SR latch 类似，可以将 J 看作是 S，K 看作是 R，它和 SR latch 的区别在于它是边沿触发，并且将 S = R = 1 状态设置为 &lt;code&gt;翻转 (toggle)&lt;/code&gt;，也就是在下一个时钟边沿，输出取反。当 J = K = 0 时，得到的并不是 DFF，而是保持输出不变。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="jk" src="/images/latch_versus_flip_flop/jk.png"/&gt;&lt;/p&gt;
&lt;h4 id="t flip-flop"&gt;T flip-flop&lt;/h4&gt;
&lt;p&gt;将 JK FF 的输入端 J 和 K 连接到一起，就可以得到 &lt;code&gt;T FF&lt;/code&gt; (toggle flip-flop)。&lt;/p&gt;
&lt;p&gt;当 T = 0 (J = K = 0) 时，输出保持不变，时钟边沿不影响状态；当 T = 1 (J = K = 1) 时，在时钟边沿输出反相，也就是翻转。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="tff" src="/images/latch_versus_flip_flop/tff.png"/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 TFF 有 1/2 分频的作用，这一特点在很多电路中得到了应用。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="timing considerations_2"&gt;Timing considerations&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="metastability"&gt;Metastability&lt;/h3&gt;
&lt;p&gt;伴随着 flip-flop 的一个问题是 &lt;code&gt;亚稳态 Metastability&lt;/code&gt;。当两个输入端口 ( 比如 data 和 clk，或者 reset 和 clk) 同时变化时，就会发生亚稳态的问题，需要消耗更长的时间来使输出达到稳定状态，而且这个稳定状态是不可预测的，有可能是 1，也有可能是 0。&lt;/p&gt;
&lt;p&gt;在计算机系统中，如果发生亚稳态，如果在下一个时钟使用数据时，还没有达到稳定状态，会导致数据传输错误或者程序崩溃。如果有两条路径同时用到了这个数据，有可能一条将它当作 1，另一条把它当作 0，这样会导致系统进入不一致的状态。&lt;/p&gt;
&lt;h3 id="setup, hold, recovery, removal times"&gt;Setup, hold, recovery, removal times&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Setup time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;before&lt;/strong&gt; the clock event so that the data are reliably sampled by the clock. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hold time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;after&lt;/strong&gt; the clock event so that the data are reliably sampled. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;Synchronous signals (like Data) should be held steady from the set-up time to the hold time, where both times are relative to the clock signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="meta" src="http://upload.wikimedia.org/wikipedia/en/thumb/d/d9/FF_Tsetup_Thold_Toutput.svg/500px-FF_Tsetup_Thold_Toutput.svg.png"/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，对于同步信号 ( 同步信号的意思是想对于时钟信号而言，它的变化和时钟是同步的，比如 data)，必须满足 &lt;code&gt;setup time&lt;/code&gt; 和 &lt;code&gt;hold time&lt;/code&gt; 要求。&lt;/p&gt;
&lt;p&gt;在有效时钟沿到来之前的 setup time 时间段内，同步信号必须保持稳定，在有效时钟沿到来之后的 hold time 时间段内，同步信号也必须保持稳定，也就是说从 setup time 到 hold time 之间，它必须保持稳定不变化，这样才能让时钟信号采样到正确的值。&lt;/p&gt;
&lt;p&gt;同理，对于异步信号，有类似的要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is like setup time for asynchronous ports (set, reset). It is the time available between the asynchronous signals going inactive and the active clock edge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is like hold time for asynchronous ports (set, reset). It is the time between active clock edge and asynchronous signal going inactive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到一个更清晰的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is the minimum length of time an asynchronous control signal, for example, and preset, must be stable &lt;strong&gt;before&lt;/strong&gt; the next active clock edge. The recovery slack time calculation is similar to the clock setup slack time calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is the minimum length of time an asynchronous control signal must be stable &lt;strong&gt;after&lt;/strong&gt; the active clock edge. The TimeQuest analyzer removal time slack calculation is similar to the clock hold slack calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;recovery time specifies the time the inactive edge of the asynchronous signal has to arrive before the closing edge of the clock.&lt;/p&gt;
&lt;p&gt;Removal time specifies the length of time the active phase of the asynchronous signal has to be held after the closing edge of the clock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 Recovery / Removal time 类似于 Setup / Hold Time，不过是用于异步信号，比如 set，reset 信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="recovery-removal" src="/images/latch_versus_flip_flop/recovery-removal.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，在时钟沿到来之前的 recovery time 之前，异步信号必须释放 ( 变无效 )，在时钟沿到来之后的 removal time 之后，异步信号才能变有效，也就是说在从 recovery time 到 removal time 这段时间内，异步信号是不能有效的。&lt;/p&gt;
&lt;p&gt;如果使 flip-flop 的输入满足 setup time 和 hold time，那么就可以避免亚稳态的出现，一般器件的手册上都会标明这些参数，从几 ns 到几百 ps 之间。根据 flip-flop 内的组织情况而定，有时候可以将 setup time 或者 hold time 两者中的一个（只能是其中之一）变为 0 甚至是负数。&lt;/p&gt;
&lt;p&gt;但是，并不是总能满足这一标准，因为有可能 flip-flop 的输入端连到了外界的，设计者无法控制的一个不断变化的信号，这时候设计者所能做的事就是根据电路要求，将发生错误的概率降低到一个确定的水平。通常使用的方法就是将信号通过一条链在一起的 flip-flop 组，这样子可以将发生亚稳态的概率降低到一个可以忽略的程度，但是还是不等于 0。链中的 flip-flop 越多，这个概率就越趋近于 0，通常的情况是采用 1 个或者两个 flip-flop。&lt;/p&gt;
&lt;p&gt;即使现在出现了所谓的 &lt;code&gt;metastable-hardened flip-flops&lt;/code&gt;，它可以尽可能地减小 setup time 和 hold time，但是仍然无法完全避免问题的出现。&lt;strong&gt;这是因为亚稳态并不是简单的设计方法上的问题。&lt;/strong&gt;当时钟信号和其他信号在相隔很近的时间内变化，flip-flop 必须判断哪一个先发生变化，哪一个后发生变化，无论我们的器件速度有多快，仍然有可能出现两者相隔的太近，以至于无法判断。所以理论上是不可能造出一个完美避免亚稳态的 flip-flop。&lt;/p&gt;
&lt;h3 id="propagation delay"&gt;Propagation delay&lt;/h3&gt;
&lt;p&gt;flip-flop 还有一个参数叫做 clock-to-output delay (common symbol in data sheets: &lt;code&gt;tco&lt;/code&gt;) 或者是 propagation delay (&lt;code&gt;tp&lt;/code&gt;)，表示的是 flip-flop 从有效时钟沿开始到输出发生变化所消耗的时间。有时候从高电平变为低电平的时间 (high-to-low transition, tPHL)) 和从低电平变为高电平的时间 (low-to-high transition, tPLH) 不相等。&lt;/p&gt;
&lt;p&gt;当用同一时钟来驱动级联的 flip-flop ( 比如移位寄存器 shift register) 时，必须保证前一级的 tco 要大于后一级的 th。这是因为必须要保证前一级的数据能够正确移位到后一级中。当有效时钟沿到来时，前后两级的 ff 在同时变化，采样前一级的输出作为本级的输入，然后经过 tco 输出更新的值。当后一级 ff 在 tsu 到 th 段内采样时，必须保证前一级的输出保持不变，也就是说前一级 ff 的响应速度不能太快，至少要等后一级正确采样完成之后才能变化，即 &lt;code&gt;tco &amp;gt; th&lt;/code&gt;。如果采用物理构造完全相同的 ff，那么通常是可以保证这一条件的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="in fpga_1"&gt;in FPGA&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;latch 和 flip-flop 的特点决定了它们各自的应用场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;latch 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面积比 ff 小&lt;/p&gt;
&lt;p&gt;门电路是构建组合逻辑电路的基础，而锁存器和触发器是构建时序逻辑电路的基础。门电路是由晶体管构成的，锁存器是由门电路构成的，而触发器是由锁存器构成的。也就是 晶体管 -&amp;gt; 门电路 -&amp;gt; 锁存器 -&amp;gt; 触发器，前一级是后一级的基础。latch 完成同一个功能所需要的门较触发器要少，所以在 asic 中用的较多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度比 ff 快&lt;/p&gt;
&lt;p&gt;用在地址锁存是很合适的，不过一定要保证所有的 latch 信号源的质量，锁存器在 CPU 设计中很常见，正是由于它的应用使得 CPU 的速度比外部 IO 部件逻辑快许多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;latch 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电平触发，非同步设计，受布线延迟影响较大，很难保证输出没有毛刺产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;latch 将静态时序分析变得极为复杂&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;边沿触发，同步设计，不容易受毛刺的印象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析简单&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面积比 latch 大，消耗的门电路比 latch 多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前 latch 只在极高端的电路中使用，如 intel 的 P4 等 CPU。而在 PLD / FPGA 中，基本单元 LE 是查找表 LUT 和触发器 FF 组成的，如果要实现 latch，反而需要更多的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般的设计规则是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在绝大多数设计中避免产生 latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch 最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用 DFF 的地方，就不用 latch。&lt;/p&gt;
&lt;h3 id="reason &amp;amp; solution to unexpected latch"&gt;Reason &amp;amp; Solution to unexpected latch&lt;/h3&gt;
&lt;p&gt;在电路设计中，要对 Latch 特别谨慎，如果综合出和设计意图不一致的 Latch，会导致设计错误，包括仿真和综合。因此，要避免产生意外的 Latch。&lt;/p&gt;
&lt;h4 id="reason"&gt;Reason&lt;/h4&gt;
&lt;p&gt;如果组合逻辑完全不使用 always 语句，那么就不会产生 latch，比如&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;电路不需要保存 dout 的前一个值，所以不会产生 latch。&lt;/p&gt;
&lt;p&gt;如果组合逻辑使用了 always 语句，那么就有可能产生 Latch ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if_latch" src="/images/latch_versus_flip_flop/if_latch.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不完整的 case&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case_latch" src="/images/latch_versus_flip_flop/case_latch.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="solution"&gt;Solution&lt;/h4&gt;
&lt;p&gt;知道了原因，那么解决方法也就显而易见了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/latch_versus_flip_flop/if_else.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 case，添加 default 分支&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din_c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;din_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b00&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;RTL Schemtatic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case-default" src="/images/latch_versus_flip_flop/case_default.png"/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="application_1"&gt;Application&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;《Verilog HDL 程序设计与实践》&lt;/a&gt; 笔记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;latch 作为一种电路单元 , 必然有其存在的理由以及应用场景 , 并不像目前的很多书籍简单地将锁存器列为 &amp;ldquo; 头等敌人 &amp;rdquo;。其实在实际中 , 有些设计是不可避免地要用到锁存器 , 特别是在总线应用上 , 锁存器能提高驱动能力、隔离前后级。例如 , 常见的应用包括地址锁存器、数据锁存器以及复位信号锁存器等。但在更多的情况下 , 很容易在代码中产生未预料到的锁存器 , 使得逻辑功能不满足要求 , 浪费了大量的调试时间 , 从而使得大多数设计人员 &amp;ldquo; 闻虎色变 &amp;rdquo;。&lt;/p&gt;
&lt;p&gt;因此较好的应用规则是 :&lt;strong&gt;要学会分析是否需要锁存器以及代码是否会产生意想不到的锁存器。只有这样才能灵活运用锁存器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面通过实例来给予说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example1&lt;/strong&gt;: 通过 Verilog HDL 实现序列最大值搜索程序，并保持检测到的最大值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  &lt;span class="nt"&gt;module&lt;/span&gt; &lt;span class="nt"&gt;latch_demo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;  
          &lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;dout&lt;/span&gt;  
      &lt;span class="o"&gt;);&lt;/span&gt;  
      &lt;span class="nt"&gt;input&lt;/span&gt;   &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
      &lt;span class="nt"&gt;output&lt;/span&gt; &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;dout&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

      &lt;span class="nt"&gt;reg&lt;/span&gt;      &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;dout&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="nt"&gt;always&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;  
       &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;127&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  
            &lt;span class="nt"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
  &lt;span class="nt"&gt;end&lt;/span&gt;

  &lt;span class="nt"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码在 ISE 中的综合结果会给出设计中包含 Latch 的警告。但实际上，abmax_tmp 锁存器正是我们需要的，所以，虽然有警告，但是代码设计是没有问题的。将上述代码的 if 语句补全：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt; if (a &amp;gt; abmax_tmp)  &lt;/span&gt;
&lt;span class="err"&gt;      abmax_tmp = a;  &lt;/span&gt;
&lt;span class="err"&gt;  else  &lt;/span&gt;
&lt;span class="err"&gt;      abmax_tmp = abmax_tmp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过综合后，仍然有 Latch 的警告。无论 Latch 是否是用户需要的，ISE 都会给出警告，主要原因就是 Latch 对整个设计的时序性能影响较大。所以，在设计中要尽量避免 Latch，但是确实需要使用的情况，也可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example2:&lt;/strong&gt; 用 Verilog HDL 实现一个锁存器，当输入数据大于 127 时，将输入数据输出，否则输出 0&lt;/p&gt;
&lt;p&gt;不期望的 latch 指的是与设计意图不符，产生的 Latch。主要问题在于设计人员没有合理使用 Verilog HDL 语言，常见的原因是对条件语句（if、casse）的分支描述不完整，导致电路的功能不是预期的，发生了错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  &lt;span class="nt"&gt;module&lt;/span&gt; &lt;span class="nt"&gt;latch_demo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;  
      &lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;dout&lt;/span&gt;  
  &lt;span class="o"&gt;);&lt;/span&gt;  
  &lt;span class="nt"&gt;input&lt;/span&gt;   &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
  &lt;span class="nt"&gt;output&lt;/span&gt;  &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;dout&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="nt"&gt;reg&lt;/span&gt;      &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="nt"&gt;dout&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="nt"&gt;always&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;  
       &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;din&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;127&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  
            &lt;span class="nt"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;din&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
  &lt;span class="nt"&gt;end&lt;/span&gt;

  &lt;span class="nt"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综合后的结果，在比较器后面级联了锁存器，这是因为 if 语句缺少 else 分支造成的。查看仿真结果，当输入小于 127 时，输出保持了上次的 127，不是 0，没有达到设计要求。修改方法很简单，就是将 if-else 补全。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;   if (din &amp;gt; 127 )&lt;/span&gt;
&lt;span class="err"&gt;       dout = din;  &lt;/span&gt;
&lt;span class="err"&gt;   else  &lt;/span&gt;
&lt;span class="err"&gt;       dout = 0;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 ISE 中综合后的结果中，可以看到补全 if-else 后，在比较器后面级联了与门，代替原来的锁存器，仿真结果也正确。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;锁存器 latch 是一种基本电路单元 , 会影响到电路的时序性能 , 应该尽量避免使用 , 但出现锁存器造成设计和原始意图不符的情况 , 则是由于设计人员代码输入不正确造成的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference_1"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Flip-flop_(electronics"&gt;Flip-flop (electronics) --wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2883561/"&gt;数字设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/surgeddd/article/details/4683657"&gt;锁存器、触发器、寄存器和缓冲器的区别&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="latch"></category><category term="flip-flop"></category></entry><entry><title>VHDL 笔记 2 —— 系统设计</title><link href="https://qiangu.cool/posts/ic/vhdl_notes_2_system_design.html" rel="alternate"></link><published>2014-09-16T20:18:00+08:00</published><updated>2014-09-16T20:18:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-09-16:/posts/ic/vhdl_notes_2_system_design.html</id><summary type="html">&lt;p&gt;VHDL 笔记，系统设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;总结 &lt;code&gt;packege&lt;/code&gt;, &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的相关知识。&lt;/p&gt;
&lt;p&gt;这些组成部分添加到代码主体部分，目的是为了实现常用代码共享。通常这些代码被放在 &lt;code&gt;library&lt;/code&gt; 中，我们可以将自己设计的一些常用代码添加到 &lt;code&gt;library&lt;/code&gt; 中，这有利于使一个复杂设计具有更清晰的结构。&lt;/p&gt;
&lt;p&gt;总之，经常使用的代码可以以 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的形式放到 &lt;code&gt;package&lt;/code&gt; 中，然后被编译到目标 &lt;code&gt;library&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="packages and components"&gt;Packages and Components&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="package"&gt;Package&lt;/h3&gt;
&lt;p&gt;除了 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 之外，package 中还可以包含 &lt;code&gt;TYPE&lt;/code&gt;, &lt;code&gt;CONSTANT&lt;/code&gt; 的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;PACKAGE&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;package_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;PACKAGE&lt;/span&gt; &lt;span class="k"&gt;BODY&lt;/span&gt; &lt;span class="n"&gt;package_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;FUNCTION&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;descriptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;package_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;可以看到，语法包括两部分，&lt;code&gt;PACKAGE&lt;/code&gt; 和 &lt;code&gt;PACKAGE BODY&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE&lt;/code&gt; 是必需的，包括所有的声明语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE BODY&lt;/code&gt;：可选，当第一部分包含一个 / 多个  FUNCTION，PROCEDURE 声明时，这部分必须包含相应的描述代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--------- package define-------------&lt;/span&gt;
&lt;span class="n"&gt;LIRRARY&lt;/span&gt; &lt;span class="nn"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;IDEE.STD_LOGIC_1164.&lt;/span&gt;&lt;span class="k"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;PACKAGE&lt;/span&gt; &lt;span class="n"&gt;my_package&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;st4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;CONSTANT&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;STD_LOGIC_VECTOR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;"11111111"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;my_package&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--------- main code ------------------&lt;/span&gt;

&lt;span class="k"&gt;LIBRARY&lt;/span&gt; &lt;span class="nn"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;IEEE.STD_LOGIC_1164.&lt;/span&gt;&lt;span class="k"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;work.my_package.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;-- declaration&lt;/span&gt;

&lt;span class="k"&gt;ENTITY&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;ARCHITECTURE&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;--------------------------------------&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="componet"&gt;Componet&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;component&lt;/code&gt; 和 Verilog HDL 中的 &lt;code&gt;module&lt;/code&gt; 类似：&lt;/p&gt;
&lt;p&gt;一个 component 是一段完整的代码（包括 library, entity, architecture 这些组成部分），如果将这些代码声明为一个 component，那么就可以被其他电路调用，从而使代码具有了层次化的结构。&lt;/p&gt;
&lt;p&gt;使用 component 必须先声明这个元件，然后再例化这个元件（类似 C++，变量先声明，在定义）。声明和例化都必须在 architecture 中进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;declaration syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;COMPONENT&lt;/span&gt; &lt;span class="nc"&gt;component_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;COMPONENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;instantiation syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;component_name&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port_list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明时，component 和 entity 相似，必须声明端口的模式和类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化时，必须添加一个标号，就像 Verilog HDL 中例化 module 必须给个名字一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;声明元件时，可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上面的方法，先声明再例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 package 进行声明，将 component 的声明放在 package 中，则可以避免每次元件例化都要重复声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方法的区别类似于使用 C++ 中的 namespace 时的不同方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法一：每次使用 STL 都添加作用域&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;"hello world!"&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法二：声明一次作用域&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="port map"&gt;port map&lt;/h3&gt;
&lt;p&gt;同 Verilog HDL 一样，两种端口映射的方法：位置映射、名字映射。&lt;/p&gt;
&lt;p&gt;位置映射书写简单，但是容易出错；名字映射书写繁琐，但是不易出错，端口连接也更清晰，未连接的端口要使用关键词 &lt;code&gt;open&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;-- positional&lt;/span&gt;
&lt;span class="n"&gt;U1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;-- nominal&lt;/span&gt;
&lt;span class="n"&gt;U1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;inverter&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="generic map"&gt;generic map&lt;/h3&gt;
&lt;p&gt;generic 功能类似于 Veriog HDL 中的 parameter，所以在例化时 component 时，可以重载参数，使设计更方便灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;component_name&lt;/span&gt; &lt;span class="k"&gt;GENERIC&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="k"&gt;MAP&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;也就是说，在例化时，添加一段 &lt;code&gt;GENERIC MAP (param.list)&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="functions and procedure_1"&gt;Functions and Procedure&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;function 和 procedure 统称为 子程序，它们和 process 相似，内部包含的都是顺序描述的代码，通常使用相同的顺序描述语句。但是，function 和 procedure 的存在主要是为了建库，以达到代码重用和共享的目的，当然它们也可以直接建立在主代码中。&lt;/p&gt;
&lt;h3 id="function"&gt;Function&lt;/h3&gt;
&lt;p&gt;一个 function 就是一段顺序描述的代码。&lt;/p&gt;
&lt;p&gt;在写代码的过程中，我们通常会遇到一些有共性的问题，我们希望实现这些功能的代码可以被共享和重用，从而使代码变得简洁，易于理解，function 的建立和使用就能达到这个目睹。
function 中可以使用 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 等语句，但是不能有 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;component&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;function 的使用方法：先创建函数体本身，再调用函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Body&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;FUNCTION&lt;/span&gt; &lt;span class="n"&gt;function_name&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;RETURN&lt;/span&gt; &lt;span class="n"&gt;data_type&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;function_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;其中，&lt;parameter list=""&gt; 指函数的输入参数：&lt;/parameter&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CONSTANT&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;constant_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;constant_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signal_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数可以是 constant, signal，但是不能是 variable；参数的个数可以是任意个，类型也任意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以单独构成表达式，也可以作为表达式的一部分。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--example&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;conv_integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;maximum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Function Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以存放在两个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Package 中，这时候，函数声明在 package 中，函数定义在 package body 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Main Code 中，既可以在 entity 中，也可以在 architecture 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="procedure"&gt;Procedure&lt;/h3&gt;
&lt;p&gt;procedure 和 function 类似，目的也相同，不同之处在于 procedure 可以有多个返回值。&lt;/p&gt;
&lt;p&gt;与 function 类似，procedure 也需要定义和调用两个过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Body&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;procedure_name&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;procedure_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;其中，&lt;parameter list=""&gt; 指出了 procedure 的输入输出参数：&lt;/parameter&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;CONSTANT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;constant_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;signal_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;variable_name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;参数可以有任意多个，可以是 in, out, inout 模式的 signal, variable, constant。&lt;/p&gt;
&lt;p&gt;和 function 一样，procedure 内部的 wait 语句，signal 声明，component 调用都是不可综合的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的调用就是它自己。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--example&lt;/span&gt;
&lt;span class="n"&gt;compute_min_max&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;in3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;out2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;divide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dividend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;quotient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;remainder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Procedure Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的存放和 function 类似，通常放在 package 中，当然也可以放在主代码中。&lt;/p&gt;
&lt;h3 id="function versus procedure summary"&gt;FUNCTION versus PROCEDURE Summary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;function 有任意个输入参数和一个返回值，输入参数只能是 constant, signal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;procedure 有任意个输入 / 输出 / 双向参数，可以是 signal, variable, constant&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 可以作为表达式的一部分，procedure 直接调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 内部，wait 和 component 都不可综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 的存放位置相同，经常位于 package 中，也可以在主代码中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference_1"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>VHDL 笔记 1 —— 电路设计</title><link href="https://qiangu.cool/posts/ic/vhdl_notes_1_circuit_design.html" rel="alternate"></link><published>2014-09-16T14:56:00+08:00</published><updated>2014-09-16T14:56:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-09-16:/posts/ic/vhdl_notes_1_circuit_design.html</id><summary type="html">&lt;p&gt;VHDL 笔记, 电路设计&lt;/p&gt;</summary><content type="html">&lt;h2 id="code structure"&gt;Code Structure&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一段独立的 VHDL 代码一般至少由 3 部分组成：&lt;code&gt;LIBRARY declarations&lt;/code&gt;、&lt;code&gt;ENTITY&lt;/code&gt;、&lt;code&gt;ARCHITECTURE&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Library 用来设计重用和代码共享，使代码结构更清晰&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;LIBRARY&lt;/span&gt; &lt;span class="nn"&gt;library_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt; &lt;span class="nn"&gt;library_name.package_name.package_parts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用的 3 个 Library：&lt;code&gt;ieee&lt;/code&gt;、&lt;code&gt;std&lt;/code&gt;、&lt;code&gt;work&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中 std 和 work 是默认可见的，不需声明，ieee 需要明确的声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Entity 描述电路的输入 / 输出引脚&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ENTITY&lt;/span&gt; &lt;span class="nc"&gt;entity_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;entity_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;singal_mode 可以是 4 种类型： &lt;code&gt;in&lt;/code&gt; &lt;code&gt;out&lt;/code&gt; &lt;code&gt;inout&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; 模式无法回读到电路内部，&lt;code&gt;Buffer&lt;/code&gt; 模式可以，但是 buffer 不能连接到其他类型的端口，即不能把该模块作为子模块例化，一般使用中间缓冲信号，解决回读问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Architecture 描述电路的行为和实现的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Architecture 包含两部分：声明部分和代码部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明部分（可选）用来声明信号、常量等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码部分（begin ... end）描述电路行为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释行用 &lt;code&gt;--&lt;/code&gt; 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VHDL 不区分大小写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="data types"&gt;Data Types&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;前面的 Entity 中的端口定义：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;port_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;signal_mode&lt;/span&gt; &lt;span class="n"&gt;signal_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;还有其它地方声明的信号 &lt;code&gt;signal&lt;/code&gt; :&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;还有 常量 &lt;code&gt;constant&lt;/code&gt; 声明：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constant&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;还有 变量 &lt;code&gt;variable&lt;/code&gt; 声明：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这些声明中都包含了数据类型字段。一个信号 / 常量 / 变量的数据类型决定了它能取到什么样的值，还有可以进行什么样的操作。&lt;/p&gt;
&lt;h3 id="pre-defined data types"&gt;Pre-defined Data Types&lt;/h3&gt;
&lt;p&gt;IEEE 1164 标准中包含了一些预先定义的数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std&lt;/code&gt; 库中的 &lt;code&gt;standard&lt;/code&gt; 包集 (package) 定义了：&lt;code&gt;bit&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;、&lt;code&gt;real&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_1164&lt;/code&gt; 包集定义了：&lt;code&gt;std_logic&lt;/code&gt;、&lt;code&gt;std_ulogic&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包集定义了：&lt;code&gt;signed&lt;/code&gt;、&lt;code&gt;unsigned&lt;/code&gt; 类型，还有一些数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_signed&lt;/code&gt; 和 &lt;code&gt;std_logic_unsigned&lt;/code&gt; 包集：包含一些函数，可以使 &lt;code&gt;std_logic_vector&lt;/code&gt; 类型的数据可以像 &lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 一样进行运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="bit &amp;amp; bit_vector"&gt;&lt;code&gt;bit&lt;/code&gt; &amp;amp; &lt;code&gt;bit_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用 '0' 和 '1' 赋值&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;bit_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;'1'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s"&gt;"0011"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="std_logic &amp;amp; std_logic_vector"&gt;&lt;code&gt;std_logic&lt;/code&gt; &amp;amp; &lt;code&gt;std_logic_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中引入的 8 逻辑值系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于 bit 类型，可以取 8 种不同的值，但只有 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; 是可综合的，其他 5 种用来仿真&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="std_ulogic &amp;amp; std_ulogic_vector"&gt;&lt;code&gt;std_ulogic&lt;/code&gt; &amp;amp; &lt;code&gt;std_ulogic_vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中定义的具有 9 种逻辑值的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std_logic&lt;/code&gt; 是 &lt;code&gt;std_ulogic&lt;/code&gt; 的子集&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="boolean"&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;只有两种取值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="integer"&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;32 位的整数 (-2 147 483 647 ~ +2 147 483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="natural"&gt;&lt;code&gt;natural&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;非负整数 (0 ~ +2 147483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="real"&gt;&lt;code&gt;real&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;实数，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="physical literal"&gt;&lt;code&gt;physical literal&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;表示物理量，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="character"&gt;&lt;code&gt;character&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单一 / 一串 ASCII 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="signed &amp;amp; unsigned"&gt;&lt;code&gt;signed&lt;/code&gt; &amp;amp; &lt;code&gt;unsigned&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包中定义的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 &lt;code&gt;std_logic_vector&lt;/code&gt; 类似，但是可以支持与整数类似的算术运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="user-defined data types_1"&gt;User-defined Data Types&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;-- integer&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;student_grade&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;RANGE&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;-- enumerated&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;backward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;white&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="subtypes"&gt;Subtypes&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;SUBTYPE&lt;/span&gt; &lt;span class="n"&gt;my_color&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="k"&gt;RANGE&lt;/span&gt; &lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- my_color = (red, green, blue);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="arrays"&gt;Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以认为 VHDL 预定义的数据类型只有 &lt;code&gt;scalar&lt;/code&gt;(single bit) 和 &lt;code&gt;vector&lt;/code&gt;(one-dimensional array of bits) 两种类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这两种类型中只有一下类型是可综合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scalars: bit, std_logic, std_ulogic, boolean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vectors: bit_vector, std_logic_vector, std_ulogic_vector, integer, signed, unsigned&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt; &lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;type_name&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;specification&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;data_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--1D array&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="kt"&gt;STD_LOGIC_VECTOR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;--2D array&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt; &lt;span class="n"&gt;matrix2D&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="k"&gt;ARRAY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;DOWNTO&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="kt"&gt;STD_LOGIC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="port array"&gt;Port Array&lt;/h3&gt;
&lt;p&gt;有时在定义端口时，需要把端口定义为矢量阵列。但是在 &lt;code&gt;Entity&lt;/code&gt; 中不允许使用 &lt;code&gt;type&lt;/code&gt; 定义，所以我们必须自己定义包集 (package)，然后使用 &lt;code&gt;use&lt;/code&gt; 声明使用该用户自定义的包集，最后才能在 Entity 中使用这种新定义的类型。&lt;/p&gt;
&lt;h3 id="signed and unsigned data types"&gt;Signed and Unsigned Data Types&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std_logic_arith&lt;/code&gt; 包中定义了有符号数 (&lt;code&gt;signed&lt;/code&gt;) 和无符号数 (&lt;code&gt;unsigned&lt;/code&gt;) 两种数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有先声明使用这个库下的包，才能在代码中使用 signed/unsigned&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;ieee.std_logic_arith.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用它们主要是为了进行算术运算，但是它们不支持逻辑运算。( std_logic_vector 不支持算术运算，但是支持逻辑运算 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果信号的类型只能是 std_logic_vector，那么通过其他方法也是可以进行算术运算的，解决方案就是声明使用 &lt;code&gt;ieee&lt;/code&gt; 的 &lt;code&gt;std_logic_unsigned&lt;/code&gt; 和 &lt;code&gt;std_logic_signed&lt;/code&gt; 两个包集，声明之后，std_logic_vector 就可以像 signed/unsigned 一样进行算术运算了。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;ieee.std_logic_signed.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- use ieee.std_logic_unsigned.all;&lt;/span&gt;

&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;out&lt;/span&gt; &lt;span class="kt"&gt;std_logic_vector&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="k"&gt;downto&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;--legal, arithmetic&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;--legal, logiccal&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;需要注意的是，这两个包不能同时存在于同一份代码中，因为这样会引入二义性。比如上面例子中的 &amp;ldquo;+&amp;rdquo; 运算，如果我们同时包含了这两个包集，那么编译器不知道我们定义的运算到底应该重载哪一个，综合时会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="data conversion"&gt;Data Conversion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 VHDL 中，不同类型的数据是不能直接进行算术 / 逻辑运算的，所以必要时必须进行类型转换操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有两种方法实现类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用包中预定义的数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动写一段专门用于数据类型转换的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std_logic_arith&lt;/code&gt; 中包含了很多数据类型转换函数，可以实现不同数据之间的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="operators and attributes_1"&gt;Operators and Attributes&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;VHDL 语法虽然枯燥无味，但是只有对数据类型、运算操作符及其属性有了深刻认识，才能写出高质量和高效率的代码。&lt;/p&gt;
&lt;h3 id="opreators"&gt;Opreators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VHDL 提供了 6 种预定义的预算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;赋值 assignment&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑 logical&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算术 arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系 relational&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移位 shift&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并置 concatenation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="assignment"&gt;&lt;code&gt;assignment&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 用于给 &lt;code&gt;signal&lt;/code&gt; 对象赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:=&lt;/code&gt; 用于给 &lt;code&gt;variable&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, &lt;code&gt;generic&lt;/code&gt; 赋值，还可用于赋初值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt; 用于给矢量 (vector) 对象的某些位赋值，常和 &lt;code&gt;others&lt;/code&gt; 一起使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="logical"&gt;&lt;code&gt;logical&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;进行逻辑运算，操作数必须是 &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;std_logic&lt;/code&gt;, &lt;code&gt;std_ulogic&lt;/code&gt; 类型或者它们的扩展，即&lt;code&gt;bit_vector&lt;/code&gt;, &lt;code&gt;std_logic_vector&lt;/code&gt;, &lt;code&gt;std_ulogic&lt;/code&gt; 类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NOT&lt;/code&gt;, &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;NAND&lt;/code&gt;, &lt;code&gt;NOR&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="arithmetic"&gt;&lt;code&gt;arithmetic&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数是 &lt;code&gt;signed&lt;/code&gt;, &lt;code&gt;unsigned&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;，其中 &lt;code&gt;real&lt;/code&gt; 类型是不可综合的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果声明了 &lt;code&gt;std_logic_signed&lt;/code&gt; 或者 &lt;code&gt;std_logic_unsigned&lt;/code&gt;，则 &lt;code&gt;std_logic_vector&lt;/code&gt; 类型也可以进行加减运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;MOD&lt;/code&gt;, &lt;code&gt;REM&lt;/code&gt;, &lt;code&gt;ABS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="comparison"&gt;&lt;code&gt;comparison&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共有 6 种：&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="shift"&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;VHDL93 中引入的操作，语法：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;shift&lt;/span&gt; &lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;left operand 必须是 &lt;code&gt;bit_vector&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right operand 必须是 &lt;code&gt;integer&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shift operator 有：&lt;code&gt;sll&lt;/code&gt;, &lt;code&gt;srl&lt;/code&gt;, &lt;code&gt;sla&lt;/code&gt;, &lt;code&gt;sra&lt;/code&gt;, &lt;code&gt;rol&lt;/code&gt;, &lt;code&gt;ror&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="concatenation"&gt;&lt;code&gt;concatenation&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;用于位的拼接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数：任何支持逻辑运算的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作符：&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;(, , ,)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="attributes_1"&gt;Attributes&lt;/h3&gt;
&lt;p&gt;VHDL 中的属性语句可以获得相关数据 / 对象 的信息，使代码更加灵活。&lt;/p&gt;
&lt;h4 id="pre-defined"&gt;Pre-defined&lt;/h4&gt;
&lt;p&gt;内置的预定义属性可以分为两大类：数值类属性 和 信号类属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;data attributes&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;signal attributes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数信号类属性都是不可综合的，只有 &lt;code&gt;s'event&lt;/code&gt; 和 &lt;code&gt;s'stable&lt;/code&gt; 是可综合的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="user-defined"&gt;User-defined&lt;/h4&gt;
&lt;p&gt;也可以用户自己定义一个新的属性，并描述某个对象的这个属性的值是多少，之后就可以使用这个属性了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;attribute_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;attribute_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;-- declaration&lt;/span&gt;
&lt;span class="n"&gt;ATTIRBUTE&lt;/span&gt; &lt;span class="n"&gt;attribute_name&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;target_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;-- specification&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;example：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;number_of_inputs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;INTEGER&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt; &lt;span class="n"&gt;number_of_inputs&lt;/span&gt; &lt;span class="k"&gt;OF&lt;/span&gt; &lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;SIGNAL&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="na"&gt;'number_of_inputs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;首先定义了一个新的属性，名字叫 &lt;code&gt;number_of_inputs&lt;/code&gt;，表示输入端口的个数，然后针对对象 nand3 (3 输入的与非门 ) 这个对象，描述它的这个属性的类型为 signal 类型，取值为 3；最后，使用这个属性，将 nand3 的这个属性的值赋值给 input 对象。&lt;/p&gt;
&lt;h3 id="operator overloading_1"&gt;Operator Overloading&lt;/h3&gt;
&lt;p&gt;用户不仅可以自定义属性，还可以自定义操作符。预定义的操作符的操作数必须是特定的类型，对于某些类型，我们可以自定义操作符对应的操作。&lt;/p&gt;
&lt;p&gt;VHDL 中的自定义操作符作用和 C++ 中的操作符重载 方法、目的都很类似。首先构造一个函数，然后调用这个函数即可。&lt;/p&gt;
&lt;h3 id="generic"&gt;GENERIC&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;generic&lt;/code&gt; 必须在 ENTITY 中声明，它可以指定常规参数，所指定的参数是&lt;strong&gt;静态的&lt;/strong&gt;，&lt;strong&gt;全局的&lt;/strong&gt;。感觉类似于 Verilog 中的 &lt;code&gt;define&lt;/code&gt; 吧，但是显然 Verilog 中的 &lt;code&gt;parameter&lt;/code&gt; 是更好的设计，因为全局变量 / 常量很不安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;GENERIC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameter_name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;parameter_type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;parameter_value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ENTITY&lt;/span&gt; &lt;span class="nc"&gt;my_entity&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;GENERIC&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;INTEGER&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;PORT&lt;/span&gt; &lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="nc"&gt;my_entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="concurrent code_1"&gt;Concurrent Code&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;从本质上讲，HDL 是 描述 (Description) 语言，对应的是硬件电路，而硬件电路是时刻工作的，所以，它的代码是并发执行的。只有 &lt;code&gt;process&lt;/code&gt;，&lt;code&gt;function&lt;/code&gt;，&lt;code&gt;procedure&lt;/code&gt; 中的代码是顺序执行的，而且当这些模块作为一个共同的整体时，它们之间也是并行的。&lt;/p&gt;
&lt;p&gt;在并发代码中可以使用下列各项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运算操作符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;when&lt;/code&gt; 语句（when/else 和 with/select/when）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generate&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;block&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔细观察可以发现，其实 when, generate, block 语句和运算语句相比，只是添加了一些条件判断，它们主要的核心还是运算操作符组成的运算，所以，并行代码的核心就是这些并行的运算语句。&lt;/p&gt;
&lt;h3 id="when"&gt;&lt;code&gt;when&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;When/else syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="k"&gt;ELSE&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="k"&gt;ELSE&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;with/select/when syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WITH&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="k"&gt;SELECT&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt; &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="generate"&gt;&lt;code&gt;generate&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;功能类似于 Verilog HDL 中的 generate，它常和 for/if 一起使用。
因为描述的对象是电路，最终的电路是固定的，功能也是静态的，所以，对于 generate，它的循环操作的上下界必须是静态的，否则代码是不可综合的。&lt;/p&gt;
&lt;p&gt;实际上，引入 generate 的主要目的是为了写出更加通用的代码，达到修改最少代码，实现不同设计的目的，也就是动态编译。而引入 for 循环，只是为了减少代码量。&lt;/p&gt;
&lt;h3 id="block"&gt;&lt;code&gt;block&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中存在两种类型的块 block：简单块 (simple block) 和 卫式块 (guarded block):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;simple block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simple block 只是对原有代码进行了区域分割，目的也仅仅是为了增强代码的可读性和可维护性。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt; &lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;guarded block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;guarder block 是一种特殊的 block，它比 simple block 多了一个表达式，叫做 &lt;code&gt;guard expression&lt;/code&gt;，只有当这个表达式为 True 时，这个 block 才会执行。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt; &lt;span class="k"&gt;guarded&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="n"&gt;unguarded&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;BLOCK&lt;/span&gt; &lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="sequential code_1"&gt;Sequential Code&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;VHDL 本质是并发执行的代码，但是在 &lt;code&gt;process&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 内部的代码是顺序执行的，当它们作为一个整体时，相互之间也是并发执行的。&lt;/p&gt;
&lt;p&gt;顺序代码并非只能与时序逻辑 (&lt;code&gt;sequential logic&lt;/code&gt;) 对应，同样也可以用它们来实现组合逻辑 (&lt;code&gt;combinational logic&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;顺序代码也称为描述代码 (&lt;code&gt;behavioral code&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;这里主要讨论顺序代码，也就是这 3 个块中的代码，包括 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 语句。&lt;/p&gt;
&lt;h3 id="process"&gt;&lt;code&gt;process&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;作用类似于 Verilog HDL 中的 always 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lable&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;PROCESS&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sensitivity&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;;]]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;PROCESS&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="if"&gt;&lt;code&gt;if&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;IF&lt;/span&gt; &lt;span class="n"&gt;conditions&lt;/span&gt; &lt;span class="k"&gt;THEN&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;ELSIF&lt;/span&gt; &lt;span class="n"&gt;conditions&lt;/span&gt; &lt;span class="k"&gt;THEN&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;ELSE&lt;/span&gt; &lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="wait"&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果在 process 中使用了 wait 语句，那么 process 就不能含有敏感信号列表了，所以此时 wait 必须是 process 的第一条语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax1&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt; &lt;span class="n"&gt;UNTILL&lt;/span&gt; &lt;span class="n"&gt;signal_condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;syntax2&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;signal1&lt;/span&gt; &lt;span class="p"&gt;[,&lt;/span&gt; &lt;span class="n"&gt;signal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;syntax3&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="kt"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;--simulation only&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="case"&gt;&lt;code&gt;case&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;case 和 when 的区别在于，case 允许在每个测试条件下执行多个赋值操作，而 when 只能执行一个赋值操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;CASE&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="k"&gt;IS&lt;/span&gt;
    &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;CASE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="loop"&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax1: FOR/LOOP repeat a fix number of times&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="k"&gt;IN&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;syntax: WHILE/LOOP&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;WHILE&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt; &lt;span class="k"&gt;LOOP&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;syntax3: EXIT&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;EXIT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;syntax4: NEXT&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;NEXT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;loop_label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="signals &amp;amp; variables_1"&gt;Signals &amp;amp; Variables&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;VHDL 提供了 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;variable&lt;/code&gt; 两种对象来处理非静态数据；提供了 &lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;generic&lt;/code&gt; 来处理静态数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;signal&lt;/code&gt; 是全局的，可以在顺序执行的代码中，也可以在并发执行的代码中；&lt;code&gt;variable&lt;/code&gt; 是局部的，只能值顺序代码中，并且它们的值是不能向外传递的 ( 如果想传递出去，必须先把这个变量值传递给一个信号，再由这个信号传递出去 )。&lt;/p&gt;
&lt;h3 id="constant"&gt;&lt;code&gt;constant&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;constant 可以定义在 package, entity, architecture 中，对应的作用域也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义在 package 中的 constant 是真正的全局的，可以被所有调用该 package 的 entity 使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 entity 中的 constant 对于该 entity 的所有 architecture 而言是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 architecture 中的 constant 仅在该 architecture 中是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;CONSTANT&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="signal"&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;signal&lt;/code&gt; 代表的是逻辑电路中的 &amp;ldquo; 硬 &amp;rdquo; 连线，既可以用于电路的输入输出端口，也可以用于 内部单元之间的连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和 Verilog HDL 的 always 中的 reg 类似，VHDL 的 process 中的 signal 也是在进程结束时更新值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对同一个信号多次重复赋值，结果取决于编译器。(Xilinx XST 不报错，认为最后一次赋值是有效的 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="variable"&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;相比于 signal 是局部的，variable 只能在 process，function，procedure 中使用，而且对它的赋值是立即更新的，新的值可以在下一行代码中立即使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;VARIABLE&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="n"&gt;initial_value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference_1"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>FPGA 时钟设计 2 —— 时钟设计</title><link href="https://qiangu.cool/posts/ic/the_clock_design_in_fpga_2_clock_design.html" rel="alternate"></link><published>2014-09-12T12:45:00+08:00</published><updated>2014-09-12T12:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-09-12:/posts/ic/the_clock_design_in_fpga_2_clock_design.html</id><summary type="html">&lt;p&gt;总结 FPGA 中的时钟设计方案&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;无论是离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字设计，为了成功地操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;设计不良的时钟在极限的温度、电压或者制造工艺的偏差情况下将导致错误的行为，并且调试困难、花销很大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下 FPGA 中的时钟设计原则。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="clock design"&gt;Clock Design&lt;/h2&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;在 FPGA/CPLD 中通常采用几种时钟类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级逻辑时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;波动式时钟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多时钟系统能够包括上述 4 种时钟类型的任意组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是 &lt;a href="http://book.douban.com/subject/10593491/"&gt;《Xiliinx FPGA 高级设计及应用》&lt;/a&gt; 中的分类方法，个人觉得并不是很清晰，我总结了一下，大概可以分为下面的这 4 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;全局时钟 Global Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟 Gated Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑时钟 Logic Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分频 / 倍频时钟 Divied/Multiplied Clock&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="gloabl clock"&gt;Gloabl Clock&lt;/h3&gt;
&lt;p&gt;关于全局时钟，前面一篇 blog  &lt;a href=""&gt;FPGA 时钟设计 1 &amp;mdash;&amp;mdash; 时钟资源总结&lt;/a&gt; 中有总结。&lt;/p&gt;
&lt;p&gt;对于一个项目来说，全局时钟是 &lt;strong&gt;最简单&lt;/strong&gt;、&lt;strong&gt;最可预测&lt;/strong&gt; 的时钟。&lt;/p&gt;
&lt;p&gt;在 PLD/FPGA 项目中 &lt;strong&gt;最好的时钟方案&lt;/strong&gt; 是：由专用的全局时钟输入引脚驱动的单个主时钟去钟控设计项目中的每一个触发器。只要可能就应该尽量在设计中采用全局时钟&lt;/p&gt;
&lt;p&gt;PLD/FPGA 都具有专门的全局时钟引脚，它直接连接到器件中的每一个寄存器，这种全局时钟提供最短的时钟到输出的延时。&lt;/p&gt;
&lt;h3 id="gated clock"&gt;Gated Clock&lt;/h3&gt;
&lt;p&gt;门控时钟的意思是通过组合逻辑，控制、禁止或允许时钟输入到寄存器和其他同步原件上的一种方法。因为它能够有效地降低功耗，所以被广泛地应用于 ASIC 设计中。但是，它不符合 &lt;code&gt;同步设计&lt;/code&gt; 的思想，可能会影响系统设计的实现和验证，所以，&lt;strong&gt;在 FPGA 设计中应该避免使用门控时钟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 ASIC 和 FPGA 结构设计上的区别，两者对待门控时钟的态度是完全不同的：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://electronics.stackexchange.com/questions/73398/gated-clocks-and-clock-enables-in-fpga-and-asics"&gt;Gated clocks and clock enables in FPGA and ASICS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;往往可以将门控时钟转化为全局时钟以改善项目设计的可靠性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;就是使用寄存器 &lt;code&gt;时钟使能 (clock enable, CE)&lt;/code&gt; 端口。&lt;/p&gt;
&lt;p&gt;单纯从功能来看，使用使能时钟代替门控时钟是一个不错的选项，但是使能时钟在使能信号关闭时，时钟信号仍然工作，它无法像门控时钟那样降低系统的功耗。&lt;/p&gt;
&lt;p&gt;推译带使能端的触发器的代码：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;dout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;得到的结果就是原语 &lt;code&gt;FDCE&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/p&gt;
&lt;p&gt;//       Clock Enable (posedge clk).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;多路选择器（mux）&lt;/code&gt; 将组合逻辑从时钟通路搬移到数据通路。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="mux" src="/images/the-clock-design-in-fpga-2-clock-design/mux.png"/&gt;&lt;/p&gt;
&lt;p&gt;如果在设计中无法避免门控时钟，那么只要保证满足下面两个条件就可以使门控时钟和全局时钟一样可靠地工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;驱动时钟的逻辑必须只包含一个与门（或门），而且这个与门（或门）必须只有两个输入端。如果采用任何附加逻辑，则会出现竞争产生的毛刺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑门的一个输入端为实际时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些条件的目的就是为了避免组合逻辑中的竞争带来的毛刺。&lt;/p&gt;
&lt;p&gt;根据数字电路的知识，我们知道可以通过添加 &amp;ldquo; 冗余逻辑 &amp;rdquo; 的方法来消除组合逻辑的冒险，但是，FPGA 的编译器在 综合时会去掉这些冗余逻辑，所以不能采用这种方法。&lt;/p&gt;
&lt;h3 id="logic clock"&gt;Logic Clock&lt;/h3&gt;
&lt;p&gt;有时候会用到组合逻辑的输出作为时钟信号或者复位信号，但是这种时钟信号有两个非常重要的缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的信号不可避免地会出现毛刺，会导致系统运行失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的时钟信号使用的是通用布线资源，和专用时钟布线相比，延迟长、时钟偏移大，满足时序要求会更加困难。如果大量的逻辑使用了这种时钟，这个问题会更加突出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（看到书上提出一个解决方案是：使用系统专用的时钟信号，将组合逻辑的输出打一拍，避免组合逻辑的直接输出，达到同步的效果。但是我个人认为这个方案不是非常好。）&lt;/p&gt;
&lt;p&gt;综上，对于 FPGA 来说，还是应该&lt;strong&gt;尽量避免使用组合逻辑的输出作为时钟&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="divide/multiplied clock"&gt;Divide/Multiplied Clock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline：&lt;/strong&gt; 尽量避免分频时钟&lt;/p&gt;
&lt;p&gt;在我们的设计中，一般都不止一个时钟频率。如果不加注意，随意使用分频时钟，这叫做时钟满天飞，是非常不好的设计风格。&lt;/p&gt;
&lt;p&gt;如果一定要使用分频时钟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于资源比较丰富的 FPGA&lt;/p&gt;
&lt;p&gt;使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频 / 分频）和相位，这样的分频时钟是最稳定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于无法使用 PLL/DLL 的 FPGA&lt;/p&gt;
&lt;p&gt;对于这些情况，首先检查是否可以用 &lt;code&gt;CE&lt;/code&gt; (clock enable) 来代替分频时钟，如果不行，则使用 &lt;a href="http://guqian110.github.io/pages/2014/10/13/clock_dividers.html"&gt;时钟分频器&lt;/a&gt; 中讨论的分频方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="other tips_1"&gt;Other Tips&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只使用时钟的单个边沿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了一些特殊的电路（如 DDR）外，设计应该只使用单个边沿（上 / 下边沿）。使用两个边沿的问题是时钟占空比不一定是 50%，这会对电路的正常工作产生影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用差分时钟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常认为频率高于 100 MHz 就属于 &lt;code&gt;高频&lt;/code&gt;。建议在高频下使用差分时钟，因为差分时钟的抗噪声性能更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检测时钟缺失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 DCM/MMCM 的 &lt;code&gt;locked&lt;/code&gt; 输出，在使用时钟前先检查时钟是否锁定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category></entry><entry><title>Xilinx FFT IP core 笔记</title><link href="https://qiangu.cool/posts/ic/xilinx_fft_core_notes.html" rel="alternate"></link><published>2014-09-02T23:12:00+08:00</published><updated>2014-09-02T23:12:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-09-02:/posts/ic/xilinx_fft_core_notes.html</id><summary type="html">&lt;p&gt;使用 Xilinx FFT IP core (xfft v7.1) 的笔记&lt;/p&gt;</summary><content type="html">&lt;p&gt;关于 FFT 的背景介绍就不再赘述，通原书和网上的教程、课件很多；关于这个 IP 核的介绍也就不再粘贴复制了，原版的 datasheet 必然是最全面的，仅记录我的使用时遇到的问题和需要注意到细节。&lt;/p&gt;
&lt;p&gt;IP 核的接口示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic symbol" src="/images/xilinx_fft_core_notes/symbol.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="timing"&gt;Timing&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="start / rfd port"&gt;&lt;code&gt;START / RFD&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;datasheet 中没有专门描述 &lt;code&gt;start&lt;/code&gt; 信号和其他信号的时序关系，只是简单介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FFT start signal (Active High): START is asserted to begin the data loading and transform calculation (for the Burst I/O architectures). For Streaming I/O, START begins data loading, which proceeds directly to transform calculation and then data unloading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我最开始的测试小程序中，是先判断 &lt;code&gt;rfd&lt;/code&gt; 信号，根据 rfd 来给 start 赋值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;思路是：首先必须等 IP core 准备好接收新数据时，才能开始&lt;/em&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rfd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;但是仿真出来的结果显示 IP core 根本就没有工作，后来改了这两个信号的先后关系，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;新思路：程序将输入 start 置有效，通知 IP core 需要调用，然后 IP core 根据自己的状态给出标识信号（rfd / busy），外部电路等到 rfd 有效时才输入需要变换的信号。&lt;/em&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这样子程序就可以正常运行了。&lt;/p&gt;
&lt;h3 id="rfd / dv port"&gt;&lt;code&gt;RFD / DV&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;在 datasheet 中给出的时序图如下所示（Burst I/O Solutions with Natural Order Output）&lt;/p&gt;
&lt;p&gt;&lt;img alt="Burst I/O Solution" src="/images/xilinx_fft_core_notes/burst_io_solution.png"/&gt;&lt;/p&gt;
&lt;p&gt;实际仿真图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rfd_dv_sim" src="/images/xilinx_fft_core_notes/rfd_dv.png"/&gt;&lt;/p&gt;
&lt;p&gt;实际仿真结果和示意图有一点点小差别：datasheet 中的时序图显示 rfd 必须在等 unload 阶段结束之后才能变有效，输入新的数据；但是实际的仿真图显示，在 unload 的后半段时间，rfd 已经变有效了，开始载入新的数据。&lt;/p&gt;
&lt;p&gt;从理论上分析，采用 Burst I/O with Natural Order Output 方案，总共需要 3N 个时钟周期，load 阶段需要 N 个周期载入数据，processing 阶段需要 N 个时钟变换，unload 阶段需要 N 个周期来输出数据。&lt;/p&gt;
&lt;p&gt;从仿真结果来看，unload 阶段和下一帧的 load 阶段有部分是重叠的，这样实际上的周期是少于 3N 个时钟的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然功能上是不影响下一帧的数据的，毕竟和预期的时序不同，不知道是否会影响时序设计，有待继续观察。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="port_1"&gt;Port&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="nfft port"&gt;&lt;code&gt;NFFT&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 是可以设置为 动态重配置的，可以在运行时改变做运算的点数，非常方便，不过有一点需要注意到是重配置的点数是有范围限制的，比如我测试时设置的最大点数为 4096 点，那么运行重配置时，最小的点数为 64。可以选择 64 ~ 4096 之间的任何一个 2 的指数。&lt;/p&gt;
&lt;p&gt;由于我一开始忽略了这一点，重配置为 16 点，迷糊了半天，重新打开 IP core 设置时才发现是自己看文档不够仔细 =.=&lt;/p&gt;
&lt;h3 id="cp port"&gt;&lt;code&gt;CP&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 专门提供了一个端口可以设置循环前缀的长度，循环前缀 (cyclic prefix) 在通信中（尤其是 OFDM）是很有用的。&lt;/p&gt;
&lt;p&gt;在向导中设置了 cyclic prefix insertion，并且在程序重配置时设置了 CP length = 10，但是仿真结果却没有出现 CP，和 CP = 0 时的结果相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仔细看了两遍程序和 datasheet，没有发现问题 ... 待解决！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 09/03/2014&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又仔细看了两遍 datasheet，终于发现了原因所在。在关于 CP length 部分，最有一小段话一直被我匆匆忽略了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The initial value and reset value of CP_LEN is 0 (no cyclic prefix). The core uses the log2(point size) MSBs of CP_LEN for the cyclic prefix length. So, when the point size decreases, the leftover LSBs are ignored. This effectively scales the cyclic prefix length with the point size, keeping them in approximately constant proportion. However, all bits of CP_LEN are latched into the core on CP_LEN_WE and are used in later transforms if the point size increases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细读了一遍才明白，CP_LEN 起作用的是高位的数据 &amp;mdash;&amp;mdash; 从 MSB 起共 log2(point size) 位。比如我测试程序设置的最大点数为 4096，这是 CP_LEN 的位宽为 12 比特，但是在程序运行过程中，我重配置为 64 点，所以这时候应该从 CP_LEN 的最高位数起，共 log2(64) = 6 比特数据起作用。如果我想设置 CP 的长度为 8 点，则应该如下&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;cp_len&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="mb"&gt;'b001000&lt;/span&gt;&lt;span class="n"&gt;_000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这时候，如下图所示，结果与预期相符。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cp" src="/images/xilinx_fft_core_notes/cp.png"/&gt;&lt;/p&gt;
&lt;h3 id="fft/ ifft"&gt;FFT/ IFFT&lt;/h3&gt;
&lt;p&gt;在 FFT 的测试程序中，一切都正常工作，但是切换为 IFFT 模式，却出现了问题。&lt;/p&gt;
&lt;p&gt;datasheet 中介绍，控制正反变换的信号一共有两个：&lt;code&gt;fwd_inv&lt;/code&gt; 和 &lt;code&gt;fwd_inv_we&lt;/code&gt;。前者取 1 时为 FFT，取 0 为 IFFT；后者是前者的写使能信号。&lt;/p&gt;
&lt;p&gt;因为 FFT 的程序可以正常工作，说明程序逻辑是没有问题的。但是只配置这两个端口，就是有问题。自己研究无果，只能 Google，还真的找到以前有人也遇到同样的问题，并且给出了解决方法（不得不说，还是 Google 好，某度搜出来的结果都是广告和没有用的链接）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://forums.xilinx.com/t5/Digital-Signal-Processing-IP-and/IFFT-of-FFT-module-does-not-work/td-p/71555"&gt;IFFT of FFT module does not work&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://myfpgablog.blogspot.com/2009/11/ifft-in-system-generator.html"&gt;IFFT in System Generator (blogspot 需翻墙 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转原博客部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, the FFT block is configured to calculate DFT. The setup and timing of control/data signals for IDFT are the same as DFT except for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FFT block needs to be set up for IDFT by setting fwd_inv_we signal to 1 and fwd_inv signal to 0 before the start of the transform.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The FFT output needs to be manually scaled to account for the factor 1/N in Equation 2 above. The scaling can be done either by using the scaling schedule input or shifting the FFT output if the FFT block is set to "unscaled".&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题关键就在于第二条，需要手动设置数据缩放，给结果乘以 1/N。&lt;/p&gt;
&lt;p&gt;原因就是这个 IP core 在计算 FFT 和 IFFT 时，利用两者表达式上的相似点，使用相同的结构，但是却缺少给 IFFT 的结果乘以 1/N 的步骤，需要用户自己添加。&lt;/p&gt;
&lt;p&gt;在 datasheet 中介绍说&lt;/p&gt;
&lt;p&gt;&lt;img alt="theory" src="/images/xilinx_fft_core_notes/theory.png"/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The inverse FFT (IFFT) is computed by conjugating the phase factors of the corresponding forward FFT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是却没有提到这个额外的 1/N 需要用户自己手动设置，应该算是 Xilinx 的坑。修正这个倍数关系以后，结果就与预期相符了～&lt;/p&gt;
&lt;p&gt;（其实如果仔细分析对比 FPGA 和 Matlab 的结果，就能发现两者的差别就是这个 1/N 的倍数关系，只是自己对数字不敏感，又懒得仔细观察 =.=）&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="p.s. test program_1"&gt;P.S. Test program&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="fft ip core"&gt;FFT IP core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;page1: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;channel = 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transform Length = 4096&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Radix-4, Burst I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run time configurable transform length&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fix Point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Input data width  = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase factor width = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block floating point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;natural output&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cyclic prefix insertion&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;input data timing - no offset&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page3:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;use 3-multiplier structer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use CLB logic to implement butterfly arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;运行时重配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变换长度为 64 点，cp 长度为 10&lt;/p&gt;
&lt;h3 id="matlab"&gt;Matlab&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;im&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'%f'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;'%f'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;FFT IP core 仿真结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fft core sim" src="/images/xilinx_fft_core_notes/fft_core_sim.png"/&gt;&lt;/p&gt;
&lt;p&gt;对比 Matlab 中的结果，可以看到 IP core 的计算结果是正确的（除了 CP 的问题）。&lt;/p&gt;</content><category term="IC"></category><category term="FFT"></category><category term="IP core"></category></entry><entry><title>FPGA 时钟设计 1 —— 时钟资源总结</title><link href="https://qiangu.cool/posts/ic/the_clock_design_in_fpga_1_summary_of_clock_resource.html" rel="alternate"></link><published>2014-08-28T22:45:00+08:00</published><updated>2014-08-28T22:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-08-28:/posts/ic/the_clock_design_in_fpga_1_summary_of_clock_resource.html</id><summary type="html">&lt;p&gt;总结 Xilinx FPGA 中的时钟资源&lt;/p&gt;</summary><content type="html">&lt;p&gt;关于一款芯片，最权威、最新的资料当然是厂家的官方文件。很多大牛都推荐直接阅读原厂的 datasheet 和 user guide。根据我的体验，这确实是最好的途径。原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，市面上的书一般都落后业界的步伐，我们看到的很多书上的资料都是过时的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，市面上书（尤其是国内）很多都是简单的翻译手册而来的，而且虽然作者标的是某某大学的教授，事实上都是教授手下的研究生替老师干活翻译的，不能保证翻译的正确性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实验室有的芯片是 Xilinx 的 Virtex-5 系列，Virtex-5 的 User Guide 是 &lt;a href="http://www.xilinx.com/support/documentation/user_guides/ug190.pdf"&gt;UG190&lt;/a&gt;，以下内容都是从中摘抄的笔记。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="three types of clock resource"&gt;Three Types of clock resource&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="global clocks"&gt;Global Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了时钟目的，每个 Virtex-5 系列的器件内部都被分成不同的区域（regions），随着器件的尺寸不同，最小的有 8 个区域，最大的有 24 个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源（Global I/O）和局部时钟资源可以完成所有的复杂的 / 简单的时钟要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不推荐使用其他的非时钟资源（比如局部布线资源）来完成时钟功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 系列的器件都有 32 条全局时钟线 （global clock line），可以驱动片上的所有时序资源（CLB、BRAM、CMTs、I/O），也可以驱动其他的逻辑信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些全局时钟线可以用在任何一个区域中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟线只能由全局时钟缓冲器（global clock buffer）驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器一般由时钟管理块（Clock Management Tile, CMT）驱动，以减少时钟布线延时或者调整和另外一个时钟的相对延时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟的个数比 CMTs 多，但是一个 CMT 可以驱动多个全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regional clocks"&gt;Regional Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个区域（region）含有 2 个局部时钟缓冲器（regional clock buffer）和 4 个局部时钟树（regional clock tree）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了处于芯片中心列的组（bank）外，一个 Virtex -5 I/O bank 恰好横跨一个区域。大小和区域完全相同的每个组含有 4 个 clock-capable 的时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个输入可以差分驱动或单端驱动同一组或区域中的四个 I/O 时
钟（I/O clocks）和两个区域时钟（regional clock）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="i/o clocks"&gt;I/O clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第三种时钟资源是 I/O clocks，可以达到非常高的速度，用于局部的 I/O 串行器 / 解串器。
&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="global clocking resources_1"&gt;Global Clocking Resources&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟（global clocks）是个专用网络，是专为覆盖对 FPGA 中各种资源的所有时钟输入设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Buffers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Tree and Nets-GCLK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Regions&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="global clock inputs"&gt;Global Clock Inputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 FPGA 包含专用的全局时钟输入位置，这些输入位置即使不用作时钟输入，也可用作常规用户 I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个器件有 20 个全局时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟输入可以按任意 I/O 标准配置，包括差分 I/O 标准。每个时钟输入可以是单端输入，也可以是差分输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Input Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IBUFG，单端输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IBUFGDS，差分输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="global clock buffers"&gt;Global Clock Buffers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 器件有 32 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每半个晶片 （上半 / 下半）包含 16 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器允许各种时钟源 / 信号源接入全局时钟树和网。可以输入全局时钟缓冲器的源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global clock inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Management Tile (CMT) outputs including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Digital Clock Managers (DCMs)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase-Locked Loops (PLLs)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Other global clock buffer outputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;General interconnect&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器只能由同半个晶片 （上半 / 下半）中的源驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，在一个时钟区域中仅能驱动十个不同的时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域 （20 个 CLB）是由上十个 CLB 行和下十个 CLB 行组成的时钟树的一个
枝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域仅横跨器件的一半。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BUFGCTRL、BUFG、BUFGCE、BUFGCE_1、BUFGMUX、BUFGMUX_1、BUFGMUX_CTRL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他所有原语均出自 &lt;strong&gt;BUFGCTRL&lt;/strong&gt; 的软件预设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFG&lt;/strong&gt; 全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGCE&lt;/strong&gt; 带有时钟使能（CE）的全局缓冲（BUFG）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGMUX&lt;/strong&gt; 全局时钟选择缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGP&lt;/strong&gt; = IBUFG + BUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGDLL&lt;/strong&gt; 全局缓冲延迟锁相环（舍，被 DCM 代替）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="clock tree and nets - gclk"&gt;Clock Tree and Nets - GCLK&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟树是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有全局时钟线和缓冲器都以差分形式实现，这有助于大大改善占空比和共模噪声抑制能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Virtex-5 架构中，全局时钟线的引脚接入不仅限于逻辑资源的时钟引脚。全局时钟线不用局部互连即可接入 CLB 中的其他引脚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="clock regions"&gt;Clock Regions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 器件通过使用时钟区域改善时钟控制分配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个时钟区域最多可有十个全局时钟域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这十个全局时钟可以由 32 个全局时钟缓冲器的任意组合驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="how to use global clock_1"&gt;How to use global clock&lt;/h3&gt;
&lt;p&gt;Xilinx 芯片全局时钟资源的使用方法主要有 5 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最基本的全局时钟资源使用方法，也称为 &amp;ldquo; BUFGP 法 &amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFGDS + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当时钟信号为差分形式时，需要用 IBUFGDS 代替 IBUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最灵活的使用方法（一般外部提供的时钟都需要倍频、分频、移相等操作以后才可以使用，所以中间需要 DCM）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BUFG 的输入可以是普通信号，当某个信号（时钟、使能、快速路径）的扇出非常大、要求抖动延迟最小时，可以使用 BUFG 来驱动这个信号，使这个信号利用全局时钟资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的输入也可以是普通信号，所以上面的例子中的信号需要倍频、分频等操作时，需要在中间添加 DCM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在具体使用这些组合方式时，有两种例化方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在设计中直接例化全局时钟资源&lt;/p&gt;
&lt;p&gt;比较简单，按照需求例化上面 5 种组合方式即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在综合阶段 / 实现阶段通过约束文件的方式实现&lt;/p&gt;
&lt;p&gt;随着综合工具 / 布局布线工具的不同而变化，大多数综合工具会自动分析时钟信号的扇出数目，在全局时钟资源富裕的情况下，使扇出数目最大的信号自动指定使用全局时钟资源。这时候我们必须保证满足下面的原则，否则会报错。如果不能满足，则必须在约束文件中明确声明该信号不使用全局时钟资源。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;"CLK"&lt;/span&gt; &lt;span class="n"&gt;CLOCK_DEDICATED_ROUTE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="principle in using global clock"&gt;Principle in Using global clock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原则：&lt;/strong&gt; 使用 IBUFG / IBUFGDS 的必要条件是信号从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;也就是说，如果某个信号从全局时钟引脚输入，不管它是否为时钟信号，必须使用 IBUFG/IBUFGDS；如果对某个信号使用了 IBUFG/IBUFGDS，则这个信号必须从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt; 由 Xilinx FPGA 内部结构决定的，IBUFG/IBUFGDS 的输入端仅和芯片的全局时钟引脚有物理连接，与普通的 I/O 和其他内部 CLB 等没有物理连接。&lt;/p&gt;
&lt;h3 id="p.s. di er quan ju shi zhong zi yuan"&gt;P.S. 第二全局时钟资源&lt;/h3&gt;
&lt;p&gt;在看其他资料时，看到一种新的时钟资源 &amp;mdash;&amp;mdash; 第二全局时钟资源。官方的文档我还没有找到，所以就直接摘抄书上的笔记了 =.=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第二全局时钟资源属于长线资源，长度和驱动能力仅次于全局时钟资源，也可以驱动芯片内部的任何一个逻辑，抖动和延时仅次于全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在设计中，一般将高频率、高扇出的时钟使能信号以及高速路径上的关键信号指定为全局第二时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用全局时钟资源并不占用逻辑资源，也不影响其他布线资源；第二时钟资源占用的是芯片内部的资源，占用部分逻辑资源，各个部分的布线会相互影响，所以建议在设计中逻辑占用资源不超过 70% 时使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在约束编辑器中的专用约束 Misc 选项中，指定所选信号使用低抖动延迟资源 &amp;ldquo;Low Skew&amp;rdquo; 来指定，也可以在 ucf 文件中添加 &amp;ldquo;USELOWSKEWLINES" 约束命令。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;"s1"&lt;/span&gt; &lt;span class="n"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;"s2"&lt;/span&gt; &lt;span class="n"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;NET&lt;/span&gt; &lt;span class="s"&gt;"s3"&lt;/span&gt; &lt;span class="n"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="regional clocking resources_1"&gt;Regional Clocking Resources&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网络是一组独立于全局时钟网络的时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与全局时钟不同，区域时钟信号 (BUFR) 的跨度限于三个时钟区域，而 I/O 时钟信号只驱动一个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟控制资源和网络由以下通路和组件构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Clock Capable I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O Clock Buffer (BUFIO)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Buffer (BUFR)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Nets&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="clock capable i/o"&gt;Clock Capable I/O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;典型时钟区域中有四个 clock-capable I/O 引脚对 （中心列有例外）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有些全局时钟输入也是 clock capable I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个组中有四个专用 clock capable I/O 区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当用作时钟输入时，clock-capable 引脚可以驱动 BUFIO 和 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些引脚不能直接连接到全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="i/o clock buffer - bufio"&gt;I/O Clock Buffer - BUFIO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I/O 时钟缓冲器 (BUFIO) 是可以在 Virtex-5 器件中使用的一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 驱动 I/O 列内一个独立于全局时钟资源的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 只能由位于同一时钟区域的 clock capable I/O 驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域中有四个 BUFIO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 不能驱动逻辑资源 （CLB、Block RAM 等），因为 I/O 时钟网络只能覆盖同一组或时钟区域内的 I/O 列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFIO Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFIO 其实就是一个时钟输入和时钟输出缓冲器。输入与输出之间有一个相位延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regional clock buffer - bufr"&gt;Regional Clock Buffer - BUFR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟缓冲器 (BUFR) 是可以在 Virtex-5 器件中使用的另一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFR 将时钟信号驱动到时钟区域内一个独立于全局时钟树的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 BUFR 可以驱动其所在区域中的四个区域时钟和相邻区域 （最多三个时钟区域）中的四个时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 BUFIO 不同，BUFR 不仅可以驱动其所在时钟区域和相邻时钟区域中的 I/O 逻辑，还可以驱动其中的逻辑资源 （CLB、Block RAM 等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域 （四个区域时钟网络）中有两个 BUFR。中心列没有 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFR Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFR 是一个具有输入时钟分频功能的时钟输入 / 时钟输出缓冲器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regional clock nets"&gt;Regional Clock Nets&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除了全局时钟树和网（global clock trees and nets），Virtex-5 器件还包含区域时钟网（Regional Clock Nets）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些时钟树也是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网的传播并非遍及整个 Virtex-5 器件，而是仅限于一个时钟区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域包含四个独立的区域时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要接入区域时钟网，BUFR 必须例化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 BUFR 最多可以驱动两个相邻时钟区域中的区域时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="clock management technology_1"&gt;Clock Management Technology&lt;/h2&gt;
&lt;hr/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 系列的芯片内部含有的时钟管理模块（Clock Management Tiles，CMTs）可以提供灵活的、高性能的时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 CMT 由 2 个 DCM 和 1 个 PLL 组成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="dcm"&gt;DCM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DCM 原语有两个：DCM_BASE、DCM_ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM_BASE 提供基本的功能，比如去歪斜、频率合成、固定相移；DCM_ADV 提供更高级的功能，比如动态重配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个原语都有各自的输入输出端口、属性设置和状态标识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM 可以连接到芯片上的其他时钟资源，包括专用时钟 I/O，时钟缓冲器和 PLL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==================Update (09/12/2014) 看到一篇介绍 DCM 的&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;文章&lt;/a&gt;，很有意思 =================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;About DCM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的内部是 DLL (Delay Lock Loop) 结构，对时钟偏移量的调节是通过长达延时线形成的。&lt;/p&gt;
&lt;p&gt;DCM 会把输入时钟 &lt;code&gt;clkin&lt;/code&gt; 和 反馈时钟 &lt;code&gt;clkfb&lt;/code&gt; 相比较，调节 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clk_1x&lt;/code&gt; 之间的延时线的数目，直到 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 之间的相位差等于所设置的参数 &lt;code&gt;PHASESHIFT&lt;/code&gt;。如果 &lt;code&gt;clk_1x&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 不相关的话，那么就永远不能锁定了。&lt;/p&gt;
&lt;p&gt;这个从一开始的不等于到等于所花费的时间就是输出时钟锁定的时间，锁定之后，&lt;code&gt;locked&lt;/code&gt; 信号才会变高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 的常用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dcm_usage" src="/images/the-clock-design-in-fpga-1-summary-of-clock-resource/dcm_usage.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;将其输出 &lt;code&gt;clk_1x&lt;/code&gt; 连接到 &lt;code&gt;BUFG&lt;/code&gt; 的输入，通过 BUFG 之后的输出一条支路是反馈到 DCM 的反馈时钟引脚 &lt;code&gt;clkfb&lt;/code&gt; 上，另外一条支路则输出驱动其他单元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 消除 skew&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;DCM 的输出开始走线到达寄存器，这段路程导致的 skew 是永远存在的，DCM 为什么可以消除呢？&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为说明方便起见 , 我们将 BUFG 的输出引脚叫做 &lt;code&gt;clk_o&lt;/code&gt;, 从 clk_o 走全局时钟布线到寄存器时叫做 &lt;code&gt;clk_o_reg&lt;/code&gt;, 从 clk_o 走线到 DCM 的反馈引脚 CLKFB 上时叫 &lt;code&gt;clkfb&lt;/code&gt;, 如上图所示。实际上 clk_o, clk_o_reg, clkfb 全部是用导线连在一起的。&lt;/p&gt;
&lt;p&gt;所谓时钟 skew, 指的就是 clk_o 到 clk_o_reg 之间的延时。如果打开 FPGA_Editor 看底层的结构 , 就可以发现虽然 DCM 和 BUFG 离得很近 , 但是从 clk_o 到 clkfb 却绕了很长一段才走回来 , 从而导致从 clk_o 到 clk_o_reg 和 clkfb 的延时大致相等。&lt;/p&gt;
&lt;p&gt;总之就是 clk_o_reg 和 clkfb 的相位应该相等。所以当 DCM 调节 clkin 和 clkfb 的相位相等时 , 实际上就调节了 clkin 和 clk_o_reg 相等。而至于 clk_1x 和 clk_o 的相位必然是超前于 clkin, clkfb, clk_o_reg 的 , 而 clk_1x 和 clk_o 之间的延时就很明显 , 就是经过那个 BUFG 的延迟时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对时钟 skew 的进一步讨论&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后 , 说一说时钟 skew 的概念。&lt;/p&gt;
&lt;p&gt;时钟 skew 实际上指的是时钟驱动不同的寄存器时 , 由于寄存器之间可能会隔得比较远 , 所以时钟到达不同的寄存器的时间可能会不一样 , 这个时间差称为 &lt;code&gt;时钟 skew&lt;/code&gt; 。这种时钟 skew 可以通过 &lt;code&gt;时钟树&lt;/code&gt; 来解决 , 也就是使时钟布线形成一种树状结构 , 使得时钟到每一个寄存器的距离是一样的。很多 FPGA 芯片里就布了这样的时钟树结构。也就是说 , 在这种芯片里 , 时钟 skew 基本上是不存在的。&lt;/p&gt;
&lt;p&gt;说到这里 , 似乎有了一个矛盾 , 既然时钟 skew 的问题用时钟树就解决了 ,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;那么为什么还需要 DCM + BUFG 来解决这个问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外 , 既然时钟 skew 指的时时钟驱动不同寄存器之间的延时 , 那么上面所说的 clk_o 到 clk_o_reg 岂非不能称为时钟 skew？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先说后一个问题。在一块 FPGA 内部 , 时钟 skew 问题确实已经被 FPGA 的时钟方案树解决 , 在这个前提下 clk_o 到 clk_o_reg 充其量只能叫做 &lt;code&gt;时钟延时 delay&lt;/code&gt;, 而不能称之为时钟 skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于第一个问题，个人不认同原博主的答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可惜的是 FPGA 的设计不可能永远只在内部做事情 , 它必然和外部交换数据。例如从外部传过来一个 32 位的数据以及随路时钟 , 数据和随路时钟之间满足建立保持时间关系 (Setup Hold time), 你如何将这 32 位的数据接收进来？如果你不使用 DCM, 直接将 clkin 接在 BUFG 的输入引脚上 , 那么从你的 clk_o_reg 就必然和 clkin 之间有个延时 , 那么你的 clk_o_reg 还能保持和进来的数据之间的建立保持关系吗？显然不能。相反 , 如果你采用了 DCM, 接上反馈时钟 , 那么 clk_o_reg 和 clkin 同相 , 就可以利用它去锁存进来的数据。可见 ,DCM
+ BUFG 的方案就是为了解决这个问题。而这个时候 clk_o 到 clk_o_reg 的延时 , 我们可以看到做内部寄存器和其他芯片传过来的数据之间的时钟 skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这个答案有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;外部数据和芯片不同源，算是异步问题，应该用同步化来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随路失踪一般不驱动芯片的整个时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，我认为答案应该是：&lt;/p&gt;
&lt;p&gt;要使用全局时钟网络，必须通过 BUFG 才行，所以才会用到 BUFG；而之所以用到 DCM 是因为它可以实现时钟的闭环控制，而且可以把时钟映射到 PCB 上，用于同步外部芯片，减少了对外部芯片的要求，将时钟控制一体化，利于系统设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在一片 FPGA 中使用两个 DCM，需要注意两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置 DCM 使用的时钟输入 &lt;code&gt;clk_in&lt;/code&gt; 是源自 FPGA 内部的，此时不能直接连接引脚的信号，需要加入缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该手动例化一个 IBUFG，然后把 IBUFG 的输出连接到两个 DCM 的输入端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有这么做，而是完全按照单个 DCM 的流程使用，那么因为时钟引脚和两个 DCM 的路径长短不同，无法做到输入时钟、两个 DCM 的输出信号的相位对齐，输入时钟只能和其中一个对其，如果对相位有要求，则必须手动调整 DCM 在芯片中的位置。&lt;/p&gt;
&lt;h3 id="pll"&gt;PLL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 芯片最多包含了 6 个 CMT 模块，每个 CMT 模块包含一个 PLL，PLL 主要用来广谱频率的合成，并且与 DCM 配合最为外部 / 内部时钟的抖动滤波器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL 也有两个原语：PLL_BASE、PLL_ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL_BASE 提供基本的功能，比如时钟去歪斜、频率合成、精确相移、占空比调整；PLL_ADV 提供更高级的功能，比如时钟切换、动态重配置等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mmcm"&gt;MMCM&lt;/h3&gt;
&lt;p&gt;不同系列的芯片内部的时钟管理模块是不同的，比如在 Virtex-5 系列后的芯片就含有了 混合模式时钟管理器 MMCM 。&lt;/p&gt;
&lt;p&gt;具体实现时该如何选择 DCM、DLL、PLL、MMCM ？找到一篇介绍 Xilinx 时钟资源的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART_8800512846_18_20010_TA_25f01c24.HTM"&gt;如何正确使用 FPGA 的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="other tips_1"&gt;Other Tips&lt;/h2&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般来说，外部提供的时钟信号都需要进行倍频 / 分频才可以使用，这时候需要组合各种时钟缓冲器和 DCM、PLL 等模块，我们有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码中例化原语，手动组合各种时钟缓冲器和 DCM、PLL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 IP core 向导，创建时钟管理器（可以发现 IP core 生成的代码就是上面 5 种组合方式）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人感觉使用第二种方法应该更加简洁、方便，不容易出错吧。（如果在代码中没有明确声明使用 buffer，ISE 综合属性、IP core 属性设置里面默认会给所有的输入输出自动加上缓冲器）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 FPGA 设计而言，全局时钟是最简单最可预测的时钟，最好的时钟方案是：由专用的全局时钟输入引脚驱动单个全局时钟，并用后者去控制设计中的每个触发器。全局时钟资源是专用布线资源，存在与全铜布线层上，使用全局时钟资源不影响芯片的其他布线资源，因此在可以使用全局时钟的时候尽可能使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;虽然各个芯片都不尽相同，但是了解相关的基本知识有利于我们快速掌握芯片的时钟资源、快速上手。&lt;/p&gt;
&lt;p&gt;Xilinx 的所有器件上的时钟资源可以分为前面说的 3 类：全局时钟（global clock）、局部时钟（regional clock）、I/O 时钟（I/O clock），但是不同的器件内部含有的时钟管理模块是不同的，具体到每一款芯片，应该以对应的 User Guide 为准。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/user_guides/ug190.pdf"&gt;Virtex 5 User Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发使用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART_8800512846_18_20010_TA_25f01c24.HTM"&gt;如何正确使用 FPGA 的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;FPGA DCM 时钟管理单元的理解&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category><category term="clock resource"></category></entry><entry><title>Verilog 中的参数化建模</title><link href="https://qiangu.cool/posts/ic/parameterization_modeling_in_veriog.html" rel="alternate"></link><published>2014-07-09T23:03:00+08:00</published><updated>2014-07-09T23:03:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-07-09:/posts/ic/parameterization_modeling_in_veriog.html</id><summary type="html">&lt;p&gt;总结 Verilog 模块化建模的技术&lt;/p&gt;</summary><content type="html">&lt;p&gt;和写软件程序一样，我们也希望 Verilog 的模块也可以重利用。要使模块可以重复利用，关键就在于避免硬编码 (hard literal)，使模块参数化。&lt;/p&gt;
&lt;p&gt;参数化建模的好处是可以使代码清晰，便于后续维护和修改。&lt;/p&gt;
&lt;p&gt;Verilog 的参数化建模是有一定限制的，它的参数值是编译时计算的，不会引入任何实际的硬件电路。参数必须在编译时确定值。也就是说只能达到动态编译，固态运行，而非软件的动态编译，动态运行。&lt;/p&gt;
&lt;p&gt;这主要是因为它是描述 (Description) 硬件的语言，而非软件设计 (Design) 语言。&lt;/p&gt;
&lt;p&gt;比如一个计数器，我们可以设置一个参数来指定它的计数周期 ( 动态编译 )，但是这个计数周期在综合之后就是固定值了 ( 固态运行 )，不能在运行的时候动态地改为另外一个值 ( 除非电路综合时同时产生了多个计数器，这种情况不算真正意义上的动态运行，而且也达不到真正意义上的动态运行，因为不可能把所有可能的计数器都实现了备用，耗费资源而且没有实际意义 )。&lt;/p&gt;
&lt;p&gt;参数化建模的主要目的是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高模块的通用性，只需要修改参数，不用修改其他代码就可以适用于不同的环境中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下我找到的资料，具体的参数化建模方法一共就 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 宏定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;parameter&lt;/code&gt; 模块参数化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`ifdef&lt;/code&gt; 等 条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面详细说明&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="define macro substitution"&gt;Define Macro Substitution&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 是编译器指令，功能是全局宏定义的文本代替。它类似于 C 语言中的 &lt;code&gt;#define&lt;/code&gt;，用法如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// define&lt;/span&gt;
&lt;span class="cp"&gt;`define     WORD_REG    reg     [31:0]&lt;/span&gt;

&lt;span class="c1"&gt;// using&lt;/span&gt;
&lt;span class="no"&gt;`WORD_REG&lt;/span&gt;   &lt;span class="n"&gt;reg32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;`define 定义的宏的作用域是全局的，这种机制会导致两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可能会有在不同文件中发生重定义的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译顺序有要求 file-order dependent，必须确保使用前，宏定义有效，所以每个使用到宏定义的源文件必须包含这个头文件，这会导致多重包含的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于第一个问题，尽可能把所有的宏定义放在同一个头文件中，比如 "global_define.vh"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于第二个问题，和 C++ 类似，头文件应该使用头文件保护符。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// global_define.vh head file&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="n"&gt;GLOBAL_DEFINE_VH&lt;/span&gt;
&lt;span class="cp"&gt;    `define     MAX = 8&lt;/span&gt;
&lt;span class="cp"&gt;    `define     SIZE = 4&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="no"&gt;`enif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="guideline"&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="parameter_1"&gt;Parameter&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="parameter_2"&gt;Parameter&lt;/h3&gt;
&lt;p&gt;应该避免硬编码设计 &lt;code&gt;hard literal&lt;/code&gt;，使用参数 &lt;code&gt;parameter&lt;/code&gt; 来代替。举个例子&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// use parameter&lt;/span&gt;
&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;      &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// DO NOT use hard literal&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;     &lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="localparam"&gt;Localparam&lt;/h3&gt;
&lt;p&gt;Verilog-2001 中添加了一个新的关键字 &lt;code&gt;localparam&lt;/code&gt;，用来定义模块内部的、不能被其他模块修改的局部常量，概念类似于 C++ 中 class 的 protect 成员。&lt;/p&gt;
&lt;p&gt;虽然 localparam 不能被外部模块修改，但是它可以用 parameter 来初始化。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;  &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;localparam&lt;/span&gt; &lt;span class="n"&gt;N1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="parameter redefinition"&gt;Parameter Redefinition&lt;/h3&gt;
&lt;p&gt;在 Verilog-2001 出现之前，Verilog-1995 中只有两种方法实现参数重定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 # 符号，顺序列表重定义&lt;/li&gt;
&lt;li&gt;使用 defparam&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逐个讨论&lt;/p&gt;
&lt;h4 id="1. uisng #"&gt;1. Uisng &lt;code&gt;#&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个栗子，模块 myreg&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;myreg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="n"&gt;Trst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;Tclk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;在上一层的模块中传递参数例化这个模块&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;  &lt;span class="n"&gt;bad_warpper&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;// legal parameter passing&lt;/span&gt;
    &lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// illegal parameter passing&lt;/span&gt;
    &lt;span class="c1"&gt;// myreg #(,,8) r1(.q(q), .d(d), .clk(clk), .rst(rst) );&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然每次例化都要说明所有的参数值，但是比第二种方法好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次例化都要说明所有的参数值。&lt;/p&gt;
&lt;h4 id="2. using defparam"&gt;2. Using &lt;code&gt;defparam&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;defparam&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;比如在上面的例子中&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;defparam&lt;/span&gt;    &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以放在任何文件的任何地方，不用再重复没有修改的参数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 defparam 有这么 " 强 " 的功能，反而会导致一系列的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Hierarchical deparam. &lt;/p&gt;
&lt;p&gt;比如顶层模块使用 defparam 修改子模块的参数，子模块中又使用 defparam 修改顶层模块要传递进来的参数，形成一个环，这样子可能导致综合时不提示错误，但是结果与预期不符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiple defparams&lt;/p&gt;
&lt;p&gt;在 单个文件 / 多个文件 中重复定义 defparam，会有微妙的问题，Verilog-1995 中没有定义这种现象，实际结果依赖于使用的综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为 defparam 有这么多缺点，所以在 2001 年之前，Synopsys 是不支持 defparam 的，网上很多转载的博客都说 defparam 是不可综合的，实际上在后来，Synopsys 在压力之下添加了对其的支持。而我用 XST 也证明是支持 defparam 可综合。&lt;/p&gt;
&lt;p&gt;综上原因，Verilog Standards Group (VSG) 倡议大家抵制使用 defparam，大神 Clifford E. Cummings 在论文中建议综合工具如果用户坚持使用 defparam 语句，必须添加以一个参数 &lt;code&gt;+Iamstupid&lt;/code&gt;...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"The Verilog compiler found a defparam statement in the source code at
(file_name/line#).
To use defparam statements in the Verilog source code, you must include the switch
+Iamstupid on the command line which will degrade compiler performance and introduce
potential problems but is bug-compatible with Verilog-1995 implementations.
Defparam statements can be replaced with named parameter redefinition as define by
the IEEE Verilog-2001 standard."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;总结一下，可以发现 Verilog-1995 中的两种方法都不怎么好，显然 VSG 也发现了这个问题，所以在 Verilog-2001 中，出现了第三种方法，并且墙裂推荐使用这种新方法。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="3. using named parameter redefinition"&gt;3. Using named parameter redefinition&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于模块例化时端口连接的方式，比如上例中只想改变 SIZE 的值&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;myreg&lt;/span&gt;   &lt;span class="p"&gt;#(.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合了前两种方法的有点，既显示说明了哪个参数值改变了，也将参数传递放在了实例化的语句中。这种方法是最干净的 (cleanest) 方法，不依赖于任何综合工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;貌似没有～&lt;/p&gt;
&lt;h3 id="guideline_2"&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="example"&gt;Example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;clock cycle definition&lt;/p&gt;
&lt;p&gt;因为时钟是一个设计中最基本的常量，它不会在随着模块变化，所以应该用 &lt;code&gt;`define&lt;/code&gt; 来定义，并且将它放在顶层的头文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FSM&lt;/p&gt;
&lt;p&gt;在一个设计中可能有不止一个 FSM，而通常 FSM 有一些共同的状态名字，比如 IDLE、READY、READ、WRITE、ERROR、DONE 等，所以应该用 &lt;code&gt;localparam&lt;/code&gt; 来定义这些常量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="conditional compilation_1"&gt;Conditional Compilation&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Verilog 的条件编译和 C 也十分类似。前面介绍 define 时，已经用到了条件编译中的 &lt;code&gt;`ifdef&lt;/code&gt;。条件编译一共有 5 个关键字，分别是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;`ifdef  `else   `elsif  `endif  `ifndef&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;条件编译一般在以下情况中使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择一个模块的不同部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的时序和结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的仿真激励&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// example1&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example2&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example3&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`elsif&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example4&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt; &lt;span class="n"&gt;text_macro&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;条件编译是一个非常好的技术，它可以帮助我们更好的管理代码。&lt;/p&gt;
&lt;p&gt;举个栗子，比如我们写了一个程序，在 debug 阶段，在程序中添加了很多显示中间变量的语句，到最后 release 时，当然要去掉这些语句。最差的方法当然是删掉这些代码，但是如果以后我们还想 debug 时，又得手动写，而且时间长了，我们自己都记不清该加哪些语句了。稍微好点的方法是把它们注释起来，但是同样，时间长了，哪些该注释，那些不该注释又混淆了。最好的方法就是用条件编译。我们可以定义一个宏 DEBUG&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;`define DEBUG&lt;/span&gt;

&lt;span class="c1"&gt;// conditional compilation&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt; &lt;span class="n"&gt;DEBUG&lt;/span&gt;
    &lt;span class="c1"&gt;// debug&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
    &lt;span class="c1"&gt;// release&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这样，我们只需要选择是否注释第一行的宏定义就可快速在 debug 和 release 之间切换。&lt;/p&gt;
&lt;p&gt;再比如在 Verilog 的模块中，针对不同的应用环境，我们要实现不同的模块，这时候也可以使用条件编译选择具体综合哪段代码。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;总结一下，就是一下几点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要时使用条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;IEEE Std 1364-1995&lt;/p&gt;
&lt;p&gt;IEEE Std 1364-2001&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON2002_Parameters_rev1_2.pdf"&gt;New Verilog-2001 Techniques for Creating Parameterized Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/oomusou/archive/2008/07/09/verilog_parameter.html"&gt;( 原创 ) 如何使用参数式模组 ? (SOC) (Verilog) (C/C++) (template)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.chinaaet.com/detail/14875"&gt;艾米电子 - 参数与常量，Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/ilove314/blog/2012-03/231583_52a1d.html"&gt;Verilog 代码可移植性设计&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="parameterization"></category></entry><entry><title>FPGA 数字处理基础 (2)</title><link href="https://qiangu.cool/posts/ic/fpga_digital_processing_basic_2.html" rel="alternate"></link><published>2014-07-07T23:28:00+08:00</published><updated>2014-07-07T23:28:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-07-07:/posts/ic/fpga_digital_processing_basic_2.html</id><summary type="html">&lt;p&gt;总结 FPGA 处理数字信号的基础知识 (2)&lt;/p&gt;</summary><content type="html">&lt;p&gt;讨论 FPGA 中无符号数 unsigned 和有符号数 signed 的问题。&lt;/p&gt;
&lt;h2 id="basic knowledge"&gt;Basic Knowledge&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;整数的分类：&lt;/strong&gt; 无符号数 &lt;code&gt;unsigned&lt;/code&gt; 和 有符号数 &lt;code&gt;signed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数制：&lt;/strong&gt; 10、2、8、16 进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器数：&lt;/strong&gt; 机器数的意思是数字在机器中的表示方式。主要有 3 种&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原码 sign-magnitude&lt;/code&gt;、&lt;code&gt;反码 one's complement&lt;/code&gt;、&lt;code&gt;补码 two's complement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以前写过的一篇总结： &lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统：&lt;/strong&gt; 采用二进制、补码系统。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPGA 中是如何表示数字的呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以前写过一篇总结，&lt;a href="http://guqian110.github.io/pages/2014/05/14/fpga_digital_processing_basic_1.html"&gt;FPGA 数字处理基础 (1)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文算是上面文章的续吧。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="(un)signed in verilog"&gt;(un)signed in Verilog&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="integer"&gt;Integer&lt;/h3&gt;
&lt;p&gt;标准格式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;null|+|-&amp;gt;&amp;lt;size&amp;gt;&amp;lt;sign:s|S&amp;gt;&amp;lt;base:d|D|h|H|o|O|b|B&amp;gt;&amp;lt;0~9|0～f|0~7|0~1|x|z&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中 size 和 base 可选。&lt;/p&gt;
&lt;p&gt;所以就有两个格式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一串 0～9 组成的数字，前面可能有 +/- 符号，默认解释为有符号数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;size&amp;gt;'&amp;lt;s&amp;gt;&amp;lt;base&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt;，默认是无符号数，除非明确使用 &lt;code&gt;s&lt;/code&gt; 字段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个参数 size 表示用多少个 bit 来存储这个整数，这个参数的取值应该是一个非 0 的无符号十进制数。若没有给出，默认最小是 32 bit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数 s 表示这个数是有符号数，这个字段只影响编译器如何解释这个数。若没有这个字段，则将这个数解释为无符号数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数 base 表示使用什么进制来表示这个数，若没有给出，默认是十进制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四个参数 value 表示这个数的大小，取值应该是一个无符号的符合 base 的数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在 FPGA 也采用补码系统&lt;/strong&gt;，即在综合时，综合工具会将有符号数翻译为补码，在硬件中存储起来。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;'d5&lt;/span&gt;   &lt;span class="c1"&gt;// 占用 4 bit，存储的值为无符号数  5 的原码 0101，综合工具将其视为无符号数 5&lt;/span&gt;
&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;'&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt;  &lt;span class="c1"&gt;// 占用 4 bit，存储的值为无符号数  5 的原码 0101，综合工具将其视为有符号数 +5&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;'d5&lt;/span&gt;  &lt;span class="c1"&gt;// 占用 4 bit，存储的值为有符号数 -5 的补码 1011，综合工具将其视为无符号数 11&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;'&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt; &lt;span class="c1"&gt;// 占用 4 bit，存储的值为 1011&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="register"&gt;Register&lt;/h3&gt;
&lt;p&gt;Verilog 中数据的基本类型： &lt;code&gt;wire&lt;/code&gt;、&lt;code&gt;reg&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Verilog-1995 中，规定所有的 wire、reg 都是 unsigned 类型，只有 integer 是 signed 类型。但是 integer 的宽度是固定的 ( 与宿主机的字是一样的，最小为 32 位 )，这样子，造成了很大的不方便和浪费。&lt;/p&gt;
&lt;p&gt;在 Verilog-2001 中，添加了 wire、reg 也可以是 signed 类型了。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据可以是 signed 和 unsigned，寄存器也可以是 signed 和 unsigned，那么综合时，是以哪个为准呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题一开始自己没有搞清楚，迷惑了一下午，后来写了几个小测试程序，最后发现这个结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;以变量类型为准&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;即 reg/wire 为哪种，那么综合时就以这个为标准进行综合。比如当 reg 为 unsigned 类型，当我们给它赋值为 signed 类型的数据 &lt;code&gt;-5&lt;/code&gt;(&lt;code&gt;-4&amp;rsquo;d5&lt;/code&gt;) 时，综合出来的结果为 reg 存储的是 &lt;code&gt;-5&lt;/code&gt; 的补码 &lt;code&gt;1011&lt;/code&gt;, 但是解释为 unsigned 类型的 &lt;code&gt;+11&lt;/code&gt;。这时候就结果和我们的预期是不一样的，出现了误差，一定要注意！另一种情况类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果参与运算的变量混合有 signed 和 unsigned 类型，那么会将 signed 转换为 unsigned 类型。( 应该避免这种情况 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;========================================= 以下为详细的分类讨论 ==================================&lt;/p&gt;
&lt;p&gt;编写一个简单的测试程序，查看综合结果和仿真波形，就可以知道综合时的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;module: &lt;a href="http://guqian110.github.io/files/test_signed.v"&gt;test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;testbench: &lt;a href="http://guqian110.github.io/files/tb_test_signed.v"&gt;tb_test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="1. unsigned reg &amp;amp; unsigned value"&gt;1. unsigned reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mi"&gt;'d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;那么可以从 RTL Schematic 中看到，综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4 id="2. unsigned reg &amp;amp; signed value"&gt;2. unsigned reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;'&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;那么综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4 id="3. signed reg &amp;amp; signed value"&gt;3. signed reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;'&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4 id="4. signed reg &amp;amp; unsigned value"&gt;4. signed reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mi"&gt;'d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4 id="5. signed reg &amp;amp; unsigned reg"&gt;5. signed reg &amp;amp; unsigned reg&lt;/h4&gt;
&lt;p&gt;如果参与运算的两个变量一个是 signed，另一个是 unsigned。（注意这种现象应该避免，一般我们是不会将两种不同类型的数据混在一起进行计算的）&lt;/p&gt;
&lt;p&gt;定义 i 为 unsigned 类型，flag 为 signed 类型&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="k"&gt;signed&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;给 flag 赋值为 signed 的 -5&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;'d5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// sigend&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;综合出来的比较器为 unsigned 类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 变量 integer 也是也可综合的。在上例中，如果将 flag 的类型改为 integer 也是可综合的，但是，因为只用到了低 8 位，所以在综合时会提示高 24 位是未连接 unconnected，但是因为 integer 是一个整体，所以即使未连接也不能优化掉，这就是在 Verilog-1995 中 integer 不够灵活的体现，好在 Verilog-2001 中已经添加了支持 reg/wire 为 signed 的类型，而且综合工具 (XST) 也是支持的。&lt;/p&gt;
&lt;p&gt;======================================= 分割线结束 ==========================================&lt;/p&gt;
&lt;p&gt;以前只知道硬件上最基本的一些运算单元，比如加法器 (adder)、减法器 (subtractor)、比较器 (comparator) 等，完成的功能是固定的，电路是不会检查输入数据的类型的。涉及到 signed 和 unsigned 类型，就出现一个问题：对于基本运算单元 ( 比如加法器 )，运算单元并不知道输入的数据是哪种数据，对于 unsigned 和 signed 类型，必然出现适合一种时不适合另外一种的问题。&lt;/p&gt;
&lt;p&gt;所以可以推断出 &lt;strong&gt;对于不同的数据类型，同样是个加法器，底层的硬件电路是不一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我在程序中定义了 signed 和 unsigned 类型的数据，那么综合工具是否足够智能，能够根据数据的类型综合出正确适合的电路？&lt;/p&gt;
&lt;p&gt;答案是肯定的，即&lt;strong&gt;综合器足够智能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面的程序证明了这一点，从 RTL 图中可以看到综合出的比较器是 signed 还是 unsigned 类型，仿真波形也可以看到，最终下载到板子上测试也符合预期。这些都证明 综合器足够智能。后来看到 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/xst.pdf"&gt;UG627(v14.5): XST User Guide&lt;/a&gt;，才发现里面已经非常清楚地写着&lt;/p&gt;
&lt;p&gt;Chapter 3: Signed and Unsigned Support in XST&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When using Verilog or VHDL in XST, some macros, such as adders or counters, can be
implemented for signed and unsigned values.
To enable support for signed and unsigned values in Verilog, enable Verilog-2001
as follows:
+ ISE&amp;reg; Design Suite
  Select Verilog 2001 as instructed in the Synthesis Options topic of ISE Design Suite
Help
+ XST Command Line
  Set -verilog2001 to yes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;花费了大量时间上网找资料，在论坛里问别人无果，最后自己动手写程序测试，最后才发现原来官方资料里面早就写的清清楚楚 =.=&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="conclusion_2"&gt;Conclusion&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;说了这么多，总结下来就是下面这几句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经验：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到问题，先不要急着上网求助，上网求助这个方法虽然简单，但是是最不好的，一方面别人的话不一定可靠，另一方面，放弃思考直接上网求助对学习无益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找资料的技巧很重要。虽然我大概能够猜测到 Xilinx 官方的文档中肯定有说明，但是就是懒得去下载文档，再去找。认为网上肯定有人也有相同的困惑，所以直接 Google。结果找到一堆没有帮助的网页，浪费了时间，最后还是要看文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实践是检验真理的唯一标准，到底行不行，写测试程序，在板子上跑跑，验证一下是最有力的证明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verilog-2001 已经支持 signed 类型的 wire 和 reg，所以我们代码中如果涉及到有符号数，那么像 C 语言一样直接定义、赋值、使用即可，综合工具会综合出正确的有符号数的运算电路。不必再像以前一样手动进行补码转换，自己来处理有符号数的补码计算的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合时的原则是按照寄存器的类型进行综合 ( 即上面的分类讨论的结论 )。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仔细对比 signed 和 unsigned 类型的综合结果，可以发现 Technology Schematic 是一样的，之所以和 &amp;ldquo; 理论上硬件电路是应该不一样 &amp;rdquo; 矛盾，我认为原因在于 FPGA 的实现是基于查找表的。以上面的例子来说明，这个比较器的功能最终是在一个 LUT6 的查找表上实现的，所以，ASIC 上硬件电路的不同映射到 FPGA 中就是 LUT 的内容不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="IC"></category><category term="digital processing"></category></entry><entry><title>FPGA 中的复位设计</title><link href="https://qiangu.cool/posts/ic/the_art_of_reset_design_in_fpga.html" rel="alternate"></link><published>2014-06-20T00:22:00+08:00</published><updated>2014-06-20T00:22:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-06-20:/posts/ic/the_art_of_reset_design_in_fpga.html</id><summary type="html">&lt;p&gt;总结 FPGA 中的复位设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;复位信号在系统中的地位和时钟信号几乎同等重要，我们想尽量把系统设计为可控，那么最基本的控制信号就是复位信号了。&lt;/p&gt;
&lt;p&gt;复位信号的设计需要考虑的因素，各种书刊、论文、白皮书、网上论坛都有相关讨论，但是至今对于给定 FPGA 设计中使用哪种复位方案仍然没有明确答案。本文总结了一些大神的经典论文和网上的许多博客，尽可能用简单的图说明选择某种设计方案及其理由，涉及的更深入的原理请自行 Google :-P&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="understanding the flip-flop reset behavior"&gt;Understanding the flip-flop reset behavior&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在开始详细讨论之前，首先得理解 FPGA 的基本单元 Slice 中的 FF 的复位方式。Xilinx 的 Virtex 5 系列的芯片中的 FF 的类型都是 DFF (D-type flip flop)，这些 DFF 的控制端口包括一个时钟 CLK，一个高有效的使能 CE，一个高有效的置位 / 复位 SR。这个 SR 端口可以配置为同步的置位 / 复位，也可以配置为异步方式的置位 / 复位。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/the-art-of-reset-design-in-fpga/dff.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;例化（&lt;code&gt;instantiation&lt;/code&gt;）和 推译（&lt;code&gt;inference&lt;/code&gt;）是在 FPGA 设计中使用元件的两种不同方法。综合器是通过 HDL 代码 推译（&lt;code&gt;infer&lt;/code&gt;） 最终的电路，所以我们写的 RTL 代码风格会影响最终综合出来的 FF 类型。&lt;/p&gt;
&lt;p&gt;如果代码的敏感列表中包含复位信号，那么就会综合出一个异步复位的 DFF，SR 端口将被配置为置位或者复位端口 (FDPE &amp;amp; FDCE primitive)。当 SR 变高时，FF 的输出值立即变为代码中的复位时设定的值 SRVAL。&lt;/p&gt;
&lt;p&gt;同理，如果代码的敏感列表中不包含复位信号，那么就会综合出一个同步复位的 DFF，SR 端口将被配置为置位 / 复位端口 (FDSE &amp;amp; FDRE primitive)。当 SR 变高时，FF 的输出值在下一个时钟的上升沿变为 SRVAL。&lt;/p&gt;
&lt;p&gt;虽然 FPGA 的 FF 可以配额为 preset/clear/set/reset 等不同的结构，但是在实现时，只能配置为其中的一种，如果在代码中多于一个 preset/clear/set/reset，那么就会产生其他的逻辑，消耗 FPGA 资源。&lt;/p&gt;
&lt;p&gt;另外，基于 SRAM 的 FPGA 可以设定上电初始化的值：如果我们在定义 reg 变量时给它一个初始值，那么 FPGA 在上电配置 (GSR 变高 ) 时，载入这个值。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="active low v.s. active high"&gt;Active low  V.S.  Active high&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;大多数书籍和博客都推荐使用 &amp;ldquo; 低电平有效 &amp;rdquo; 的复位方案，却没有明确说明为什么使用 &amp;ldquo; 低电平有效 &amp;rdquo;。&lt;/p&gt;
&lt;p&gt;目前大多数书籍中都使用 低电平复位，网上给出的理由是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ASIC 设计大多数是低电平复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数厂商使用低电平复位多一些 (Xilinx 基本全是高电平复位，这也叫大多数？)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低电平复位方式，在上电时系统就处于复位状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3919870/"&gt;Verilog Verilog 嵌入式数字系统设计教程&lt;/a&gt; 说明了原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One reason for using active-low logic is that some kinds of digital circuits are able to sink more current when driving an output low than they can source when driving the output high. If such an output is used to activate some condition for which current flow is required, it would be better to use a low logic level rather than a high logic level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说目前推荐的 &amp;ldquo; 低电平有效 &amp;rdquo; 更多的是 IC 设计的传统，然而根据我查到资料来看，对于 Xilinx FPGA 这条传统并不适用。Xilinx 的器件全部是高电平复位端口，他们的 white paper 中的例子也都是高电平复位方式。而且，从综合结果来看，如果非要使用低电平复位，那么就会额外添加一个反相器，然后将反向得到的高电平连接到 FF 的复位端口，从而导致复位信号的传输时延增加，芯片的利用率下降，同时会影响到时序和功耗。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 中也证实了这一点，文中提到对于 Xilinx 器件，尽可能使用高有效复位，如果实在没有办法控制系统的复位极性，那么最好在系统的顶层模块中将输入的低有效复位翻转极性，这样做的好处是反向器将被吸收到 IO logic 中，不会消耗 FPGA 内的逻辑和布线资源。&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="synchronous v.s. asynchronous_1"&gt;Synchronous V.S. Asynchronous&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;因为 DFF 有两种复位端口，所以对应的有两种复位方式：同步复位 和 异步复位。两种复位方式各有特点，适用于不同的应用场景。下面先分别总结两种方案的优劣，最后总结当前流行的的主流复位方案。&lt;/p&gt;
&lt;h3 id="synchronous reset"&gt;Synchronous Reset&lt;/h3&gt;
&lt;h4 id="coding style"&gt;Coding Style&lt;/h4&gt;
&lt;p&gt;同步复位的假设前提：只有在时钟信号的有效沿，复位信号才能影响寄存器的状态。&lt;/p&gt;
&lt;p&gt;通常把 reset 信号作为组合逻辑的一部分连接到寄存器输入端口 D，从而对寄存器起作用。因此同步复位的 coding style 应该是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块的 &lt;code&gt;sensitivity list&lt;/code&gt; 中不包含 &lt;code&gt;rst&lt;/code&gt; 信号，并且 reset 信号应该在 if-else 的最前面（if 分支），以便于优先考虑，其他组合逻辑位于后面（else 分支）。&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;对应的 RTL Schematic 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync reset" src="/images/the-art-of-reset-design-in-fpga/sync_reset.png"/&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdr&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Singal Data Rate D Flip-Flop with Synchronous Reset and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="n"&gt;FDRE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1'b0 or 1'b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDRE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Synchronous reset input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDRE_inst instantiation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;有时候，有些器件不带同步复位专用端口，那么综合器一般会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;h4 id="problem"&gt;Problem&lt;/h4&gt;
&lt;p&gt;如果没有遵守这样的 coding style，可能会引起下面的两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在一些基于逻辑表达式计算的仿真器上，一些逻辑可能会阻止复位信号作用到寄存器上&lt;/p&gt;
&lt;p&gt;注意：只存在于仿真器的问题，硬件上没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于时钟信号而言，因为复位树（reset tree）上有着非常高的扇出，所以复位信号可能是一个晚到底信号（late arriving signal）&lt;/p&gt;
&lt;p&gt;明智之举是：即使在复位树上加入 buffer，一旦复位信号进入到局部逻辑区域（local logic），那么就要限制复位信号到达寄存器所经历的逻辑数量，以减少延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用同步复位还有一个问题是：&lt;/p&gt;
&lt;p&gt;综合工具无法很轻松地从其他逻辑信号中识别出复位信号。（这可能导致一些仿真的问题，注意只是仿真问题，实际电路会正常工作，正确复位）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;solution:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;synposys 提供了综合指令 &lt;code&gt;sync_set_reset&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;// synposys sync_set_reset "rst"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个指令的作用是告诉综合工具指定的信号是同步 set/reset，那么综合工具就会尽量把这个信号放在靠近寄存器的位置，以防前面说仿真问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常，只有在综合指令是不许的而且是紧要的时候，我们才使用它们。&lt;/strong&gt;我们应该遵守这一原则，因为综合指令的使用可能导致前后仿真的不一致。&lt;/p&gt;
&lt;p&gt;但是 &lt;code&gt;sync_set_reset&lt;/code&gt; 是个例外情况，因为它不会影响逻辑行为，只影响设计的功能实现。&lt;/p&gt;
&lt;p&gt;所以明智的设计者在项目开始的时候就把 &lt;code&gt;sync_set_reset&lt;/code&gt; 添加到 RTL 代码中，以避免以后的多次综合。由于每个模块对这条指令只要求使用一次（模块只有一个复位信号），所以推荐为每个模块添加这条指令。&lt;/p&gt;
&lt;p&gt;如果觉得每个模块都添加这种方式太繁琐，还有另外一种方法：在读取 RTL 代码前，设置综合变量 &lt;code&gt;hdlin_ff_always_sync_set_reset&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，可以达到同样的效果。&lt;/p&gt;
&lt;h4 id="advantage"&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证设计是 100% 同步，有利于时序分析，也利于仿真&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低亚稳态出现的几率，时钟起到过滤毛刺的作用 ( 如果毛刺发生在时钟沿附近，那么仍然会出现亚稳态的问题 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某些设计中，复位信号是由内部逻辑产生的，推荐使用同步复位，因为这样可以避免逻辑产生的毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="disadvantage"&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;并不是所有的 ASIC 库里面都有带同步复位端的寄存器，不过这个问题并不严重，因为同步复位信号只是另外一个数据输入信号，所以综合工具很容易把复位信号综合到寄存器外部的逻辑中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步复位需要保证复位信号具有一定的脉冲宽度 (pulse stretcher)，使其能被时钟沿采样到，尤其是多时钟域的设计中。这是需要重点考虑到，可以使用一个小岛计数器，以保证复位脉冲信号保持一定数量的时钟周期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在仿真过程中，同步复位信号可能被 X 态掩盖 (? 不懂 ...)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步复位信号需要时钟信号正常工作。在一些设计中这个条件可能不是问题，但是在一些设计中就比较让人恼火了。比如，为了节省功耗使用了门控时钟（gated clock），在复位信号有效时，时钟信号还处于禁止状态（disabled），而在时钟恢复时，复位信号已经被撤销了。这种情况就会导致电路无法复位（异步复位则无此问题）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果设计中含有三态总线，为了防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果逻辑器件的目标库内的 FF 只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;p&gt;有很多教材和博客都直接说 &amp;ldquo; 同步复位会产生额外的逻辑资源 &amp;rdquo;，可能他们是基于 Altera 的 FPGA 这么做的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="extra logic" src="/images/the-art-of-reset-design-in-fpga/extra_logic.png"/&gt;&lt;/p&gt;
&lt;p&gt;但是根据我实际的测试结果，对于 Virtex 5 系列的芯片，它的原语里面已经含有各种带同步、异步复位端口的 FF，ISE 自带的 XST 也已经很智能了，它会根据代码分析，自动选择合适的 FF。所以上面同步复位综合出来的 RTL Schematic 中没有所谓的 &amp;ldquo; 多余的逻辑资源 &amp;rdquo;。&lt;/p&gt;
&lt;p&gt;所以，是否占用多余的资源，还得针对具体的芯片分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="asynchronous_1"&gt;Asynchronous&lt;/h3&gt;
&lt;h4 id="coding style_1"&gt;Coding Style&lt;/h4&gt;
&lt;p&gt;虽然异步复位信号是电平有效，但是敏感列表必须在异步复位信号的前沿激活：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;对应的 RTL Schematic 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="aync reset" src="/images/the-art-of-reset-design-in-fpga/async_reset.png"/&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdc&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Single Data Rate D Flip-Flop with Asynchronous Clear and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="n"&gt;FDCE&lt;/span&gt; &lt;span class="p"&gt;#(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// Initial value of register (1'b0 or 1'b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;FDCE_inst&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;      &lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="c1"&gt;// 1-bit Asynchronous clear input&lt;/span&gt;
   &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDCE_inst instantiation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h4 id="problem_1"&gt;Problem&lt;/h4&gt;
&lt;p&gt;由于复位信号相对于时钟信号来说是异步的，所以可能导致两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;复位信号违反 recovery time&lt;/p&gt;
&lt;p&gt;recovery time 是复位信号撤销的沿到时钟有效沿之间最小的时间间隔（类似于同步信号中的 setup time），如果违反 recovery time，寄存器的输出会出现亚稳态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于不同的寄存器，复位信号的撤销（removal）可能发生在不同的时钟周期内 &lt;/p&gt;
&lt;p&gt;由于复位信号和时钟在传输延迟的轻微差别，导致有的寄存器的复位信号早于时钟信号，在时钟沿之前寄存器就被先复位；有些复位信号晚于时钟信号，在时钟沿之后寄存器才复位，从而有些寄存器先于其他寄存器退出复位状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;异步复位和同步复位是互补，一个的优点（缺点）即使另外一个的缺点（优点）：&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="advantage_1"&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单元库中肯定是包含异步复位的寄存器的，所以异步复位最大的优点是不需要额外的逻辑，可以保持数据路径（data path）的干净。这在数据路径时序很紧张的情况下非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脉冲宽度没有限制，可以快速复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有时钟的时候也可以将电路复位 ( 使用 gated clock，同步复位无法工作，而异步复位是可以的 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EDA 工具 route 起来更容易，对于大型设计，能显著减少编译时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="disadvantage_1"&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不是同步电路，不利于时序分析，设计者要正确约束异步复位信号比同步复位复杂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位信号容易收到毛刺的干扰，板上或者系统复位上的噪声或者毛刺会导致假的复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步复位最大的问题是容易在复位信号的起效（assert）和失效（deassert）是异步的，起效异步没有问题，但是失效异步可能导致亚稳态。( 撤销的时候 (release) 不满足 &lt;code&gt;removal time&lt;/code&gt; 时序要求，从而产生亚稳态 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="reset synchronizer_1"&gt;Reset Synchronizer&lt;/h3&gt;
&lt;p&gt;两种复位方式各有优缺点，设计者应该根据实际情况选择合适的复位方法。目前，很多文献书籍中都推荐一种 &amp;ldquo; 异步复位，同步释放 &amp;rdquo; 的方法。这种方法可以将两者结合起来，取长补短。&lt;/p&gt;
&lt;p&gt;它的原理如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer.png"/&gt;&lt;/p&gt;
&lt;p&gt;需要注意到是，上图的复位是传统的低电平有效方式，对于 Xilinx 器件，原理图稍有不同，其复位按钮接到了 FF 的置位端，第一级 FF 的输入也由 &lt;code&gt;Vcc&lt;/code&gt; 变为 &lt;code&gt;GND&lt;/code&gt;。 &lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 介绍了对应的 RTL Schematic ：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset_synchronizer_xilinx" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_xilinx.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;对于 Xilinx 器件，用代码具体实现&lt;/p&gt;
&lt;h4 id="coding style_2"&gt;Coding Style&lt;/h4&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;SYSRST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sys_rst&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;rst_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="c1"&gt;// reset&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;sys_rst&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;对应的 RTL Schematic 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_rtl.png"/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;rst_pb&lt;/code&gt; 是系统的复位按钮，&lt;code&gt;sys_rst&lt;/code&gt; 是同步化的结果。可以看到综合结果和上图是一致的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simulation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="simulation" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_simulation.png"/&gt;&lt;/p&gt;
&lt;p&gt;所谓 &amp;ldquo; 异步复位 &amp;rdquo;，如上图 ( 由于连接到了置位端，叫 &amp;ldquo; 异步置位 &amp;rdquo; 更合适 )，一旦复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 有效，那么输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 立即被置为 &lt;code&gt;1&lt;/code&gt;，否则输出为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓 &amp;ldquo; 同步释放 &amp;rdquo;。如上图，当复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 释放时 ( 从有效变为无效 )，输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 不是立即变化，而是被 FF 延迟了一个时钟输出，从而使其和时钟同步化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否存在亚稳态？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案：不存在。&lt;/p&gt;
&lt;p&gt;分析：第一个寄存器的输入和输出在复位变有效前后是不一致的，当复位信号很靠近时钟信号时，可能违反 recovery time，其输出可能存在亚稳态。但是到了第二个寄存器，因为它的输入和输出在复位信号有效前后是一致的，所以它的输出没有机会在两个电平之间抖动，所以不存在亚稳态。&lt;/p&gt;
&lt;p&gt;可以看到，这种 &amp;ldquo; 异步复位，同步释放 &amp;rdquo; 的方法既解决了同步复位对脉冲宽度的要求，又解决了异步复位可能导致的亚稳态问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guidelien:&lt;/strong&gt; Every ASIC using an asynchronous reset should include a reset synchronizer circuit!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="conclusion_2"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;知道了这点，选择复位信号的策略就很明显了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 &amp;ldquo; 同步化 &amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了 (CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步 / 异步复位端口 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要异步复位时，必须包含同步器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在详细讨论了复位的有效电平、复位方式之后，我们开始讨论稍微复杂一点的复位设计：包括系统的复位方案、多时钟域的复位方案、复位信号的去除毛刺等。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="think local v.s. think global_1"&gt;Think Local V.S. Think Global&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;我们使用复位信号的一个目的就是为了使电路可控，当上电时或者系统出错时，可以通过复位的方式回到正常状态。为了达到完全可控，传统的做法是对系统内的每个 FF 都连接复位信号，这样就造成了复位信号的高扇出，而高扇出会导致一系列的问题。&lt;/p&gt;
&lt;p&gt;Xilinx 有个 White Paper，&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;，提出一种新的复位思路： 能不用全局复位时，尽量不要使用，这样可以降低复位信号的扇出。&lt;/p&gt;
&lt;p&gt;这个原则和我们平时的理解和习惯是相反的，它不使用全局复位的原因主要有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随着时钟速率的提高，GSR 逐渐变为时序关键路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果电路中没有反馈环路，那么上电初始化已经足够了，很多设计中的 reset 信号都可以省去&lt;/p&gt;
&lt;p&gt;如果没有反馈环路，比如移位寄存器，即使开始状态是错误的，当数据流进入到一段时间，错误数据将被冲刷出去，所以没有必要保留 reset 信号。如果系统中有反馈环路，比如状态机，当初始状态不对或者状态跑飞时，无法回到正常状态，那么 reset 信号是有必要保留的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码中简单的添加一个 reset 端口，在底层实现时要消耗很多我们想不到的资源。&lt;/p&gt;
&lt;p&gt;全局复位会和设计中的其他单元竞争布线资源，全局复位一般来说肯定有非常高的扇出，因为它需要连接到设计中的每一个 FF。这样，它会消耗大量的布线资源，使芯片利用率下降，同时也会影响时序性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，有必要使用其他的不依靠全局复位的方法。&lt;/p&gt;
&lt;p&gt;如图所示，Xilinx FPGA 在配置 / 重配置的时候，每个 FF 和 BRAM 都会被初始化一个预先设定的值 ( 大部分器件的默认值是 0, 也有例外 )，所以，上电配置和全局复位有着类似的功能，将每个存储单元配置为一个已知的状态。&lt;/p&gt;
&lt;p&gt;&lt;img alt="configuration" src="/images/the-art-of-reset-design-in-fpga/configuration.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;系统在上电配置时，内部有个信号叫 &lt;code&gt;GSR&lt;/code&gt; (Global Set/Reset)，它是一种特殊的预布线的复位信号，能够在 FPGA 配置的过程中让设计保持初始状态。在配置完成后，GSR 会被释放，所有的触发器及其它资源都加载的是 INIT 值。除了在配置进程中自动使用 GSR，用户设计还可以通过实例化 STARTUP 模块并连接到 GSR 端口的方法来访问 GSR 网。使用该端口，设计者可以重新断言 GSR ，相应地 FPGA 中的所有存储元件将返回到它们的 INIT 属性所规定的状态。&lt;/p&gt;
&lt;p&gt;设定初值的语法很简单，只需要在定义变量时给它初始值就可以了：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;和 reg 类似，BRAM 也可以在配置的时候初始化，随着嵌入式系统的 BRAM 逐渐增大，BRAM 初始化非常有用：因为预先定义 RAM 的值可以使仿真更容易，而且无需使用引导序列为嵌入式设计清空内存。&lt;/p&gt;
&lt;p&gt;使用 GSR 的好处是 &lt;strong&gt;可以解决复位信号高扇出的问题&lt;/strong&gt;，因为 GSR 是预布线的资源，它不占用每个 FF 和 Latch 的 set/reset 端口，如下图所示。很多资料都推荐将设计中的 reset 按钮连接到 GSR，以利用它比较低的 skew。&lt;/p&gt;
&lt;p&gt;&lt;img alt="gsr rset" src="/images/the-art-of-reset-design-in-fpga/gsr_reset.gif"/&gt;&lt;/p&gt;
&lt;p&gt;既然 GSR 这么好，那么是不是只使用 GSR 就可以了，不必再用 FF 和 Latch 的 set/reset 端口了呢？&lt;/p&gt;
&lt;p&gt;答案当然是否定的。由于 GSR 的释放是异步方式，所以，如果我们只使用 GSR 作为系统的唯一复位机制，那么可能导致系统不可靠。所以还是需要显式地使用同步复位信号来复位状态机、计数器等能自动改变状态的逻辑。&lt;/p&gt;
&lt;p&gt;所以，应该使用 &lt;strong&gt;GSR + explict reset&lt;/strong&gt; 的解决方案：&lt;/p&gt;
&lt;p&gt;给系统中的 reg 赋初值，对于没有环路的电路节省 reset，利用 GSR 实现复位的功能；对于有环路的电路，使用显示的复位信号。&lt;/p&gt;
&lt;h3 id="upate: 07/01/2014"&gt;Upate: 07/01/2014&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关于 initialize 代替 reset&lt;/p&gt;
&lt;p&gt;这几天看 resest 相关问题时，又在 &lt;code&gt;stackoverflow&lt;/code&gt; 上发现一个关于&lt;a href="http://stackoverflow.com/questions/6363130/is-there-a-reason-to-initialize-not-reset-signals-in-vhdl-and-verilog"&gt;是否应该使用 initialize 代替 reset 的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支持用 initialize 代替 reset 的人提出的方案是尽量不要使用全局复位信号，使用初始化值代替复位，对于一些必须要求复位的模块，使用 &lt;em&gt;local&lt;/em&gt; 的复位信号。&lt;/p&gt;
&lt;p&gt;反对者认为，用 initialize 代替 reset 的想法只是学院派的不切实际的想法。一般只有基于 SRAM 的 FPGA 才会使用到初始化。而这样做的目的只是为了节省布线资源，降低时序要求，但是现代 FPGA 有很多布线资源和没有使用的全局网络，所以，复位信号一般不是时序关键路径。即使遇到问题，可以通过手动例化一个时钟 BUF 来解决。使用这种无复位的设计虽然在某些情况是可行的，但是当你把你的设计和其他系统连接起来时，通常会感到非常痛苦，因为大多数系统都会要求有个复位信号。在由 FPGA 转 ASIC 时也比较方便，因为只有基于 SRAM 的 FPGA 才可以使用这种 initialize 代替 reset 的技术，而 ASIC 不行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于 GSR&lt;/p&gt;
&lt;p&gt;网上有很多人都推荐将我们用户定义的复位信号连接到 GSR 信号上，以便利用 GSR 提供的低抖动性，包括 &lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 也推荐使用 GSR 信号。但是在 Xilinx 的另一份文档 &lt;a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx14_7/sim.pdf"&gt;UG626: Synthesis and Simulation Design Guide&lt;/a&gt; 中说不推荐使用 GSR 来作为系统的复位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although you can access the GSR net after configuration, Xilinx does not recommend using the GSR circuitry in place of a manual reset. This is because the FPGA devices offer high-speed backbone routing for high fanout signals such as a system reset. This backbone route is faster than the dedicated GSR circuitry, and is easier to analyze than the dedicated global routing that transports the GSR signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这个矛盾早就有人在 Xilinx Forum 上提问了 &lt;a href="http://forums.xilinx.com/t5/Virtex-Family-FPGAs/What-does-GSR-signal-really-mean-and-how-should-I-handle-the/td-p/35610"&gt;What does GSR signal really mean and how should I handle the reset signal properly&lt;/a&gt;，还有 &lt;a href="http://forums.xilinx.com/t5/Archived-ISE-issues/FPGA-Power-On-Reset/m-p/7027?query.id=134602#M2035"&gt;FPGA Power On Reset!&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="conclusion_3"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;p&gt;P.S. 事实上没有一个通用的、适合所有器件的复位方案，我们应该首先了解所使用的器件和工具，针对它们的特点进行复位方案的设计。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="shift register reset"&gt;Shift Register Reset&lt;/h3&gt;
&lt;p&gt;并不是每一个设计，器件中的每一个寄存器都需要复位的。最好的做法是只将复位连接到那些需要复位的寄存器。一个典型特例就是移位寄存器的复位。&lt;/p&gt;
&lt;p&gt;如果一个模块内部含有一组触发器 ( 移位寄存器 )，这些寄存器可以分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;resetable flip-flops&lt;/p&gt;
&lt;p&gt;第一个 ff，它是需要复位信号的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;follower flip-flops&lt;/p&gt;
&lt;p&gt;后续的 ff，仅作为简单的数据移位寄存器，不含复位端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在设计时应该只复位第一个触发器，后续的触发器仅作为数据寄存器使用，不能对它们进行复位。
这里体现出来的一个原则就是：能节省 reset 时，尽量节省。&lt;/p&gt;
&lt;p&gt;原因就是 reset 作为一个实际存在的物理信号，需要占用 FPGA 内部的 route 资源，往往 reset 的 fanout 又多得吓人。这就很容易造成 route 难度上升，性能下降，编译时间增加。因此，在 FPGA 设计中能省略的复位应尽量省略。&lt;/p&gt;
&lt;p&gt;比较好的设计风格，不同类型的 FF 不应该组合进单个 alway 块中。也就是说，不要把这两种 FF 写在同一个 always 块中，而应该每个 &lt;code&gt;always&lt;/code&gt; 模块只对一种 FF 建模。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bad Style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;BADSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于第二个 ff 来说，是一个片选信号 &lt;code&gt;ce&lt;/code&gt;，这样的设计产生额外的逻辑，是不好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bad style" src="/images/the-art-of-reset-design-in-fpga/bad_style.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good Style:&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;GOODSTYLE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;       &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt;      &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt;         &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于两个 ff 来说，都是复位信号，不需要额外的逻辑，这样的设计是比较好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="good style" src="/images/the-art-of-reset-design-in-fpga/good_style.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reset distribution tree_1"&gt;Reset Distribution Tree&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;复位信号的 &lt;code&gt;reset distribution tree&lt;/code&gt; 和 时钟信号的 &lt;code&gt;clock distribution tree&lt;/code&gt; 差不多同等重要，因为在设计中，几乎每个器件都有时钟端口和复位端口 ( 同步 / 异步 )。&lt;/p&gt;
&lt;p&gt;reset distribution tree 和 clock distribution tree 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree" src="/images/the-art-of-reset-design-in-fpga/reset_tree.png"/&gt;&lt;/p&gt;
&lt;p&gt;系统中的主复位信号经过 reset distribution tree 达到每个元件，实现复位。&lt;code&gt;reset distribution tree&lt;/code&gt; 和 &lt;code&gt;clock distribution tree&lt;/code&gt; 最大的区别就是它们对 &lt;code&gt;skew&lt;/code&gt; 的要求不同。由上面的讨论可知，复位信号和时钟的关系最好是 &amp;ldquo; 同步释放 &amp;rdquo;，不像时钟信号的要求那么严格，复位信号之间的 skew 不需要那么严格，只要复位信号的延迟足够小，满足能在一个时钟周期内到达所有的复位负载端，并且满足各个 reg 和 flip-flop 的 &lt;code&gt;recovery time&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3 id="in asic"&gt;in ASIC&lt;/h3&gt;
&lt;p&gt;在 ASIC 设计中，两种 tree 的关系有以下两种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;驱动 reset tree 最安全的方法就是使用 clock tree 的叶子节点的时钟信号来驱动，如下图所示。如果采用这种方法且时序分析是满足的，那么就没有问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_delayed_clock.png"/&gt;&lt;/p&gt;
&lt;p&gt;分析以下情况：clock tree 中的一路叶子时钟信号驱动 &lt;code&gt;reset synchroinzer&lt;/code&gt;，得到的复位信号 masterrst_n 穿过 reset tree，输入到 DFF 的复位端口；clock tree 的另外一路叶子时钟信号直接连接 DFF 的时钟端。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;理想情况下（时钟速率不高），reset 支路即使经过 reset synchronizer 和 reset tree，仍然满足 slack 为正，满足时序，电路可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，在大多数情况下，时钟信号的频率都比较高，这些操作产生的延时太大，无法在一个时钟周期内完成，导致 slack 为负，此时无法满足时序要求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了加速 reset 信号到达系统内的 DFF，使用进入 clock tree 之前的时钟信号来驱动 reset synchronizer，如图所示。这时候 reset 和 clock 是异步的，所以必须在 &lt;code&gt;PAR&lt;/code&gt; 之后进行 &lt;code&gt;STA&lt;/code&gt;，以保证&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若系统使用异步复位方式，则经过 reset tree 的复位信号释放 (release) 满足 &lt;code&gt;恢复时间 (recovery time)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若系统使用同步复位方式，则经过 reset tree 的复位信号满足&lt;code&gt;建立时间 (setup time)&lt;/code&gt; 和 &lt;code&gt;保持时间 (hold time)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，只有最后完成布局布线之后，才能根据具体情况进行分析调整 clock tree 和 reset tree。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_parallel_clock.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对于 synchronou/asynchronous 两种 tree，可以用两种技术来进行优化：&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="synchronous reset distribution tree"&gt;synchronous reset distribution tree&lt;/h4&gt;
&lt;p&gt;如下图所示，在 reset tree 中嵌入 DFF，在每个模块中，输入的 reset 信号首先经过一个 DFF，然后把经过 DFF 延迟输出的复位信号用作复位信号来复位逻辑、驱动子模块。这样 reset 信号就不必在一个时钟周期内到达每一个 DFF 的复位端口，从而可以把 reset 信号的时序要求降得很低。&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronous reset" src="/images/the-art-of-reset-design-in-fpga/synchronous_reset_distribution.png"/&gt;&lt;/p&gt;
&lt;p&gt;通过这种技巧，复位信号就被当作了普通的数据信号，而且时序分析要简单的多（因为 reset tree 的每一部分 stage 都有合理的扇出）。&lt;/p&gt;
&lt;p&gt;所以每个 module 里面都含有以下代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;input&lt;/span&gt;    &lt;span class="n"&gt;reset_raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// synposys sync_set_reset "reset"&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;reset&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;reset_raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;reset_raw 是本模块的输入复位信号，reset 为经过 DFF 后的本地（local）复位信号，同时也连接子模块 reset_raw 的输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantage&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;降低 reset 的时序要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低 reset 的扇出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利于时序工具分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要多个时钟周期才能复位&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="asynchronous reset distribution tree"&gt;asynchronous reset distribution tree&lt;/h4&gt;
&lt;p&gt;和同步复位类似，异步复位也可以采用相同的策略，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="asynchronous reset" src="/images/the-art-of-reset-design-in-fpga/asynchronous_reset_distribution.png"/&gt;&lt;/p&gt;
&lt;p&gt;利用前面讨论过的 reset synchronizer 将异步复位信号同步到每个子模块当中。&lt;/p&gt;
&lt;p&gt;和 synchronous reset 一样，在 reset tree 中加入 synchronizer 之后，复位功能需要多个时钟周期才能完成。&lt;/p&gt;
&lt;h4 id="problem_2"&gt;Problem&lt;/h4&gt;
&lt;p&gt;因为不同的子模块深度不同，所以不同模块可能不是同时复位的（同一个时钟周期）。这种情况是否会引起问题，依应用情况而定，大多数设计都没有问题，但是如果要求一定要在同一时钟周期复位，那么就要平衡不同子模块内的 synchronizer 数量，无论是 synchronous 还是 asynchronous 都是一样的。&lt;/p&gt;
&lt;h4 id="advantage_2"&gt;Advantage&lt;/h4&gt;
&lt;p&gt;前面讨论的 reset tree 和 clock tree 主要问题就是两者是异步的，一定要保证 reset 的释放满足 recovery time，在 P&amp;amp;R 之后，时序分析如果不满足的话，设计者需要手动调整时序，然后重新 P&amp;amp;R，时序分析直到满足为止。&lt;/p&gt;
&lt;p&gt;作为对比，如果采用这里插入 synchronizer 的方法，则免去了手动调整的工作，让综合工具完成时序分析和调整工作。经过调整之后，全局（global）复位信号就变为本地（local）复位信号了。（synchronous 也一样，变为 local reset）&lt;/p&gt;
&lt;h3 id="in fpga_1"&gt;in FPGA&lt;/h3&gt;
&lt;p&gt;对于 FPGA，因为系统的 clock tree 是预先布线好的，而全局主复位信号一般也使用时钟布线资源，所以不存在两棵 tree 之间关系的调整问题，所以只需要采用上面的 synchronou/asynchronous reset distribution tree 即可。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="multi-clock reset_1"&gt;Multi-clock Reset&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;在一个系统中，往往有多个时钟，每个时钟域都应该有独立的 synchronizer 和 reset tree，这么做的目的是为了保证每个时钟域的每个寄存器都能满足 removal time。&lt;/p&gt;
&lt;p&gt;因为只有一个全局复位的话，它与系统的时钟都没有关系，是异步复位信号，要求这个信号满足所有时钟域的 recovery 和 removal 时序不是一件容易的事情，因此为每个时钟域分配复位是有必要的。&lt;/p&gt;
&lt;p&gt;根据实际情况的不同，有两种方案可以采用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-coordinated reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于多时钟域的设计，很多时候不同时钟域之间复位信号的先后顺序没有要求，尤其是在有 &lt;code&gt;request-acknowledge&lt;/code&gt; 这样握手信号的系统中，不会引起硬件上的错误操作，这时候下图所示的方法就足够了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="non coordinated reset" src="/images/the-art-of-reset-design-in-fpga/non_coordination.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequenced coordination of reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些设计，要求复位信号的释放顺序有一定顺序，这时候应该使用下图所示的方法&lt;/p&gt;
&lt;p&gt;&lt;img alt="sequenced rcoordination" src="/images/the-art-of-reset-design-in-fpga/sequenced_coordination.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 在文中提供了一张图来说明典型的系统复位方案，图中 &lt;code&gt;MMCM&lt;/code&gt; 的 &lt;code&gt;lock&lt;/code&gt; 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="typical reset implementation in FPGA" src="/images/the-art-of-reset-design-in-fpga/typical_reset.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reset glitch filtering"&gt;Reset Glitch Filtering&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;最后讨论一下复位信号毛刺的问题。&lt;/p&gt;
&lt;p&gt;使用异步复位信号时，考虑到异步复位信号对毛次比较敏感，所以在一些系统中需要处理毛次，下图显示了一种简单但是比较丑陋的方法 ( 时延不是固定的，会随温度、电压变化 )&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset glitch filtering" src="/images/the-art-of-reset-design-in-fpga/reset_glitch_filtering.png"/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;毛刺 Glitch&lt;/code&gt; 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论待续&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是所有的系统都需要过滤毛刺，设计者要先研究需求，再觉得是否使用延时来过滤毛次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;本文是读书笔记，总结了参考资料中的复位信号的设计方法和需要注意的问题，包含了底层的 DFF 复位方式、高 / 低电平有效、同步 / 异步复位、和系统级的复位方案选择、设计。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 &amp;ldquo; 同步化 &amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了 (CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步 / 异步复位端口 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要使用异步复位同步化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用 synchronou/asynchronous reset distribution tree 可以降低 reset 信号的时序要求，减小扇出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个时钟域都应该有一个同步器来同步复位信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总而言之，一句话：我们想象中的，简单的，统一的复位方案是 ... 不存在的 =.=&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ_Resets.pdf"&gt;Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2003Boston_Resets.pdf"&gt;Asynchronous &amp;amp; Synchronous Reset Design Techniques - Part Deux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/white_papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc_id=1278998"&gt;How do I rest my FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/coyoo/blog/13-12/301045_9c39f.html"&gt;FPGA 复位电路的实现及其时序分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://item.jd.com/11337565.html"&gt;100 Power Tips for FPGA Designers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379"&gt;Advanced FPGA Design by Steve Kilts&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="reset"></category></entry><entry><title>有限状态机 FSM 设计</title><link href="https://qiangu.cool/posts/ic/fsm_design.html" rel="alternate"></link><published>2014-06-05T17:55:00+08:00</published><updated>2014-06-05T17:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-06-05:/posts/ic/fsm_design.html</id><summary type="html">&lt;p&gt;博客搬家，温故而知新。&lt;/p&gt;</summary><content type="html">&lt;p&gt;有限状态机是数字电路中经常出现、非常重要的电路，设计一个安全、高效的状态机有一套程序化的方法，我们在数字电路课中就学习过了。搬运以前写的博客，总结一下相关知识，温故而知新～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面的废话：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇博客是在我以前在 CSDN 上写的两篇博客的基础上，参考了其他各位大神、博主的文章，写的总结。欢迎批评、讨论，毕竟写博客的意义就在于给自己一个总结知识的机会、并且在和别人讨论的过程中进步 :-D&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="what is fsm"&gt;What is FSM&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Finite-state_machine"&gt;FSM on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有限状态机 (Finite State Machine, FSM)&lt;/strong&gt; 有时候也简称为&lt;strong&gt;状态机 (state machine)&lt;/strong&gt;，它是一种数学模型，通常用来设计电脑程序或者时序电路。它被构思设计为一个抽象的机器，并且某个时刻只能处于一个有限数字代表的状态之下。&lt;/p&gt;
&lt;p&gt;有限状态自动机在很多不同领域中是重要的，包括电子工程、语言学、计算机科学、哲学、生物学、数学和逻辑学。有限状态机是在自动机理论和计算理论中研究的一类自动机。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。( 这里讨论的只限于电子工程里的状态机 )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组成元素：&lt;/strong&gt;输入、状态、状态转移条件、输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态转移图&lt;/li&gt;
&lt;li&gt;状态转移表&lt;/li&gt;
&lt;li&gt;HDL 描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机的框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/fsm.png"/&gt;&lt;/p&gt;
&lt;p&gt;按照输出的产生方式，可以将状态机分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Moore_machine"&gt;Moore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它的输出只取决于当前状态，而与输入无关。Moore 状态机最重要的特点就是将输入与输出信号隔离开来，而且输出与时钟信号同步的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Mealy_machine"&gt;Mealy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它的输出不仅和当前状态有关，而且和输入也有关。Mealy 有限状态机对输入的响应发生在当前时钟周期，比 Moore 有限状态机对输入信号的响应要早一个周期。因此，输入信号的噪声可能影响在输出的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="how to design a fsm"&gt;How to Design a FSM&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;关于如何设计一个状态机，这在数字电路和逻辑设计的书里有详细介绍。简单地总结一下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑抽象，建立原始状态转移图：确定输入、输出、状态变量、画状态转移图&lt;/li&gt;
&lt;li&gt;状态简化，得到最简的状态转移图 ( 卡诺图 )&lt;/li&gt;
&lt;li&gt;状态分配，选择编码方案 (Binary、Gray、One-Hot)&lt;/li&gt;
&lt;li&gt;画逻辑图，检查能否自启动，得到了最终的状态机模型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="how to implement a fsm"&gt;How to implement a FSM&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;当设计好之后，就要使用 HDL 语言来实现这个 FSM 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言：&lt;/strong&gt; Verilog HDL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合工具：&lt;/strong&gt; XST (Xilinx Synthesis Tools)&lt;/p&gt;
&lt;h3 id="coding goals"&gt;Coding goals&lt;/h3&gt;
&lt;p&gt;我们的代码需要达到的目的应该是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FSM coding style should be easily modified to change state encodings and FSM styles&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should be compact&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should be easy to code and understand&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should facilitate debugging&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should yield efficient synthesis results&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id="template"&gt;Template&lt;/h3&gt;
&lt;p&gt;为了达到目的，总结出了下面的这个三段式的模板（使用 index one-hot + reverse case + synopsys FSM 语法）&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
                     &lt;span class="n"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;'d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;S1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;'d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;S2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;'d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;S3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;'d3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;ERROR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;'d4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// synopsys state_vector state&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
                &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt;       &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;'d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// synopsys full_case parallel_case&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// default output&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;需要注意的是 synopsys FSM 的语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;parameter 定义的两端都要定义位宽，不能省略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释 &lt;code&gt;// synopsys ...&lt;/code&gt; 的位置不能随意改变&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使改用其他的综合工具，前面的 FSM 定义的综合指令不影响，需要修改的只有 case 综合指令（如 XST 改为 &lt;code&gt;// synthesis full_case parallel_case&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面逐个讨论为什么这么写，以及需要注意的问题。&lt;/p&gt;
&lt;h3 id="always block"&gt;Always Block&lt;/h3&gt;
&lt;p&gt;状态机一般有三种写法，他们在速度、面积、代码可维护性等各个方面互有优劣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一段式：&lt;/strong&gt; 只有一个 always block，把所有的逻辑（输入、输出、状态）都在一个 always block 中实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：看起来很简洁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：不利于维护，如果状态复杂一些就很容易出错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不推荐这种方法，但是在简单的状态机可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二段式：&lt;/strong&gt; 有两个 always block，把时序逻辑和组合逻辑分隔开来。时序逻辑里进行当前状态和下一状态的切换，组合逻辑实现各个输入、输出以及状态判断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：便于阅读、理解、维护，而且利于综合器优化代码，利于用户添加合适的时序约束条件，利于布局布线器实现设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：输出是组合逻辑，可能含有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决输出毛刺的问题，最简单的方法就是用寄存器打一拍，但很多情况不允许插入寄存器节拍，此时使用三段式描述。其优势在于能够根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而不需要额外插入时钟节拍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三段式：&lt;/strong&gt; 有三个 always block，一个时序逻辑采用同步时序的方式描述状态转移，一个采用组合逻辑的方式判断状态转移条件、描述状态转移规律，第三个模块使用同步时序的方式描述每个状态的输出。这 3 个 always block 正好对应图示的 3 个子模块，更加容易理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：代码容易维护，时序逻辑的输出解决了两段式组合逻辑的毛刺问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点： 代码量大、资源消耗多一些&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一段 or 三段？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，三段式的效果更好，唯一的缺点是占用的资源稍微多一点 ( 对于拥有丰富的触发器资源的 FPGA 来说，这个缺点可以忽略吧 )。所以除非是非常简单的状态机用一段式实现，其他情况下三段式更简单。&lt;/p&gt;
&lt;h3 id="localparam"&gt;localparam&lt;/h3&gt;
&lt;p&gt;尽量使用 &lt;code&gt;localparam&lt;/code&gt; 而不是 &lt;code&gt;define&lt;/code&gt; 和 &lt;code&gt;parameter&lt;/code&gt;。这个原则不仅仅限于 FSM，其他模块也应该遵守。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;define&lt;/code&gt;：在设计中很可能有多个 FSM，而且它们很可能包含有相同的状态名，使用 &lt;code&gt;define&lt;/code&gt; 定义的状态名是全局可见的，那么这些 FSM 之间会相互影响（C++ 解决这个问题的方法是 namespace）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;parameter&lt;/code&gt;：虽然 &lt;code&gt;parameter&lt;/code&gt; 定义的参数是局部的，但是它可以被其他模块通过参数修改。FSM 中的状态定义应该是内部可见的，外部模块应该是不能修改的（类似于 C++ 中 class 的 private 成员）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，使用 &lt;code&gt;localparam&lt;/code&gt; 是更好的选择。&lt;/p&gt;
&lt;h3 id="reset"&gt;Reset&lt;/h3&gt;
&lt;p&gt;FPGA 上电时，GSR(Global Set/Reset) 拉高，对所有 寄存器 /RAM 进行复位，此时配置于 FPGA 的逻辑并未生效，所以不能保证 FSM 进入正确的初始化状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般，FSM 使用用户定义的复位 ( 同步 or 异步 )。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Synchronous Reset&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一种方法，是将初始状态编码为全 0 ( 带 0 的 One-Hot 编码方式 )，这样当 GSR 复位后，状态机自动进入初始状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="state encode"&gt;State encode&lt;/h3&gt;
&lt;p&gt;状态机的状态的编码，通常有 &lt;code&gt;Binary&lt;/code&gt;、&lt;code&gt;One-Hot&lt;/code&gt;、&lt;code&gt;Gray&lt;/code&gt; 码等几种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binary 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用最简单的递增的编码方式对状态进行编码，对于 n 个状态的状态机，共需要 log2(n) 个触发器表示所有的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：在状态很多的情况下，可以大大减少触发器的数量，对设计的面积有积极的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：但是在状态跳转过程中，很可能出现多位同时变化的情况，容易在 next state 的生成逻辑上产生毛刺。同时，输出也是所有状态位的译码，译码逻辑多数很复杂，往往成为整个设计的关键路径。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Gray 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 Binary，但是采用了格雷码的编码方式，每两个相邻的状态只有一位信号变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：避免了 next state 上毛刺的产生。同时两个相邻状态的输出译码变得简单了，避免了复杂组合逻辑的产生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点；格雷码的这些优点都是建立在状态跳转是顺序执行的基础上的。如果状态机有很多随机跳转和分支，格雷码的实际效果和二进制码相差无几，优势荡然无存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;One-Hot 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前设计中最常用的状态机编码方式。One-Hot 编码在一组 0 中只有一个 1，对一个 n 个状态的 FSM 设计，需要 n 个触发器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：在任意两个状态之间跳转都只有两位状态位变化，不会产生非常复杂的组合逻辑。各个状态之间的译码也相对简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：对状态编码需要的寄存器比其他方式多，不过这个缺点基本可以忽略吧 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Binary、Gray 编码使用最少的触发器，较多的组合逻辑。而 One-Hot  编码反之。由于 CPLD 更多的提供组合逻辑资源，而 FPGA 更多的提供触发器资源，所以 CPLD 多使用 Gray，而 FPGA  多使用 One-Hot 编码。另一方面，对于小型设计使用 Gray 和 Binary 编码更有效，而大型状态机使用 One-Hot 更高效。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;FSM encoding algorithm&lt;/code&gt; 值默认为 &lt;code&gt;auto&lt;/code&gt;，编写程序测试发现，它会根据代码中状态的多少，FSM 的复杂度，自动选择合适的编码方式对状态进行编码。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;
one-hot 和 reverse case 相结合，可以得到一种更加简洁的电路（如模板所示的 index one-hot），这种方式和传统的 one-hot 相比，它不再是对比整个状态向量的值，而是逐 bit 对比，从而简化了状态译码电路。&lt;/p&gt;
&lt;p&gt;利用前面的模板和结尾附录的模板，对参考文章 &lt;a href="http://www.trilobyte.com/pdf/golson_snug94.pdf"&gt;Steve Golson State machine design techniques for Verilog and VHDL&lt;/a&gt; 中的状态机例子进行综合测试，实际结果证实了 index 方式要更加节省资源（如果状态机更加复杂一些的话，两者的差别应该更大）：&lt;/p&gt;
&lt;p&gt;index one-hot style:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/fsm_index.v"&gt;index.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="indx style" src="/images/fsm-design/index_summary.png"/&gt;&lt;/p&gt;
&lt;p&gt;non-index one-hot style:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/fsm_non_index.v"&gt;non-index.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="non-index" src="/images/fsm-design/non_index_summary.png"/&gt;&lt;/p&gt;
&lt;p&gt;======================== 分割线 =============================&lt;/p&gt;
&lt;p&gt;使用 XST 综合上面的 index one-hot + reverse case 风格的 FSM，结果 XST 并没有识别出 FSM，而 Synplify 我没有破解版本，只能作罢 =.=&lt;/p&gt;
&lt;p&gt;虽然 XST 没有识别出 non-index 的 FSM，但是 Modelsim 是可以识别出来的，可以在 Modelsim 中查看最终综合出来的 FSM 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/state_diagram.png"/&gt;&lt;/p&gt;
&lt;p&gt;补上普通的 one-hot + case 的模板，这个模板是可以被 XST 识别出来的：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
                     &lt;span class="n"&gt;IDLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;'b00001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;S1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;'b00010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;S2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;'b00100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;S3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;'b01000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;ERROR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;'b10000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// synopsys state_vector state&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
                &lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;CS&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;'&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// synopsys full_case parallel_case&lt;/span&gt;
        &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S2:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;S3:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;       &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//...&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;        &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="nl"&gt;ERROR:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// reset&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// default output&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;S1:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;S2:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;S3:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
            &lt;span class="nl"&gt;ERROR:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
                &lt;span class="c1"&gt;// ...&lt;/span&gt;
            &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;endcase&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;======================== 分割线 =============================&lt;/p&gt;
&lt;h3 id="safe fsm"&gt;Safe FSM&lt;/h3&gt;
&lt;p&gt;所谓 &amp;ldquo; 安全 &amp;rdquo; 的状态机，就是说即使因为某些意外原因，状态机跑飞了，仍然可以自动回复到正常状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例：可能出现的不安全情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，我们采用 One-Hot 编码方式，对于 8 个状态，总共使用了 8 bit 的寄存器，那么这个状态寄存器向量可以取到的值一共有 &lt;code&gt;2^8 = 256&lt;/code&gt; 种。如果我们只对需要的 8 种状态进行了说明，而忽略了剩余的 248 种，此时综合工具 (Synplify、XST) 会对设计进行 &amp;ldquo; 优化 &amp;rdquo;，将没有用到的状态去掉。但是，有时候这种 &amp;ldquo; 优化 &amp;rdquo; 反而不好，如果状态机进入未定义的全 0 状态，那么它就会卡在这个未定义的状态，无法自动回复正常工作状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果我们对状态向量的所有取值情况都显式地进行了说明，那么这个状态机就是安全的，否则就是不安全的。书写完备的 &lt;code&gt;case&lt;/code&gt; 语句。在代码中对每一种可能的取值对进行描述，对于不使用的状态编码，一定要有 &lt;code&gt;default&lt;/code&gt; 分支进行说明。&lt;/p&gt;
&lt;p&gt;在第二段 &lt;code&gt;always&lt;/code&gt; 中，&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
    &lt;span class="n"&gt;NS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这里应该赋值 &lt;code&gt;8'bx&lt;/code&gt; 更合理，因为状态机上电时处于未知状态，所以应该赋值 &lt;code&gt;x&lt;/code&gt; 更符合实际，但是这样赋值必须有个条件，就是必须所有的状态编码都全部被使用了，不然就会出现锁死现象，FSM 无法返回工作状态。我们前面使用的是 One-Hot 编码方式，有大量无效状态，所以这里不能赋值为 &lt;code&gt;x&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST 支持状态机编码的完备属性 &amp;mdash;&amp;mdash; &lt;code&gt;case implementation style&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是这个设置可能会导致前后仿真不一致的问题，一般不使用。我们应该在代码中满足条件，而不是依靠综合工具。&lt;/p&gt;
&lt;p&gt;XST 的选项 &lt;code&gt;safe implementation&lt;/code&gt; 值默认为 &lt;code&gt;None&lt;/code&gt;，如果应用环境要求 FSM 必须能恢复任何错误，比如航天、医疗、汽车等，这时我们可以打开这个设置，这时综合工具会添加额外的逻辑，保证 FSM 可以从无效状态恢复过来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使使用第一种方法，似乎我们的状态机已经是 perfect 了，但是真的是这样么？考虑这种情况：一个状态机有 8 个状态，采用 One-Hot 编码方式，代码含有 &lt;code&gt;default&lt;/code&gt; 分支处理未定义的状态向量可能取到的值。现在把这个状态机放在卫星中，接受宇宙射线的辐射，导致状态向量的值发生了变化，进入了无效状态，然后状态机自动恢复到正常状态 (Good Job)，但是！状态机的外围电路并没有随着状态机恢复，它还在等 FSM 输出某个信号呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，仅仅是回到正常状态并不够，最好的设计应该有个错误状态专门来与外围电路通信，当 FSM 进入错误状态时，外围电路会检测到这个错误状态，并采取合适的措施（如重启、复位 FSM）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合上面讨论的 index one-hot 编码方式，就有了两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;显式地定义定义一个 ERROR state&lt;/p&gt;
&lt;p&gt;如模板所示。&lt;/p&gt;
&lt;p&gt;比如一个 FSM，有 4 个状态，分别是 IDLE、S1、S2、S3，那么额外定义一个 ERROR 状态机的框图如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;parameter   [4:0]   IDLE  = 5'd0,&lt;/span&gt;
&lt;span class="err"&gt;                    S1    = 5'd1,&lt;/span&gt;
&lt;span class="err"&gt;                    S2    = 5'd2,&lt;/span&gt;
&lt;span class="err"&gt;                    S3    = 5'd3,&lt;/span&gt;
&lt;span class="err"&gt;                    ERROR = 5'd4;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在每个 case item 中，最后添加一个 else 分支且 &lt;code&gt;NS[ERROR] = 1'b1&lt;/code&gt;，并且多加一个 case item&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zero-idle&lt;/p&gt;
&lt;p&gt;在状态定义时，不用显式地定义一个 ERROR 状态，而是用全 0 状态表示 ERROR 状态：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;parameter   [4:1]   IDLE  = 5'd1,&lt;/span&gt;
&lt;span class="err"&gt;                    S1    = 5'd2,&lt;/span&gt;
&lt;span class="err"&gt;                    S2    = 5'd3,&lt;/span&gt;
&lt;span class="err"&gt;                    S3    = 5'd4;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多加一个 case item：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;~|&lt;/span&gt;&lt;span class="nl"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对比两种方式，我觉得第一种更能体现出设计意图，所以在模板中选择这种方式。&lt;/p&gt;
&lt;h3 id="case(cs)"&gt;case(CS)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用 case 的原则：&lt;/strong&gt; 尽量不要使用综合指令 full_case 和 parallel_case，而是代码本身满足 full、parallel 的条件（因为综合指令可能导致前后仿真不一致的问题）&lt;/p&gt;
&lt;p&gt;下面根据状态编码方案分类讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果使用 &amp;ldquo; 非 index one-hot + 非 reverse case&amp;rdquo; 的方法，那么在第二个 always block 中，在 case 前给 NS 一个默认值（如下）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NS = 8'bx;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是个很有用的小技巧，它可以帮助我们在综合前发现状态是否完备：如果状态完备，则在下面的 &lt;code&gt;case&lt;/code&gt; 中会给 &lt;code&gt;NS&lt;/code&gt; 合适的值；如果状态不完备，则状态机会进入错误状态，输出不定，仿真时可以很快的发现。而且，综合工具对于 &lt;code&gt;x&lt;/code&gt; 采取的态度是 &lt;code&gt;don't care&lt;/code&gt;，综合时会自动将其忽略，生成的电路最简洁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 index one-hot + reverse case 的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NS 必须赋值为全 0：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;NS = 8'b0;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 synopsys 综合指令&lt;/p&gt;
&lt;p&gt;一般的原则是尽量不要使用综合指令，这里是个特殊情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;// synopsys full_case parallel_case&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;default 分支&lt;/p&gt;
&lt;p&gt;使用了综合指令，则 default 分支在综合时就没有必要，但是仿真器并不能识别综合指令，所以在行为仿真的时候仍然需要 default 分支，所以可以用下面的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;// synopsys translate_off&lt;/span&gt;
&lt;span class="c"&gt;default: $display("FSM is dead!");&lt;/span&gt;
&lt;span class="err"&gt;// synopsys translate_on&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用 index one-hot + reverse case 的方式，这里违背了 case 语句本身满足 full_case、parallel_case 的原则，使用了综合指令、并且省掉了 default 分支，是唯一的例外情况，其他情况下都应该遵守这一原则！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="ouput"&gt;Ouput&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;避免 Latch&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在第三个 &lt;code&gt;always&lt;/code&gt; 中，在 &lt;code&gt;case&lt;/code&gt; 前，所有的输出都有默认的值，这样做的好处是可以消除 &lt;code&gt;Latch&lt;/code&gt; 的出现，而且，可以减少在后面每种状态下重复相同的赋值，而且强调显示了 case 内哪个输出发生了变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外一种避免 latch 的方法：书写完备的 &lt;code&gt;if-else&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;消除输出毛刺&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于三段式，因为输出是寄存器输出，所以解决了输出毛次。&lt;/p&gt;
&lt;p&gt;讨论一下采用寄存器输出的方式对设计的影响&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动可以优化 FSM 的时序性能&lt;/p&gt;
&lt;p&gt;影响一个时序电路运行速度的主要因素是两个寄存器之间的组合逻辑路径的长度，越长的组合逻辑路径，其时序性能越差。一个电路中的最长组合逻辑路径决定了这个电路最高运行速率，该路径就是这个电路的关键路径（&lt;code&gt;critical path&lt;/code&gt;）。所以，切断最长的组合逻辑路径可以提高局部电路的运行速度，切断多个较长的组合逻辑路径可以提高整体电路的运行速度。切断组合逻辑路径的工具就是寄存器。所以，添加寄存器可以提高电路的性能，但是会增加资源的消耗，这也是速度（speed）和面积（area）互为矛盾的原因。&lt;/p&gt;
&lt;p&gt;在考虑 FSM 的时序问题时，不能独立的考虑 FSM 本身，需要综合考虑 FSM 模块和下游模块构成的电路。在 FSM 不采用输出寄存时，在 FSM 模块和下游模块的接口处，是两部分组合逻辑直接相连。关键路径由两部分组合逻辑构成；在 FSM 采用输出寄存时，两个模块的组合逻辑被分隔成两部分，可能的关键路径被切断了。同步寄存器输出和组合逻辑输出就是采用资源优化还是速度优化的问题。组合逻辑表面上会提高电路的速度，看似节省了资源而且提高了速度，其实不然（对 FPGA 结构来说，节省寄存器不等于节省 LE；对同步设计来说，异步输出速度上的优势是可以忽略的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动会降低输出队输入信号变化的响应速度？&lt;/p&gt;
&lt;p&gt;到底应不应该采用 FSM 输出寄存器？是否必须在时序性能和响应速度之间做出取舍？在同步设计中，答案是必须牺牲一定的响应速度以换取更佳的时序性能，只考虑响应速度会带来潜在的时序性能损失。&lt;/p&gt;
&lt;p&gt;在考虑 FSM 的响应速度时，不能独立的考虑 FSM 本身，需要综合考虑 FSM 模块和上、下游模块构成的电路。采用输出寄存器的电路可以运行在更高的时钟频率下，所引入的响应时延与更高的运行频率相比是可以牺牲的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="case (ns) vs case (cs)"&gt;case (NS) vs case (CS)&lt;/h3&gt;
&lt;p&gt;采用二段式实现状态机，它的输出是组合逻辑，可能存在竞争和冒险，产生毛刺，要消除毛刺就要对输出用寄存器打一拍，但是很多时候，是不允许插入寄存器节拍的。&lt;/p&gt;
&lt;p&gt;这时候可以采用三段式实现，三段式的输出是寄存器输出，所以消除了毛次；同时，如果三段式的第三段判断输出采用&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nl"&gt;IDLE:&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="c1"&gt;// ....&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;begian&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;就可以提前判断下一状态的输出，节省了一个节拍，使输出和状态变化同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计一个简单的 FSM，测试使用 &lt;code&gt;case(CS)&lt;/code&gt; 和 &lt;code&gt;case(NS)&lt;/code&gt; 的结果：&lt;/p&gt;
&lt;p&gt;FSM 设计：一共有 4 个状态 (IDLE、S1、S2、S3)，只有一个输入 (&lt;code&gt;jump&lt;/code&gt; 信号 )，两个输出 (&lt;code&gt;dout_p&lt;/code&gt;、&lt;code&gt;dout_q&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;跳转规律：状态机开始处于 IDLE 状态，当 jump 变高时，从 IDLE 跳转到 S1 状态，同时内部的一个 4 bit 计数器开始计数，当计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 S2，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时跳转到 S3，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 IDLE，等待 jump 再次变高。状态转移图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/diagram.png"/&gt;&lt;/p&gt;
&lt;p&gt;程序：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/fsm.v"&gt;状态机源文件 fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tb_fsm.v"&gt;测试平台 testbench tb_fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仿真结果：使用 &lt;code&gt;NS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出同时改变。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_ns.png"/&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;CS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出变化相对于状态变化延时一个时钟周期。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_cs.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ref_1"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1998SJ_FSM.pdf"&gt;Clifford E. Cumming State Machine Coding Styles for Synthesis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsICU2002_FSMFundamentals.pdf"&gt;Clifford E. Cumming The Fundamentals of Efficient Synthesizable Finite State Machine
Design using NC-Verilog and BuildGates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.trilobyte.com/pdf/golson_snug94.pdf"&gt;Steve Golson State machine design techniques for Verilog and VHDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/freeny/archive/2012/04/14/2447612.html"&gt;Verilog HDL 学习心得&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;foreveryoung 《状态机设计》&lt;/p&gt;
&lt;p&gt;云创工作室《 Verilog HDL 程序设计与实践》&lt;/p&gt;</content><category term="IC"></category><category term="FSM"></category><category term="Verilog"></category></entry><entry><title>FPGA 数字处理基础 (1)</title><link href="https://qiangu.cool/posts/ic/fpga_digital_processing_basic_1.html" rel="alternate"></link><published>2014-05-14T23:25:00+08:00</published><updated>2014-05-14T23:25:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-05-14:/posts/ic/fpga_digital_processing_basic_1.html</id><summary type="html">&lt;p&gt;总结 FPGA 处理数字信号的基础知识 (1)&lt;/p&gt;</summary><content type="html">&lt;h2 id="shu zi chu li ji chu"&gt;数字处理基础&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;数字处理基础&lt;/strong&gt;主要包括两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数的表示&lt;/li&gt;
&lt;li&gt;常用算术运算的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="shu de biao shi"&gt;数的表示&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;这部分讨论对于计算机 (PC)、数字信号处理器件 (DSP)、数字芯片 ( 包括 FPGA) 都是成立的。&lt;/p&gt;
&lt;h3 id="ren lei ru he ji shu"&gt;人类如何计数&lt;/h3&gt;
&lt;p&gt;最早我们的祖先采用的是结绳计数，经过几千年的发展，现在我们使用的 10 进制位置计数法 。那么我们为什么偏偏选择 10 这个数字呢？&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles_Petzold"&gt;Charles Petzold&lt;/a&gt; 在他的著作 &lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt; 中分析了我们的计数进制现象 。原因其实很简单，10 这个数字对于我们如此特别只是因为我们有 10 个手指 ( 脚趾 )，于是我们采用了 10 进制，并且逐渐习惯了它 。他在书中模拟了一下进制系统的演化过程，让我们逐渐从人类的 10 进制思维逐渐转化到计算机的 2 进制系统中：&lt;/p&gt;
&lt;p&gt;假设我们是卡通动画中的人物，比如米老鼠 Mickey，仔细观察它就会发现，他的每个手只有 4 个手指，理所当然，他采用 8 进制来计数。如果更进一步，假设我们是龙虾，那么我们的每一只钳子上有两个 &amp;ldquo; 手指 &amp;rdquo;，一共有 4 个手指，所以，我们会采取 4 进制计数系统。最后，假设我们是海豚，那么我们只有两个鳍来计数了，这时候的计数系统就是 2 进制数字系统了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;r 进制 to 10 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需要按权值展开就可以了，比如： &lt;/p&gt;
&lt;p&gt;2 进制数 &lt;code&gt;110101&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;32 + 16 + 4 + 1 = 53&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;8 进制数 &lt;code&gt;B65F&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;11 &amp;times; 16^3 + 6 &amp;times; 16^2 + 5 &amp;times; 16 + 15 &amp;times; 1 = 46687&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10 进制 to r 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整数部分：基数连除，逆序取余&lt;/p&gt;
&lt;p&gt;小数部分：基数连乘，顺序取余&lt;/p&gt;
&lt;h3 id="ji suan ji ru he ji shu"&gt;计算机如何计数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;正数 &amp;amp; 负数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人类和计算机的计数原理是完全不同的，所以采用的方法也是完全不同的。对于人来说，区分正负数只需要在数字绝对值前添加一个符号 &lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;-&lt;/code&gt; 即可，但是计算机只有 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 这两个符号可以使用；对于人来说，减法借位很容易，但是对于计算机硬件电路来说这是一件很麻烦的事。&lt;/p&gt;
&lt;p&gt;常用的表示方法有 3 种：&lt;strong&gt;原码&lt;/strong&gt;、&lt;strong&gt;反码&lt;/strong&gt;、&lt;strong&gt;补码&lt;/strong&gt; 。对于计算机而言，硬件上最容易实现的是补码，这也是大多数计算机采用补码系统的原因 。&lt;/p&gt;
&lt;p&gt;以前总结过一篇博客，&lt;a href="http://guqian110.github.io/pages/2014/03/19/signed_number_representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整数 &amp;amp; 小数&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数&lt;/p&gt;
&lt;p&gt;对于整数而言，不存在小数点的问题，所以自然地将我们人类所熟悉的 10 进制数转化为计算机熟悉的 2 进制数，分配足够的空间存储起来就 ok 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小数&lt;/p&gt;
&lt;p&gt;在计算机中，整数和小数之间并不是很容易转换的的，而且小数的存储和处理要比整数复杂。对于小数，可以有两种方法来表示：&lt;strong&gt;定点数&lt;/strong&gt; &amp;amp; &lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定点数的意思是小数点在数中的位置是固定不变的。整数可以看作是一种特殊的定点数，小数点在数的末尾。值得注意的是小数点的位置信息并没有和数字存储在一起，所以，使用定点数的程序必须知道小数点的位置。&lt;/p&gt;
&lt;p&gt;浮点数的意思是小数点在数中的位置是变化的。当代大部分计算机处理浮点数的标准是 IEEE 在 1985 年制定的 ANSI/IEEE Std 754-1985 。&lt;/p&gt;
&lt;p&gt;============================== 跑题分割线 ========================&lt;/p&gt;
&lt;p&gt;在计算机出现不久的年代，计算机处理浮点数是一件很重要但也让人头疼的事。最早，还没有专门处理浮点数的硬件，所以程序猿必须编写软件来完成浮点数的计算。浮点数在科学运算和工程类程序中极为重要，因此常常被赋予很高的优先级，在计算机发展的早期，为新制造的计算机做的第一项工作就是为其编写浮点数运算程序。&lt;/p&gt;
&lt;p&gt;如果可以直接利用计算机机器码指令来实现浮点数的计算，类似于 16 位处理器上进行乘法和除法运输，那么这台机器上所有的浮点数运算都会变得更快。IBM 公司在 1954 年发布了 IBM 704，它是第一台将浮点数运算硬件作为可选配件的商用计算机。该机器的浮点运算硬件可以直接进行加法、减法、乘法和除法，其他的浮点运算必须通过软件来实现。&lt;/p&gt;
&lt;p&gt;从 1980 年开始，浮点运算硬件开始应用于桌面计算机，这起始于 Intel 当年发布的 8087 数字协同处理 (Numberic Data Coprocessor) 芯片，当时这种集成电路被称为 &lt;strong&gt;数学协同处理器 (math coprocessor)&lt;/strong&gt; 或者 &lt;strong&gt;浮点运算单元 (floating-point,FPU)&lt;/strong&gt;。8087 不能独立工作，必须和 8086 或者 8088 一起工作，所以被称为 &amp;ldquo;&lt;strong&gt;协处理器&lt;/strong&gt;&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;在最初版本的 IBM PC 主板上，位于 8080 芯片的右边有一个 40 个管脚的插槽供 8087 芯片接入，但是，这个插槽是空的，如果用户需要浮点运算则必须单独购买一块 8087 芯片。数字协处理器并不能加速所有的程序的运行速度，比如文字处理程序几乎用不到浮点运算，而电子表格处理程序对浮点数运算依赖程度很高。&lt;/p&gt;
&lt;p&gt;安装了数学协处理器，程序员必须使用协处理器的机器码指令来编写特定的程序，因为数学协处理器不是标准硬件。最后就出现了这样的局面：如果机器上安装了数学协处理器，程序员就要学会编写相应的应用程序以支持它的运行；如果没有安装，程序员必须通过编程来模拟它进行浮点数的运算。&lt;/p&gt;
&lt;p&gt;在 1989 年发布的 486DX 芯片中，FPU 已经内建在 CPU 的结构里，但是在 1991 年发布的 486SX 中，又没有内建 FPU，到了 1993 年发布的奔腾芯片中，CPU 内置 FPU 再次成为标准，并且是永远的标准。在 1990 年发布的 68040 芯片中，摩托罗拉首次将 FPU 集成到 CPU 中，在此之前是使用 68881 和 68882 数学协处理器来支持 68000 家族的微处理器。PowerPC 芯片同样使用了内置 FPU 的技术。&lt;/p&gt;
&lt;p&gt;============================== 跑题分割线结束 ========================&lt;/p&gt;
&lt;p&gt;FPGA 不同于微处理器，它内部没有内置 FPU( 不包括硬核 )，对于 FPGA，浮点数可以克服定点数动态范围小的缺点，但是在运算时，实现浮点数的硬件实时成本高，处理速度慢，所以在非实时运算中有广泛的应用。对于通信系统中的信号，一般都是实时处理的，所以在 FPGA 开发中，一般只使用定点数 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="chang yong suan zhu yun suan de  fpga shi xian_1"&gt;常用算术运算的 FPGA 实现&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="jia fa"&gt;加法&lt;/h3&gt;
&lt;p&gt;在 Verilog HDL 中，直接使用运算符 &lt;code&gt;+&lt;/code&gt;，其本质上是一种并行加法器，应该保证两边的数位宽是一致的。举个栗子&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;add_4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;input&lt;/span&gt;   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;output&lt;/span&gt;          &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h3 id="cheng fa"&gt;乘法&lt;/h3&gt;
&lt;p&gt;第一种方法，最简单，直接使用运算符 &lt;code&gt;*&lt;/code&gt;，如下所示 。但是这种方法写出来的代码效率很低，甚至有时候是不可综合的，实际应用中基本不会采用这种方法。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;第二种方法是自己写代码实现乘法运算，或者是使用 IP COre。一般 FPGA 中都集成了硬核的乘法器，所以可以有两种方案来实现乘法器，DSP48 硬核 或者是 Slice 搭建 。&lt;/p&gt;
&lt;h3 id="chu fa"&gt;除法&lt;/h3&gt;
&lt;p&gt;除法是四则基本运算中最复杂的，也是最难实现的。除法可以看作是乘法的逆运算，但除法要复杂的多，最大的区别是乘法中的一些操作可以并行支持，通过流水线提高计算速度，但是除法必须顺序执行，运算最耗时间。&lt;/p&gt;
&lt;p&gt;Verilog 提供了除法运算符 &lt;code&gt;/&lt;/code&gt;，如下所示。但是只有在除数为 2 或者 2 的整幂次时才是可综合的，其余情况都不可综合 。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;常用的方法是采用 IP Core，可以完成定点数和浮点数两类算法。&lt;/p&gt;
&lt;h3 id="cordic suan fa"&gt;Cordic 算法&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/CORDIC"&gt;Cordic 算法&lt;/a&gt; 算法即坐标旋转数字计算方法，是 J.D.Volder1 于 1959 年首次提出，主要用于三角函数、双曲线、指数、对数的计算。该算法通过基本的加和移位运算代替乘法运算，使得矢量的旋转和定向的计算不再需要三角函数、乘法、开方、反三角、指数等函数。&lt;/p&gt;
&lt;p&gt;它通常应用在没有硬件乘法器的应用中，比如微控制器、FPGA 中，进行的所有操作只有加法、移位和查表 。&lt;/p&gt;
&lt;p&gt;Coridc 算法可以自己编写代码实现，也可以使用 IP Core 。( 事实上，所有的 IP 软核理论上都可以自己写，因为这些软核实际上就是别人写好的代码和文档，类似于 C 语言中的库函数 )&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="can kao_1"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3795386/"&gt;《无线通信的 Matlab 和 FPGA 实现》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="digital processing"></category></entry><entry><title>脉冲边沿检测</title><link href="https://qiangu.cool/posts/ic/pulse_edge_detection.html" rel="alternate"></link><published>2014-04-08T18:33:00+08:00</published><updated>2014-04-08T18:33:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-08:/posts/ic/pulse_edge_detection.html</id><summary type="html">&lt;p&gt;总结 FPGA 中的脉冲边沿检测方法&lt;/p&gt;</summary><content type="html">&lt;p&gt;脉冲边沿检测是 FPGA 设计中经常用到的方法，本文总结一下其原理和实现代码，可以将其加入我们自己的代码库中，以备以后使用 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="mai chong bian yan jian ce yuan li"&gt;脉冲边沿检测原理&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img alt="pulse" src="/images/learning-fpga-pulse-edge-detection/pulse.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;如图，任何一个脉冲既有上升沿也有下降沿，系统的时钟周期一定要比脉冲宽度小，而且越小越好，即频率越高越好 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脉冲边沿的特点就是：边沿两侧的电平发生了变化 。&lt;/strong&gt; 利用这一点，我们就可以设计出检测边沿的方法 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作方法：&lt;/strong&gt; 建立 2 个寄存器，形成二级寄存器，在时钟触发中，首先把数据送入第一个寄存器中，然后在下一个时钟上沿到来时，将第一个寄存器中的数据存入第二个寄存器，也就是说第二个寄存器中的数据始终比第一个寄存器晚一个周期，即晚一个数据 。根据系统时钟检测，如果前后进来的信号发生了变化，可以用异或运算，异或结果为 1，说明电平发生了变化，有边沿产生。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="mai chong bian yan jian ce fang fa"&gt;脉冲边沿检测方法&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="jian ce shi fou you bian yan"&gt;检测是否有边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_edge&lt;/span&gt;  
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trigedge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trigEdge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl1" src="/images/learning-fpga-pulse-edge-detection/rtl1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/learning-fpga-pulse-edge-detection/sim1.png"/&gt;&lt;/p&gt;
&lt;h3 id="jian ce  shang  / xia  bian yan"&gt;检测 上 / 下 边沿&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;下降沿检测原理：&lt;/strong&gt; 将第一个寄存器中的数据取反与第二个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 1 变为 0 时，就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上升沿检测原理：&lt;/strong&gt; 将第二个寄存器中的数据取反与第一个寄存器的数据相与，产生的数存入一个新的寄存器里，这样产生的结果是当第一个寄存器中的数据由 0 变为 1 时（上升沿，此时 r1 变为 1，但 r2 仍保持前一周期的 0），就会在新的寄存器里产生一个高电平，并维持一个周期 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序：&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r2&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;end&lt;/span&gt;  
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;trig_r1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// Detect posedge  &lt;/span&gt;
    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;trig_r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;trig_r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// Detect negedge&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl2" src="/images/learning-fpga-pulse-edge-detection/rtl2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/learning-fpga-pulse-edge-detection/sim2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外一种写法：&lt;/strong&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="n"&gt;DETECT_EDGE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;  
    &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tirg_pos_edge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;  
    &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;input&lt;/span&gt; &lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;output&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;reg&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;'b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt;  
            &lt;span class="n"&gt;trig_r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;trig_in&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_pos_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b01&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;assign&lt;/span&gt; &lt;span class="n"&gt;trig_neg_edge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trig_r&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;综合结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="rtl3" src="/images/learning-fpga-pulse-edge-detection/rtl3.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仿真结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim3" src="/images/learning-fpga-pulse-edge-detection/sim3.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="mai chong bian yan jian ce ying yong_1"&gt;脉冲边沿检测应用&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;理想的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard1" src="/images/learning-fpga-pulse-edge-detection/keyboard1.png"/&gt;&lt;/p&gt;
&lt;p&gt;然而实际的键盘受制造工艺等影响，其输入特性不可能如上图完美 。当按键按下时，在触点即将接触到完全接触这段时间里，键盘的通断状态很可能已经改变了多次 。即在这段时间里，键盘输入了多次逻辑 0 和 1，也就是输入处于失控状态 。如果这些输入被系统响应，则系统暂时也将处于失控状态，这是我们要尽量避免的 。在触点即将分离到完全分离这段时间也是一样的 。&lt;/p&gt;
&lt;p&gt;实际的键盘输入特性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="keyboard2" src="/images/learning-fpga-pulse-edge-detection/keyboard2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件消抖&lt;/strong&gt; 要占用系统资源，在系统资源充足的情况下使用软件消抖更加简单 。软件消抖的实质在于降低键盘输入端口的采样频率，将高频抖动略去 。实际应用中通常采用延时跳过高频抖动区间，然后再检测输入做出相应处理。一般程序代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;// 一旦检测到键值&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Delay&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// 延时 20ms，有效滤除按键的抖动&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;// 再次确定键值是否有效&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;    &lt;span class="c1"&gt;// 执行相应处理&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;这段软消抖程序从机理上看不会有什么问题，通常在软件程序不太 " 繁忙 " 的情况下也能够很好的消抖并做相应处理 。但是如果在延时期间产生了中断，则此中断可能无法得到响应 。&lt;/p&gt;
&lt;p&gt;对于硬件资源丰富的 FPGA 系统，可以使用硬件来减轻软件工作量，通常称之为 &lt;strong&gt;" 硬件加速 "&lt;/strong&gt; 。在按键信号输入到软件系统前用逻辑对其进行一下简单的处理即可实现所谓的 " 硬件消抖 "，代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 对输入信号 inpio 硬件滤波，每 20ms 采样一次当前值&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//20ms 计数器&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;19&lt;/span&gt;&lt;span class="mi"&gt;'d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mh"&gt;19&lt;/span&gt;&lt;span class="mi"&gt;'d500000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;'b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; 
        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;19&lt;/span&gt;&lt;span class="mi"&gt;'d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 当前 inpio 信号锁存，每 20ms 锁存一拍&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt; &lt;span class="n"&gt;clk_25m&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt; &lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;'b11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;19'h7ffff&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;inpior&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;wire&lt;/span&gt; &lt;span class="n"&gt;inpio_swin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;inpior&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// 前后 20ms 两次锁存值都为 0 时才为 0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;该程序中设置了一个 20 ms 计数器，通过间隔 20 ms 对输入信号 inpio 采样两次，两次相同则认为键盘输入稳定，得到用硬件逻辑处理后的 inpio_swin 信号则是消抖处理过的信号 。程序不再需要 delay() 来滤波了，也不会出现使用纯软件处理出现的 " 中断失去响应 " 的情况了，这就是 " 硬件加速 " 的效果 。&lt;/p&gt;
&lt;p&gt;我们可以看到，传统单片机等系统大多是串行处理，即顺序执行，只能并行处理一些中断程序 。对于这样的系统，只能采用单纯软件或硬件电路消抖，但都不那么完美 。而对于 FPGA 等并行处理的系统，其优势就很明显，只要片内逻辑资源够用，通过硬件加速软件消抖的处理，完全可以做到按键消抖并行化，不影响系统的实时性 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="can kao"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG_ARTICLE_213430.HTM"&gt;脉冲边沿检测（Verilog）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/lg2lh/article/details/8104551"&gt;脉冲边沿检测原理 verilog 版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/LVY33/article/details/6225925"&gt;脉冲边缘检测法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_790c0ca10100srid.html"&gt;按键消抖&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="pulse edge detection"></category></entry><entry><title>(转载) 如何学习 FPGA</title><link href="https://qiangu.cool/posts/ic/learning_fpga_how_to.html" rel="alternate"></link><published>2014-04-07T16:16:00+08:00</published><updated>2014-04-07T16:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-07:/posts/ic/learning_fpga_how_to.html</id><summary type="html">&lt;p&gt;转载一篇初学 FPGA 时看到的文章，感觉对于初学者来说还不错~&lt;/p&gt;</summary><content type="html">&lt;p&gt;学习 FPGA 差不多一年多，长期混迹于各大论坛，让我学习到了很多知识，转载一篇文章。&lt;/p&gt;
&lt;p&gt;当年在对于 FPGA 什么都不懂的情况下，觉得这篇文章相当高大上，现在看来，的确如此～和别的入门级别的文章书籍相比，这篇文章没有涉及 FPGA 设计的细节，而是很精炼地讲了 FPGA 设计中最基本的 &lt;em&gt;&amp;ldquo; 世界观 &amp;rdquo;&lt;/em&gt; 。也就是说这篇没有一头扎进 &lt;strong&gt;&amp;ldquo; 术 &amp;rdquo;&lt;/strong&gt; 的内容中让读者无从读起，而是从整体上给出 FPGA 设计的 &lt;strong&gt;&amp;ldquo; 道 &amp;rdquo;&lt;/strong&gt; 。对于初学者 &amp;mdash;&amp;mdash; 尤其是我这样从软件思维过渡过来的人，的确是不错的入门指导 。&lt;/p&gt;
&lt;p&gt;转载地址：&lt;a href="http://www.ednchina.com/ART_8800513345_18_20010_TA_38ec22f4.HTM"&gt;如何学习 FPGA？FPGA 学习必备的基础知识&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;FPGA 已成为现今的技术热点之一，无论学生还是工程师都希望跨进 FPGA 的大门。网络上各种开发板、培训班更是多如牛毛，仿佛在告诉你不懂 FPGA 你就 OUT 啦。那么我们要玩转 FPGA 必须具备哪些基础知识呢 ? 下面我们慢慢道来。&lt;/p&gt;
&lt;h2 id="yao liao jie shi yao shi  fpga"&gt;要了解什么是 FPGA&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;既然要玩转 FPGA，那我们首先最重要的当然是要了解什么 FPGA 。FPGA（Field-Programmable Gate Array），即现场可编程门阵列 。看到编程两个字码农就笑了，不就是编程嘛，那可是我们的强项 。且慢，此编程非彼编程 。一定要把 FPGA 的编程和软件编程区分开来 。软件的编程，处理器会逐条的把语言翻译成各种控制信号，去控制内部电路完成一个个运算或操作 。那么 FPGA 的编程是怎么实现的呢？无论 Altera 家还是 Xlinix 家的 FPGA，叫法有什么差异，基本单元都相似，都是由真值表和 D 触发器构成 。改变真值表的值就改变了逻辑功能，再通过和 D 触发器组合来实现任何时序逻辑 。所以我们对 FPGA 的编程，实际上就是去修改这些真值表和连接关系，使他们组成一张专门的真值表，去实现特定的功能 。这和软件编程一步步运行程序有本质的区别 。要想玩转 FPGA，就必须理解 FPGA 内部的工作原理，学习如何利用这些单元实现复杂的逻辑设计 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="zheng que li jie  hdl yu yan"&gt;正确理解 HDL 语言&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;HDL（Hardware Description Language），硬件描述语言 。通过名称我们能看出来，HDL 语言是一种 &amp;ldquo; 描述 &amp;rdquo; 语言，这一点和 C 语言是有本质区别的 。正确理解描述的含义，对学好 HDL 语言很有帮助 。HDL 语言只是用文本的方式把硬件电路描述出来 。我们在阅读 HDL 程序的时候，在脑子里应该能反映出一个完整的硬件电路结构 。从另一方面说，我们在编写 HDL 语言之前，就已经对要实现的电路有清晰的概念 。所以 HDL 语言只是一个描述我们头脑中具体电路的工具，&lt;strong&gt;玩转 FPGA 的根本不是语言而是逻辑电路设计&lt;/strong&gt;。不要再纠结于我应该学习 VHDL 还是 Verilog，哪种语言更好学这些问题 。如果把学习 FPGA 的重点放在学习语言上，死记硬背一些语法，那自然是抓错了重点 。语言在日常使用中会越用越熟练，不需要花很长的专门时间去学习 。当然一本好的参考资料可以随时方便查询会是很有帮助的 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="shu zi dian lu ji chu"&gt;数字电路基础&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;说到底，FPGA 就是一堆数字逻辑组合在一起实现特定功能而已 。所以数字电路基础知识是根本 。如果你连触发器，组合电路，时序电路，竞争，毛刺等等基本概念还莫能两可不清不楚的话，那玩转 FPGA 只能是痴人说梦的幻想了 。我们必须要好好的学好数字电路基础这门课，基本的数字电路烂熟于心 。把这些基础打牢固，再往更深的方向发展 。什么时候能够从抽象的算法中提炼算法的结构，再分解成具体的模块并通过硬件电路实现出来，这时候就算从菜鸟级别步入老鸟级别了 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ying jian she ji si xiang"&gt;硬件设计思想&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;这一点应该说是重中之重 。学习 FPGA，一定要有硬件设计思想 。在软件编程的时候，比如 1 秒钟能实现 5 次乘法运算，那系统要求 1 秒钟实现 50 次乘法运算怎么办，我们会尽可能的优化代码，让代码更简洁更高效，或者提高系统主频，让系统跑的更快 。但是在 FPGA 里面我们不是这种思维方式。在 FPGA 里实现一个乘法器不够用，那我就实现两个实现三个去满足系统要求；我可以进行流水线设计；串行运行方式不够快了，我可以先串并转换，再并行的做处理 &amp;mdash; &amp;mdash; 只要 FPGA 的资源够用，我可以充分利用资源去满足系统要求 。因为在我手里的就是一堆硬件资源，我要做的是把他们组合成一个好用的电路 。评价硬件描述语言写的好坏的标准和其他软件编程语言的标准是完全不同的 。因此一定要摒弃软件编程的一些固有思路，学会用硬件的方式去解决问题 。时刻提醒自己正在设计的是一个电路，而不是一行行空洞的代码 。这是很多做软件编程的人很难跨过的坎 。FPGA 学了很久还在纠结到底是用 &lt;code&gt;if-else&lt;/code&gt; 语句好呢还是用 &lt;code&gt;case&lt;/code&gt; 语句好？而不能透过这些语句表面看到他们所具体代表的电路 。只有建立了硬件设计思想，才有更深入学习 FPGA 的可能 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;FPGA 入门简单精通难 。要想入门，买一块开发板跟着例程走一遍，很多人都能在很短的时间内熟悉开发软件的操作方法并且点亮开发板上的 LED 或者再实现个跑马灯什么的，但是再往后进步往往就进展很慢 。上面提到的这四条是玩转 FPGA 的基础，只有打好了坚实的基础后面才能一马平川 。希望每个学习 FPGA 的人最后都能成为大牛，设计出自己的完美电路 。&lt;/p&gt;</content><category term="IC"></category><category term="FPGA"></category></entry><entry><title>编写可综合的 Verilog HDL 代码</title><link href="https://qiangu.cool/posts/ic/writing_synthesizable_code.html" rel="alternate"></link><published>2014-04-04T01:35:00+08:00</published><updated>2014-04-04T01:35:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-04:/posts/ic/writing_synthesizable_code.html</id><summary type="html">&lt;p&gt;总结可综合 Verilog HDL 代码，如何编写可综合的代码&lt;/p&gt;</summary><content type="html">&lt;p&gt;对电路建模方法有很多种，可以用绘制原理图，也可以用 &lt;em&gt;硬件描述语言（Hardware Description Language）&lt;/em&gt; 建模 。硬件描述语言中最常用的就是 Verlilog 和 VHDL 。&lt;/p&gt;
&lt;p&gt;Verilog HDL 和 VHDL 相比有很多优点，有 C 语言基础的话很容易上手。搜集了一些网上大神的经验总结和书上的例子，所以对于和我一样的初学者，这篇博客应该还是很有提高作用的，至于具体语法，任何一本书都讲的很详细。&lt;/p&gt;
&lt;h2 id="hdl"&gt;HDL&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;从网上找到一篇文章，把 HDL 的历史说的非常清楚。&lt;/p&gt;
&lt;p&gt;作者 董培良 &lt;/p&gt;
&lt;p&gt;题目： &lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈 VHDL/Verilog 的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先要明确的是 VHDL 和 Verilog 并非是针对硬件设计而开发的语言，只不过目前被我们用来设计硬件。HDL 是 Hardware &lt;strong&gt;Description&lt;/strong&gt; Language 的缩写，正式中文名称是 &amp;ldquo; 硬件描述语言 &amp;rdquo;。也就是说，HDL 并不是 &amp;ldquo; 硬件设计语言（Hardware &lt;strong&gt;Design&lt;/strong&gt; Language）&amp;rdquo;。别看只差这一个单词，正是这一个单词才决定了绝大部分电路设计必须遵循 RTL 的模式来编写代码，而不能随心所欲得写仅仅符合语法的 HDL 代码。&lt;/p&gt;
&lt;p&gt;VHDL 于 1980 年开始在美国国防部的指导下开发，完成于 1983 年，并于 1987 年成为 IEEE 的标准。当初开发这种语言，是出于美国国防部采购电子设备的需要。美军的装备采购自私人企业，时常要面对这样一种风险：如果某种武器大量装备部队，而其中某个零件的供应商却在几年后倒闭了，那这种武器的再生产、维修和保养都会出现大问题。而电子设备、尤其是集成电路的内部结构较为复杂，若出现前面所说的情况要找其他公司生产代用品非常困难。于是美国防部希望供应商能以某种形式留下其产品的信息，以保证一旦其破产后能由其他厂商迅速生产出代用品。&lt;/p&gt;
&lt;p&gt;显然，当初的设计文档显然是不能交出来的，这在美国会涉及商业机密和知识产权问题。于是美国防部就想出了一种折衷的方法 &amp;mdash;&amp;mdash; 描述硬件的语言，也就是 VHDL 。通过 VHDL，供应商要把自己生产的集成电路芯片的行为描述出来：比如说，加了什么样的信号后过多少时间它能输出什么等等。这样，如果有必要让其他厂商生产代用品，他们只需照着 VHDL 文档，设计出行为与其相同的芯片即可。这样的代用品相当于是新厂商在不了解原产品结构的情况下独立设计的，所以不太会涉及知识侵权。&lt;/p&gt;
&lt;p&gt;Verilog HDL 也形成于差不多的年代，是由 Gateway Design Automation 公司大约在 1983 年左右开发的。其架构同 VHDL 相似，但主要被用来进行硬件仿真。或许私人公司更注重实用，Verilog 要比 VHDL 简洁得多。&lt;/p&gt;
&lt;p&gt;由此可见，这两种最流行的用于电路设计的语言，没有一种是为了设计硬件而开发的（更何况 80 年代还没有现在的那些功能强大的 EDA 软件呢）。因此，当初制订 HDL 语言标准的时候，并没有考虑这些代码如何用硬件来实现。换句话说，有些代码写起来简单，实现起来却可能非常复杂，或者几乎不可能实现。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="ke zong he dai ma"&gt;可综合代码&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;任何符合 HDL 语法标准的代码都是对硬件行为的一种描述，但不一定是可直接对应成电路的设计信息。行为描述可以基于不同的层次，如系统级，算法级，寄存器传输级 (RTL)、门级等等。以目前大部分 EDA 软件的综合能力来说，&lt;strong&gt;只有 RTL 或更低层次的行为描述才能保证是可综合的&lt;/strong&gt;。而众多初学者试图做的，却是想让软件去综合 &lt;em&gt;算法级或者更加抽象的硬件行为描述&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id="suo you zong he gong ju du zhi chi de yu fa :"&gt;所有综合工具都支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    &lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;tri&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;inout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aupply0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;supply1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;and&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;nand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;nor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;xor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;xnor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;bufif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;bufif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;notif0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;notif1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;instantitation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;operators&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;parameter&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="you xie gong ju zhi chi ,you xie gong ju bu zhi chi de yu fa :"&gt;有些工具支持，有些工具不支持的语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    &lt;span class="n"&gt;asex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;casez&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;wand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;triand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;trior&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;disable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;forever&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arrays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;memories&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;repreat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="jian li ke zong he mo kuai de yuan ze"&gt;建立可综合模块的原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要用 initial （FPGA 上电时初始状态不定，一般需要上电复位信号，在复位信号有效的时候进行初始化，上电复位信号可以由外部手动输入，也可以系统自己产生 &amp;mdash;&amp;mdash; 写一个实现上电产生自动复位信号的模块）。P.S. 现在的综合软件功能已经足够强大，即使写了 initial 语句，在 ISE 13.3 中仍然是可综合的，而且没有 warning 和 info 的提示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;#10&lt;/code&gt;（在仿真中有用，实际在硬件上不会实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用循环次数不定的循环语句，如 &lt;code&gt;forever&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt; 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用用户自定义原语（UDP 原件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除非是关键路径设计，一般不采用调用门级原件描述的设计的方法，建议采用行为语句完成设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用同步方式设计电路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;always&lt;/code&gt; 语句描述组合逻辑时，在敏感信号列表中要列出所有输入信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的内部寄存器都应该可以被复位，在 FPGA 设计时应尽量使用器件的全局复位端信号作为系统的总复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序逻辑使用非阻塞赋值，组合逻辑使用阻塞赋值，同一过程块中不要同时使用阻塞和非阻塞两种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在不同的 &lt;code&gt;always&lt;/code&gt; 过程块中对同一变量赋值（否则综合时会提示有多驱动源错误，&lt;em&gt;multiple source
&lt;/em&gt;），对同一赋值对象，不能既使用阻塞赋值，又使用非阻塞赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不打算把变量综合成锁存器，在 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;case&lt;/code&gt; 语句的所有分支中都要对变量明确赋值（不能省去 &lt;code&gt;else&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt;，原理：在省去的情况下，变量的值会保持原来的值不变，所以系统会综合出一个锁存器 Latch）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免混合使用上升沿和下降沿触发器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一变量的赋值不能受多个时钟控制，也不能受两种不同时钟条件（或不同时钟沿）控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在 &lt;code&gt;case&lt;/code&gt; 语句中使用 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;z&lt;/code&gt; 值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="bu ke zong he dai ma_1"&gt;不可综合代码&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="bu ke zong he yu fa :"&gt;不可综合语法：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    &lt;span class="kt"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;defparam&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;$finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;join&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;initial&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delays&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UDP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;wait&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;initial&lt;/code&gt; 只能在 Testbench 中使用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;events&lt;/code&gt; 在 Testbench 中更有用，不能综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;real&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;time&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;assign&lt;/code&gt; 和 &lt;code&gt;deassign&lt;/code&gt; 不支持 &lt;code&gt;reg&lt;/code&gt; 类型的综合，支持 &lt;code&gt;wire&lt;/code&gt; 类型的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fork...join&lt;/code&gt; 不可综合，可以用非块语句达到同样的效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;primitives&lt;/code&gt; 支持门级原语综合，不支持非门级原语综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持 &lt;code&gt;table&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 的综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个 &lt;code&gt;reg&lt;/code&gt; 被多个 &lt;code&gt;always&lt;/code&gt; 块驱动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;延时，不可综合为硬件电路延时，综合工具会忽略延时，但是不会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 &lt;code&gt;x&lt;/code&gt;、&lt;code&gt;z&lt;/code&gt; 比较，综合工具会忽略，所以要保证信号只有两个状态，&lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="pan duan shi fou ke zong he_1"&gt;判断是否可综合&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;继续引用 &lt;strong&gt;董培良&lt;/strong&gt; 的文章：&lt;/p&gt;
&lt;p&gt;用一句简单的话概括：电脑永远没有你聪明 。具体来说，通常 EDA 软件对 HDL 代码的综合能力总是比人差 。对于一段代码，如果你不能想象出一个较直观的硬件实现方法，那 EDA 软件肯定也不行。比如说，加法器、多路选择器是大家都很熟悉的电路，所以类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="nl"&gt;C:&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的运算一定可以综合。而除法、开根、对数等等较复杂的运算，必须通过一定的算法实现，没有直观简单的实现方法，则可以判断那些计算式是不能综合的，必须按它们的算法写出更具体的代码才能实现 。此外，硬件无法支持的行为描述，当然也不能被综合（比如想在 FPGA 上实现 DDR 内存那样的双延触发逻辑，代码很容易写，但却不能实现）。&lt;/p&gt;
&lt;p&gt;不过，这样的判断标准非常主观模糊，遇到具体情况还得按设计人员自己的经验来判断 。如果要一个相对客观的标准，一般来说：在 RTL 级的描述中，所有逻辑运算和加减法运算、以及他们的有限次组合，基本上是可综合的，否则就有无法综合的可能性 。当然，这样的标准仍然有缺陷，更况且 EDA 的技术也在不断发展，过去无法综合的代码或许将来行，某些软件不支持的代码换个软件或许行 。比如固定次数的循环，含一个常数参数的乘法运算等等，有些 EDA 软件支持对它们的综合，而有些软件不行。&lt;/p&gt;
&lt;p&gt;所以，正确的判断仍然要靠实践来积累经验。当你可以较准确判断代码的可综合性的时候，你对 HDL 的掌握就算完全入门了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="can kao"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.dzkf.cn/html/EDAjishu/2006/0720/9.html"&gt;浅谈 VHDL/Verilog 的可综合性以及对初学者的一些建议&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="Verilog"></category><category term="synthesis"></category></entry><entry><title>学习 FPGA 入门</title><link href="https://qiangu.cool/posts/ic/learning_fpga_getting_started.html" rel="alternate"></link><published>2014-04-03T12:40:00+08:00</published><updated>2014-04-03T12:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qiangu.cool,2014-04-03:/posts/ic/learning_fpga_getting_started.html</id><summary type="html">&lt;p&gt;总结 FPGA 的学习经历，温故而知新。&lt;/p&gt;</summary><content type="html">&lt;h2 id="fpga shi shi yao"&gt;FPGA 是什么&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;FPGA 是 PLD 家族中的一员，要说清楚什么是 FPGA，就不得不说一说 PLD 。（&lt;strong&gt;以下内容来自 wikipedia&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id="pld &amp;amp; asic"&gt;PLD &amp;amp; ASIC&lt;/h3&gt;
&lt;p&gt;早期的数字逻辑系统，是由中、小规模集成电路芯片搭建而成的。这种形式的电路在可靠性、工作速度、功耗和体积方面都难以满足大规模、高性能信息处理系统的要求 。后来，随着集成电路的发展，出现可专用集成电路 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专用集成电路&lt;/strong&gt;（Application Specific Integrated Circuits, &lt;a href="http://en.wikipedia.org/wiki/Application-specific_integrated_circuit"&gt;&lt;code&gt;ASIC&lt;/code&gt;&lt;/a&gt;）是指依产品需求不同而非通用目的，而自定义的特殊规格集成电路 。ASIC 可以将整个系统集成到一个芯片上。由于芯片内集成度高、连线短，所以它可以满足之前 &amp;rdquo; 搭建系统 &amp;ldquo; 难以满足的性能指标 。&lt;/p&gt;
&lt;p&gt;随着芯片尺寸的减小和设计工具的发展，这些年来 ASIC 芯片最大的集成度从 5,000 增长到了 超过 100,000,000 门 。现代的 ASIC 通常都包含了微处理器、存储块（如 ROM 、RAM 、EEPROM 、Flash 等）。这种 ASIC 被称为 SoC （&lt;a href="http://en.wikipedia.org/wiki/System-on-chip"&gt;system on chip&lt;/a&gt;），ASIC 设计师采用硬件描述语言（Hardware Description Language，HDL），比如 Verilog、VHDL，描述 ASIC 的功能 。&lt;/p&gt;
&lt;p&gt;但是 ASIC 的研制周期长，现代信息处理的快速发展要求集成电路的设计、测试和生产周期尽可能的段，这就促进了可编程逻辑器件的发展 。严格地说，有些可编程器件出现的时间比 ASIC 出现的早，这里说的可编程器件主要是指 CPLD/FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可编程逻辑器件&lt;/strong&gt;（Programmable Logic Device,&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;&lt;code&gt;PLD&lt;/code&gt;&lt;/a&gt;）是一种用来搭建可重配置数字电路的电子器件。和逻辑门（logic gate）不同，PLD 出厂时逻辑功能是没有被定义的，在使用之前，必须先重配置（reconfigure）。&lt;/p&gt;
&lt;h3 id="li shi"&gt;历史&lt;/h3&gt;
&lt;h4 id="rom as pld"&gt;ROM as PLD&lt;/h4&gt;
&lt;p&gt;在 PLD 器件被发明之前，就已经有人 &lt;em&gt;将 &lt;a href="http://en.wikipedia.org/wiki/Read-only_memory"&gt;ROM&lt;/a&gt; 以 PLD 的概念来运用&lt;/em&gt;，用 ROM 芯片来充当一些输入性的组合逻辑（combinatorial logic）的函数发生器。ROM 有 m 个地址线，则有 &lt;code&gt;n = 2^m&lt;/code&gt; 个输出结果，这和布尔逻辑是一一对应的，所以如果把 ROM 的地址线当作相互之间没有关系的输入，则相应的输出就可以实现不同的函数。&lt;/p&gt;
&lt;p&gt;早期的 Mask ROM 存储数据的方式是使用内部的硬件电路，所以只能在出厂时就写入数据，而且以后不能更改。这就导致了一系列缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为消费者必须联系制造商才能生产出自定义的芯片，所以只有买大量的 ROM 芯片时才经济划算 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为同样的原因，从设计到最终生产出产品，中间耗费的时间很长 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mask ROM 在研发中基本上不能使用，因为设计师在改进设计时需要经常改动 ROM 里面的值 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个设备中含有故障的 Mask ROM，那么修复这个设备的唯一方法就是召回设备并且更换其中的每一个 Mask ROM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_read-only_memory"&gt;PROM&lt;/a&gt;（Programmable Read Only Memory）是周文俊于 1956 年发明的。他在纽约 Garden City 的 American Bosch Arma Corporation 工作，当时，美国空军为了提升空军用计算机以及 Atlas E/F 波段导弹的灵活性和保安性而提出要求，这项技术就是为了满足这一要求而产生的 。&lt;/p&gt;
&lt;p&gt;PROM 是通过熔丝 / 反熔丝（fuse/antifuse）实现对每个 bit 的设置 。通过使用高电压脉冲改变内部的物理结构，这种方法通常是不可逆的，所以它只允许用户更改一次配置 。PROM 解决了上面提到的问题 1 和问题 2 ，因为公司可以买一大批没有配置过的 PROM，设计人员可以根据自己的需要随意配置 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EPROM"&gt;EPROM&lt;/a&gt;（Erasable Programmable Read Only Memory）是 intel 公司的 Dov Frohman 于 1971 年发明的 。与 PROM 不同的是，EPROM 可利用高电压将资料编程写入，通过紫外线照射的方式不断的重置为未配置状态。因此，在封装外壳上会预留一个石英玻璃所制的透明窗以便进行紫外线曝光。写入程序后通常会用贴纸遮盖透明窗，以防日久不慎曝光过量影响资料。&lt;/p&gt;
&lt;p&gt;因为 EPROM 可以重复配置，所以它解决了上面的第 3 个问题 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EEPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EEPROM"&gt;EEPROM&lt;/a&gt;（Electrically Erasable Programmable Read-Only Memory）于 1983 年被发明出来。相比 EPROM，EEPROM 不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据 。&lt;/p&gt;
&lt;p&gt;如果设备可以从外部接收数据（比如 PC 通过串口线），就可以在线配置 EEPROM，这样它解决了问题 4 。&lt;/p&gt;
&lt;p&gt;虽然解决了上面的 4 个问题，但是把 ROM 当作 PLD 器件使用，还是有很多弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与专用逻辑电路相比，ROM 的速度很慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当输入不同步时（异步状态），ROM 的输出有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更加耗电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与可编程逻辑相比，价格更贵，尤其是高速应用中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，大部分 ROM 没有输出寄存器，所以它不能直接应用在时序电路中，所以在状态机的设计中，通常还需要一个外部的 TTL 寄存器 。对电路设计的业余爱好者来说，有时也仍然用 &amp;ldquo;2716&amp;rdquo; 之类的普遍型 EPROM 芯片来充当 PLD，这种用法有时也称为 &amp;ldquo; 穷人的 PAL&amp;rdquo;。（PAL 也是 PLD 的一种，以下将再进一步说明）&lt;/p&gt;
&lt;p&gt;于是，就出现了 PLD 器件。&lt;/p&gt;
&lt;h4 id="zao qi ke bian cheng luo ji"&gt;早期可编程逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1969 年，Motorola 生产出 XC157，它是一个有 12 个逻辑门和 30 个独立输入 / 输出管脚的可编程逻辑正列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（PLA）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1971 年，通用电器公司（GE）在新的 PROM 技术的基础上发明了一种可编程逻辑器件。这个实验性质的设备通过使用多层逻辑来提高 IBM 的 ROAM 性能 。GE 的这个设备是最早的 PLD 设备，比 Altera 的 EPLD 早了十几年 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1974 年，GE 和 Monolithic Memories 达成协议，开发一种可编程逻辑器件。这个设备被称为 &amp;rdquo;Programmable Associative Logic Array&amp;ldquo; 或者是 PALA 。最终于 1976 年完成 MMI 5760 ，它可以实现超过 100 门的时序电路。GE 的开发环境支持这一器件，它可以直接将布尔表达式转化为配置器件的代码，然而最终这个器件却没有上市。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="pla"&gt;PLA&lt;/h4&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（&lt;a href="http://en.wikipedia.org/wiki/Programmable_Logic_Array"&gt;PLA&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;PLA 具有一组可编程的 AND 阵列，AND 阵列之后连接一组可编程的 OR 阵列 ，这样就可以只在合乎设定条件时才允许产生逻辑信号输出 。&lt;/p&gt;
&lt;p&gt;虽然名字中含有可编程 3 个字，但是并不是所有的 PLA 都可以现场编程，事实上许多都属遮罩性的可编程化，性质与 ROM 相同，必须在芯片制造厂内就执行与完成程序化设定，尤其是内嵌于电路较复杂的芯片（例如：微处理器）的 PLA 多属此种程序化方式。&lt;/p&gt;
&lt;h4 id="pal"&gt;PAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_Array_Logic"&gt;PAL&lt;/a&gt;（Programmable Array Logic）是 Monolithic Memories 公司在 1978 年 3 月提出的，在数字电路中用来搭建逻辑功能的可编程器件的总称 。PAL 内部含有固定的或门阵列，可编程的与门阵列，从而实现所要求的逻辑函数。&lt;/p&gt;
&lt;p&gt;PAL 内部有个 PROM 的核，外部附加的输出逻辑电路，这样就可以实现所需要的逻辑功能 。因为 PAL 是基于 PROM 的，所以要使用特殊的设备，PAL 才具有可编程性，而且是 &amp;rdquo; 一次编程 &amp;ldquo; 。&lt;/p&gt;
&lt;h4 id="gal"&gt;GAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Generic_array_logic"&gt;GAL&lt;/a&gt;（Generic array logic）是 PAL 的发展，是 Lattice Semiconductor 于 1985 年发明 。这个设备具有和 PAL 同样的功能，但是可以重配置多次，所以 GAL 在设计中很有用，一旦有错误，只需要擦除后重新配置即可 。&lt;/p&gt;
&lt;p&gt;后来，International CMOS Technology (ICT) 公司发明了 类似的设备，称为 PEEL（programmable electrically erasable logic）。&lt;/p&gt;
&lt;h4 id="cpld"&gt;CPLD&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Complex_programmable_logic_device"&gt;CPLD&lt;/a&gt;（Complex programmable logic device）适合用来实现各种运算和组合逻辑（combinational logic）。PAL、GAL 仅适合用在约数百个逻辑门所构成的小型电路，若要实现更大的电路则适合用 CPLD，一颗 CPLD 内等于包含了数颗的 PAL，各 PAL（逻辑区块）间的互接连线也可以进行程序性的规划、烧录，CPLD 运用这种多合一（All-In-One）的整合作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。&lt;/p&gt;
&lt;p&gt;CPLD 与 PAL 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非易失性配置存储器。与 FPGA 不同，CPLD v 不需要外部的 ROM，只要系统上电，就可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于许多旧的 CPLD 来说，布线约束要求大部分逻辑块要和输入输出相连接，以减少内部状态记录，对于新的 CPLD 系列来说，已经不需要这样了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPLD 与 FPGA 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以利用大量的逻辑资源，CPLD 等价有有数百万的逻辑门资源可以用来实现比较复杂的设计，而 PAL 最多等价有几千个逻辑门，FPGA 有几万到几百万的逻辑门。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一些更加灵活的资源，比如宏模块之间复杂的反馈连接和整数运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大的 CPLD 和小 FPGA 之间最显著的差别就是 CPLD 含有片内非易失性存储器 。因为非易失性存储器的特点，CPLD 在数字电路设计中被当作 &amp;rdquo;boot loader&amp;ldquo; 来使用，之后它再把系统的控制权转交给没有这种特性的设备，最好的例子就是使一块 CPLD 从非易失性存储器中装载配置 FPGA 所需要的数据 。&lt;/p&gt;
&lt;h4 id="fpga"&gt;FPGA&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA&lt;/a&gt;（Field Programmable Gate Array，FPGA）是在 PAL、GAL、CPLD 等可编程逻辑器件的基础上进一步发展的产物。它是作为专用集成电路领域中的一种半定制电路而出现的，既解决了全定制电路的不足，又克服了原有可编程逻辑器件门电路数有限的缺点。&lt;/p&gt;
&lt;p&gt;当 PAL 忙于进展成 GAL、CPLD 时，另一种 &amp;ldquo; 可编程化 &amp;rdquo; 的流派也逐渐成形，此称之为现场可编程闸阵列（Field Programmable Gate Array，FPGA）。FPGA 是以阵列（Gate Array）技术为基础所发展成的一种 PLD 。所谓 &amp;rdquo;Field Programmable&amp;ldquo; 就是说芯片是出厂以后由客户或者设计师配置而工作的 。&lt;/p&gt;
&lt;p&gt;1980 年代后期，Naval Surface Warfare Department 在 Steve Casselman 的提议下成立了实验项目，目的是为了研制一台由 600,000 个逻辑门组成的计算机。Casselman 最后成功了并且在 1992 年获得了专利 。&lt;/p&gt;
&lt;p&gt;Xilinx 公司的共同创世人 &lt;a href="http://en.wikipedia.org/wiki/Ross_Freeman"&gt;Ross Freeman&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Bernard_Vonderschmitt"&gt;Bernard Vonderschmitt&lt;/a&gt; 在 1985 年发明出第一款商业 FPGA &amp;mdash;&amp;mdash; XC2064 。XC2064 芯片有可以编程的逻辑门和可以编程的内部连接线，这开辟了一项新的技术和市场 。XC2064 有 64 个可配置逻辑块（configurable logic blocks，CLBs），和 3 输入查找表（lookup tables，LUTs）。&lt;/p&gt;
&lt;p&gt;从 1985 开始到 90 年代中期，Xilinx 一直处于高速发展阶段，之后竞争对手出现了，截至 1993 年，Actel 占据了 18% 的市场 。&lt;/p&gt;
&lt;p&gt;90 年代是 FPGA 爆炸式发展的年代，这一期间出现了大量高端技术和产品。在 90 年代初期，FPGA 主要应用于通信领域，在 90 年代后期，FPGA 已经广泛应用于消费品、汽车和工业应用 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="wei shi yao xuan ze  fpga_2"&gt;为什么选择 FPGA&lt;/h2&gt;
&lt;hr/&gt;
&lt;h3 id="fpga vs asic"&gt;FPGA vs ASIC&lt;/h3&gt;
&lt;p&gt;ASIC 的优点：&lt;/p&gt;
&lt;p&gt;ASIC 在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低 。&lt;/p&gt;
&lt;p&gt;ASIC 的缺点：&lt;/p&gt;
&lt;p&gt;设计周期最长，设计成本贵，设计费用最高，适合于批量很大或者对产品成本不计较的场合。&lt;/p&gt;
&lt;p&gt;至于 FPGA 的优点和缺点完全就是 ASIC 的取反 。FPGA 一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA 具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用 FPGA 进行除错的成本较低 。在一些技术更新比较快的行业，FPGA 几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时 FPGA 方便灵活的优势就显得很重要。这也是 FPGA 能够发展起来的原因，市场是不会允许一个毫无优势的技术发展到今天这种地步的 。&lt;/p&gt;
&lt;p&gt;个人认为两者不是对立的，由于各自的特点，它们有各自适用的环境，不能一棒子打死，否定其中一个 。事实上更多的情况是：设计的开发是在普通的 FPGA 上完成的，然后将设计转移到一个类似于专用集成电路的芯片上 。&lt;/p&gt;
&lt;h3 id="fpga vs cpld"&gt;FPGA vs CPLD&lt;/h3&gt;
&lt;p&gt;为了达到上述目的，还有一种方法是使用 CPLD 。
CPLD 和 FPGA 都包括了一些相对大数量的可以编辑逻辑单元。CPLD 逻辑门的密度在几千到几万个逻辑单元之间，而 FPGA 通常是在几万到几百万。&lt;/p&gt;
&lt;p&gt;FPGA 与 CLPD 最大的区别就是：FPGA 是基于查找表（look up table，LUT），而 CPLD 是基于海门架构（sea-of-gates），也就是它们的系统结构 。CPLD 的结构具有一定的局限性 。这个结构由一个或者多个可编辑的结果之和的逻辑组列和一些相对少量的锁定的寄存器组成 。这样的结果是缺乏编辑灵活性，但是它的优点是，其延迟时间易于预计，逻辑单元对连接单元比率较高 。而 FPGA 具有的连接单元数量很大，这样虽然让它可以更加灵活的编辑，但是结构却复杂的多 。&lt;/p&gt;
&lt;p&gt;CPLD 和 FPGA 另外一个区别是大多数的 FPGA 含有高层次的内置模块（比如加法器和乘法器）和内置的存储器 。一个由此带来的重要区别是，很多新的 FPGA 支持完全的或者部分的系统内重新配置 。允许他们的设计随着系统升级或者动态重新配置而改变 。一些 FPGA 可以让设备的一部分重新编辑，而其他部分继续正常运行 。&lt;/p&gt;
&lt;p&gt;CPLD 与 FPGA 之间结构、原理上的差别导致两者应用上的差别 。考虑成本、性能要求等因素，应该根据实际情况选择 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="xilinx &amp;amp; altera_1"&gt;Xilinx &amp;amp; Altera&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;FPGA 的制造商主要是 Xilinx 和 Altera 两家，他们合起来市场占有率达到了 80% 之多 。两家是 FPGA 技术的领导者也是长期竞争对手 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Xilinx"&gt;Xilinx&lt;/a&gt; 于 1984 年创建于美国加利福尼亚州的硅谷，总部位于硅谷核心的圣何塞。它是一家主要提供 FPGA 的科技公司 。并且就是它的创始人是发明了 FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Altera"&gt;Altera&lt;/a&gt; 是一家位于美国硅谷的可编程逻辑器件和 CPLD 的制造商 。该公司于 1984 年推出了其首款可编程逻辑设备。&lt;/p&gt;
&lt;p&gt;两家一直是互为竞争对手，一般来说，大学里面都 Altera 的器件和 VHDL 上课，所以在学校里面用 Xilinx 的人比较少 。&lt;/p&gt;
&lt;p&gt;因为原理是一样的，所以只要学会一种，另一种就很容易上手。学校实验室里面用的是 Xilinx 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="xilinx fpga architecture(jia gou )"&gt;Xilinx FPGA Architecture（架构）&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;FPGA 需要反复烧写，所以不能像 ASIC 一样通过固定的与非门来完成，只能采用一种易于反复配置的结构，查找表就可以很好的满足这一要求。目前主流 FPGA 都是采用了基于 SRAM 工艺的查找表结构（军品和宇航级 FPGA 采用 Flash 或者熔丝 / 反熔丝工艺），通过烧写文件改变查找表内容的方法来实现对 FPGA 的重复配置。&lt;/p&gt;
&lt;p&gt;查找表（look-up table，LUT）本质上就是一个 RAM 。当用户通过原理图或 HDL 语言描述了一个电路以后，FPGA 开发软件会计算逻辑电路的所有可能结果，并把真值表事先写入 RAM，这样，每输入一个信号进行逻辑运算就相当于输入一个地址进行查找，这样 LUT 就具有了和逻辑电路相同的功能 。实际上，LUT 具有更快的执行速度和更大的规模 。&lt;/p&gt;
&lt;p&gt;上电时，FPGA 将外部存储器中的数据读入片内 RAM，完成配置后，进入工作状态；掉电后 FPGA 恢复为白片，内部逻辑消失。这样 FPGA 不仅能够反复使用，还无须专门的 FPGA 编程器，只需通用的 EPROM、PROM 编程器即可。&lt;/p&gt;
&lt;p&gt;目前，Xilinx FPGA 仍然是基于查找表技术，但是其概念已经远远超出查找表技术的限制，并且整合了常用功能的硬核模块（如块 RAM，时钟管理和 DSP）。Xilinx FPGA 内部大致可以分为 6 部分：&lt;/p&gt;
&lt;h3 id="iob"&gt;IOB&lt;/h3&gt;
&lt;p&gt;可编程输入 / 输出单元简称 I/O 单元，是芯片与外界电路的接口部分，完成不同电气特性下输入 / 输出信号的驱动和匹配 。&lt;/p&gt;
&lt;h3 id="clb"&gt;CLB&lt;/h3&gt;
&lt;p&gt;CLB（Configurable Logic Block）是 FPGA 内的基本逻辑单元，Xilinx FPGA 的 CLB 由多个相同的 Slice 和附加逻辑组成 。&lt;/p&gt;
&lt;h3 id="dcm"&gt;DCM&lt;/h3&gt;
&lt;p&gt;业内大多数 FPGA 都提供数字时钟管理（Digital Clock Manager）。Xilinx FPGA 提供 DCM 和 PLL 。&lt;/p&gt;
&lt;h3 id="bram"&gt;BRAM&lt;/h3&gt;
&lt;p&gt;大多数 FPGA 都具有内嵌的块 RAM，这大大扩展了 FPGA 的应用范围和灵活度 。块 RAM 可以被配置为单口 RAM、双端口 RAM、内容地址存储器（CAM）和 FIFO 等常用存储结构 。&lt;/p&gt;
&lt;h3 id="routing resource"&gt;Routing Resource&lt;/h3&gt;
&lt;p&gt;布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度 。Xilinx FPGA 的布线资源可以分为 4 类：全局布线资源、长线资源、短线资源、分布式资源 。&lt;/p&gt;
&lt;h3 id="embedded module"&gt;Embedded Module&lt;/h3&gt;
&lt;p&gt;内嵌功能模块只要是指 DLL、PLL、DSP 和 CPU 等 &lt;strong&gt;软核&lt;/strong&gt;，还有底层的 &lt;strong&gt;硬核&lt;/strong&gt; 资源，比如内嵌的 Power PC、ARM9、DSP 芯片等 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Xilinx 主流 FPGA&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 主流的 FPGA 主要有 A 系列、K 系列、V 系列、Spartan 系列，如今还有最新的 Zynq 系列，官网上有详细介绍 。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="kai fa liu cheng_1"&gt;开发流程&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;FPGA 的开发流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="design flow" src="/images/learning-fpga-getting-started/design-flow.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;整个开发过程就是使用开发工具 ISE Design Suite，按照流程图进行 。图示是标准流程，但是实际上并不是严格按照每一个步骤进行 。&lt;/p&gt;
&lt;p&gt;一般简化过的流程是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计可综合的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合 Systhesis&lt;/p&gt;
&lt;p&gt;前两步主要是确保写的代码是开发工具可以转化为实际电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合后仿真&lt;/p&gt;
&lt;p&gt;这一步保证模块的逻辑功能是正确的，即检验模块的结果是否和预期一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序约束&lt;/p&gt;
&lt;p&gt;为设计添加时序约束和管脚约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现 Implement&lt;/p&gt;
&lt;p&gt;按照约束条件将综合结果映射到实际器件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析&lt;/p&gt;
&lt;p&gt;实际上，一次就能达到时序要求且布线成功的情况并不多，尤其是对于高速设计，所以需要根据上一步的时序结果对设计进行修改，以满足时序要求，类似于写软件的 Debug 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载，在线调试&lt;/p&gt;
&lt;p&gt;将设计下载到芯片中调试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="can kao"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable_logic_devices"&gt;PLD wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable_gate_array"&gt;FPGA wikipedia&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="FPGA"></category></entry></feed>